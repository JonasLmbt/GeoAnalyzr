// ==UserScript==
// @name         GeoAnalyzr
// @namespace    geoanalyzr
// @author       JonasLmbt
// @version      2.1.1
// @updateURL    https://raw.githubusercontent.com/JonasLmbt/GeoAnalyzr/master/geoanalyzr.user.js
// @downloadURL  https://raw.githubusercontent.com/JonasLmbt/GeoAnalyzr/master/geoanalyzr.user.js
// @match        https://www.geoguessr.com/*
// @grant        GM_download
// @grant        GM_xmlhttpRequest
// @connect      www.geoguessr.com
// @connect      game-server.geoguessr.com
// @connect      raw.githubusercontent.com
// @connect      cdn.jsdelivr.net
// @connect      api.bigdatacloud.net
// ==/UserScript==
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/dexie/dist/dexie.js
  var require_dexie = __commonJS({
    "node_modules/dexie/dist/dexie.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Dexie = factory());
      })(exports, (function() {
        "use strict";
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        function __extends(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }
        var __assign = function() {
          __assign = Object.assign || function __assign2(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        function __spreadArray(to, from, pack) {
          if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
          return to.concat(ar || Array.prototype.slice.call(from));
        }
        typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
          var e = new Error(message);
          return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
        };
        var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
        var keys2 = Object.keys;
        var isArray = Array.isArray;
        if (typeof Promise !== "undefined" && !_global.Promise) {
          _global.Promise = Promise;
        }
        function extend(obj, extension) {
          if (typeof extension !== "object")
            return obj;
          keys2(extension).forEach(function(key) {
            obj[key] = extension[key];
          });
          return obj;
        }
        var getProto = Object.getPrototypeOf;
        var _hasOwn = {}.hasOwnProperty;
        function hasOwn(obj, prop) {
          return _hasOwn.call(obj, prop);
        }
        function props(proto, extension) {
          if (typeof extension === "function")
            extension = extension(getProto(proto));
          (typeof Reflect === "undefined" ? keys2 : Reflect.ownKeys)(extension).forEach(function(key) {
            setProp(proto, key, extension[key]);
          });
        }
        var defineProperty = Object.defineProperty;
        function setProp(obj, prop, functionOrGetSet, options) {
          defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
        }
        function derive(Child) {
          return {
            from: function(Parent) {
              Child.prototype = Object.create(Parent.prototype);
              setProp(Child.prototype, "constructor", Child);
              return {
                extend: props.bind(null, Child.prototype)
              };
            }
          };
        }
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        function getPropertyDescriptor(obj, prop) {
          var pd = getOwnPropertyDescriptor(obj, prop);
          var proto;
          return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
        }
        var _slice = [].slice;
        function slice(args, start, end) {
          return _slice.call(args, start, end);
        }
        function override(origFunc, overridedFactory) {
          return overridedFactory(origFunc);
        }
        function assert2(b) {
          if (!b)
            throw new Error("Assertion Failed");
        }
        function asap$1(fn) {
          if (_global.setImmediate)
            setImmediate(fn);
          else
            setTimeout(fn, 0);
        }
        function arrayToObject(array, extractor) {
          return array.reduce(function(result, item, i) {
            var nameAndValue = extractor(item, i);
            if (nameAndValue)
              result[nameAndValue[0]] = nameAndValue[1];
            return result;
          }, {});
        }
        function getByKeyPath(obj, keyPath) {
          if (typeof keyPath === "string" && hasOwn(obj, keyPath))
            return obj[keyPath];
          if (!keyPath)
            return obj;
          if (typeof keyPath !== "string") {
            var rv = [];
            for (var i = 0, l = keyPath.length; i < l; ++i) {
              var val = getByKeyPath(obj, keyPath[i]);
              rv.push(val);
            }
            return rv;
          }
          var period = keyPath.indexOf(".");
          if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
          }
          return void 0;
        }
        function setByKeyPath(obj, keyPath, value) {
          if (!obj || keyPath === void 0)
            return;
          if ("isFrozen" in Object && Object.isFrozen(obj))
            return;
          if (typeof keyPath !== "string" && "length" in keyPath) {
            assert2(typeof value !== "string" && "length" in value);
            for (var i = 0, l = keyPath.length; i < l; ++i) {
              setByKeyPath(obj, keyPath[i], value[i]);
            }
          } else {
            var period = keyPath.indexOf(".");
            if (period !== -1) {
              var currentKeyPath = keyPath.substr(0, period);
              var remainingKeyPath = keyPath.substr(period + 1);
              if (remainingKeyPath === "")
                if (value === void 0) {
                  if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
                    obj.splice(currentKeyPath, 1);
                  else
                    delete obj[currentKeyPath];
                } else
                  obj[currentKeyPath] = value;
              else {
                var innerObj = obj[currentKeyPath];
                if (!innerObj || !hasOwn(obj, currentKeyPath))
                  innerObj = obj[currentKeyPath] = {};
                setByKeyPath(innerObj, remainingKeyPath, value);
              }
            } else {
              if (value === void 0) {
                if (isArray(obj) && !isNaN(parseInt(keyPath)))
                  obj.splice(keyPath, 1);
                else
                  delete obj[keyPath];
              } else
                obj[keyPath] = value;
            }
          }
        }
        function delByKeyPath(obj, keyPath) {
          if (typeof keyPath === "string")
            setByKeyPath(obj, keyPath, void 0);
          else if ("length" in keyPath)
            [].map.call(keyPath, function(kp) {
              setByKeyPath(obj, kp, void 0);
            });
        }
        function shallowClone(obj) {
          var rv = {};
          for (var m in obj) {
            if (hasOwn(obj, m))
              rv[m] = obj[m];
          }
          return rv;
        }
        var concat = [].concat;
        function flatten(a) {
          return concat.apply([], a);
        }
        var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map(function(num) {
          return ["Int", "Uint", "Float"].map(function(t) {
            return t + num + "Array";
          });
        }))).filter(function(t) {
          return _global[t];
        });
        var intrinsicTypes = new Set(intrinsicTypeNames.map(function(t) {
          return _global[t];
        }));
        function cloneSimpleObjectTree(o) {
          var rv = {};
          for (var k in o)
            if (hasOwn(o, k)) {
              var v = o[k];
              rv[k] = !v || typeof v !== "object" || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
            }
          return rv;
        }
        function objectIsEmpty(o) {
          for (var k in o)
            if (hasOwn(o, k))
              return false;
          return true;
        }
        var circularRefs = null;
        function deepClone(any) {
          circularRefs = /* @__PURE__ */ new WeakMap();
          var rv = innerDeepClone(any);
          circularRefs = null;
          return rv;
        }
        function innerDeepClone(x) {
          if (!x || typeof x !== "object")
            return x;
          var rv = circularRefs.get(x);
          if (rv)
            return rv;
          if (isArray(x)) {
            rv = [];
            circularRefs.set(x, rv);
            for (var i = 0, l = x.length; i < l; ++i) {
              rv.push(innerDeepClone(x[i]));
            }
          } else if (intrinsicTypes.has(x.constructor)) {
            rv = x;
          } else {
            var proto = getProto(x);
            rv = proto === Object.prototype ? {} : Object.create(proto);
            circularRefs.set(x, rv);
            for (var prop in x) {
              if (hasOwn(x, prop)) {
                rv[prop] = innerDeepClone(x[prop]);
              }
            }
          }
          return rv;
        }
        var toString = {}.toString;
        function toStringTag(o) {
          return toString.call(o).slice(8, -1);
        }
        var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
        var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
          var i;
          return x != null && (i = x[iteratorSymbol]) && i.apply(x);
        } : function() {
          return null;
        };
        function delArrayItem(a, x) {
          var i = a.indexOf(x);
          if (i >= 0)
            a.splice(i, 1);
          return i >= 0;
        }
        var NO_CHAR_ARRAY = {};
        function getArrayOf(arrayLike) {
          var i, a, x, it;
          if (arguments.length === 1) {
            if (isArray(arrayLike))
              return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
              return [arrayLike];
            if (it = getIteratorOf(arrayLike)) {
              a = [];
              while (x = it.next(), !x.done)
                a.push(x.value);
              return a;
            }
            if (arrayLike == null)
              return [arrayLike];
            i = arrayLike.length;
            if (typeof i === "number") {
              a = new Array(i);
              while (i--)
                a[i] = arrayLike[i];
              return a;
            }
            return [arrayLike];
          }
          i = arguments.length;
          a = new Array(i);
          while (i--)
            a[i] = arguments[i];
          return a;
        }
        var isAsyncFunction = typeof Symbol !== "undefined" ? function(fn) {
          return fn[Symbol.toStringTag] === "AsyncFunction";
        } : function() {
          return false;
        };
        var dexieErrorNames = [
          "Modify",
          "Bulk",
          "OpenFailed",
          "VersionChange",
          "Schema",
          "Upgrade",
          "InvalidTable",
          "MissingAPI",
          "NoSuchDatabase",
          "InvalidArgument",
          "SubTransaction",
          "Unsupported",
          "Internal",
          "DatabaseClosed",
          "PrematureCommit",
          "ForeignAwait"
        ];
        var idbDomErrorNames = [
          "Unknown",
          "Constraint",
          "Data",
          "TransactionInactive",
          "ReadOnly",
          "Version",
          "NotFound",
          "InvalidState",
          "InvalidAccess",
          "Abort",
          "Timeout",
          "QuotaExceeded",
          "Syntax",
          "DataClone"
        ];
        var errorList = dexieErrorNames.concat(idbDomErrorNames);
        var defaultTexts = {
          VersionChanged: "Database version changed by other database connection",
          DatabaseClosed: "Database has been closed",
          Abort: "Transaction aborted",
          TransactionInactive: "Transaction has already completed or failed",
          MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
        };
        function DexieError(name, msg) {
          this.name = name;
          this.message = msg;
        }
        derive(DexieError).from(Error).extend({
          toString: function() {
            return this.name + ": " + this.message;
          }
        });
        function getMultiErrorMessage(msg, failures) {
          return msg + ". Errors: " + Object.keys(failures).map(function(key) {
            return failures[key].toString();
          }).filter(function(v, i, s) {
            return s.indexOf(v) === i;
          }).join("\n");
        }
        function ModifyError(msg, failures, successCount, failedKeys) {
          this.failures = failures;
          this.failedKeys = failedKeys;
          this.successCount = successCount;
          this.message = getMultiErrorMessage(msg, failures);
        }
        derive(ModifyError).from(DexieError);
        function BulkError(msg, failures) {
          this.name = "BulkError";
          this.failures = Object.keys(failures).map(function(pos) {
            return failures[pos];
          });
          this.failuresByPos = failures;
          this.message = getMultiErrorMessage(msg, this.failures);
        }
        derive(BulkError).from(DexieError);
        var errnames = errorList.reduce(function(obj, name) {
          return obj[name] = name + "Error", obj;
        }, {});
        var BaseException = DexieError;
        var exceptions = errorList.reduce(function(obj, name) {
          var fullName = name + "Error";
          function DexieError2(msgOrInner, inner) {
            this.name = fullName;
            if (!msgOrInner) {
              this.message = defaultTexts[name] || fullName;
              this.inner = null;
            } else if (typeof msgOrInner === "string") {
              this.message = "".concat(msgOrInner).concat(!inner ? "" : "\n " + inner);
              this.inner = inner || null;
            } else if (typeof msgOrInner === "object") {
              this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
              this.inner = msgOrInner;
            }
          }
          derive(DexieError2).from(BaseException);
          obj[name] = DexieError2;
          return obj;
        }, {});
        exceptions.Syntax = SyntaxError;
        exceptions.Type = TypeError;
        exceptions.Range = RangeError;
        var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
          obj[name + "Error"] = exceptions[name];
          return obj;
        }, {});
        function mapError(domError, message) {
          if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
            return domError;
          var rv = new exceptionMap[domError.name](message || domError.message, domError);
          if ("stack" in domError) {
            setProp(rv, "stack", { get: function() {
              return this.inner.stack;
            } });
          }
          return rv;
        }
        var fullNameExceptions = errorList.reduce(function(obj, name) {
          if (["Syntax", "Type", "Range"].indexOf(name) === -1)
            obj[name + "Error"] = exceptions[name];
          return obj;
        }, {});
        fullNameExceptions.ModifyError = ModifyError;
        fullNameExceptions.DexieError = DexieError;
        fullNameExceptions.BulkError = BulkError;
        function nop() {
        }
        function mirror(val) {
          return val;
        }
        function pureFunctionChain(f1, f2) {
          if (f1 == null || f1 === mirror)
            return f2;
          return function(val) {
            return f2(f1(val));
          };
        }
        function callBoth(on1, on2) {
          return function() {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
          };
        }
        function hookCreatingChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            var res = f1.apply(this, arguments);
            if (res !== void 0)
              arguments[0] = res;
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== void 0 ? res2 : res;
          };
        }
        function hookDeletingChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess)
              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          };
        }
        function hookUpdatingChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function(modifications) {
            var res = f1.apply(this, arguments);
            extend(modifications, res);
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
          };
        }
        function reverseStoppableEventChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            if (f2.apply(this, arguments) === false)
              return false;
            return f1.apply(this, arguments);
          };
        }
        function promisableChain(f1, f2) {
          if (f1 === nop)
            return f2;
          return function() {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === "function") {
              var thiz = this, i = arguments.length, args = new Array(i);
              while (i--)
                args[i] = arguments[i];
              return res.then(function() {
                return f2.apply(thiz, args);
              });
            }
            return f2.apply(this, arguments);
          };
        }
        var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
        function setDebug(value, filter) {
          debug = value;
        }
        var INTERNAL = {};
        var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === "undefined" ? [] : (function() {
          var globalP = Promise.resolve();
          if (typeof crypto === "undefined" || !crypto.subtle)
            return [globalP, getProto(globalP), globalP];
          var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
          return [
            nativeP,
            getProto(nativeP),
            globalP
          ];
        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
        var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
        var patchGlobalPromise = !!resolvedGlobalPromise;
        function schedulePhysicalTick() {
          queueMicrotask(physicalTick);
        }
        var asap = function(callback, args) {
          microtickQueue.push([callback, args]);
          if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
          }
        };
        var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], rejectionMapper = mirror;
        var globalPSD = {
          id: "global",
          global: true,
          ref: 0,
          unhandleds: [],
          onunhandled: nop,
          pgp: false,
          env: {},
          finalize: nop
        };
        var PSD = globalPSD;
        var microtickQueue = [];
        var numScheduledCalls = 0;
        var tickFinalizers = [];
        function DexiePromise(fn) {
          if (typeof this !== "object")
            throw new TypeError("Promises must be constructed via new");
          this._listeners = [];
          this._lib = false;
          var psd = this._PSD = PSD;
          if (typeof fn !== "function") {
            if (fn !== INTERNAL)
              throw new TypeError("Not a function");
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false)
              handleRejection(this, this._value);
            return;
          }
          this._state = null;
          this._value = null;
          ++psd.ref;
          executePromiseTask(this, fn);
        }
        var thenProp = {
          get: function() {
            var psd = PSD, microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
              var _this = this;
              var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
              var cleanup = possibleAwait && !decrementExpectedAwaits();
              var rv = new DexiePromise(function(resolve, reject) {
                propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
              });
              if (this._consoleTask)
                rv._consoleTask = this._consoleTask;
              return rv;
            }
            then.prototype = INTERNAL;
            return then;
          },
          set: function(value) {
            setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
              get: function() {
                return value;
              },
              set: thenProp.set
            });
          }
        };
        props(DexiePromise.prototype, {
          then: thenProp,
          _then: function(onFulfilled, onRejected) {
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
          },
          catch: function(onRejected) {
            if (arguments.length === 1)
              return this.then(null, onRejected);
            var type2 = arguments[0], handler = arguments[1];
            return typeof type2 === "function" ? this.then(null, function(err) {
              return err instanceof type2 ? handler(err) : PromiseReject(err);
            }) : this.then(null, function(err) {
              return err && err.name === type2 ? handler(err) : PromiseReject(err);
            });
          },
          finally: function(onFinally) {
            return this.then(function(value) {
              return DexiePromise.resolve(onFinally()).then(function() {
                return value;
              });
            }, function(err) {
              return DexiePromise.resolve(onFinally()).then(function() {
                return PromiseReject(err);
              });
            });
          },
          timeout: function(ms, msg) {
            var _this = this;
            return ms < Infinity ? new DexiePromise(function(resolve, reject) {
              var handle = setTimeout(function() {
                return reject(new exceptions.Timeout(msg));
              }, ms);
              _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
            }) : this;
          }
        });
        if (typeof Symbol !== "undefined" && Symbol.toStringTag)
          setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
        globalPSD.env = snapShot();
        function Listener(onFulfilled, onRejected, resolve, reject, zone) {
          this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
          this.onRejected = typeof onRejected === "function" ? onRejected : null;
          this.resolve = resolve;
          this.reject = reject;
          this.psd = zone;
        }
        props(DexiePromise, {
          all: function() {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
              if (values.length === 0)
                resolve([]);
              var remaining = values.length;
              values.forEach(function(a, i) {
                return DexiePromise.resolve(a).then(function(x) {
                  values[i] = x;
                  if (!--remaining)
                    resolve(values);
                }, reject);
              });
            });
          },
          resolve: function(value) {
            if (value instanceof DexiePromise)
              return value;
            if (value && typeof value.then === "function")
              return new DexiePromise(function(resolve, reject) {
                value.then(resolve, reject);
              });
            var rv = new DexiePromise(INTERNAL, true, value);
            return rv;
          },
          reject: PromiseReject,
          race: function() {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
              values.map(function(value) {
                return DexiePromise.resolve(value).then(resolve, reject);
              });
            });
          },
          PSD: {
            get: function() {
              return PSD;
            },
            set: function(value) {
              return PSD = value;
            }
          },
          totalEchoes: { get: function() {
            return totalEchoes;
          } },
          newPSD: newScope,
          usePSD,
          scheduler: {
            get: function() {
              return asap;
            },
            set: function(value) {
              asap = value;
            }
          },
          rejectionMapper: {
            get: function() {
              return rejectionMapper;
            },
            set: function(value) {
              rejectionMapper = value;
            }
          },
          follow: function(fn, zoneProps) {
            return new DexiePromise(function(resolve, reject) {
              return newScope(function(resolve2, reject2) {
                var psd = PSD;
                psd.unhandleds = [];
                psd.onunhandled = reject2;
                psd.finalize = callBoth(function() {
                  var _this = this;
                  run_at_end_of_this_or_next_physical_tick(function() {
                    _this.unhandleds.length === 0 ? resolve2() : reject2(_this.unhandleds[0]);
                  });
                }, psd.finalize);
                fn();
              }, zoneProps, resolve, reject);
            });
          }
        });
        if (NativePromise) {
          if (NativePromise.allSettled)
            setProp(DexiePromise, "allSettled", function() {
              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
              return new DexiePromise(function(resolve) {
                if (possiblePromises.length === 0)
                  resolve([]);
                var remaining = possiblePromises.length;
                var results = new Array(remaining);
                possiblePromises.forEach(function(p, i) {
                  return DexiePromise.resolve(p).then(function(value) {
                    return results[i] = { status: "fulfilled", value };
                  }, function(reason) {
                    return results[i] = { status: "rejected", reason };
                  }).then(function() {
                    return --remaining || resolve(results);
                  });
                });
              });
            });
          if (NativePromise.any && typeof AggregateError !== "undefined")
            setProp(DexiePromise, "any", function() {
              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
              return new DexiePromise(function(resolve, reject) {
                if (possiblePromises.length === 0)
                  reject(new AggregateError([]));
                var remaining = possiblePromises.length;
                var failures = new Array(remaining);
                possiblePromises.forEach(function(p, i) {
                  return DexiePromise.resolve(p).then(function(value) {
                    return resolve(value);
                  }, function(failure) {
                    failures[i] = failure;
                    if (!--remaining)
                      reject(new AggregateError(failures));
                  });
                });
              });
            });
          if (NativePromise.withResolvers)
            DexiePromise.withResolvers = NativePromise.withResolvers;
        }
        function executePromiseTask(promise, fn) {
          try {
            fn(function(value) {
              if (promise._state !== null)
                return;
              if (value === promise)
                throw new TypeError("A promise cannot be resolved with itself.");
              var shouldExecuteTick = promise._lib && beginMicroTickScope();
              if (value && typeof value.then === "function") {
                executePromiseTask(promise, function(resolve, reject) {
                  value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
                });
              } else {
                promise._state = true;
                promise._value = value;
                propagateAllListeners(promise);
              }
              if (shouldExecuteTick)
                endMicroTickScope();
            }, handleRejection.bind(null, promise));
          } catch (ex) {
            handleRejection(promise, ex);
          }
        }
        function handleRejection(promise, reason) {
          rejectingErrors.push(reason);
          if (promise._state !== null)
            return;
          var shouldExecuteTick = promise._lib && beginMicroTickScope();
          reason = rejectionMapper(reason);
          promise._state = false;
          promise._value = reason;
          addPossiblyUnhandledError(promise);
          propagateAllListeners(promise);
          if (shouldExecuteTick)
            endMicroTickScope();
        }
        function propagateAllListeners(promise) {
          var listeners = promise._listeners;
          promise._listeners = [];
          for (var i = 0, len = listeners.length; i < len; ++i) {
            propagateToListener(promise, listeners[i]);
          }
          var psd = promise._PSD;
          --psd.ref || psd.finalize();
          if (numScheduledCalls === 0) {
            ++numScheduledCalls;
            asap(function() {
              if (--numScheduledCalls === 0)
                finalizePhysicalTick();
            }, []);
          }
        }
        function propagateToListener(promise, listener) {
          if (promise._state === null) {
            promise._listeners.push(listener);
            return;
          }
          var cb = promise._state ? listener.onFulfilled : listener.onRejected;
          if (cb === null) {
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
          }
          ++listener.psd.ref;
          ++numScheduledCalls;
          asap(callListener, [cb, promise, listener]);
        }
        function callListener(cb, promise, listener) {
          try {
            var ret, value = promise._value;
            if (!promise._state && rejectingErrors.length)
              rejectingErrors = [];
            ret = debug && promise._consoleTask ? promise._consoleTask.run(function() {
              return cb(value);
            }) : cb(value);
            if (!promise._state && rejectingErrors.indexOf(value) === -1) {
              markErrorAsHandled(promise);
            }
            listener.resolve(ret);
          } catch (e) {
            listener.reject(e);
          } finally {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
          }
        }
        function physicalTick() {
          usePSD(globalPSD, function() {
            beginMicroTickScope() && endMicroTickScope();
          });
        }
        function beginMicroTickScope() {
          var wasRootExec = isOutsideMicroTick;
          isOutsideMicroTick = false;
          needsNewPhysicalTick = false;
          return wasRootExec;
        }
        function endMicroTickScope() {
          var callbacks, i, l;
          do {
            while (microtickQueue.length > 0) {
              callbacks = microtickQueue;
              microtickQueue = [];
              l = callbacks.length;
              for (i = 0; i < l; ++i) {
                var item = callbacks[i];
                item[0].apply(null, item[1]);
              }
            }
          } while (microtickQueue.length > 0);
          isOutsideMicroTick = true;
          needsNewPhysicalTick = true;
        }
        function finalizePhysicalTick() {
          var unhandledErrs = unhandledErrors;
          unhandledErrors = [];
          unhandledErrs.forEach(function(p) {
            p._PSD.onunhandled.call(null, p._value, p);
          });
          var finalizers = tickFinalizers.slice(0);
          var i = finalizers.length;
          while (i)
            finalizers[--i]();
        }
        function run_at_end_of_this_or_next_physical_tick(fn) {
          function finalizer() {
            fn();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
          }
          tickFinalizers.push(finalizer);
          ++numScheduledCalls;
          asap(function() {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
          }, []);
        }
        function addPossiblyUnhandledError(promise) {
          if (!unhandledErrors.some(function(p) {
            return p._value === promise._value;
          }))
            unhandledErrors.push(promise);
        }
        function markErrorAsHandled(promise) {
          var i = unhandledErrors.length;
          while (i)
            if (unhandledErrors[--i]._value === promise._value) {
              unhandledErrors.splice(i, 1);
              return;
            }
        }
        function PromiseReject(reason) {
          return new DexiePromise(INTERNAL, false, reason);
        }
        function wrap(fn, errorCatcher) {
          var psd = PSD;
          return function() {
            var wasRootExec = beginMicroTickScope(), outerScope = PSD;
            try {
              switchToZone(psd, true);
              return fn.apply(this, arguments);
            } catch (e) {
              errorCatcher && errorCatcher(e);
            } finally {
              switchToZone(outerScope, false);
              if (wasRootExec)
                endMicroTickScope();
            }
          };
        }
        var task = { awaits: 0, echoes: 0, id: 0 };
        var taskCounter = 0;
        var zoneStack = [];
        var zoneEchoes = 0;
        var totalEchoes = 0;
        var zone_id_counter = 0;
        function newScope(fn, props2, a1, a2) {
          var parent = PSD, psd = Object.create(parent);
          psd.parent = parent;
          psd.ref = 0;
          psd.global = false;
          psd.id = ++zone_id_counter;
          globalPSD.env;
          psd.env = patchGlobalPromise ? {
            Promise: DexiePromise,
            PromiseProp: { value: DexiePromise, configurable: true, writable: true },
            all: DexiePromise.all,
            race: DexiePromise.race,
            allSettled: DexiePromise.allSettled,
            any: DexiePromise.any,
            resolve: DexiePromise.resolve,
            reject: DexiePromise.reject
          } : {};
          if (props2)
            extend(psd, props2);
          ++parent.ref;
          psd.finalize = function() {
            --this.parent.ref || this.parent.finalize();
          };
          var rv = usePSD(psd, fn, a1, a2);
          if (psd.ref === 0)
            psd.finalize();
          return rv;
        }
        function incrementExpectedAwaits() {
          if (!task.id)
            task.id = ++taskCounter;
          ++task.awaits;
          task.echoes += ZONE_ECHO_LIMIT;
          return task.id;
        }
        function decrementExpectedAwaits() {
          if (!task.awaits)
            return false;
          if (--task.awaits === 0)
            task.id = 0;
          task.echoes = task.awaits * ZONE_ECHO_LIMIT;
          return true;
        }
        if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
          incrementExpectedAwaits = decrementExpectedAwaits = nop;
        }
        function onPossibleParallellAsync(possiblePromise) {
          if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(function(x) {
              decrementExpectedAwaits();
              return x;
            }, function(e) {
              decrementExpectedAwaits();
              return rejection(e);
            });
          }
          return possiblePromise;
        }
        function zoneEnterEcho(targetZone) {
          ++totalEchoes;
          if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.awaits = task.id = 0;
          }
          zoneStack.push(PSD);
          switchToZone(targetZone, true);
        }
        function zoneLeaveEcho() {
          var zone = zoneStack[zoneStack.length - 1];
          zoneStack.pop();
          switchToZone(zone, false);
        }
        function switchToZone(targetZone, bEnteringZone) {
          var currentZone = PSD;
          if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
          }
          if (targetZone === PSD)
            return;
          PSD = targetZone;
          if (currentZone === globalPSD)
            globalPSD.env = snapShot();
          if (patchGlobalPromise) {
            var GlobalPromise = globalPSD.env.Promise;
            var targetEnv = targetZone.env;
            if (currentZone.global || targetZone.global) {
              Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
              GlobalPromise.all = targetEnv.all;
              GlobalPromise.race = targetEnv.race;
              GlobalPromise.resolve = targetEnv.resolve;
              GlobalPromise.reject = targetEnv.reject;
              if (targetEnv.allSettled)
                GlobalPromise.allSettled = targetEnv.allSettled;
              if (targetEnv.any)
                GlobalPromise.any = targetEnv.any;
            }
          }
        }
        function snapShot() {
          var GlobalPromise = _global.Promise;
          return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            allSettled: GlobalPromise.allSettled,
            any: GlobalPromise.any,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject
          } : {};
        }
        function usePSD(psd, fn, a1, a2, a3) {
          var outerScope = PSD;
          try {
            switchToZone(psd, true);
            return fn(a1, a2, a3);
          } finally {
            switchToZone(outerScope, false);
          }
        }
        function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
          return typeof fn !== "function" ? fn : function() {
            var outerZone = PSD;
            if (possibleAwait)
              incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
              return fn.apply(this, arguments);
            } finally {
              switchToZone(outerZone, false);
              if (cleanup)
                queueMicrotask(decrementExpectedAwaits);
            }
          };
        }
        function execInGlobalContext(cb) {
          if (Promise === NativePromise && task.echoes === 0) {
            if (zoneEchoes === 0) {
              cb();
            } else {
              enqueueNativeMicroTask(cb);
            }
          } else {
            setTimeout(cb, 0);
          }
        }
        var rejection = DexiePromise.reject;
        function tempTransaction(db2, mode, storeNames, fn) {
          if (!db2.idbdb || !db2._state.openComplete && (!PSD.letThrough && !db2._vip)) {
            if (db2._state.openComplete) {
              return rejection(new exceptions.DatabaseClosed(db2._state.dbOpenError));
            }
            if (!db2._state.isBeingOpened) {
              if (!db2._state.autoOpen)
                return rejection(new exceptions.DatabaseClosed());
              db2.open().catch(nop);
            }
            return db2._state.dbReadyPromise.then(function() {
              return tempTransaction(db2, mode, storeNames, fn);
            });
          } else {
            var trans = db2._createTransaction(mode, storeNames, db2._dbSchema);
            try {
              trans.create();
              db2._state.PR1398_maxLoop = 3;
            } catch (ex) {
              if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
                console.warn("Dexie: Need to reopen db");
                db2.close({ disableAutoOpen: false });
                return db2.open().then(function() {
                  return tempTransaction(db2, mode, storeNames, fn);
                });
              }
              return rejection(ex);
            }
            return trans._promise(mode, function(resolve, reject) {
              return newScope(function() {
                PSD.trans = trans;
                return fn(resolve, reject, trans);
              });
            }).then(function(result) {
              if (mode === "readwrite")
                try {
                  trans.idbtrans.commit();
                } catch (_a2) {
                }
              return mode === "readonly" ? result : trans._completion.then(function() {
                return result;
              });
            });
          }
        }
        var DEXIE_VERSION = "4.3.0";
        var maxString = String.fromCharCode(65535);
        var minKey = -Infinity;
        var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
        var STRING_EXPECTED = "String expected.";
        var connections = [];
        var DBNAMES_DB = "__dbnames";
        var READONLY = "readonly";
        var READWRITE = "readwrite";
        function combine(filter1, filter2) {
          return filter1 ? filter2 ? function() {
            return filter1.apply(this, arguments) && filter2.apply(this, arguments);
          } : filter1 : filter2;
        }
        var AnyRange = {
          type: 3,
          lower: -Infinity,
          lowerOpen: false,
          upper: [[]],
          upperOpen: false
        };
        function workaroundForUndefinedPrimKey(keyPath) {
          return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
            if (obj[keyPath] === void 0 && keyPath in obj) {
              obj = deepClone(obj);
              delete obj[keyPath];
            }
            return obj;
          } : function(obj) {
            return obj;
          };
        }
        function Entity2() {
          throw exceptions.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
        }
        function cmp2(a, b) {
          try {
            var ta = type(a);
            var tb = type(b);
            if (ta !== tb) {
              if (ta === "Array")
                return 1;
              if (tb === "Array")
                return -1;
              if (ta === "binary")
                return 1;
              if (tb === "binary")
                return -1;
              if (ta === "string")
                return 1;
              if (tb === "string")
                return -1;
              if (ta === "Date")
                return 1;
              if (tb !== "Date")
                return NaN;
              return -1;
            }
            switch (ta) {
              case "number":
              case "Date":
              case "string":
                return a > b ? 1 : a < b ? -1 : 0;
              case "binary": {
                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
              }
              case "Array":
                return compareArrays(a, b);
            }
          } catch (_a2) {
          }
          return NaN;
        }
        function compareArrays(a, b) {
          var al = a.length;
          var bl = b.length;
          var l = al < bl ? al : bl;
          for (var i = 0; i < l; ++i) {
            var res = cmp2(a[i], b[i]);
            if (res !== 0)
              return res;
          }
          return al === bl ? 0 : al < bl ? -1 : 1;
        }
        function compareUint8Arrays(a, b) {
          var al = a.length;
          var bl = b.length;
          var l = al < bl ? al : bl;
          for (var i = 0; i < l; ++i) {
            if (a[i] !== b[i])
              return a[i] < b[i] ? -1 : 1;
          }
          return al === bl ? 0 : al < bl ? -1 : 1;
        }
        function type(x) {
          var t = typeof x;
          if (t !== "object")
            return t;
          if (ArrayBuffer.isView(x))
            return "binary";
          var tsTag = toStringTag(x);
          return tsTag === "ArrayBuffer" ? "binary" : tsTag;
        }
        function getUint8Array(a) {
          if (a instanceof Uint8Array)
            return a;
          if (ArrayBuffer.isView(a))
            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
          return new Uint8Array(a);
        }
        function builtInDeletionTrigger(table, keys3, res) {
          var yProps = table.schema.yProps;
          if (!yProps)
            return res;
          if (keys3 && res.numFailures > 0)
            keys3 = keys3.filter(function(_, i) {
              return !res.failures[i];
            });
          return Promise.all(yProps.map(function(_a2) {
            var updatesTable = _a2.updatesTable;
            return keys3 ? table.db.table(updatesTable).where("k").anyOf(keys3).delete() : table.db.table(updatesTable).clear();
          })).then(function() {
            return res;
          });
        }
        var PropModification2 = (function() {
          function PropModification3(spec) {
            this["@@propmod"] = spec;
          }
          PropModification3.prototype.execute = function(value) {
            var _a2;
            var spec = this["@@propmod"];
            if (spec.add !== void 0) {
              var term = spec.add;
              if (isArray(term)) {
                return __spreadArray(__spreadArray([], isArray(value) ? value : [], true), term, true).sort();
              }
              if (typeof term === "number")
                return (Number(value) || 0) + term;
              if (typeof term === "bigint") {
                try {
                  return BigInt(value) + term;
                } catch (_b) {
                  return BigInt(0) + term;
                }
              }
              throw new TypeError("Invalid term ".concat(term));
            }
            if (spec.remove !== void 0) {
              var subtrahend_1 = spec.remove;
              if (isArray(subtrahend_1)) {
                return isArray(value) ? value.filter(function(item) {
                  return !subtrahend_1.includes(item);
                }).sort() : [];
              }
              if (typeof subtrahend_1 === "number")
                return Number(value) - subtrahend_1;
              if (typeof subtrahend_1 === "bigint") {
                try {
                  return BigInt(value) - subtrahend_1;
                } catch (_c) {
                  return BigInt(0) - subtrahend_1;
                }
              }
              throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
            }
            var prefixToReplace = (_a2 = spec.replacePrefix) === null || _a2 === void 0 ? void 0 : _a2[0];
            if (prefixToReplace && typeof value === "string" && value.startsWith(prefixToReplace)) {
              return spec.replacePrefix[1] + value.substring(prefixToReplace.length);
            }
            return value;
          };
          return PropModification3;
        })();
        function applyUpdateSpec(obj, changes) {
          var keyPaths = keys2(changes);
          var numKeys = keyPaths.length;
          var anythingModified = false;
          for (var i = 0; i < numKeys; ++i) {
            var keyPath = keyPaths[i];
            var value = changes[keyPath];
            var origValue = getByKeyPath(obj, keyPath);
            if (value instanceof PropModification2) {
              setByKeyPath(obj, keyPath, value.execute(origValue));
              anythingModified = true;
            } else if (origValue !== value) {
              setByKeyPath(obj, keyPath, value);
              anythingModified = true;
            }
          }
          return anythingModified;
        }
        var Table2 = (function() {
          function Table3() {
          }
          Table3.prototype._trans = function(mode, fn, writeLocked) {
            var trans = this._tx || PSD.trans;
            var tableName = this.name;
            var task2 = debug && typeof console !== "undefined" && console.createTask && console.createTask("Dexie: ".concat(mode === "readonly" ? "read" : "write", " ").concat(this.name));
            function checkTableInTransaction(resolve, reject, trans2) {
              if (!trans2.schema[tableName])
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
              return fn(trans2.idbtrans, trans2);
            }
            var wasRootExec = beginMicroTickScope();
            try {
              var p = trans && trans.db._novip === this.db._novip ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
                return trans._promise(mode, checkTableInTransaction, writeLocked);
              }, { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
              if (task2) {
                p._consoleTask = task2;
                p = p.catch(function(err) {
                  console.trace(err);
                  return rejection(err);
                });
              }
              return p;
            } finally {
              if (wasRootExec)
                endMicroTickScope();
            }
          };
          Table3.prototype.get = function(keyOrCrit, cb) {
            var _this = this;
            if (keyOrCrit && keyOrCrit.constructor === Object)
              return this.where(keyOrCrit).first(cb);
            if (keyOrCrit == null)
              return rejection(new exceptions.Type("Invalid argument to Table.get()"));
            return this._trans("readonly", function(trans) {
              return _this.core.get({ trans, key: keyOrCrit }).then(function(res) {
                return _this.hook.reading.fire(res);
              });
            }).then(cb);
          };
          Table3.prototype.where = function(indexOrCrit) {
            if (typeof indexOrCrit === "string")
              return new this.db.WhereClause(this, indexOrCrit);
            if (isArray(indexOrCrit))
              return new this.db.WhereClause(this, "[".concat(indexOrCrit.join("+"), "]"));
            var keyPaths = keys2(indexOrCrit);
            if (keyPaths.length === 1)
              return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
              if (ix.compound && keyPaths.every(function(keyPath) {
                return ix.keyPath.indexOf(keyPath) >= 0;
              })) {
                for (var i = 0; i < keyPaths.length; ++i) {
                  if (keyPaths.indexOf(ix.keyPath[i]) === -1)
                    return false;
                }
                return true;
              }
              return false;
            }).sort(function(a, b) {
              return a.keyPath.length - b.keyPath.length;
            })[0];
            if (compoundIndex && this.db._maxKey !== maxString) {
              var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
              return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map(function(kp) {
                return indexOrCrit[kp];
              }));
            }
            if (!compoundIndex && debug)
              console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(keyPaths.join("+"), "]"));
            var idxByName = this.schema.idxByName;
            function equals(a, b) {
              return cmp2(a, b) === 0;
            }
            var _a2 = keyPaths.reduce(function(_a3, keyPath) {
              var prevIndex = _a3[0], prevFilterFn = _a3[1];
              var index = idxByName[keyPath];
              var value = indexOrCrit[keyPath];
              return [
                prevIndex || index,
                prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function(x) {
                  var prop = getByKeyPath(x, keyPath);
                  return isArray(prop) && prop.some(function(item) {
                    return equals(value, item);
                  });
                } : function(x) {
                  return equals(value, getByKeyPath(x, keyPath));
                }) : prevFilterFn
              ];
            }, [null, null]), idx = _a2[0], filterFunction = _a2[1];
            return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
          };
          Table3.prototype.filter = function(filterFunction) {
            return this.toCollection().and(filterFunction);
          };
          Table3.prototype.count = function(thenShortcut) {
            return this.toCollection().count(thenShortcut);
          };
          Table3.prototype.offset = function(offset) {
            return this.toCollection().offset(offset);
          };
          Table3.prototype.limit = function(numRows) {
            return this.toCollection().limit(numRows);
          };
          Table3.prototype.each = function(callback) {
            return this.toCollection().each(callback);
          };
          Table3.prototype.toArray = function(thenShortcut) {
            return this.toCollection().toArray(thenShortcut);
          };
          Table3.prototype.toCollection = function() {
            return new this.db.Collection(new this.db.WhereClause(this));
          };
          Table3.prototype.orderBy = function(index) {
            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? "[".concat(index.join("+"), "]") : index));
          };
          Table3.prototype.reverse = function() {
            return this.toCollection().reverse();
          };
          Table3.prototype.mapToClass = function(constructor) {
            var _a2 = this, db2 = _a2.db, tableName = _a2.name;
            this.schema.mappedClass = constructor;
            if (constructor.prototype instanceof Entity2) {
              constructor = (function(_super) {
                __extends(class_1, _super);
                function class_1() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                Object.defineProperty(class_1.prototype, "db", {
                  get: function() {
                    return db2;
                  },
                  enumerable: false,
                  configurable: true
                });
                class_1.prototype.table = function() {
                  return tableName;
                };
                return class_1;
              })(constructor);
            }
            var inheritedProps = /* @__PURE__ */ new Set();
            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {
              Object.getOwnPropertyNames(proto).forEach(function(propName) {
                return inheritedProps.add(propName);
              });
            }
            var readHook = function(obj) {
              if (!obj)
                return obj;
              var res = Object.create(constructor.prototype);
              for (var m in obj)
                if (!inheritedProps.has(m))
                  try {
                    res[m] = obj[m];
                  } catch (_) {
                  }
              return res;
            };
            if (this.schema.readHook) {
              this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
          };
          Table3.prototype.defineClass = function() {
            function Class(content) {
              extend(this, content);
            }
            return this.mapToClass(Class);
          };
          Table3.prototype.add = function(obj, key) {
            var _this = this;
            var _a2 = this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
            }).then(function(lastResult) {
              if (keyPath) {
                try {
                  setByKeyPath(obj, keyPath, lastResult);
                } catch (_) {
                }
              }
              return lastResult;
            });
          };
          Table3.prototype.upsert = function(key, modifications) {
            var _this = this;
            var keyPath = this.schema.primKey.keyPath;
            return this._trans("readwrite", function(trans) {
              return _this.core.get({ trans, key }).then(function(existing) {
                var obj = existing !== null && existing !== void 0 ? existing : {};
                applyUpdateSpec(obj, modifications);
                if (keyPath)
                  setByKeyPath(obj, keyPath, key);
                return _this.core.mutate({
                  trans,
                  type: "put",
                  values: [obj],
                  keys: [key],
                  upsert: true,
                  updates: { keys: [key], changeSpecs: [modifications] }
                }).then(function(res) {
                  return res.numFailures ? DexiePromise.reject(res.failures[0]) : !!existing;
                });
              });
            });
          };
          Table3.prototype.update = function(keyOrObject, modifications) {
            if (typeof keyOrObject === "object" && !isArray(keyOrObject)) {
              var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
              if (key === void 0)
                return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
              return this.where(":id").equals(key).modify(modifications);
            } else {
              return this.where(":id").equals(keyOrObject).modify(modifications);
            }
          };
          Table3.prototype.put = function(obj, key) {
            var _this = this;
            var _a2 = this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
            }).then(function(lastResult) {
              if (keyPath) {
                try {
                  setByKeyPath(obj, keyPath, lastResult);
                } catch (_) {
                }
              }
              return lastResult;
            });
          };
          Table3.prototype.delete = function(key) {
            var _this = this;
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "delete", keys: [key] }).then(function(res) {
                return builtInDeletionTrigger(_this, [key], res);
              }).then(function(res) {
                return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
              });
            });
          };
          Table3.prototype.clear = function() {
            var _this = this;
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "deleteRange", range: AnyRange }).then(function(res) {
                return builtInDeletionTrigger(_this, null, res);
              });
            }).then(function(res) {
              return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
            });
          };
          Table3.prototype.bulkGet = function(keys3) {
            var _this = this;
            return this._trans("readonly", function(trans) {
              return _this.core.getMany({
                keys: keys3,
                trans
              }).then(function(result) {
                return result.map(function(res) {
                  return _this.hook.reading.fire(res);
                });
              });
            });
          };
          Table3.prototype.bulkAdd = function(objects, keysOrOptions, options) {
            var _this = this;
            var keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
            options = options || (keys3 ? void 0 : keysOrOptions);
            var wantResults = options ? options.allKeys : void 0;
            return this._trans("readwrite", function(trans) {
              var _a2 = _this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
              if (keyPath && keys3)
                throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
              if (keys3 && keys3.length !== objects.length)
                throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
              var numObjects = objects.length;
              var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
              return _this.core.mutate({ trans, type: "add", keys: keys3, values: objectsToAdd, wantResults }).then(function(_a3) {
                var numFailures = _a3.numFailures, results = _a3.results, lastResult = _a3.lastResult, failures = _a3.failures;
                var result = wantResults ? results : lastResult;
                if (numFailures === 0)
                  return result;
                throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
              });
            });
          };
          Table3.prototype.bulkPut = function(objects, keysOrOptions, options) {
            var _this = this;
            var keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
            options = options || (keys3 ? void 0 : keysOrOptions);
            var wantResults = options ? options.allKeys : void 0;
            return this._trans("readwrite", function(trans) {
              var _a2 = _this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
              if (keyPath && keys3)
                throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
              if (keys3 && keys3.length !== objects.length)
                throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
              var numObjects = objects.length;
              var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
              return _this.core.mutate({ trans, type: "put", keys: keys3, values: objectsToPut, wantResults }).then(function(_a3) {
                var numFailures = _a3.numFailures, results = _a3.results, lastResult = _a3.lastResult, failures = _a3.failures;
                var result = wantResults ? results : lastResult;
                if (numFailures === 0)
                  return result;
                throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
              });
            });
          };
          Table3.prototype.bulkUpdate = function(keysAndChanges) {
            var _this = this;
            var coreTable = this.core;
            var keys3 = keysAndChanges.map(function(entry) {
              return entry.key;
            });
            var changeSpecs = keysAndChanges.map(function(entry) {
              return entry.changes;
            });
            var offsetMap = [];
            return this._trans("readwrite", function(trans) {
              return coreTable.getMany({ trans, keys: keys3, cache: "clone" }).then(function(objs) {
                var resultKeys = [];
                var resultObjs = [];
                keysAndChanges.forEach(function(_a2, idx) {
                  var key = _a2.key, changes = _a2.changes;
                  var obj = objs[idx];
                  if (obj) {
                    for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {
                      var keyPath = _b[_i];
                      var value = changes[keyPath];
                      if (keyPath === _this.schema.primKey.keyPath) {
                        if (cmp2(value, key) !== 0) {
                          throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                        }
                      } else {
                        setByKeyPath(obj, keyPath, value);
                      }
                    }
                    offsetMap.push(idx);
                    resultKeys.push(key);
                    resultObjs.push(obj);
                  }
                });
                var numEntries = resultKeys.length;
                return coreTable.mutate({
                  trans,
                  type: "put",
                  keys: resultKeys,
                  values: resultObjs,
                  updates: {
                    keys: keys3,
                    changeSpecs
                  }
                }).then(function(_a2) {
                  var numFailures = _a2.numFailures, failures = _a2.failures;
                  if (numFailures === 0)
                    return numEntries;
                  for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {
                    var offset = _b[_i];
                    var mappedOffset = offsetMap[Number(offset)];
                    if (mappedOffset != null) {
                      var failure = failures[offset];
                      delete failures[offset];
                      failures[mappedOffset] = failure;
                    }
                  }
                  throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
                });
              });
            });
          };
          Table3.prototype.bulkDelete = function(keys3) {
            var _this = this;
            var numKeys = keys3.length;
            return this._trans("readwrite", function(trans) {
              return _this.core.mutate({ trans, type: "delete", keys: keys3 }).then(function(res) {
                return builtInDeletionTrigger(_this, keys3, res);
              });
            }).then(function(_a2) {
              var numFailures = _a2.numFailures, lastResult = _a2.lastResult, failures = _a2.failures;
              if (numFailures === 0)
                return lastResult;
              throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
            });
          };
          return Table3;
        })();
        function Events(ctx) {
          var evs = {};
          var rv = function(eventName, subscriber) {
            if (subscriber) {
              var i2 = arguments.length, args = new Array(i2 - 1);
              while (--i2)
                args[i2 - 1] = arguments[i2];
              evs[eventName].subscribe.apply(null, args);
              return ctx;
            } else if (typeof eventName === "string") {
              return evs[eventName];
            }
          };
          rv.addEventType = add3;
          for (var i = 1, l = arguments.length; i < l; ++i) {
            add3(arguments[i]);
          }
          return rv;
          function add3(eventName, chainFunction, defaultFunction) {
            if (typeof eventName === "object")
              return addConfiguredEvents(eventName);
            if (!chainFunction)
              chainFunction = reverseStoppableEventChain;
            if (!defaultFunction)
              defaultFunction = nop;
            var context = {
              subscribers: [],
              fire: defaultFunction,
              subscribe: function(cb) {
                if (context.subscribers.indexOf(cb) === -1) {
                  context.subscribers.push(cb);
                  context.fire = chainFunction(context.fire, cb);
                }
              },
              unsubscribe: function(cb) {
                context.subscribers = context.subscribers.filter(function(fn) {
                  return fn !== cb;
                });
                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
              }
            };
            evs[eventName] = rv[eventName] = context;
            return context;
          }
          function addConfiguredEvents(cfg) {
            keys2(cfg).forEach(function(eventName) {
              var args = cfg[eventName];
              if (isArray(args)) {
                add3(eventName, cfg[eventName][0], cfg[eventName][1]);
              } else if (args === "asap") {
                var context = add3(eventName, mirror, function fire() {
                  var i2 = arguments.length, args2 = new Array(i2);
                  while (i2--)
                    args2[i2] = arguments[i2];
                  context.subscribers.forEach(function(fn) {
                    asap$1(function fireEvent() {
                      fn.apply(null, args2);
                    });
                  });
                });
              } else
                throw new exceptions.InvalidArgument("Invalid event config");
            });
          }
        }
        function makeClassConstructor(prototype, constructor) {
          derive(constructor).from({ prototype });
          return constructor;
        }
        function createTableConstructor(db2) {
          return makeClassConstructor(Table2.prototype, function Table3(name, tableSchema, trans) {
            this.db = db2;
            this._tx = trans;
            this.name = name;
            this.schema = tableSchema;
            this.hook = db2._allTables[name] ? db2._allTables[name].hook : Events(null, {
              "creating": [hookCreatingChain, nop],
              "reading": [pureFunctionChain, mirror],
              "updating": [hookUpdatingChain, nop],
              "deleting": [hookDeletingChain, nop]
            });
          });
        }
        function isPlainKeyRange(ctx, ignoreLimitFilter) {
          return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
        }
        function addFilter(ctx, fn) {
          ctx.filter = combine(ctx.filter, fn);
        }
        function addReplayFilter(ctx, factory, isLimitFilter) {
          var curr = ctx.replayFilter;
          ctx.replayFilter = curr ? function() {
            return combine(curr(), factory());
          } : factory;
          ctx.justLimit = isLimitFilter && !curr;
        }
        function addMatchFilter(ctx, fn) {
          ctx.isMatch = combine(ctx.isMatch, fn);
        }
        function getIndexOrStore(ctx, coreSchema) {
          if (ctx.isPrimKey)
            return coreSchema.primaryKey;
          var index = coreSchema.getIndexByKeyPath(ctx.index);
          if (!index)
            throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
          return index;
        }
        function openCursor(ctx, coreTable, trans) {
          var index = getIndexOrStore(ctx, coreTable.schema);
          return coreTable.openCursor({
            trans,
            values: !ctx.keysOnly,
            reverse: ctx.dir === "prev",
            unique: !!ctx.unique,
            query: {
              index,
              range: ctx.range
            }
          });
        }
        function iter(ctx, fn, coreTrans, coreTable) {
          var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
          if (!ctx.or) {
            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
          } else {
            var set_1 = {};
            var union = function(item, cursor, advance) {
              if (!filter || filter(cursor, advance, function(result) {
                return cursor.stop(result);
              }, function(err) {
                return cursor.fail(err);
              })) {
                var primaryKey = cursor.primaryKey;
                var key = "" + primaryKey;
                if (key === "[object ArrayBuffer]")
                  key = "" + new Uint8Array(primaryKey);
                if (!hasOwn(set_1, key)) {
                  set_1[key] = true;
                  fn(item, cursor, advance);
                }
              }
            };
            return Promise.all([
              ctx.or._iterate(union, coreTrans),
              iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
            ]);
          }
        }
        function iterate(cursorPromise, filter, fn, valueMapper) {
          var mappedFn = valueMapper ? function(x, c, a) {
            return fn(valueMapper(x), c, a);
          } : fn;
          var wrappedFn = wrap(mappedFn);
          return cursorPromise.then(function(cursor) {
            if (cursor) {
              return cursor.start(function() {
                var c = function() {
                  return cursor.continue();
                };
                if (!filter || filter(cursor, function(advancer) {
                  return c = advancer;
                }, function(val) {
                  cursor.stop(val);
                  c = nop;
                }, function(e) {
                  cursor.fail(e);
                  c = nop;
                }))
                  wrappedFn(cursor.value, cursor, function(advancer) {
                    return c = advancer;
                  });
                c();
              });
            }
          });
        }
        var Collection = (function() {
          function Collection2() {
          }
          Collection2.prototype._read = function(fn, cb) {
            var ctx = this._ctx;
            return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
          };
          Collection2.prototype._write = function(fn) {
            var ctx = this._ctx;
            return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
          };
          Collection2.prototype._addAlgorithm = function(fn) {
            var ctx = this._ctx;
            ctx.algorithm = combine(ctx.algorithm, fn);
          };
          Collection2.prototype._iterate = function(fn, coreTrans) {
            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
          };
          Collection2.prototype.clone = function(props2) {
            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
            if (props2)
              extend(ctx, props2);
            rv._ctx = ctx;
            return rv;
          };
          Collection2.prototype.raw = function() {
            this._ctx.valueMapper = null;
            return this;
          };
          Collection2.prototype.each = function(fn) {
            var ctx = this._ctx;
            return this._read(function(trans) {
              return iter(ctx, fn, trans, ctx.table.core);
            });
          };
          Collection2.prototype.count = function(cb) {
            var _this = this;
            return this._read(function(trans) {
              var ctx = _this._ctx;
              var coreTable = ctx.table.core;
              if (isPlainKeyRange(ctx, true)) {
                return coreTable.count({
                  trans,
                  query: {
                    index: getIndexOrStore(ctx, coreTable.schema),
                    range: ctx.range
                  }
                }).then(function(count2) {
                  return Math.min(count2, ctx.limit);
                });
              } else {
                var count = 0;
                return iter(ctx, function() {
                  ++count;
                  return false;
                }, trans, coreTable).then(function() {
                  return count;
                });
              }
            }).then(cb);
          };
          Collection2.prototype.sortBy = function(keyPath, cb) {
            var parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
            function getval(obj, i) {
              if (i)
                return getval(obj[parts[i]], i - 1);
              return obj[lastPart];
            }
            var order = this._ctx.dir === "next" ? 1 : -1;
            function sorter(a, b) {
              var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
              return cmp2(aVal, bVal) * order;
            }
            return this.toArray(function(a) {
              return a.sort(sorter);
            }).then(cb);
          };
          Collection2.prototype.toArray = function(cb) {
            var _this = this;
            return this._read(function(trans) {
              var ctx = _this._ctx;
              if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                var valueMapper_1 = ctx.valueMapper;
                var index = getIndexOrStore(ctx, ctx.table.core.schema);
                return ctx.table.core.query({
                  trans,
                  limit: ctx.limit,
                  values: true,
                  query: {
                    index,
                    range: ctx.range
                  }
                }).then(function(_a2) {
                  var result = _a2.result;
                  return valueMapper_1 ? result.map(valueMapper_1) : result;
                });
              } else {
                var a_1 = [];
                return iter(ctx, function(item) {
                  return a_1.push(item);
                }, trans, ctx.table.core).then(function() {
                  return a_1;
                });
              }
            }, cb);
          };
          Collection2.prototype.offset = function(offset) {
            var ctx = this._ctx;
            if (offset <= 0)
              return this;
            ctx.offset += offset;
            if (isPlainKeyRange(ctx)) {
              addReplayFilter(ctx, function() {
                var offsetLeft = offset;
                return function(cursor, advance) {
                  if (offsetLeft === 0)
                    return true;
                  if (offsetLeft === 1) {
                    --offsetLeft;
                    return false;
                  }
                  advance(function() {
                    cursor.advance(offsetLeft);
                    offsetLeft = 0;
                  });
                  return false;
                };
              });
            } else {
              addReplayFilter(ctx, function() {
                var offsetLeft = offset;
                return function() {
                  return --offsetLeft < 0;
                };
              });
            }
            return this;
          };
          Collection2.prototype.limit = function(numRows) {
            this._ctx.limit = Math.min(this._ctx.limit, numRows);
            addReplayFilter(this._ctx, function() {
              var rowsLeft = numRows;
              return function(cursor, advance, resolve) {
                if (--rowsLeft <= 0)
                  advance(resolve);
                return rowsLeft >= 0;
              };
            }, true);
            return this;
          };
          Collection2.prototype.until = function(filterFunction, bIncludeStopEntry) {
            addFilter(this._ctx, function(cursor, advance, resolve) {
              if (filterFunction(cursor.value)) {
                advance(resolve);
                return bIncludeStopEntry;
              } else {
                return true;
              }
            });
            return this;
          };
          Collection2.prototype.first = function(cb) {
            return this.limit(1).toArray(function(a) {
              return a[0];
            }).then(cb);
          };
          Collection2.prototype.last = function(cb) {
            return this.reverse().first(cb);
          };
          Collection2.prototype.filter = function(filterFunction) {
            addFilter(this._ctx, function(cursor) {
              return filterFunction(cursor.value);
            });
            addMatchFilter(this._ctx, filterFunction);
            return this;
          };
          Collection2.prototype.and = function(filter) {
            return this.filter(filter);
          };
          Collection2.prototype.or = function(indexName) {
            return new this.db.WhereClause(this._ctx.table, indexName, this);
          };
          Collection2.prototype.reverse = function() {
            this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
            if (this._ondirectionchange)
              this._ondirectionchange(this._ctx.dir);
            return this;
          };
          Collection2.prototype.desc = function() {
            return this.reverse();
          };
          Collection2.prototype.eachKey = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function(val, cursor) {
              cb(cursor.key, cursor);
            });
          };
          Collection2.prototype.eachUniqueKey = function(cb) {
            this._ctx.unique = "unique";
            return this.eachKey(cb);
          };
          Collection2.prototype.eachPrimaryKey = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function(val, cursor) {
              cb(cursor.primaryKey, cursor);
            });
          };
          Collection2.prototype.keys = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function(item, cursor) {
              a.push(cursor.key);
            }).then(function() {
              return a;
            }).then(cb);
          };
          Collection2.prototype.primaryKeys = function(cb) {
            var ctx = this._ctx;
            if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
              return this._read(function(trans) {
                var index = getIndexOrStore(ctx, ctx.table.core.schema);
                return ctx.table.core.query({
                  trans,
                  values: false,
                  limit: ctx.limit,
                  query: {
                    index,
                    range: ctx.range
                  }
                });
              }).then(function(_a2) {
                var result = _a2.result;
                return result;
              }).then(cb);
            }
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function(item, cursor) {
              a.push(cursor.primaryKey);
            }).then(function() {
              return a;
            }).then(cb);
          };
          Collection2.prototype.uniqueKeys = function(cb) {
            this._ctx.unique = "unique";
            return this.keys(cb);
          };
          Collection2.prototype.firstKey = function(cb) {
            return this.limit(1).keys(function(a) {
              return a[0];
            }).then(cb);
          };
          Collection2.prototype.lastKey = function(cb) {
            return this.reverse().firstKey(cb);
          };
          Collection2.prototype.distinct = function() {
            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
            if (!idx || !idx.multi)
              return this;
            var set = {};
            addFilter(this._ctx, function(cursor) {
              var strKey = cursor.primaryKey.toString();
              var found = hasOwn(set, strKey);
              set[strKey] = true;
              return !found;
            });
            return this;
          };
          Collection2.prototype.modify = function(changes) {
            var _this = this;
            var ctx = this._ctx;
            return this._write(function(trans) {
              var modifyer;
              if (typeof changes === "function") {
                modifyer = changes;
              } else {
                modifyer = function(item) {
                  return applyUpdateSpec(item, changes);
                };
              }
              var coreTable = ctx.table.core;
              var _a2 = coreTable.schema.primaryKey, outbound = _a2.outbound, extractKey = _a2.extractKey;
              var limit = 200;
              var modifyChunkSize = _this.db._options.modifyChunkSize;
              if (modifyChunkSize) {
                if (typeof modifyChunkSize == "object") {
                  limit = modifyChunkSize[coreTable.name] || modifyChunkSize["*"] || 200;
                } else {
                  limit = modifyChunkSize;
                }
              }
              var totalFailures = [];
              var successCount = 0;
              var failedKeys = [];
              var applyMutateResult = function(expectedCount, res) {
                var failures = res.failures, numFailures = res.numFailures;
                successCount += expectedCount - numFailures;
                for (var _i = 0, _a3 = keys2(failures); _i < _a3.length; _i++) {
                  var pos = _a3[_i];
                  totalFailures.push(failures[pos]);
                }
              };
              var isUnconditionalDelete = changes === deleteCallback;
              return _this.clone().primaryKeys().then(function(keys3) {
                var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || isUnconditionalDelete) && {
                  index: ctx.index,
                  range: ctx.range
                };
                var nextChunk = function(offset) {
                  var count = Math.min(limit, keys3.length - offset);
                  var keysInChunk = keys3.slice(offset, offset + count);
                  return (isUnconditionalDelete ? Promise.resolve([]) : coreTable.getMany({
                    trans,
                    keys: keysInChunk,
                    cache: "immutable"
                  })).then(function(values) {
                    var addValues = [];
                    var putValues = [];
                    var putKeys = outbound ? [] : null;
                    var deleteKeys = isUnconditionalDelete ? keysInChunk : [];
                    if (!isUnconditionalDelete)
                      for (var i = 0; i < count; ++i) {
                        var origValue = values[i];
                        var ctx_1 = {
                          value: deepClone(origValue),
                          primKey: keys3[offset + i]
                        };
                        if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                          if (ctx_1.value == null) {
                            deleteKeys.push(keys3[offset + i]);
                          } else if (!outbound && cmp2(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                            deleteKeys.push(keys3[offset + i]);
                            addValues.push(ctx_1.value);
                          } else {
                            putValues.push(ctx_1.value);
                            if (outbound)
                              putKeys.push(keys3[offset + i]);
                          }
                        }
                      }
                    return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then(function(res) {
                      for (var pos in res.failures) {
                        deleteKeys.splice(parseInt(pos), 1);
                      }
                      applyMutateResult(addValues.length, res);
                    })).then(function() {
                      return (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
                        trans,
                        type: "put",
                        keys: putKeys,
                        values: putValues,
                        criteria,
                        changeSpec: typeof changes !== "function" && changes,
                        isAdditionalChunk: offset > 0
                      }).then(function(res) {
                        return applyMutateResult(putValues.length, res);
                      });
                    }).then(function() {
                      return (deleteKeys.length > 0 || criteria && isUnconditionalDelete) && coreTable.mutate({
                        trans,
                        type: "delete",
                        keys: deleteKeys,
                        criteria,
                        isAdditionalChunk: offset > 0
                      }).then(function(res) {
                        return builtInDeletionTrigger(ctx.table, deleteKeys, res);
                      }).then(function(res) {
                        return applyMutateResult(deleteKeys.length, res);
                      });
                    }).then(function() {
                      return keys3.length > offset + count && nextChunk(offset + limit);
                    });
                  });
                };
                return nextChunk(0).then(function() {
                  if (totalFailures.length > 0)
                    throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                  return keys3.length;
                });
              });
            });
          };
          Collection2.prototype.delete = function() {
            var ctx = this._ctx, range = ctx.range;
            if (isPlainKeyRange(ctx) && !ctx.table.schema.yProps && (ctx.isPrimKey || range.type === 3)) {
              return this._write(function(trans) {
                var primaryKey = ctx.table.core.schema.primaryKey;
                var coreRange = range;
                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(function(count) {
                  return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(function(_a2) {
                    var failures = _a2.failures, numFailures = _a2.numFailures;
                    if (numFailures)
                      throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                        return failures[pos];
                      }), count - numFailures);
                    return count - numFailures;
                  });
                });
              });
            }
            return this.modify(deleteCallback);
          };
          return Collection2;
        })();
        var deleteCallback = function(value, ctx) {
          return ctx.value = null;
        };
        function createCollectionConstructor(db2) {
          return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
            this.db = db2;
            var keyRange = AnyRange, error = null;
            if (keyRangeGenerator)
              try {
                keyRange = keyRangeGenerator();
              } catch (ex) {
                error = ex;
              }
            var whereCtx = whereClause._ctx;
            var table = whereCtx.table;
            var readingHook = table.hook.reading.fire;
            this._ctx = {
              table,
              index: whereCtx.index,
              isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
              range: keyRange,
              keysOnly: false,
              dir: "next",
              unique: "",
              algorithm: null,
              filter: null,
              replayFilter: null,
              justLimit: true,
              isMatch: null,
              offset: 0,
              limit: Infinity,
              error,
              or: whereCtx.or,
              valueMapper: readingHook !== mirror ? readingHook : null
            };
          });
        }
        function simpleCompare(a, b) {
          return a < b ? -1 : a === b ? 0 : 1;
        }
        function simpleCompareReverse(a, b) {
          return a > b ? -1 : a === b ? 0 : 1;
        }
        function fail(collectionOrWhereClause, err, T) {
          var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
          collection._ctx.error = T ? new T(err) : new TypeError(err);
          return collection;
        }
        function emptyCollection(whereClause) {
          return new whereClause.Collection(whereClause, function() {
            return rangeEqual("");
          }).limit(0);
        }
        function upperFactory(dir) {
          return dir === "next" ? function(s) {
            return s.toUpperCase();
          } : function(s) {
            return s.toLowerCase();
          };
        }
        function lowerFactory(dir) {
          return dir === "next" ? function(s) {
            return s.toLowerCase();
          } : function(s) {
            return s.toUpperCase();
          };
        }
        function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp3, dir) {
          var length = Math.min(key.length, lowerNeedle.length);
          var llp = -1;
          for (var i = 0; i < length; ++i) {
            var lwrKeyChar = lowerKey[i];
            if (lwrKeyChar !== lowerNeedle[i]) {
              if (cmp3(key[i], upperNeedle[i]) < 0)
                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
              if (cmp3(key[i], lowerNeedle[i]) < 0)
                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
              if (llp >= 0)
                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
              return null;
            }
            if (cmp3(key[i], lwrKeyChar) < 0)
              llp = i;
          }
          if (length < lowerNeedle.length && dir === "next")
            return key + upperNeedle.substr(key.length);
          if (length < key.length && dir === "prev")
            return key.substr(0, upperNeedle.length);
          return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
        }
        function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
          var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
          if (!needles.every(function(s) {
            return typeof s === "string";
          })) {
            return fail(whereClause, STRING_EXPECTED);
          }
          function initDirection(dir) {
            upper = upperFactory(dir);
            lower = lowerFactory(dir);
            compare = dir === "next" ? simpleCompare : simpleCompareReverse;
            var needleBounds = needles.map(function(needle) {
              return { lower: lower(needle), upper: upper(needle) };
            }).sort(function(a, b) {
              return compare(a.lower, b.lower);
            });
            upperNeedles = needleBounds.map(function(nb) {
              return nb.upper;
            });
            lowerNeedles = needleBounds.map(function(nb) {
              return nb.lower;
            });
            direction = dir;
            nextKeySuffix = dir === "next" ? "" : suffix;
          }
          initDirection("next");
          var c = new whereClause.Collection(whereClause, function() {
            return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
          });
          c._ondirectionchange = function(direction2) {
            initDirection(direction2);
          };
          var firstPossibleNeedle = 0;
          c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            if (typeof key !== "string")
              return false;
            var lowerKey = lower(key);
            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
              return true;
            } else {
              var lowestPossibleCasing = null;
              for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                if (casing === null && lowestPossibleCasing === null)
                  firstPossibleNeedle = i + 1;
                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                  lowestPossibleCasing = casing;
                }
              }
              if (lowestPossibleCasing !== null) {
                advance(function() {
                  cursor.continue(lowestPossibleCasing + nextKeySuffix);
                });
              } else {
                advance(resolve);
              }
              return false;
            }
          });
          return c;
        }
        function createRange(lower, upper, lowerOpen, upperOpen) {
          return {
            type: 2,
            lower,
            upper,
            lowerOpen,
            upperOpen
          };
        }
        function rangeEqual(value) {
          return {
            type: 1,
            lower: value,
            upper: value
          };
        }
        var WhereClause = (function() {
          function WhereClause2() {
          }
          Object.defineProperty(WhereClause2.prototype, "Collection", {
            get: function() {
              return this._ctx.table.db.Collection;
            },
            enumerable: false,
            configurable: true
          });
          WhereClause2.prototype.between = function(lower, upper, includeLower, includeUpper) {
            includeLower = includeLower !== false;
            includeUpper = includeUpper === true;
            try {
              if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
                return emptyCollection(this);
              return new this.Collection(this, function() {
                return createRange(lower, upper, !includeLower, !includeUpper);
              });
            } catch (e) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
          };
          WhereClause2.prototype.equals = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return rangeEqual(value);
            });
          };
          WhereClause2.prototype.above = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange(value, void 0, true);
            });
          };
          WhereClause2.prototype.aboveOrEqual = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange(value, void 0, false);
            });
          };
          WhereClause2.prototype.below = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange(void 0, value, false, true);
            });
          };
          WhereClause2.prototype.belowOrEqual = function(value) {
            if (value == null)
              return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
              return createRange(void 0, value);
            });
          };
          WhereClause2.prototype.startsWith = function(str) {
            if (typeof str !== "string")
              return fail(this, STRING_EXPECTED);
            return this.between(str, str + maxString, true, true);
          };
          WhereClause2.prototype.startsWithIgnoreCase = function(str) {
            if (str === "")
              return this.startsWith(str);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return x.indexOf(a[0]) === 0;
            }, [str], maxString);
          };
          WhereClause2.prototype.equalsIgnoreCase = function(str) {
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return x === a[0];
            }, [str], "");
          };
          WhereClause2.prototype.anyOfIgnoreCase = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
              return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return a.indexOf(x) !== -1;
            }, set, "");
          };
          WhereClause2.prototype.startsWithAnyOfIgnoreCase = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
              return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
              return a.some(function(n) {
                return x.indexOf(n) === 0;
              });
            }, set, maxString);
          };
          WhereClause2.prototype.anyOf = function() {
            var _this = this;
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            var compare = this._cmp;
            try {
              set.sort(compare);
            } catch (e) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
            if (set.length === 0)
              return emptyCollection(this);
            var c = new this.Collection(this, function() {
              return createRange(set[0], set[set.length - 1]);
            });
            c._ondirectionchange = function(direction) {
              compare = direction === "next" ? _this._ascending : _this._descending;
              set.sort(compare);
            };
            var i = 0;
            c._addAlgorithm(function(cursor, advance, resolve) {
              var key = cursor.key;
              while (compare(key, set[i]) > 0) {
                ++i;
                if (i === set.length) {
                  advance(resolve);
                  return false;
                }
              }
              if (compare(key, set[i]) === 0) {
                return true;
              } else {
                advance(function() {
                  cursor.continue(set[i]);
                });
                return false;
              }
            });
            return c;
          };
          WhereClause2.prototype.notEqual = function(value) {
            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
          };
          WhereClause2.prototype.noneOf = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
              return new this.Collection(this);
            try {
              set.sort(this._ascending);
            } catch (e) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
            var ranges = set.reduce(function(res, val) {
              return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
            }, null);
            ranges.push([set[set.length - 1], this.db._maxKey]);
            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
          };
          WhereClause2.prototype.inAnyRange = function(ranges, options) {
            var _this = this;
            var cmp3 = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
            if (ranges.length === 0)
              return emptyCollection(this);
            if (!ranges.every(function(range) {
              return range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0;
            })) {
              return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
            }
            var includeLowers = !options || options.includeLowers !== false;
            var includeUppers = options && options.includeUppers === true;
            function addRange2(ranges2, newRange) {
              var i = 0, l = ranges2.length;
              for (; i < l; ++i) {
                var range = ranges2[i];
                if (cmp3(newRange[0], range[1]) < 0 && cmp3(newRange[1], range[0]) > 0) {
                  range[0] = min(range[0], newRange[0]);
                  range[1] = max(range[1], newRange[1]);
                  break;
                }
              }
              if (i === l)
                ranges2.push(newRange);
              return ranges2;
            }
            var sortDirection = ascending;
            function rangeSorter(a, b) {
              return sortDirection(a[0], b[0]);
            }
            var set;
            try {
              set = ranges.reduce(addRange2, []);
              set.sort(rangeSorter);
            } catch (ex) {
              return fail(this, INVALID_KEY_ARGUMENT);
            }
            var rangePos = 0;
            var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
              return ascending(key, set[rangePos][1]) > 0;
            } : function(key) {
              return ascending(key, set[rangePos][1]) >= 0;
            };
            var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
              return descending(key, set[rangePos][0]) > 0;
            } : function(key) {
              return descending(key, set[rangePos][0]) >= 0;
            };
            function keyWithinCurrentRange(key) {
              return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
            }
            var checkKey = keyIsBeyondCurrentEntry;
            var c = new this.Collection(this, function() {
              return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
            });
            c._ondirectionchange = function(direction) {
              if (direction === "next") {
                checkKey = keyIsBeyondCurrentEntry;
                sortDirection = ascending;
              } else {
                checkKey = keyIsBeforeCurrentEntry;
                sortDirection = descending;
              }
              set.sort(rangeSorter);
            };
            c._addAlgorithm(function(cursor, advance, resolve) {
              var key = cursor.key;
              while (checkKey(key)) {
                ++rangePos;
                if (rangePos === set.length) {
                  advance(resolve);
                  return false;
                }
              }
              if (keyWithinCurrentRange(key)) {
                return true;
              } else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
                return false;
              } else {
                advance(function() {
                  if (sortDirection === ascending)
                    cursor.continue(set[rangePos][0]);
                  else
                    cursor.continue(set[rangePos][1]);
                });
                return false;
              }
            });
            return c;
          };
          WhereClause2.prototype.startsWithAnyOf = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (!set.every(function(s) {
              return typeof s === "string";
            })) {
              return fail(this, "startsWithAnyOf() only works with strings");
            }
            if (set.length === 0)
              return emptyCollection(this);
            return this.inAnyRange(set.map(function(str) {
              return [str, str + maxString];
            }));
          };
          return WhereClause2;
        })();
        function createWhereClauseConstructor(db2) {
          return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {
            this.db = db2;
            this._ctx = {
              table,
              index: index === ":id" ? null : index,
              or: orCollection
            };
            this._cmp = this._ascending = cmp2;
            this._descending = function(a, b) {
              return cmp2(b, a);
            };
            this._max = function(a, b) {
              return cmp2(a, b) > 0 ? a : b;
            };
            this._min = function(a, b) {
              return cmp2(a, b) < 0 ? a : b;
            };
            this._IDBKeyRange = db2._deps.IDBKeyRange;
            if (!this._IDBKeyRange)
              throw new exceptions.MissingAPI();
          });
        }
        function eventRejectHandler(reject) {
          return wrap(function(event) {
            preventDefault(event);
            reject(event.target.error);
            return false;
          });
        }
        function preventDefault(event) {
          if (event.stopPropagation)
            event.stopPropagation();
          if (event.preventDefault)
            event.preventDefault();
        }
        var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
        var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
        var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
        var Transaction = (function() {
          function Transaction2() {
          }
          Transaction2.prototype._lock = function() {
            assert2(!PSD.global);
            ++this._reculock;
            if (this._reculock === 1 && !PSD.global)
              PSD.lockOwnerFor = this;
            return this;
          };
          Transaction2.prototype._unlock = function() {
            assert2(!PSD.global);
            if (--this._reculock === 0) {
              if (!PSD.global)
                PSD.lockOwnerFor = null;
              while (this._blockedFuncs.length > 0 && !this._locked()) {
                var fnAndPSD = this._blockedFuncs.shift();
                try {
                  usePSD(fnAndPSD[1], fnAndPSD[0]);
                } catch (e) {
                }
              }
            }
            return this;
          };
          Transaction2.prototype._locked = function() {
            return this._reculock && PSD.lockOwnerFor !== this;
          };
          Transaction2.prototype.create = function(idbtrans) {
            var _this = this;
            if (!this.mode)
              return this;
            var idbdb = this.db.idbdb;
            var dbOpenError = this.db._state.dbOpenError;
            assert2(!this.idbtrans);
            if (!idbtrans && !idbdb) {
              switch (dbOpenError && dbOpenError.name) {
                case "DatabaseClosedError":
                  throw new exceptions.DatabaseClosed(dbOpenError);
                case "MissingAPIError":
                  throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                default:
                  throw new exceptions.OpenFailed(dbOpenError);
              }
            }
            if (!this.active)
              throw new exceptions.TransactionInactive();
            assert2(this._completion._state === null);
            idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
            idbtrans.onerror = wrap(function(ev) {
              preventDefault(ev);
              _this._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap(function(ev) {
              preventDefault(ev);
              _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
              _this.active = false;
              _this.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap(function() {
              _this.active = false;
              _this._resolve();
              if ("mutatedParts" in idbtrans) {
                globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
              }
            });
            return this;
          };
          Transaction2.prototype._promise = function(mode, fn, bWriteLock) {
            var _this = this;
            if (mode === "readwrite" && this.mode !== "readwrite")
              return rejection(new exceptions.ReadOnly("Transaction is readonly"));
            if (!this.active)
              return rejection(new exceptions.TransactionInactive());
            if (this._locked()) {
              return new DexiePromise(function(resolve, reject) {
                _this._blockedFuncs.push([function() {
                  _this._promise(mode, fn, bWriteLock).then(resolve, reject);
                }, PSD]);
              });
            } else if (bWriteLock) {
              return newScope(function() {
                var p2 = new DexiePromise(function(resolve, reject) {
                  _this._lock();
                  var rv = fn(resolve, reject, _this);
                  if (rv && rv.then)
                    rv.then(resolve, reject);
                });
                p2.finally(function() {
                  return _this._unlock();
                });
                p2._lib = true;
                return p2;
              });
            } else {
              var p = new DexiePromise(function(resolve, reject) {
                var rv = fn(resolve, reject, _this);
                if (rv && rv.then)
                  rv.then(resolve, reject);
              });
              p._lib = true;
              return p;
            }
          };
          Transaction2.prototype._root = function() {
            return this.parent ? this.parent._root() : this;
          };
          Transaction2.prototype.waitFor = function(promiseLike) {
            var root = this._root();
            var promise = DexiePromise.resolve(promiseLike);
            if (root._waitingFor) {
              root._waitingFor = root._waitingFor.then(function() {
                return promise;
              });
            } else {
              root._waitingFor = promise;
              root._waitingQueue = [];
              var store = root.idbtrans.objectStore(root.storeNames[0]);
              (function spin() {
                ++root._spinCount;
                while (root._waitingQueue.length)
                  root._waitingQueue.shift()();
                if (root._waitingFor)
                  store.get(-Infinity).onsuccess = spin;
              })();
            }
            var currentWaitPromise = root._waitingFor;
            return new DexiePromise(function(resolve, reject) {
              promise.then(function(res) {
                return root._waitingQueue.push(wrap(resolve.bind(null, res)));
              }, function(err) {
                return root._waitingQueue.push(wrap(reject.bind(null, err)));
              }).finally(function() {
                if (root._waitingFor === currentWaitPromise) {
                  root._waitingFor = null;
                }
              });
            });
          };
          Transaction2.prototype.abort = function() {
            if (this.active) {
              this.active = false;
              if (this.idbtrans)
                this.idbtrans.abort();
              this._reject(new exceptions.Abort());
            }
          };
          Transaction2.prototype.table = function(tableName) {
            var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
            if (hasOwn(memoizedTables, tableName))
              return memoizedTables[tableName];
            var tableSchema = this.schema[tableName];
            if (!tableSchema) {
              throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            }
            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
            transactionBoundTable.core = this.db.core.table(tableName);
            memoizedTables[tableName] = transactionBoundTable;
            return transactionBoundTable;
          };
          return Transaction2;
        })();
        function createTransactionConstructor(db2) {
          return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
            var _this = this;
            if (mode !== "readonly")
              storeNames.forEach(function(storeName) {
                var _a2;
                var yProps = (_a2 = dbschema[storeName]) === null || _a2 === void 0 ? void 0 : _a2.yProps;
                if (yProps)
                  storeNames = storeNames.concat(yProps.map(function(p) {
                    return p.updatesTable;
                  }));
              });
            this.db = db2;
            this.mode = mode;
            this.storeNames = storeNames;
            this.schema = dbschema;
            this.chromeTransactionDurability = chromeTransactionDurability;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0;
            this._completion = new DexiePromise(function(resolve, reject) {
              _this._resolve = resolve;
              _this._reject = reject;
            });
            this._completion.then(function() {
              _this.active = false;
              _this.on.complete.fire();
            }, function(e) {
              var wasActive = _this.active;
              _this.active = false;
              _this.on.error.fire(e);
              _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
              return rejection(e);
            });
          });
        }
        function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey, type2) {
          return {
            name,
            keyPath,
            unique,
            multi,
            auto,
            compound,
            src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath),
            type: type2
          };
        }
        function nameFromKeyPath(keyPath) {
          return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
        }
        function createTableSchema(name, primKey, indexes) {
          return {
            name,
            primKey,
            indexes,
            mappedClass: null,
            idxByName: arrayToObject(indexes, function(index) {
              return [index.name, index];
            })
          };
        }
        function safariMultiStoreFix(storeNames) {
          return storeNames.length === 1 ? storeNames[0] : storeNames;
        }
        var getMaxKey = function(IdbKeyRange) {
          try {
            IdbKeyRange.only([[]]);
            getMaxKey = function() {
              return [[]];
            };
            return [[]];
          } catch (e) {
            getMaxKey = function() {
              return maxString;
            };
            return maxString;
          }
        };
        function getKeyExtractor(keyPath) {
          if (keyPath == null) {
            return function() {
              return void 0;
            };
          } else if (typeof keyPath === "string") {
            return getSinglePathKeyExtractor(keyPath);
          } else {
            return function(obj) {
              return getByKeyPath(obj, keyPath);
            };
          }
        }
        function getSinglePathKeyExtractor(keyPath) {
          var split = keyPath.split(".");
          if (split.length === 1) {
            return function(obj) {
              return obj[keyPath];
            };
          } else {
            return function(obj) {
              return getByKeyPath(obj, keyPath);
            };
          }
        }
        function arrayify(arrayLike) {
          return [].slice.call(arrayLike);
        }
        var _id_counter = 0;
        function getKeyPathAlias(keyPath) {
          return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : "[".concat(keyPath.join("+"), "]");
        }
        function createDBCore(db2, IdbKeyRange, tmpTrans) {
          function extractSchema(db3, trans) {
            var tables2 = arrayify(db3.objectStoreNames);
            return {
              schema: {
                name: db3.name,
                tables: tables2.map(function(table) {
                  return trans.objectStore(table);
                }).map(function(store) {
                  var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                  var compound = isArray(keyPath);
                  var outbound = keyPath == null;
                  var indexByKeyPath = {};
                  var result = {
                    name: store.name,
                    primaryKey: {
                      name: null,
                      isPrimaryKey: true,
                      outbound,
                      compound,
                      keyPath,
                      autoIncrement,
                      unique: true,
                      extractKey: getKeyExtractor(keyPath)
                    },
                    indexes: arrayify(store.indexNames).map(function(indexName) {
                      return store.index(indexName);
                    }).map(function(index) {
                      var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath2 = index.keyPath;
                      var compound2 = isArray(keyPath2);
                      var result2 = {
                        name,
                        compound: compound2,
                        keyPath: keyPath2,
                        unique,
                        multiEntry,
                        extractKey: getKeyExtractor(keyPath2)
                      };
                      indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
                      return result2;
                    }),
                    getIndexByKeyPath: function(keyPath2) {
                      return indexByKeyPath[getKeyPathAlias(keyPath2)];
                    }
                  };
                  indexByKeyPath[":id"] = result.primaryKey;
                  if (keyPath != null) {
                    indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                  }
                  return result;
                })
              },
              hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
            };
          }
          function makeIDBKeyRange(range) {
            if (range.type === 3)
              return null;
            if (range.type === 4)
              throw new Error("Cannot convert never type to IDBKeyRange");
            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
            var idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
            return idbRange;
          }
          function createDbCoreTable(tableSchema) {
            var tableName = tableSchema.name;
            function mutate(_a3) {
              var trans = _a3.trans, type2 = _a3.type, keys3 = _a3.keys, values = _a3.values, range = _a3.range;
              return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var store = trans.objectStore(tableName);
                var outbound = store.keyPath == null;
                var isAddOrPut = type2 === "put" || type2 === "add";
                if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
                  throw new Error("Invalid operation type: " + type2);
                var length = (keys3 || values || { length: 1 }).length;
                if (keys3 && values && keys3.length !== values.length) {
                  throw new Error("Given keys array must have same length as given values array.");
                }
                if (length === 0)
                  return resolve({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
                var req;
                var reqs = [];
                var failures = [];
                var numFailures = 0;
                var errorHandler = function(event) {
                  ++numFailures;
                  preventDefault(event);
                };
                if (type2 === "deleteRange") {
                  if (range.type === 4)
                    return resolve({ numFailures, failures, results: [], lastResult: void 0 });
                  if (range.type === 3)
                    reqs.push(req = store.clear());
                  else
                    reqs.push(req = store.delete(makeIDBKeyRange(range)));
                } else {
                  var _a4 = isAddOrPut ? outbound ? [values, keys3] : [values, null] : [keys3, null], args1 = _a4[0], args2 = _a4[1];
                  if (isAddOrPut) {
                    for (var i = 0; i < length; ++i) {
                      reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
                      req.onerror = errorHandler;
                    }
                  } else {
                    for (var i = 0; i < length; ++i) {
                      reqs.push(req = store[type2](args1[i]));
                      req.onerror = errorHandler;
                    }
                  }
                }
                var done = function(event) {
                  var lastResult = event.target.result;
                  reqs.forEach(function(req2, i2) {
                    return req2.error != null && (failures[i2] = req2.error);
                  });
                  resolve({
                    numFailures,
                    failures,
                    results: type2 === "delete" ? keys3 : reqs.map(function(req2) {
                      return req2.result;
                    }),
                    lastResult
                  });
                };
                req.onerror = function(event) {
                  errorHandler(event);
                  done(event);
                };
                req.onsuccess = done;
              });
            }
            function openCursor2(_a3) {
              var trans = _a3.trans, values = _a3.values, query2 = _a3.query, reverse = _a3.reverse, unique = _a3.unique;
              return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var index = query2.index, range = query2.range;
                var store = trans.objectStore(tableName);
                var source = index.isPrimaryKey ? store : store.index(index.name);
                var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
                var req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
                req.onerror = eventRejectHandler(reject);
                req.onsuccess = wrap(function(ev) {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve(null);
                    return;
                  }
                  cursor.___id = ++_id_counter;
                  cursor.done = false;
                  var _cursorContinue = cursor.continue.bind(cursor);
                  var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                  if (_cursorContinuePrimaryKey)
                    _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                  var _cursorAdvance = cursor.advance.bind(cursor);
                  var doThrowCursorIsNotStarted = function() {
                    throw new Error("Cursor not started");
                  };
                  var doThrowCursorIsStopped = function() {
                    throw new Error("Cursor not stopped");
                  };
                  cursor.trans = trans;
                  cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                  cursor.fail = wrap(reject);
                  cursor.next = function() {
                    var _this = this;
                    var gotOne = 1;
                    return this.start(function() {
                      return gotOne-- ? _this.continue() : _this.stop();
                    }).then(function() {
                      return _this;
                    });
                  };
                  cursor.start = function(callback) {
                    var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                      resolveIteration = wrap(resolveIteration);
                      req.onerror = eventRejectHandler(rejectIteration);
                      cursor.fail = rejectIteration;
                      cursor.stop = function(value) {
                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                        resolveIteration(value);
                      };
                    });
                    var guardedCallback = function() {
                      if (req.result) {
                        try {
                          callback();
                        } catch (err) {
                          cursor.fail(err);
                        }
                      } else {
                        cursor.done = true;
                        cursor.start = function() {
                          throw new Error("Cursor behind last entry");
                        };
                        cursor.stop();
                      }
                    };
                    req.onsuccess = wrap(function(ev2) {
                      req.onsuccess = guardedCallback;
                      guardedCallback();
                    });
                    cursor.continue = _cursorContinue;
                    cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                    cursor.advance = _cursorAdvance;
                    guardedCallback();
                    return iterationPromise;
                  };
                  resolve(cursor);
                }, reject);
              });
            }
            function query(hasGetAll2) {
              return function(request) {
                return new Promise(function(resolve, reject) {
                  resolve = wrap(resolve);
                  var trans = request.trans, values = request.values, limit = request.limit, query2 = request.query;
                  var nonInfinitLimit = limit === Infinity ? void 0 : limit;
                  var index = query2.index, range = query2.range;
                  var store = trans.objectStore(tableName);
                  var source = index.isPrimaryKey ? store : store.index(index.name);
                  var idbKeyRange = makeIDBKeyRange(range);
                  if (limit === 0)
                    return resolve({ result: [] });
                  if (hasGetAll2) {
                    var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
                    req.onsuccess = function(event) {
                      return resolve({ result: event.target.result });
                    };
                    req.onerror = eventRejectHandler(reject);
                  } else {
                    var count_1 = 0;
                    var req_1 = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
                    var result_1 = [];
                    req_1.onsuccess = function(event) {
                      var cursor = req_1.result;
                      if (!cursor)
                        return resolve({ result: result_1 });
                      result_1.push(values ? cursor.value : cursor.primaryKey);
                      if (++count_1 === limit)
                        return resolve({ result: result_1 });
                      cursor.continue();
                    };
                    req_1.onerror = eventRejectHandler(reject);
                  }
                });
              };
            }
            return {
              name: tableName,
              schema: tableSchema,
              mutate,
              getMany: function(_a3) {
                var trans = _a3.trans, keys3 = _a3.keys;
                return new Promise(function(resolve, reject) {
                  resolve = wrap(resolve);
                  var store = trans.objectStore(tableName);
                  var length = keys3.length;
                  var result = new Array(length);
                  var keyCount = 0;
                  var callbackCount = 0;
                  var req;
                  var successHandler = function(event) {
                    var req2 = event.target;
                    if ((result[req2._pos] = req2.result) != null)
                      ;
                    if (++callbackCount === keyCount)
                      resolve(result);
                  };
                  var errorHandler = eventRejectHandler(reject);
                  for (var i = 0; i < length; ++i) {
                    var key = keys3[i];
                    if (key != null) {
                      req = store.get(keys3[i]);
                      req._pos = i;
                      req.onsuccess = successHandler;
                      req.onerror = errorHandler;
                      ++keyCount;
                    }
                  }
                  if (keyCount === 0)
                    resolve(result);
                });
              },
              get: function(_a3) {
                var trans = _a3.trans, key = _a3.key;
                return new Promise(function(resolve, reject) {
                  resolve = wrap(resolve);
                  var store = trans.objectStore(tableName);
                  var req = store.get(key);
                  req.onsuccess = function(event) {
                    return resolve(event.target.result);
                  };
                  req.onerror = eventRejectHandler(reject);
                });
              },
              query: query(hasGetAll),
              openCursor: openCursor2,
              count: function(_a3) {
                var query2 = _a3.query, trans = _a3.trans;
                var index = query2.index, range = query2.range;
                return new Promise(function(resolve, reject) {
                  var store = trans.objectStore(tableName);
                  var source = index.isPrimaryKey ? store : store.index(index.name);
                  var idbKeyRange = makeIDBKeyRange(range);
                  var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                  req.onsuccess = wrap(function(ev) {
                    return resolve(ev.target.result);
                  });
                  req.onerror = eventRejectHandler(reject);
                });
              }
            };
          }
          var _a2 = extractSchema(db2, tmpTrans), schema = _a2.schema, hasGetAll = _a2.hasGetAll;
          var tables = schema.tables.map(function(tableSchema) {
            return createDbCoreTable(tableSchema);
          });
          var tableMap = {};
          tables.forEach(function(table) {
            return tableMap[table.name] = table;
          });
          return {
            stack: "dbcore",
            transaction: db2.transaction.bind(db2),
            table: function(name) {
              var result = tableMap[name];
              if (!result)
                throw new Error("Table '".concat(name, "' not found"));
              return tableMap[name];
            },
            MIN_KEY: -Infinity,
            MAX_KEY: getMaxKey(IdbKeyRange),
            schema
          };
        }
        function createMiddlewareStack(stackImpl, middlewares) {
          return middlewares.reduce(function(down, _a2) {
            var create = _a2.create;
            return __assign(__assign({}, down), create(down));
          }, stackImpl);
        }
        function createMiddlewareStacks(middlewares, idbdb, _a2, tmpTrans) {
          var IDBKeyRange = _a2.IDBKeyRange;
          _a2.indexedDB;
          var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
          return {
            dbcore
          };
        }
        function generateMiddlewareStacks(db2, tmpTrans) {
          var idbdb = tmpTrans.db;
          var stacks = createMiddlewareStacks(db2._middlewares, idbdb, db2._deps, tmpTrans);
          db2.core = stacks.dbcore;
          db2.tables.forEach(function(table) {
            var tableName = table.name;
            if (db2.core.schema.tables.some(function(tbl) {
              return tbl.name === tableName;
            })) {
              table.core = db2.core.table(tableName);
              if (db2[tableName] instanceof db2.Table) {
                db2[tableName].core = table.core;
              }
            }
          });
        }
        function setApiOnPlace(db2, objs, tableNames, dbschema) {
          tableNames.forEach(function(tableName) {
            var schema = dbschema[tableName];
            objs.forEach(function(obj) {
              var propDesc = getPropertyDescriptor(obj, tableName);
              if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
                if (obj === db2.Transaction.prototype || obj instanceof db2.Transaction) {
                  setProp(obj, tableName, {
                    get: function() {
                      return this.table(tableName);
                    },
                    set: function(value) {
                      defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                    }
                  });
                } else {
                  obj[tableName] = new db2.Table(tableName, schema);
                }
              }
            });
          });
        }
        function removeTablesApi(db2, objs) {
          objs.forEach(function(obj) {
            for (var key in obj) {
              if (obj[key] instanceof db2.Table)
                delete obj[key];
            }
          });
        }
        function lowerVersionFirst(a, b) {
          return a._cfg.version - b._cfg.version;
        }
        function runUpgraders(db2, oldVersion, idbUpgradeTrans, reject) {
          var globalSchema = db2._dbSchema;
          if (idbUpgradeTrans.objectStoreNames.contains("$meta") && !globalSchema.$meta) {
            globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
            db2._storeNames.push("$meta");
          }
          var trans = db2._createTransaction("readwrite", db2._storeNames, globalSchema);
          trans.create(idbUpgradeTrans);
          trans._completion.catch(reject);
          var rejectTransaction = trans._reject.bind(trans);
          var transless = PSD.transless || PSD;
          newScope(function() {
            PSD.trans = trans;
            PSD.transless = transless;
            if (oldVersion === 0) {
              keys2(globalSchema).forEach(function(tableName) {
                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
              });
              generateMiddlewareStacks(db2, idbUpgradeTrans);
              DexiePromise.follow(function() {
                return db2.on.populate.fire(trans);
              }).catch(rejectTransaction);
            } else {
              generateMiddlewareStacks(db2, idbUpgradeTrans);
              return getExistingVersion(db2, trans, oldVersion).then(function(oldVersion2) {
                return updateTablesAndIndexes(db2, oldVersion2, trans, idbUpgradeTrans);
              }).catch(rejectTransaction);
            }
          });
        }
        function patchCurrentVersion(db2, idbUpgradeTrans) {
          createMissingTables(db2._dbSchema, idbUpgradeTrans);
          if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains("$meta")) {
            idbUpgradeTrans.db.createObjectStore("$meta").add(Math.ceil(idbUpgradeTrans.db.version / 10 - 1), "version");
          }
          var globalSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
          adjustToExistingIndexNames(db2, db2._dbSchema, idbUpgradeTrans);
          var diff = getSchemaDiff(globalSchema, db2._dbSchema);
          var _loop_1 = function(tableChange2) {
            if (tableChange2.change.length || tableChange2.recreate) {
              console.warn("Unable to patch indexes of table ".concat(tableChange2.name, " because it has changes on the type of index or primary key."));
              return { value: void 0 };
            }
            var store = idbUpgradeTrans.objectStore(tableChange2.name);
            tableChange2.add.forEach(function(idx) {
              if (debug)
                console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange2.name, ".").concat(idx.src));
              addIndex(store, idx);
            });
          };
          for (var _i = 0, _a2 = diff.change; _i < _a2.length; _i++) {
            var tableChange = _a2[_i];
            var state_1 = _loop_1(tableChange);
            if (typeof state_1 === "object")
              return state_1.value;
          }
        }
        function getExistingVersion(db2, trans, oldVersion) {
          if (trans.storeNames.includes("$meta")) {
            return trans.table("$meta").get("version").then(function(metaVersion) {
              return metaVersion != null ? metaVersion : oldVersion;
            });
          } else {
            return DexiePromise.resolve(oldVersion);
          }
        }
        function updateTablesAndIndexes(db2, oldVersion, trans, idbUpgradeTrans) {
          var queue = [];
          var versions = db2._versions;
          var globalSchema = db2._dbSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
          var versToRun = versions.filter(function(v) {
            return v._cfg.version >= oldVersion;
          });
          if (versToRun.length === 0) {
            return DexiePromise.resolve();
          }
          versToRun.forEach(function(version2) {
            queue.push(function() {
              var oldSchema = globalSchema;
              var newSchema = version2._cfg.dbschema;
              adjustToExistingIndexNames(db2, oldSchema, idbUpgradeTrans);
              adjustToExistingIndexNames(db2, newSchema, idbUpgradeTrans);
              globalSchema = db2._dbSchema = newSchema;
              var diff = getSchemaDiff(oldSchema, newSchema);
              diff.add.forEach(function(tuple) {
                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
              });
              diff.change.forEach(function(change) {
                if (change.recreate) {
                  throw new exceptions.Upgrade("Not yet support for changing primary key");
                } else {
                  var store_1 = idbUpgradeTrans.objectStore(change.name);
                  change.add.forEach(function(idx) {
                    return addIndex(store_1, idx);
                  });
                  change.change.forEach(function(idx) {
                    store_1.deleteIndex(idx.name);
                    addIndex(store_1, idx);
                  });
                  change.del.forEach(function(idxName) {
                    return store_1.deleteIndex(idxName);
                  });
                }
              });
              var contentUpgrade = version2._cfg.contentUpgrade;
              if (contentUpgrade && version2._cfg.version > oldVersion) {
                generateMiddlewareStacks(db2, idbUpgradeTrans);
                trans._memoizedTables = {};
                var upgradeSchema_1 = shallowClone(newSchema);
                diff.del.forEach(function(table) {
                  upgradeSchema_1[table] = oldSchema[table];
                });
                removeTablesApi(db2, [db2.Transaction.prototype]);
                setApiOnPlace(db2, [db2.Transaction.prototype], keys2(upgradeSchema_1), upgradeSchema_1);
                trans.schema = upgradeSchema_1;
                var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                if (contentUpgradeIsAsync_1) {
                  incrementExpectedAwaits();
                }
                var returnValue_1;
                var promiseFollowed = DexiePromise.follow(function() {
                  returnValue_1 = contentUpgrade(trans);
                  if (returnValue_1) {
                    if (contentUpgradeIsAsync_1) {
                      var decrementor = decrementExpectedAwaits.bind(null, null);
                      returnValue_1.then(decrementor, decrementor);
                    }
                  }
                });
                return returnValue_1 && typeof returnValue_1.then === "function" ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
                  return returnValue_1;
                });
              }
            });
            queue.push(function(idbtrans) {
              var newSchema = version2._cfg.dbschema;
              deleteRemovedTables(newSchema, idbtrans);
              removeTablesApi(db2, [db2.Transaction.prototype]);
              setApiOnPlace(db2, [db2.Transaction.prototype], db2._storeNames, db2._dbSchema);
              trans.schema = db2._dbSchema;
            });
            queue.push(function(idbtrans) {
              if (db2.idbdb.objectStoreNames.contains("$meta")) {
                if (Math.ceil(db2.idbdb.version / 10) === version2._cfg.version) {
                  db2.idbdb.deleteObjectStore("$meta");
                  delete db2._dbSchema.$meta;
                  db2._storeNames = db2._storeNames.filter(function(name) {
                    return name !== "$meta";
                  });
                } else {
                  idbtrans.objectStore("$meta").put(version2._cfg.version, "version");
                }
              }
            });
          });
          function runQueue() {
            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
          }
          return runQueue().then(function() {
            createMissingTables(globalSchema, idbUpgradeTrans);
          });
        }
        function getSchemaDiff(oldSchema, newSchema) {
          var diff = {
            del: [],
            add: [],
            change: []
          };
          var table;
          for (table in oldSchema) {
            if (!newSchema[table])
              diff.del.push(table);
          }
          for (table in newSchema) {
            var oldDef = oldSchema[table], newDef = newSchema[table];
            if (!oldDef) {
              diff.add.push([table, newDef]);
            } else {
              var change = {
                name: table,
                def: newDef,
                recreate: false,
                del: [],
                add: [],
                change: []
              };
              if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto) {
                change.recreate = true;
                diff.change.push(change);
              } else {
                var oldIndexes = oldDef.idxByName;
                var newIndexes = newDef.idxByName;
                var idxName = void 0;
                for (idxName in oldIndexes) {
                  if (!newIndexes[idxName])
                    change.del.push(idxName);
                }
                for (idxName in newIndexes) {
                  var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                  if (!oldIdx)
                    change.add.push(newIdx);
                  else if (oldIdx.src !== newIdx.src)
                    change.change.push(newIdx);
                }
                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                  diff.change.push(change);
                }
              }
            }
          }
          return diff;
        }
        function createTable(idbtrans, tableName, primKey, indexes) {
          var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
          indexes.forEach(function(idx) {
            return addIndex(store, idx);
          });
          return store;
        }
        function createMissingTables(newSchema, idbtrans) {
          keys2(newSchema).forEach(function(tableName) {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
              if (debug)
                console.debug("Dexie: Creating missing table", tableName);
              createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
          });
        }
        function deleteRemovedTables(newSchema, idbtrans) {
          [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
          });
        }
        function addIndex(store, idx) {
          store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
        }
        function buildGlobalSchema(db2, idbdb, tmpTrans) {
          var globalSchema = {};
          var dbStoreNames = slice(idbdb.objectStoreNames, 0);
          dbStoreNames.forEach(function(storeName) {
            var store = tmpTrans.objectStore(storeName);
            var keyPath = store.keyPath;
            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
            var indexes = [];
            for (var j = 0; j < store.indexNames.length; ++j) {
              var idbindex = store.index(store.indexNames[j]);
              keyPath = idbindex.keyPath;
              var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
              indexes.push(index);
            }
            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
          });
          return globalSchema;
        }
        function readGlobalSchema(db2, idbdb, tmpTrans) {
          db2.verno = idbdb.version / 10;
          var globalSchema = db2._dbSchema = buildGlobalSchema(db2, idbdb, tmpTrans);
          db2._storeNames = slice(idbdb.objectStoreNames, 0);
          setApiOnPlace(db2, [db2._allTables], keys2(globalSchema), globalSchema);
        }
        function verifyInstalledSchema(db2, tmpTrans) {
          var installedSchema = buildGlobalSchema(db2, db2.idbdb, tmpTrans);
          var diff = getSchemaDiff(installedSchema, db2._dbSchema);
          return !(diff.add.length || diff.change.some(function(ch) {
            return ch.add.length || ch.change.length;
          }));
        }
        function adjustToExistingIndexNames(db2, schema, idbtrans) {
          var storeNames = idbtrans.db.objectStoreNames;
          for (var i = 0; i < storeNames.length; ++i) {
            var storeName = storeNames[i];
            var store = idbtrans.objectStore(storeName);
            db2._hasGetAll = "getAll" in store;
            for (var j = 0; j < store.indexNames.length; ++j) {
              var indexName = store.indexNames[j];
              var keyPath = store.index(indexName).keyPath;
              var dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
              if (schema[storeName]) {
                var indexSpec = schema[storeName].idxByName[dexieName];
                if (indexSpec) {
                  indexSpec.name = indexName;
                  delete schema[storeName].idxByName[dexieName];
                  schema[storeName].idxByName[indexName] = indexSpec;
                }
              }
            }
          }
          if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
            db2._hasGetAll = false;
          }
        }
        function parseIndexSyntax(primKeyAndIndexes) {
          return primKeyAndIndexes.split(",").map(function(index, indexNum) {
            var _a2;
            var typeSplit = index.split(":");
            var type2 = (_a2 = typeSplit[1]) === null || _a2 === void 0 ? void 0 : _a2.trim();
            index = typeSplit[0].trim();
            var name = index.replace(/([&*]|\+\+)/g, "");
            var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
            return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0, type2);
          });
        }
        var Version = (function() {
          function Version2() {
          }
          Version2.prototype._createTableSchema = function(name, primKey, indexes) {
            return createTableSchema(name, primKey, indexes);
          };
          Version2.prototype._parseIndexSyntax = function(primKeyAndIndexes) {
            return parseIndexSyntax(primKeyAndIndexes);
          };
          Version2.prototype._parseStoresSpec = function(stores, outSchema) {
            var _this = this;
            keys2(stores).forEach(function(tableName) {
              if (stores[tableName] !== null) {
                var indexes = _this._parseIndexSyntax(stores[tableName]);
                var primKey = indexes.shift();
                if (!primKey) {
                  throw new exceptions.Schema("Invalid schema for table " + tableName + ": " + stores[tableName]);
                }
                primKey.unique = true;
                if (primKey.multi)
                  throw new exceptions.Schema("Primary key cannot be multiEntry*");
                indexes.forEach(function(idx) {
                  if (idx.auto)
                    throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                  if (!idx.keyPath)
                    throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                });
                var tblSchema = _this._createTableSchema(tableName, primKey, indexes);
                outSchema[tableName] = tblSchema;
              }
            });
          };
          Version2.prototype.stores = function(stores) {
            var db2 = this.db;
            this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
            var versions = db2._versions;
            var storesSpec = {};
            var dbschema = {};
            versions.forEach(function(version2) {
              extend(storesSpec, version2._cfg.storesSource);
              dbschema = version2._cfg.dbschema = {};
              version2._parseStoresSpec(storesSpec, dbschema);
            });
            db2._dbSchema = dbschema;
            removeTablesApi(db2, [db2._allTables, db2, db2.Transaction.prototype]);
            setApiOnPlace(db2, [db2._allTables, db2, db2.Transaction.prototype, this._cfg.tables], keys2(dbschema), dbschema);
            db2._storeNames = keys2(dbschema);
            return this;
          };
          Version2.prototype.upgrade = function(upgradeFunction) {
            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
            return this;
          };
          return Version2;
        })();
        function createVersionConstructor(db2) {
          return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
            this.db = db2;
            this._cfg = {
              version: versionNumber,
              storesSource: null,
              dbschema: {},
              tables: {},
              contentUpgrade: null
            };
          });
        }
        function getDbNamesTable(indexedDB2, IDBKeyRange) {
          var dbNamesDB = indexedDB2["_dbNamesDB"];
          if (!dbNamesDB) {
            dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
              addons: [],
              indexedDB: indexedDB2,
              IDBKeyRange
            });
            dbNamesDB.version(1).stores({ dbnames: "name" });
          }
          return dbNamesDB.table("dbnames");
        }
        function hasDatabasesNative(indexedDB2) {
          return indexedDB2 && typeof indexedDB2.databases === "function";
        }
        function getDatabaseNames(_a2) {
          var indexedDB2 = _a2.indexedDB, IDBKeyRange = _a2.IDBKeyRange;
          return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then(function(infos) {
            return infos.map(function(info) {
              return info.name;
            }).filter(function(name) {
              return name !== DBNAMES_DB;
            });
          }) : getDbNamesTable(indexedDB2, IDBKeyRange).toCollection().primaryKeys();
        }
        function _onDatabaseCreated(_a2, name) {
          var indexedDB2 = _a2.indexedDB, IDBKeyRange = _a2.IDBKeyRange;
          !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).put({ name }).catch(nop);
        }
        function _onDatabaseDeleted(_a2, name) {
          var indexedDB2 = _a2.indexedDB, IDBKeyRange = _a2.IDBKeyRange;
          !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).delete(name).catch(nop);
        }
        function vip(fn) {
          return newScope(function() {
            PSD.letThrough = true;
            return fn();
          });
        }
        function idbReady() {
          var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
          if (!isSafari || !indexedDB.databases)
            return Promise.resolve();
          var intervalId;
          return new Promise(function(resolve) {
            var tryIdb = function() {
              return indexedDB.databases().finally(resolve);
            };
            intervalId = setInterval(tryIdb, 100);
            tryIdb();
          }).finally(function() {
            return clearInterval(intervalId);
          });
        }
        var _a;
        function isEmptyRange(node) {
          return !("from" in node);
        }
        var RangeSet2 = function(fromOrTree, to) {
          if (this) {
            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
          } else {
            var rv = new RangeSet2();
            if (fromOrTree && "d" in fromOrTree) {
              extend(rv, fromOrTree);
            }
            return rv;
          }
        };
        props(RangeSet2.prototype, (_a = {
          add: function(rangeSet) {
            mergeRanges2(this, rangeSet);
            return this;
          },
          addKey: function(key) {
            addRange(this, key, key);
            return this;
          },
          addKeys: function(keys3) {
            var _this = this;
            keys3.forEach(function(key) {
              return addRange(_this, key, key);
            });
            return this;
          },
          hasKey: function(key) {
            var node = getRangeSetIterator(this).next(key).value;
            return node && cmp2(node.from, key) <= 0 && cmp2(node.to, key) >= 0;
          }
        }, _a[iteratorSymbol] = function() {
          return getRangeSetIterator(this);
        }, _a));
        function addRange(target, from, to) {
          var diff = cmp2(from, to);
          if (isNaN(diff))
            return;
          if (diff > 0)
            throw RangeError();
          if (isEmptyRange(target))
            return extend(target, { from, to, d: 1 });
          var left = target.l;
          var right = target.r;
          if (cmp2(to, target.from) < 0) {
            left ? addRange(left, from, to) : target.l = { from, to, d: 1, l: null, r: null };
            return rebalance(target);
          }
          if (cmp2(from, target.to) > 0) {
            right ? addRange(right, from, to) : target.r = { from, to, d: 1, l: null, r: null };
            return rebalance(target);
          }
          if (cmp2(from, target.from) < 0) {
            target.from = from;
            target.l = null;
            target.d = right ? right.d + 1 : 1;
          }
          if (cmp2(to, target.to) > 0) {
            target.to = to;
            target.r = null;
            target.d = target.l ? target.l.d + 1 : 1;
          }
          var rightWasCutOff = !target.r;
          if (left && !target.l) {
            mergeRanges2(target, left);
          }
          if (right && rightWasCutOff) {
            mergeRanges2(target, right);
          }
        }
        function mergeRanges2(target, newSet) {
          function _addRangeSet(target2, _a2) {
            var from = _a2.from, to = _a2.to, l = _a2.l, r = _a2.r;
            addRange(target2, from, to);
            if (l)
              _addRangeSet(target2, l);
            if (r)
              _addRangeSet(target2, r);
          }
          if (!isEmptyRange(newSet))
            _addRangeSet(target, newSet);
        }
        function rangesOverlap2(rangeSet1, rangeSet2) {
          var i1 = getRangeSetIterator(rangeSet2);
          var nextResult1 = i1.next();
          if (nextResult1.done)
            return false;
          var a = nextResult1.value;
          var i2 = getRangeSetIterator(rangeSet1);
          var nextResult2 = i2.next(a.from);
          var b = nextResult2.value;
          while (!nextResult1.done && !nextResult2.done) {
            if (cmp2(b.from, a.to) <= 0 && cmp2(b.to, a.from) >= 0)
              return true;
            cmp2(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
          }
          return false;
        }
        function getRangeSetIterator(node) {
          var state = isEmptyRange(node) ? null : { s: 0, n: node };
          return {
            next: function(key) {
              var keyProvided = arguments.length > 0;
              while (state) {
                switch (state.s) {
                  case 0:
                    state.s = 1;
                    if (keyProvided) {
                      while (state.n.l && cmp2(key, state.n.from) < 0)
                        state = { up: state, n: state.n.l, s: 1 };
                    } else {
                      while (state.n.l)
                        state = { up: state, n: state.n.l, s: 1 };
                    }
                  case 1:
                    state.s = 2;
                    if (!keyProvided || cmp2(key, state.n.to) <= 0)
                      return { value: state.n, done: false };
                  case 2:
                    if (state.n.r) {
                      state.s = 3;
                      state = { up: state, n: state.n.r, s: 0 };
                      continue;
                    }
                  case 3:
                    state = state.up;
                }
              }
              return { done: true };
            }
          };
        }
        function rebalance(target) {
          var _a2, _b;
          var diff = (((_a2 = target.r) === null || _a2 === void 0 ? void 0 : _a2.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
          var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
          if (r) {
            var l = r === "r" ? "l" : "r";
            var rootClone = __assign({}, target);
            var oldRootRight = target[r];
            target.from = oldRootRight.from;
            target.to = oldRootRight.to;
            target[r] = oldRootRight[r];
            rootClone[r] = oldRootRight[l];
            target[l] = rootClone;
            rootClone.d = computeDepth(rootClone);
          }
          target.d = computeDepth(target);
        }
        function computeDepth(_a2) {
          var r = _a2.r, l = _a2.l;
          return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
        }
        function extendObservabilitySet(target, newSet) {
          keys2(newSet).forEach(function(part) {
            if (target[part])
              mergeRanges2(target[part], newSet[part]);
            else
              target[part] = cloneSimpleObjectTree(newSet[part]);
          });
          return target;
        }
        function obsSetsOverlap(os1, os2) {
          return os1.all || os2.all || Object.keys(os1).some(function(key) {
            return os2[key] && rangesOverlap2(os2[key], os1[key]);
          });
        }
        var cache2 = {};
        var unsignaledParts = {};
        var isTaskEnqueued = false;
        function signalSubscribersLazily(part, optimistic) {
          extendObservabilitySet(unsignaledParts, part);
          if (!isTaskEnqueued) {
            isTaskEnqueued = true;
            setTimeout(function() {
              isTaskEnqueued = false;
              var parts = unsignaledParts;
              unsignaledParts = {};
              signalSubscribersNow(parts, false);
            }, 0);
          }
        }
        function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
          if (deleteAffectedCacheEntries === void 0) {
            deleteAffectedCacheEntries = false;
          }
          var queriesToSignal = /* @__PURE__ */ new Set();
          if (updatedParts.all) {
            for (var _i = 0, _a2 = Object.values(cache2); _i < _a2.length; _i++) {
              var tblCache = _a2[_i];
              collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
          } else {
            for (var key in updatedParts) {
              var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
              if (parts) {
                var dbName = parts[1], tableName = parts[2];
                var tblCache = cache2["idb://".concat(dbName, "/").concat(tableName)];
                if (tblCache)
                  collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
              }
            }
          }
          queriesToSignal.forEach(function(requery) {
            return requery();
          });
        }
        function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
          var updatedEntryLists = [];
          for (var _i = 0, _a2 = Object.entries(tblCache.queries.query); _i < _a2.length; _i++) {
            var _b = _a2[_i], indexName = _b[0], entries = _b[1];
            var filteredEntries = [];
            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
              var entry = entries_1[_c];
              if (obsSetsOverlap(updatedParts, entry.obsSet)) {
                entry.subscribers.forEach(function(requery) {
                  return outQueriesToSignal.add(requery);
                });
              } else if (deleteAffectedCacheEntries) {
                filteredEntries.push(entry);
              }
            }
            if (deleteAffectedCacheEntries)
              updatedEntryLists.push([indexName, filteredEntries]);
          }
          if (deleteAffectedCacheEntries) {
            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
              var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
              tblCache.queries.query[indexName] = filteredEntries;
            }
          }
        }
        function dexieOpen(db2) {
          var state = db2._state;
          var indexedDB2 = db2._deps.indexedDB;
          if (state.isBeingOpened || db2.idbdb)
            return state.dbReadyPromise.then(function() {
              return state.dbOpenError ? rejection(state.dbOpenError) : db2;
            });
          state.isBeingOpened = true;
          state.dbOpenError = null;
          state.openComplete = false;
          var openCanceller = state.openCanceller;
          var nativeVerToOpen = Math.round(db2.verno * 10);
          var schemaPatchMode = false;
          function throwIfCancelled() {
            if (state.openCanceller !== openCanceller)
              throw new exceptions.DatabaseClosed("db.open() was cancelled");
          }
          var resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
          var tryOpenDB = function() {
            return new DexiePromise(function(resolve, reject) {
              throwIfCancelled();
              if (!indexedDB2)
                throw new exceptions.MissingAPI();
              var dbName = db2.name;
              var req = state.autoSchema || !nativeVerToOpen ? indexedDB2.open(dbName) : indexedDB2.open(dbName, nativeVerToOpen);
              if (!req)
                throw new exceptions.MissingAPI();
              req.onerror = eventRejectHandler(reject);
              req.onblocked = wrap(db2._fireOnBlocked);
              req.onupgradeneeded = wrap(function(e) {
                upgradeTransaction = req.transaction;
                if (state.autoSchema && !db2._options.allowEmptyDB) {
                  req.onerror = preventDefault;
                  upgradeTransaction.abort();
                  req.result.close();
                  var delreq = indexedDB2.deleteDatabase(dbName);
                  delreq.onsuccess = delreq.onerror = wrap(function() {
                    reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                  });
                } else {
                  upgradeTransaction.onerror = eventRejectHandler(reject);
                  var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                  wasCreated = oldVer < 1;
                  db2.idbdb = req.result;
                  if (schemaPatchMode) {
                    patchCurrentVersion(db2, upgradeTransaction);
                  }
                  runUpgraders(db2, oldVer / 10, upgradeTransaction, reject);
                }
              }, reject);
              req.onsuccess = wrap(function() {
                upgradeTransaction = null;
                var idbdb = db2.idbdb = req.result;
                var objectStoreNames = slice(idbdb.objectStoreNames);
                if (objectStoreNames.length > 0)
                  try {
                    var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
                    if (state.autoSchema)
                      readGlobalSchema(db2, idbdb, tmpTrans);
                    else {
                      adjustToExistingIndexNames(db2, db2._dbSchema, tmpTrans);
                      if (!verifyInstalledSchema(db2, tmpTrans) && !schemaPatchMode) {
                        console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                        idbdb.close();
                        nativeVerToOpen = idbdb.version + 1;
                        schemaPatchMode = true;
                        return resolve(tryOpenDB());
                      }
                    }
                    generateMiddlewareStacks(db2, tmpTrans);
                  } catch (e) {
                  }
                connections.push(db2);
                idbdb.onversionchange = wrap(function(ev) {
                  state.vcFired = true;
                  db2.on("versionchange").fire(ev);
                });
                idbdb.onclose = wrap(function() {
                  db2.close({ disableAutoOpen: false });
                });
                if (wasCreated)
                  _onDatabaseCreated(db2._deps, dbName);
                resolve();
              }, reject);
            }).catch(function(err) {
              switch (err === null || err === void 0 ? void 0 : err.name) {
                case "UnknownError":
                  if (state.PR1398_maxLoop > 0) {
                    state.PR1398_maxLoop--;
                    console.warn("Dexie: Workaround for Chrome UnknownError on open()");
                    return tryOpenDB();
                  }
                  break;
                case "VersionError":
                  if (nativeVerToOpen > 0) {
                    nativeVerToOpen = 0;
                    return tryOpenDB();
                  }
                  break;
              }
              return DexiePromise.reject(err);
            });
          };
          return DexiePromise.race([
            openCanceller,
            (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
          ]).then(function() {
            throwIfCancelled();
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(function() {
              return db2.on.ready.fire(db2.vip);
            })).then(function fireRemainders() {
              if (state.onReadyBeingFired.length > 0) {
                var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
                state.onReadyBeingFired = [];
                return DexiePromise.resolve(vip(function() {
                  return remainders_1(db2.vip);
                })).then(fireRemainders);
              }
            });
          }).finally(function() {
            if (state.openCanceller === openCanceller) {
              state.onReadyBeingFired = null;
              state.isBeingOpened = false;
            }
          }).catch(function(err) {
            state.dbOpenError = err;
            try {
              upgradeTransaction && upgradeTransaction.abort();
            } catch (_a2) {
            }
            if (openCanceller === state.openCanceller) {
              db2._close();
            }
            return rejection(err);
          }).finally(function() {
            state.openComplete = true;
            resolveDbReady();
          }).then(function() {
            if (wasCreated) {
              var everything_1 = {};
              db2.tables.forEach(function(table) {
                table.schema.indexes.forEach(function(idx) {
                  if (idx.name)
                    everything_1["idb://".concat(db2.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet2(-Infinity, [[[]]]);
                });
                everything_1["idb://".concat(db2.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db2.name, "/").concat(table.name, "/:dels")] = new RangeSet2(-Infinity, [[[]]]);
              });
              globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
              signalSubscribersNow(everything_1, true);
            }
            return db2;
          });
        }
        function awaitIterator(iterator) {
          var callNext = function(result) {
            return iterator.next(result);
          }, doThrow = function(error) {
            return iterator.throw(error);
          }, onSuccess = step(callNext), onError = step(doThrow);
          function step(getNext) {
            return function(val) {
              var next = getNext(val), value = next.value;
              return next.done ? value : !value || typeof value.then !== "function" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
            };
          }
          return step(callNext)();
        }
        function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
          var i = arguments.length;
          if (i < 2)
            throw new exceptions.InvalidArgument("Too few arguments");
          var args = new Array(i - 1);
          while (--i)
            args[i - 1] = arguments[i];
          scopeFunc = args.pop();
          var tables = flatten(args);
          return [mode, tables, scopeFunc];
        }
        function enterTransactionScope(db2, mode, storeNames, parentTransaction, scopeFunc) {
          return DexiePromise.resolve().then(function() {
            var transless = PSD.transless || PSD;
            var trans = db2._createTransaction(mode, storeNames, db2._dbSchema, parentTransaction);
            trans.explicit = true;
            var zoneProps = {
              trans,
              transless
            };
            if (parentTransaction) {
              trans.idbtrans = parentTransaction.idbtrans;
            } else {
              try {
                trans.create();
                trans.idbtrans._explicit = true;
                db2._state.PR1398_maxLoop = 3;
              } catch (ex) {
                if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
                  console.warn("Dexie: Need to reopen db");
                  db2.close({ disableAutoOpen: false });
                  return db2.open().then(function() {
                    return enterTransactionScope(db2, mode, storeNames, null, scopeFunc);
                  });
                }
                return rejection(ex);
              }
            }
            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
            if (scopeFuncIsAsync) {
              incrementExpectedAwaits();
            }
            var returnValue;
            var promiseFollowed = DexiePromise.follow(function() {
              returnValue = scopeFunc.call(trans, trans);
              if (returnValue) {
                if (scopeFuncIsAsync) {
                  var decrementor = decrementExpectedAwaits.bind(null, null);
                  returnValue.then(decrementor, decrementor);
                } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
                  returnValue = awaitIterator(returnValue);
                }
              }
            }, zoneProps);
            return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then(function(x) {
              return trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : promiseFollowed.then(function() {
              return returnValue;
            })).then(function(x) {
              if (parentTransaction)
                trans._resolve();
              return trans._completion.then(function() {
                return x;
              });
            }).catch(function(e) {
              trans._reject(e);
              return rejection(e);
            });
          });
        }
        function pad(a, value, count) {
          var result = isArray(a) ? a.slice() : [a];
          for (var i = 0; i < count; ++i)
            result.push(value);
          return result;
        }
        function createVirtualIndexMiddleware(down) {
          return __assign(__assign({}, down), { table: function(tableName) {
            var table = down.table(tableName);
            var schema = table.schema;
            var indexLookup = {};
            var allVirtualIndexes = [];
            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
              var keyPathAlias = getKeyPathAlias(keyPath);
              var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
              var keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
              var isVirtual = keyTail > 0;
              var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")") : lowLevelIndex.name, lowLevelIndex, isVirtual, keyTail, keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
              indexList.push(virtualIndex);
              if (!virtualIndex.isPrimaryKey) {
                allVirtualIndexes.push(virtualIndex);
              }
              if (keyLength > 1) {
                var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
                addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
              }
              indexList.sort(function(a, b) {
                return a.keyTail - b.keyTail;
              });
              return virtualIndex;
            }
            var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
            indexLookup[":id"] = [primaryKey];
            for (var _i = 0, _a2 = schema.indexes; _i < _a2.length; _i++) {
              var index = _a2[_i];
              addVirtualIndexes(index.keyPath, 0, index);
            }
            function findBestIndex(keyPath) {
              var result2 = indexLookup[getKeyPathAlias(keyPath)];
              return result2 && result2[0];
            }
            function translateRange(range, keyTail) {
              return {
                type: range.type === 1 ? 2 : range.type,
                lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                lowerOpen: true,
                upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                upperOpen: true
              };
            }
            function translateRequest(req) {
              var index2 = req.query.index;
              return index2.isVirtual ? __assign(__assign({}, req), { query: {
                index: index2.lowLevelIndex,
                range: translateRange(req.query.range, index2.keyTail)
              } }) : req;
            }
            var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function(req) {
              return table.count(translateRequest(req));
            }, query: function(req) {
              return table.query(translateRequest(req));
            }, openCursor: function(req) {
              var _a3 = req.query.index, keyTail = _a3.keyTail, isVirtual = _a3.isVirtual, keyLength = _a3.keyLength;
              if (!isVirtual)
                return table.openCursor(req);
              function createVirtualCursor(cursor) {
                function _continue(key) {
                  key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
                }
                var virtualCursor = Object.create(cursor, {
                  continue: { value: _continue },
                  continuePrimaryKey: {
                    value: function(key, primaryKey2) {
                      cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                    }
                  },
                  primaryKey: {
                    get: function() {
                      return cursor.primaryKey;
                    }
                  },
                  key: {
                    get: function() {
                      var key = cursor.key;
                      return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                    }
                  },
                  value: {
                    get: function() {
                      return cursor.value;
                    }
                  }
                });
                return virtualCursor;
              }
              return table.openCursor(translateRequest(req)).then(function(cursor) {
                return cursor && createVirtualCursor(cursor);
              });
            } });
            return result;
          } });
        }
        var virtualIndexMiddleware = {
          stack: "dbcore",
          name: "VirtualIndexMiddleware",
          level: 1,
          create: createVirtualIndexMiddleware
        };
        function getObjectDiff(a, b, rv, prfx) {
          rv = rv || {};
          prfx = prfx || "";
          keys2(a).forEach(function(prop) {
            if (!hasOwn(b, prop)) {
              rv[prfx + prop] = void 0;
            } else {
              var ap = a[prop], bp = b[prop];
              if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
                var apTypeName = toStringTag(ap);
                var bpTypeName = toStringTag(bp);
                if (apTypeName !== bpTypeName) {
                  rv[prfx + prop] = b[prop];
                } else if (apTypeName === "Object") {
                  getObjectDiff(ap, bp, rv, prfx + prop + ".");
                } else if (ap !== bp) {
                  rv[prfx + prop] = b[prop];
                }
              } else if (ap !== bp)
                rv[prfx + prop] = b[prop];
            }
          });
          keys2(b).forEach(function(prop) {
            if (!hasOwn(a, prop)) {
              rv[prfx + prop] = b[prop];
            }
          });
          return rv;
        }
        function getEffectiveKeys(primaryKey, req) {
          if (req.type === "delete")
            return req.keys;
          return req.keys || req.values.map(primaryKey.extractKey);
        }
        var hooksMiddleware = {
          stack: "dbcore",
          name: "HooksMiddleware",
          level: 2,
          create: function(downCore) {
            return __assign(__assign({}, downCore), { table: function(tableName) {
              var downTable = downCore.table(tableName);
              var primaryKey = downTable.schema.primaryKey;
              var tableMiddleware = __assign(__assign({}, downTable), { mutate: function(req) {
                var dxTrans = PSD.trans;
                var _a2 = dxTrans.table(tableName).hook, deleting = _a2.deleting, creating = _a2.creating, updating = _a2.updating;
                switch (req.type) {
                  case "add":
                    if (creating.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return addPutOrDelete(req);
                    }, true);
                  case "put":
                    if (creating.fire === nop && updating.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return addPutOrDelete(req);
                    }, true);
                  case "delete":
                    if (deleting.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return addPutOrDelete(req);
                    }, true);
                  case "deleteRange":
                    if (deleting.fire === nop)
                      break;
                    return dxTrans._promise("readwrite", function() {
                      return deleteRange(req);
                    }, true);
                }
                return downTable.mutate(req);
                function addPutOrDelete(req2) {
                  var dxTrans2 = PSD.trans;
                  var keys3 = req2.keys || getEffectiveKeys(primaryKey, req2);
                  if (!keys3)
                    throw new Error("Keys missing");
                  req2 = req2.type === "add" || req2.type === "put" ? __assign(__assign({}, req2), { keys: keys3 }) : __assign({}, req2);
                  if (req2.type !== "delete")
                    req2.values = __spreadArray([], req2.values, true);
                  if (req2.keys)
                    req2.keys = __spreadArray([], req2.keys, true);
                  return getExistingValues(downTable, req2, keys3).then(function(existingValues) {
                    var contexts = keys3.map(function(key, i) {
                      var existingValue = existingValues[i];
                      var ctx = { onerror: null, onsuccess: null };
                      if (req2.type === "delete") {
                        deleting.fire.call(ctx, key, existingValue, dxTrans2);
                      } else if (req2.type === "add" || existingValue === void 0) {
                        var generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                        if (key == null && generatedPrimaryKey != null) {
                          key = generatedPrimaryKey;
                          req2.keys[i] = key;
                          if (!primaryKey.outbound) {
                            setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                          }
                        }
                      } else {
                        var objectDiff = getObjectDiff(existingValue, req2.values[i]);
                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                        if (additionalChanges_1) {
                          var requestedValue_1 = req2.values[i];
                          Object.keys(additionalChanges_1).forEach(function(keyPath) {
                            if (hasOwn(requestedValue_1, keyPath)) {
                              requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                            } else {
                              setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                            }
                          });
                        }
                      }
                      return ctx;
                    });
                    return downTable.mutate(req2).then(function(_a3) {
                      var failures = _a3.failures, results = _a3.results, numFailures = _a3.numFailures, lastResult = _a3.lastResult;
                      for (var i = 0; i < keys3.length; ++i) {
                        var primKey = results ? results[i] : keys3[i];
                        var ctx = contexts[i];
                        if (primKey == null) {
                          ctx.onerror && ctx.onerror(failures[i]);
                        } else {
                          ctx.onsuccess && ctx.onsuccess(
                            req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                          );
                        }
                      }
                      return { failures, results, numFailures, lastResult };
                    }).catch(function(error) {
                      contexts.forEach(function(ctx) {
                        return ctx.onerror && ctx.onerror(error);
                      });
                      return Promise.reject(error);
                    });
                  });
                }
                function deleteRange(req2) {
                  return deleteNextChunk(req2.trans, req2.range, 1e4);
                }
                function deleteNextChunk(trans, range, limit) {
                  return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(function(_a3) {
                    var result = _a3.result;
                    return addPutOrDelete({ type: "delete", keys: result, trans }).then(function(res) {
                      if (res.numFailures > 0)
                        return Promise.reject(res.failures[0]);
                      if (result.length < limit) {
                        return { failures: [], numFailures: 0, lastResult: void 0 };
                      } else {
                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                      }
                    });
                  });
                }
              } });
              return tableMiddleware;
            } });
          }
        };
        function getExistingValues(table, req, effectiveKeys) {
          return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
        }
        function getFromTransactionCache(keys3, cache3, clone) {
          try {
            if (!cache3)
              return null;
            if (cache3.keys.length < keys3.length)
              return null;
            var result = [];
            for (var i = 0, j = 0; i < cache3.keys.length && j < keys3.length; ++i) {
              if (cmp2(cache3.keys[i], keys3[j]) !== 0)
                continue;
              result.push(clone ? deepClone(cache3.values[i]) : cache3.values[i]);
              ++j;
            }
            return result.length === keys3.length ? result : null;
          } catch (_a2) {
            return null;
          }
        }
        var cacheExistingValuesMiddleware = {
          stack: "dbcore",
          level: -1,
          create: function(core) {
            return {
              table: function(tableName) {
                var table = core.table(tableName);
                return __assign(__assign({}, table), { getMany: function(req) {
                  if (!req.cache) {
                    return table.getMany(req);
                  }
                  var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                  if (cachedResult) {
                    return DexiePromise.resolve(cachedResult);
                  }
                  return table.getMany(req).then(function(res) {
                    req.trans["_cache"] = {
                      keys: req.keys,
                      values: req.cache === "clone" ? deepClone(res) : res
                    };
                    return res;
                  });
                }, mutate: function(req) {
                  if (req.type !== "add")
                    req.trans["_cache"] = null;
                  return table.mutate(req);
                } });
              }
            };
          }
        };
        function isCachableContext(ctx, table) {
          return ctx.trans.mode === "readonly" && !!ctx.subscr && !ctx.trans.explicit && ctx.trans.db._options.cache !== "disabled" && !table.schema.primaryKey.outbound;
        }
        function isCachableRequest(type2, req) {
          switch (type2) {
            case "query":
              return req.values && !req.unique;
            case "get":
              return false;
            case "getMany":
              return false;
            case "count":
              return false;
            case "openCursor":
              return false;
          }
        }
        var observabilityMiddleware = {
          stack: "dbcore",
          level: 0,
          name: "Observability",
          create: function(core) {
            var dbName = core.schema.name;
            var FULL_RANGE = new RangeSet2(core.MIN_KEY, core.MAX_KEY);
            return __assign(__assign({}, core), { transaction: function(stores, mode, options) {
              if (PSD.subscr && mode !== "readonly") {
                throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
              }
              return core.transaction(stores, mode, options);
            }, table: function(tableName) {
              var table = core.table(tableName);
              var schema = table.schema;
              var primaryKey = schema.primaryKey, indexes = schema.indexes;
              var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
              var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function(index) {
                return index.compound && index.keyPath.includes(primaryKey.keyPath);
              });
              var tableClone = __assign(__assign({}, table), { mutate: function(req) {
                var _a2, _b;
                var trans = req.trans;
                var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
                var getRangeSet = function(indexName) {
                  var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                  return mutatedParts[part] || (mutatedParts[part] = new RangeSet2());
                };
                var pkRangeSet = getRangeSet("");
                var delsRangeSet = getRangeSet(":dels");
                var type2 = req.type;
                var _c = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [getEffectiveKeys(primaryKey, req).filter(function(id) {
                  return id;
                }), req.values] : [], keys3 = _c[0], newObjs = _c[1];
                var oldCache = req.trans["_cache"];
                if (isArray(keys3)) {
                  pkRangeSet.addKeys(keys3);
                  var oldObjs = type2 === "delete" || keys3.length === newObjs.length ? getFromTransactionCache(keys3, oldCache) : null;
                  if (!oldObjs) {
                    delsRangeSet.addKeys(keys3);
                  }
                  if (oldObjs || newObjs) {
                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                  }
                } else if (keys3) {
                  var range = {
                    from: (_a2 = keys3.lower) !== null && _a2 !== void 0 ? _a2 : core.MIN_KEY,
                    to: (_b = keys3.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY
                  };
                  delsRangeSet.add(range);
                  pkRangeSet.add(range);
                } else {
                  pkRangeSet.add(FULL_RANGE);
                  delsRangeSet.add(FULL_RANGE);
                  schema.indexes.forEach(function(idx) {
                    return getRangeSet(idx.name).add(FULL_RANGE);
                  });
                }
                return table.mutate(req).then(function(res) {
                  if (keys3 && (req.type === "add" || req.type === "put")) {
                    pkRangeSet.addKeys(res.results);
                    if (indexesWithAutoIncPK) {
                      indexesWithAutoIncPK.forEach(function(idx) {
                        var idxVals = req.values.map(function(v) {
                          return idx.extractKey(v);
                        });
                        var pkPos = idx.keyPath.findIndex(function(prop) {
                          return prop === primaryKey.keyPath;
                        });
                        for (var i = 0, len = res.results.length; i < len; ++i) {
                          idxVals[i][pkPos] = res.results[i];
                        }
                        getRangeSet(idx.name).addKeys(idxVals);
                      });
                    }
                  }
                  trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                  return res;
                });
              } });
              var getRange = function(_a2) {
                var _b, _c;
                var _d = _a2.query, index = _d.index, range = _d.range;
                return [
                  index,
                  new RangeSet2((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
                ];
              };
              var readSubscribers = {
                get: function(req) {
                  return [primaryKey, new RangeSet2(req.key)];
                },
                getMany: function(req) {
                  return [primaryKey, new RangeSet2().addKeys(req.keys)];
                },
                count: getRange,
                query: getRange,
                openCursor: getRange
              };
              keys2(readSubscribers).forEach(function(method) {
                tableClone[method] = function(req) {
                  var subscr = PSD.subscr;
                  var isLiveQuery = !!subscr;
                  var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                  var obsSet = cachable ? req.obsSet = {} : subscr;
                  if (isLiveQuery) {
                    var getRangeSet = function(indexName) {
                      var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                      return obsSet[part] || (obsSet[part] = new RangeSet2());
                    };
                    var pkRangeSet_1 = getRangeSet("");
                    var delsRangeSet_1 = getRangeSet(":dels");
                    var _a2 = readSubscribers[method](req), queriedIndex = _a2[0], queriedRanges = _a2[1];
                    if (method === "query" && queriedIndex.isPrimaryKey && !req.values) {
                      delsRangeSet_1.add(queriedRanges);
                    } else {
                      getRangeSet(queriedIndex.name || "").add(queriedRanges);
                    }
                    if (!queriedIndex.isPrimaryKey) {
                      if (method === "count") {
                        delsRangeSet_1.add(FULL_RANGE);
                      } else {
                        var keysPromise_1 = method === "query" && outbound && req.values && table.query(__assign(__assign({}, req), { values: false }));
                        return table[method].apply(this, arguments).then(function(res) {
                          if (method === "query") {
                            if (outbound && req.values) {
                              return keysPromise_1.then(function(_a3) {
                                var resultingKeys = _a3.result;
                                pkRangeSet_1.addKeys(resultingKeys);
                                return res;
                              });
                            }
                            var pKeys = req.values ? res.result.map(extractKey) : res.result;
                            if (req.values) {
                              pkRangeSet_1.addKeys(pKeys);
                            } else {
                              delsRangeSet_1.addKeys(pKeys);
                            }
                          } else if (method === "openCursor") {
                            var cursor_1 = res;
                            var wantValues_1 = req.values;
                            return cursor_1 && Object.create(cursor_1, {
                              key: {
                                get: function() {
                                  delsRangeSet_1.addKey(cursor_1.primaryKey);
                                  return cursor_1.key;
                                }
                              },
                              primaryKey: {
                                get: function() {
                                  var pkey = cursor_1.primaryKey;
                                  delsRangeSet_1.addKey(pkey);
                                  return pkey;
                                }
                              },
                              value: {
                                get: function() {
                                  wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                  return cursor_1.value;
                                }
                              }
                            });
                          }
                          return res;
                        });
                      }
                    }
                  }
                  return table[method].apply(this, arguments);
                };
              });
              return tableClone;
            } });
          }
        };
        function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
          function addAffectedIndex(ix) {
            var rangeSet = getRangeSet(ix.name || "");
            function extractKey(obj) {
              return obj != null ? ix.extractKey(obj) : null;
            }
            var addKeyOrKeys = function(key) {
              return ix.multiEntry && isArray(key) ? key.forEach(function(key2) {
                return rangeSet.addKey(key2);
              }) : rangeSet.addKey(key);
            };
            (oldObjs || newObjs).forEach(function(_, i) {
              var oldKey = oldObjs && extractKey(oldObjs[i]);
              var newKey = newObjs && extractKey(newObjs[i]);
              if (cmp2(oldKey, newKey) !== 0) {
                if (oldKey != null)
                  addKeyOrKeys(oldKey);
                if (newKey != null)
                  addKeyOrKeys(newKey);
              }
            });
          }
          schema.indexes.forEach(addAffectedIndex);
        }
        function adjustOptimisticFromFailures(tblCache, req, res) {
          if (res.numFailures === 0)
            return req;
          if (req.type === "deleteRange") {
            return null;
          }
          var numBulkOps = req.keys ? req.keys.length : "values" in req && req.values ? req.values.length : 1;
          if (res.numFailures === numBulkOps) {
            return null;
          }
          var clone = __assign({}, req);
          if (isArray(clone.keys)) {
            clone.keys = clone.keys.filter(function(_, i) {
              return !(i in res.failures);
            });
          }
          if ("values" in clone && isArray(clone.values)) {
            clone.values = clone.values.filter(function(_, i) {
              return !(i in res.failures);
            });
          }
          return clone;
        }
        function isAboveLower(key, range) {
          return range.lower === void 0 ? true : range.lowerOpen ? cmp2(key, range.lower) > 0 : cmp2(key, range.lower) >= 0;
        }
        function isBelowUpper(key, range) {
          return range.upper === void 0 ? true : range.upperOpen ? cmp2(key, range.upper) < 0 : cmp2(key, range.upper) <= 0;
        }
        function isWithinRange(key, range) {
          return isAboveLower(key, range) && isBelowUpper(key, range);
        }
        function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
          if (!ops || ops.length === 0)
            return result;
          var index = req.query.index;
          var multiEntry = index.multiEntry;
          var queryRange = req.query.range;
          var primaryKey = table.schema.primaryKey;
          var extractPrimKey = primaryKey.extractKey;
          var extractIndex = index.extractKey;
          var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;
          var finalResult = ops.reduce(function(result2, op) {
            var modifedResult = result2;
            var includedValues = [];
            if (op.type === "add" || op.type === "put") {
              var includedPKs = new RangeSet2();
              for (var i = op.values.length - 1; i >= 0; --i) {
                var value = op.values[i];
                var pk = extractPrimKey(value);
                if (includedPKs.hasKey(pk))
                  continue;
                var key = extractIndex(value);
                if (multiEntry && isArray(key) ? key.some(function(k) {
                  return isWithinRange(k, queryRange);
                }) : isWithinRange(key, queryRange)) {
                  includedPKs.addKey(pk);
                  includedValues.push(value);
                }
              }
            }
            switch (op.type) {
              case "add": {
                var existingKeys_1 = new RangeSet2().addKeys(req.values ? result2.map(function(v) {
                  return extractPrimKey(v);
                }) : result2);
                modifedResult = result2.concat(req.values ? includedValues.filter(function(v) {
                  var key2 = extractPrimKey(v);
                  if (existingKeys_1.hasKey(key2))
                    return false;
                  existingKeys_1.addKey(key2);
                  return true;
                }) : includedValues.map(function(v) {
                  return extractPrimKey(v);
                }).filter(function(k) {
                  if (existingKeys_1.hasKey(k))
                    return false;
                  existingKeys_1.addKey(k);
                  return true;
                }));
                break;
              }
              case "put": {
                var keySet_1 = new RangeSet2().addKeys(op.values.map(function(v) {
                  return extractPrimKey(v);
                }));
                modifedResult = result2.filter(
                  function(item) {
                    return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item);
                  }
                ).concat(
                  req.values ? includedValues : includedValues.map(function(v) {
                    return extractPrimKey(v);
                  })
                );
                break;
              }
              case "delete":
                var keysToDelete_1 = new RangeSet2().addKeys(op.keys);
                modifedResult = result2.filter(function(item) {
                  return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
                });
                break;
              case "deleteRange":
                var range_1 = op.range;
                modifedResult = result2.filter(function(item) {
                  return !isWithinRange(extractPrimKey(item), range_1);
                });
                break;
            }
            return modifedResult;
          }, result);
          if (finalResult === result)
            return result;
          finalResult.sort(function(a, b) {
            return cmp2(extractLowLevelIndex(a), extractLowLevelIndex(b)) || cmp2(extractPrimKey(a), extractPrimKey(b));
          });
          if (req.limit && req.limit < Infinity) {
            if (finalResult.length > req.limit) {
              finalResult.length = req.limit;
            } else if (result.length === req.limit && finalResult.length < req.limit) {
              cacheEntry.dirty = true;
            }
          }
          return immutable ? Object.freeze(finalResult) : finalResult;
        }
        function areRangesEqual(r1, r2) {
          return cmp2(r1.lower, r2.lower) === 0 && cmp2(r1.upper, r2.upper) === 0 && !!r1.lowerOpen === !!r2.lowerOpen && !!r1.upperOpen === !!r2.upperOpen;
        }
        function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
          if (lower1 === void 0)
            return lower2 !== void 0 ? -1 : 0;
          if (lower2 === void 0)
            return 1;
          var c = cmp2(lower1, lower2);
          if (c === 0) {
            if (lowerOpen1 && lowerOpen2)
              return 0;
            if (lowerOpen1)
              return 1;
            if (lowerOpen2)
              return -1;
          }
          return c;
        }
        function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
          if (upper1 === void 0)
            return upper2 !== void 0 ? 1 : 0;
          if (upper2 === void 0)
            return -1;
          var c = cmp2(upper1, upper2);
          if (c === 0) {
            if (upperOpen1 && upperOpen2)
              return 0;
            if (upperOpen1)
              return -1;
            if (upperOpen2)
              return 1;
          }
          return c;
        }
        function isSuperRange(r1, r2) {
          return compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 && compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0;
        }
        function findCompatibleQuery(dbName, tableName, type2, req) {
          var tblCache = cache2["idb://".concat(dbName, "/").concat(tableName)];
          if (!tblCache)
            return [];
          var queries = tblCache.queries[type2];
          if (!queries)
            return [null, false, tblCache, null];
          var indexName = req.query ? req.query.index.name : null;
          var entries = queries[indexName || ""];
          if (!entries)
            return [null, false, tblCache, null];
          switch (type2) {
            case "query":
              var equalEntry = entries.find(function(entry) {
                return entry.req.limit === req.limit && entry.req.values === req.values && areRangesEqual(entry.req.query.range, req.query.range);
              });
              if (equalEntry)
                return [
                  equalEntry,
                  true,
                  tblCache,
                  entries
                ];
              var superEntry = entries.find(function(entry) {
                var limit = "limit" in entry.req ? entry.req.limit : Infinity;
                return limit >= req.limit && (req.values ? entry.req.values : true) && isSuperRange(entry.req.query.range, req.query.range);
              });
              return [superEntry, false, tblCache, entries];
            case "count":
              var countQuery = entries.find(function(entry) {
                return areRangesEqual(entry.req.query.range, req.query.range);
              });
              return [countQuery, !!countQuery, tblCache, entries];
          }
        }
        function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
          cacheEntry.subscribers.add(requery);
          signal.addEventListener("abort", function() {
            cacheEntry.subscribers.delete(requery);
            if (cacheEntry.subscribers.size === 0) {
              enqueForDeletion(cacheEntry, container);
            }
          });
        }
        function enqueForDeletion(cacheEntry, container) {
          setTimeout(function() {
            if (cacheEntry.subscribers.size === 0) {
              delArrayItem(container, cacheEntry);
            }
          }, 3e3);
        }
        var cacheMiddleware = {
          stack: "dbcore",
          level: 0,
          name: "Cache",
          create: function(core) {
            var dbName = core.schema.name;
            var coreMW = __assign(__assign({}, core), { transaction: function(stores, mode, options) {
              var idbtrans = core.transaction(stores, mode, options);
              if (mode === "readwrite") {
                var ac_1 = new AbortController();
                var signal = ac_1.signal;
                var endTransaction = function(wasCommitted) {
                  return function() {
                    ac_1.abort();
                    if (mode === "readwrite") {
                      var affectedSubscribers_1 = /* @__PURE__ */ new Set();
                      for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {
                        var storeName = stores_1[_i];
                        var tblCache = cache2["idb://".concat(dbName, "/").concat(storeName)];
                        if (tblCache) {
                          var table = core.table(storeName);
                          var ops = tblCache.optimisticOps.filter(function(op) {
                            return op.trans === idbtrans;
                          });
                          if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                            for (var _a2 = 0, _b = Object.values(tblCache.queries.query); _a2 < _b.length; _a2++) {
                              var entries = _b[_a2];
                              for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                                var entry = _d[_c];
                                if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                  delArrayItem(entries, entry);
                                  entry.subscribers.forEach(function(requery) {
                                    return affectedSubscribers_1.add(requery);
                                  });
                                }
                              }
                            }
                          } else if (ops.length > 0) {
                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function(op) {
                              return op.trans !== idbtrans;
                            });
                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                              var entries = _f[_e];
                              for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                                var entry = _h[_g];
                                if (entry.res != null && idbtrans.mutatedParts) {
                                  if (wasCommitted && !entry.dirty) {
                                    var freezeResults = Object.isFrozen(entry.res);
                                    var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                    if (entry.dirty) {
                                      delArrayItem(entries, entry);
                                      entry.subscribers.forEach(function(requery) {
                                        return affectedSubscribers_1.add(requery);
                                      });
                                    } else if (modRes !== entry.res) {
                                      entry.res = modRes;
                                      entry.promise = DexiePromise.resolve({ result: modRes });
                                    }
                                  } else {
                                    if (entry.dirty) {
                                      delArrayItem(entries, entry);
                                    }
                                    entry.subscribers.forEach(function(requery) {
                                      return affectedSubscribers_1.add(requery);
                                    });
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      affectedSubscribers_1.forEach(function(requery) {
                        return requery();
                      });
                    }
                  };
                };
                idbtrans.addEventListener("abort", endTransaction(false), {
                  signal
                });
                idbtrans.addEventListener("error", endTransaction(false), {
                  signal
                });
                idbtrans.addEventListener("complete", endTransaction(true), {
                  signal
                });
              }
              return idbtrans;
            }, table: function(tableName) {
              var downTable = core.table(tableName);
              var primKey = downTable.schema.primaryKey;
              var tableMW = __assign(__assign({}, downTable), { mutate: function(req) {
                var trans = PSD.trans;
                if (primKey.outbound || trans.db._options.cache === "disabled" || trans.explicit || trans.idbtrans.mode !== "readwrite") {
                  return downTable.mutate(req);
                }
                var tblCache = cache2["idb://".concat(dbName, "/").concat(tableName)];
                if (!tblCache)
                  return downTable.mutate(req);
                var promise = downTable.mutate(req);
                if ((req.type === "add" || req.type === "put") && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function(key) {
                  return key == null;
                }))) {
                  promise.then(function(res) {
                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function(value, i) {
                      var _a2;
                      if (res.failures[i])
                        return value;
                      var valueWithKey = ((_a2 = primKey.keyPath) === null || _a2 === void 0 ? void 0 : _a2.includes(".")) ? deepClone(value) : __assign({}, value);
                      setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                      return valueWithKey;
                    }) });
                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                    tblCache.optimisticOps.push(adjustedReq);
                    queueMicrotask(function() {
                      return req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                    });
                  });
                } else {
                  tblCache.optimisticOps.push(req);
                  req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  promise.then(function(res) {
                    if (res.numFailures > 0) {
                      delArrayItem(tblCache.optimisticOps, req);
                      var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                      if (adjustedReq) {
                        tblCache.optimisticOps.push(adjustedReq);
                      }
                      req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                    }
                  });
                  promise.catch(function() {
                    delArrayItem(tblCache.optimisticOps, req);
                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  });
                }
                return promise;
              }, query: function(req) {
                var _a2;
                if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                  return downTable.query(req);
                var freezeResults = ((_a2 = PSD.trans) === null || _a2 === void 0 ? void 0 : _a2.db._options.cache) === "immutable";
                var _b = PSD, requery = _b.requery, signal = _b.signal;
                var _c = findCompatibleQuery(dbName, tableName, "query", req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
                if (cacheEntry && exactMatch) {
                  cacheEntry.obsSet = req.obsSet;
                } else {
                  var promise = downTable.query(req).then(function(res) {
                    var result = res.result;
                    if (cacheEntry)
                      cacheEntry.res = result;
                    if (freezeResults) {
                      for (var i = 0, l = result.length; i < l; ++i) {
                        Object.freeze(result[i]);
                      }
                      Object.freeze(result);
                    } else {
                      res.result = deepClone(result);
                    }
                    return res;
                  }).catch(function(error) {
                    if (container && cacheEntry)
                      delArrayItem(container, cacheEntry);
                    return Promise.reject(error);
                  });
                  cacheEntry = {
                    obsSet: req.obsSet,
                    promise,
                    subscribers: /* @__PURE__ */ new Set(),
                    type: "query",
                    req,
                    dirty: false
                  };
                  if (container) {
                    container.push(cacheEntry);
                  } else {
                    container = [cacheEntry];
                    if (!tblCache) {
                      tblCache = cache2["idb://".concat(dbName, "/").concat(tableName)] = {
                        queries: {
                          query: {},
                          count: {}
                        },
                        objs: /* @__PURE__ */ new Map(),
                        optimisticOps: [],
                        unsignaledParts: {}
                      };
                    }
                    tblCache.queries.query[req.query.index.name || ""] = container;
                  }
                }
                subscribeToCacheEntry(cacheEntry, container, requery, signal);
                return cacheEntry.promise.then(function(res) {
                  return {
                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults)
                  };
                });
              } });
              return tableMW;
            } });
            return coreMW;
          }
        };
        function vipify(target, vipDb) {
          return new Proxy(target, {
            get: function(target2, prop, receiver) {
              if (prop === "db")
                return vipDb;
              return Reflect.get(target2, prop, receiver);
            }
          });
        }
        var Dexie$1 = (function() {
          function Dexie3(name, options) {
            var _this = this;
            this._middlewares = {};
            this.verno = 0;
            var deps = Dexie3.dependencies;
            this._options = options = __assign({
              addons: Dexie3.addons,
              autoOpen: true,
              indexedDB: deps.indexedDB,
              IDBKeyRange: deps.IDBKeyRange,
              cache: "cloned"
            }, options);
            this._deps = {
              indexedDB: options.indexedDB,
              IDBKeyRange: options.IDBKeyRange
            };
            var addons = options.addons;
            this._dbSchema = {};
            this._versions = [];
            this._storeNames = [];
            this._allTables = {};
            this.idbdb = null;
            this._novip = this;
            var state = {
              dbOpenError: null,
              isBeingOpened: false,
              onReadyBeingFired: null,
              openComplete: false,
              dbReadyResolve: nop,
              dbReadyPromise: null,
              cancelOpen: nop,
              openCanceller: null,
              autoSchema: true,
              PR1398_maxLoop: 3,
              autoOpen: options.autoOpen
            };
            state.dbReadyPromise = new DexiePromise(function(resolve) {
              state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function(_, reject) {
              state.cancelOpen = reject;
            });
            this._state = state;
            this.name = name;
            this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
            this.once = function(event, callback) {
              var fn = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                _this.on(event).unsubscribe(fn);
                callback.apply(_this, args);
              };
              return _this.on(event, fn);
            };
            this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
              return function(subscriber, bSticky) {
                Dexie3.vip(function() {
                  var state2 = _this._state;
                  if (state2.openComplete) {
                    if (!state2.dbOpenError)
                      DexiePromise.resolve().then(subscriber);
                    if (bSticky)
                      subscribe(subscriber);
                  } else if (state2.onReadyBeingFired) {
                    state2.onReadyBeingFired.push(subscriber);
                    if (bSticky)
                      subscribe(subscriber);
                  } else {
                    subscribe(subscriber);
                    var db_1 = _this;
                    if (!bSticky)
                      subscribe(function unsubscribe() {
                        db_1.on.ready.unsubscribe(subscriber);
                        db_1.on.ready.unsubscribe(unsubscribe);
                      });
                  }
                });
              };
            });
            this.Collection = createCollectionConstructor(this);
            this.Table = createTableConstructor(this);
            this.Transaction = createTransactionConstructor(this);
            this.Version = createVersionConstructor(this);
            this.WhereClause = createWhereClauseConstructor(this);
            this.on("versionchange", function(ev) {
              if (ev.newVersion > 0)
                console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
              else
                console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
              _this.close({ disableAutoOpen: false });
            });
            this.on("blocked", function(ev) {
              if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
              else
                console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
            });
            this._maxKey = getMaxKey(options.IDBKeyRange);
            this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
              return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
            };
            this._fireOnBlocked = function(ev) {
              _this.on("blocked").fire(ev);
              connections.filter(function(c) {
                return c.name === _this.name && c !== _this && !c._state.vcFired;
              }).map(function(c) {
                return c.on("versionchange").fire(ev);
              });
            };
            this.use(cacheExistingValuesMiddleware);
            this.use(cacheMiddleware);
            this.use(observabilityMiddleware);
            this.use(virtualIndexMiddleware);
            this.use(hooksMiddleware);
            var vipDB = new Proxy(this, {
              get: function(_, prop, receiver) {
                if (prop === "_vip")
                  return true;
                if (prop === "table")
                  return function(tableName) {
                    return vipify(_this.table(tableName), vipDB);
                  };
                var rv = Reflect.get(_, prop, receiver);
                if (rv instanceof Table2)
                  return vipify(rv, vipDB);
                if (prop === "tables")
                  return rv.map(function(t) {
                    return vipify(t, vipDB);
                  });
                if (prop === "_createTransaction")
                  return function() {
                    var tx = rv.apply(this, arguments);
                    return vipify(tx, vipDB);
                  };
                return rv;
              }
            });
            this.vip = vipDB;
            addons.forEach(function(addon) {
              return addon(_this);
            });
          }
          Dexie3.prototype.version = function(versionNumber) {
            if (isNaN(versionNumber) || versionNumber < 0.1)
              throw new exceptions.Type("Given version is not a positive number");
            versionNumber = Math.round(versionNumber * 10) / 10;
            if (this.idbdb || this._state.isBeingOpened)
              throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            var versions = this._versions;
            var versionInstance = versions.filter(function(v) {
              return v._cfg.version === versionNumber;
            })[0];
            if (versionInstance)
              return versionInstance;
            versionInstance = new this.Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            versionInstance.stores({});
            this._state.autoSchema = false;
            return versionInstance;
          };
          Dexie3.prototype._whenReady = function(fn) {
            var _this = this;
            return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function(resolve, reject) {
              if (_this._state.openComplete) {
                return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
              }
              if (!_this._state.isBeingOpened) {
                if (!_this._state.autoOpen) {
                  reject(new exceptions.DatabaseClosed());
                  return;
                }
                _this.open().catch(nop);
              }
              _this._state.dbReadyPromise.then(resolve, reject);
            }).then(fn);
          };
          Dexie3.prototype.use = function(_a2) {
            var stack = _a2.stack, create = _a2.create, level = _a2.level, name = _a2.name;
            if (name)
              this.unuse({ stack, name });
            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
            middlewares.push({ stack, create, level: level == null ? 10 : level, name });
            middlewares.sort(function(a, b) {
              return a.level - b.level;
            });
            return this;
          };
          Dexie3.prototype.unuse = function(_a2) {
            var stack = _a2.stack, name = _a2.name, create = _a2.create;
            if (stack && this._middlewares[stack]) {
              this._middlewares[stack] = this._middlewares[stack].filter(function(mw) {
                return create ? mw.create !== create : name ? mw.name !== name : false;
              });
            }
            return this;
          };
          Dexie3.prototype.open = function() {
            var _this = this;
            return usePSD(
              globalPSD,
              function() {
                return dexieOpen(_this);
              }
            );
          };
          Dexie3.prototype._close = function() {
            this.on.close.fire(new CustomEvent("close"));
            var state = this._state;
            var idx = connections.indexOf(this);
            if (idx >= 0)
              connections.splice(idx, 1);
            if (this.idbdb) {
              try {
                this.idbdb.close();
              } catch (e) {
              }
              this.idbdb = null;
            }
            if (!state.isBeingOpened) {
              state.dbReadyPromise = new DexiePromise(function(resolve) {
                state.dbReadyResolve = resolve;
              });
              state.openCanceller = new DexiePromise(function(_, reject) {
                state.cancelOpen = reject;
              });
            }
          };
          Dexie3.prototype.close = function(_a2) {
            var _b = _a2 === void 0 ? { disableAutoOpen: true } : _a2, disableAutoOpen = _b.disableAutoOpen;
            var state = this._state;
            if (disableAutoOpen) {
              if (state.isBeingOpened) {
                state.cancelOpen(new exceptions.DatabaseClosed());
              }
              this._close();
              state.autoOpen = false;
              state.dbOpenError = new exceptions.DatabaseClosed();
            } else {
              this._close();
              state.autoOpen = this._options.autoOpen || state.isBeingOpened;
              state.openComplete = false;
              state.dbOpenError = null;
            }
          };
          Dexie3.prototype.delete = function(closeOptions) {
            var _this = this;
            if (closeOptions === void 0) {
              closeOptions = { disableAutoOpen: true };
            }
            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== "object";
            var state = this._state;
            return new DexiePromise(function(resolve, reject) {
              var doDelete = function() {
                _this.close(closeOptions);
                var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                req.onsuccess = wrap(function() {
                  _onDatabaseDeleted(_this._deps, _this.name);
                  resolve();
                });
                req.onerror = eventRejectHandler(reject);
                req.onblocked = _this._fireOnBlocked;
              };
              if (hasInvalidArguments)
                throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
              if (state.isBeingOpened) {
                state.dbReadyPromise.then(doDelete);
              } else {
                doDelete();
              }
            });
          };
          Dexie3.prototype.backendDB = function() {
            return this.idbdb;
          };
          Dexie3.prototype.isOpen = function() {
            return this.idbdb !== null;
          };
          Dexie3.prototype.hasBeenClosed = function() {
            var dbOpenError = this._state.dbOpenError;
            return dbOpenError && dbOpenError.name === "DatabaseClosed";
          };
          Dexie3.prototype.hasFailed = function() {
            return this._state.dbOpenError !== null;
          };
          Dexie3.prototype.dynamicallyOpened = function() {
            return this._state.autoSchema;
          };
          Object.defineProperty(Dexie3.prototype, "tables", {
            get: function() {
              var _this = this;
              return keys2(this._allTables).map(function(name) {
                return _this._allTables[name];
              });
            },
            enumerable: false,
            configurable: true
          });
          Dexie3.prototype.transaction = function() {
            var args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
          };
          Dexie3.prototype._transaction = function(mode, tables, scopeFunc) {
            var _this = this;
            var parentTransaction = PSD.trans;
            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
              parentTransaction = null;
            var onlyIfCompatible = mode.indexOf("?") !== -1;
            mode = mode.replace("!", "").replace("?", "");
            var idbMode, storeNames;
            try {
              storeNames = tables.map(function(table) {
                var storeName = table instanceof _this.Table ? table.name : table;
                if (typeof storeName !== "string")
                  throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                return storeName;
              });
              if (mode == "r" || mode === READONLY)
                idbMode = READONLY;
              else if (mode == "rw" || mode == READWRITE)
                idbMode = READWRITE;
              else
                throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
              if (parentTransaction) {
                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                  if (onlyIfCompatible) {
                    parentTransaction = null;
                  } else
                    throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                }
                if (parentTransaction) {
                  storeNames.forEach(function(storeName) {
                    if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                      if (onlyIfCompatible) {
                        parentTransaction = null;
                      } else
                        throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                    }
                  });
                }
                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                  parentTransaction = null;
                }
              }
            } catch (e) {
              return parentTransaction ? parentTransaction._promise(null, function(_, reject) {
                reject(e);
              }) : rejection(e);
            }
            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
            return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
              return _this._whenReady(enterTransaction);
            }) : this._whenReady(enterTransaction);
          };
          Dexie3.prototype.table = function(tableName) {
            if (!hasOwn(this._allTables, tableName)) {
              throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
            }
            return this._allTables[tableName];
          };
          return Dexie3;
        })();
        var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
        var Observable = (function() {
          function Observable2(subscribe) {
            this._subscribe = subscribe;
          }
          Observable2.prototype.subscribe = function(x, error, complete) {
            return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
          };
          Observable2.prototype[symbolObservable] = function() {
            return this;
          };
          return Observable2;
        })();
        var domDeps;
        try {
          domDeps = {
            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
          };
        } catch (e) {
          domDeps = { indexedDB: null, IDBKeyRange: null };
        }
        function liveQuery2(querier) {
          var hasValue = false;
          var currentValue;
          var observable = new Observable(function(observer) {
            var scopeFuncIsAsync = isAsyncFunction(querier);
            function execute(ctx) {
              var wasRootExec = beginMicroTickScope();
              try {
                if (scopeFuncIsAsync) {
                  incrementExpectedAwaits();
                }
                var rv = newScope(querier, ctx);
                if (scopeFuncIsAsync) {
                  rv = rv.finally(decrementExpectedAwaits);
                }
                return rv;
              } finally {
                wasRootExec && endMicroTickScope();
              }
            }
            var closed = false;
            var abortController;
            var accumMuts = {};
            var currentObs = {};
            var subscription = {
              get closed() {
                return closed;
              },
              unsubscribe: function() {
                if (closed)
                  return;
                closed = true;
                if (abortController)
                  abortController.abort();
                if (startedListening)
                  globalEvents.storagemutated.unsubscribe(mutationListener);
              }
            };
            observer.start && observer.start(subscription);
            var startedListening = false;
            var doQuery = function() {
              return execInGlobalContext(_doQuery);
            };
            function shouldNotify() {
              return obsSetsOverlap(currentObs, accumMuts);
            }
            var mutationListener = function(parts) {
              extendObservabilitySet(accumMuts, parts);
              if (shouldNotify()) {
                doQuery();
              }
            };
            var _doQuery = function() {
              if (closed || !domDeps.indexedDB) {
                return;
              }
              accumMuts = {};
              var subscr = {};
              if (abortController)
                abortController.abort();
              abortController = new AbortController();
              var ctx = {
                subscr,
                signal: abortController.signal,
                requery: doQuery,
                querier,
                trans: null
              };
              var ret = execute(ctx);
              Promise.resolve(ret).then(function(result) {
                hasValue = true;
                currentValue = result;
                if (closed || ctx.signal.aborted) {
                  return;
                }
                accumMuts = {};
                currentObs = subscr;
                if (!objectIsEmpty(currentObs) && !startedListening) {
                  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                  startedListening = true;
                }
                execInGlobalContext(function() {
                  return !closed && observer.next && observer.next(result);
                });
              }, function(err) {
                hasValue = false;
                if (!["DatabaseClosedError", "AbortError"].includes(err === null || err === void 0 ? void 0 : err.name)) {
                  if (!closed)
                    execInGlobalContext(function() {
                      if (closed)
                        return;
                      observer.error && observer.error(err);
                    });
                }
              });
            };
            setTimeout(doQuery, 0);
            return subscription;
          });
          observable.hasValue = function() {
            return hasValue;
          };
          observable.getValue = function() {
            return currentValue;
          };
          return observable;
        }
        var Dexie2 = Dexie$1;
        props(Dexie2, __assign(__assign({}, fullNameExceptions), {
          delete: function(databaseName) {
            var db2 = new Dexie2(databaseName, { addons: [] });
            return db2.delete();
          },
          exists: function(name) {
            return new Dexie2(name, { addons: [] }).open().then(function(db2) {
              db2.close();
              return true;
            }).catch("NoSuchDatabaseError", function() {
              return false;
            });
          },
          getDatabaseNames: function(cb) {
            try {
              return getDatabaseNames(Dexie2.dependencies).then(cb);
            } catch (_a2) {
              return rejection(new exceptions.MissingAPI());
            }
          },
          defineClass: function() {
            function Class(content) {
              extend(this, content);
            }
            return Class;
          },
          ignoreTransaction: function(scopeFunc) {
            return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
          },
          vip,
          async: function(generatorFn) {
            return function() {
              try {
                var rv = awaitIterator(generatorFn.apply(this, arguments));
                if (!rv || typeof rv.then !== "function")
                  return DexiePromise.resolve(rv);
                return rv;
              } catch (e) {
                return rejection(e);
              }
            };
          },
          spawn: function(generatorFn, args, thiz) {
            try {
              var rv = awaitIterator(generatorFn.apply(thiz, args || []));
              if (!rv || typeof rv.then !== "function")
                return DexiePromise.resolve(rv);
              return rv;
            } catch (e) {
              return rejection(e);
            }
          },
          currentTransaction: {
            get: function() {
              return PSD.trans || null;
            }
          },
          waitFor: function(promiseOrFunction, optionalTimeout) {
            var promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie2.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
            return PSD.trans ? PSD.trans.waitFor(promise) : promise;
          },
          Promise: DexiePromise,
          debug: {
            get: function() {
              return debug;
            },
            set: function(value) {
              setDebug(value);
            }
          },
          derive,
          extend,
          props,
          override,
          Events,
          on: globalEvents,
          liveQuery: liveQuery2,
          extendObservabilitySet,
          getByKeyPath,
          setByKeyPath,
          delByKeyPath,
          shallowClone,
          deepClone,
          getObjectDiff,
          cmp: cmp2,
          asap: asap$1,
          minKey,
          addons: [],
          connections,
          errnames,
          dependencies: domDeps,
          cache: cache2,
          semVer: DEXIE_VERSION,
          version: DEXIE_VERSION.split(".").map(function(n) {
            return parseInt(n);
          }).reduce(function(p, c, i) {
            return p + c / Math.pow(10, i * 2);
          })
        }));
        Dexie2.maxKey = getMaxKey(Dexie2.dependencies.IDBKeyRange);
        if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
          globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
            if (!propagatingLocally) {
              var event_1;
              event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                detail: updatedParts
              });
              propagatingLocally = true;
              dispatchEvent(event_1);
              propagatingLocally = false;
            }
          });
          addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a2) {
            var detail = _a2.detail;
            if (!propagatingLocally) {
              propagateLocally(detail);
            }
          });
        }
        function propagateLocally(updateParts) {
          var wasMe = propagatingLocally;
          try {
            propagatingLocally = true;
            globalEvents.storagemutated.fire(updateParts);
            signalSubscribersNow(updateParts, true);
          } finally {
            propagatingLocally = wasMe;
          }
        }
        var propagatingLocally = false;
        var bc;
        var createBC = function() {
        };
        if (typeof BroadcastChannel !== "undefined") {
          createBC = function() {
            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
            bc.onmessage = function(ev) {
              return ev.data && propagateLocally(ev.data);
            };
          };
          createBC();
          if (typeof bc.unref === "function") {
            bc.unref();
          }
          globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
            if (!propagatingLocally) {
              bc.postMessage(changedParts);
            }
          });
        }
        if (typeof addEventListener !== "undefined") {
          addEventListener("pagehide", function(event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
              if (debug)
                console.debug("Dexie: handling persisted pagehide");
              bc === null || bc === void 0 ? void 0 : bc.close();
              for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {
                var db2 = connections_1[_i];
                db2.close({ disableAutoOpen: false });
              }
            }
          });
          addEventListener("pageshow", function(event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
              if (debug)
                console.debug("Dexie: handling persisted pageshow");
              createBC();
              propagateLocally({ all: new RangeSet2(-Infinity, [[]]) });
            }
          });
        }
        function add2(value) {
          return new PropModification2({ add: value });
        }
        function remove2(value) {
          return new PropModification2({ remove: value });
        }
        function replacePrefix2(a, b) {
          return new PropModification2({ replacePrefix: [a, b] });
        }
        DexiePromise.rejectionMapper = mapError;
        setDebug(debug);
        var namedExports = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          Dexie: Dexie$1,
          Entity: Entity2,
          PropModification: PropModification2,
          RangeSet: RangeSet2,
          add: add2,
          cmp: cmp2,
          default: Dexie$1,
          liveQuery: liveQuery2,
          mergeRanges: mergeRanges2,
          rangesOverlap: rangesOverlap2,
          remove: remove2,
          replacePrefix: replacePrefix2
        });
        __assign(Dexie$1, namedExports, { default: Dexie$1 });
        return Dexie$1;
      }));
    }
  });

  // src/ui/logo.ts
  var LOGO_SVG_DEFS = `
  <defs>
    <radialGradient id="bg" cx="30%" cy="20%" r="80%">
      <stop offset="0" stop-color="#7c5cff" stop-opacity="0.38"/>
      <stop offset="55%" stop-color="#0b1020" stop-opacity="1"/>
      <stop offset="100%" stop-color="#060a14" stop-opacity="1"/>
    </radialGradient>
    <linearGradient id="g" x1="70" y1="70" x2="200" y2="200" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#7950E5"/>
      <stop offset="0.55" stop-color="#00A2FE"/>
      <stop offset="1" stop-color="#3AE8BD"/>
    </linearGradient>
    <filter id="shadow" x="-25%" y="-25%" width="150%" height="150%">
      <feDropShadow dx="0" dy="14" stdDeviation="12" flood-color="#000" flood-opacity="0.45"/>
    </filter>
    <filter id="glow" x="-40%" y="-40%" width="180%" height="180%">
      <feGaussianBlur stdDeviation="6" result="b"/>
      <feMerge>
        <feMergeNode in="b"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  </defs>
`;
  var LOGO_SVG_SHAPES = `
  <path filter="url(#shadow)"
        d="M128 28c-38.7 0-70 31.3-70 70 0 55.3 70 130 70 130s70-74.7 70-130c0-38.7-31.3-70-70-70z"
        fill="rgba(255,255,255,0.06)" stroke="rgba(255,255,255,0.16)" stroke-width="4"/>

  <circle cx="128" cy="98" r="46" fill="rgba(255,255,255,0.05)" stroke="rgba(255,255,255,0.12)" stroke-width="3"/>

  <path filter="url(#glow)"
        d="M88 110l26-22 20 16 22-30 30 22"
        fill="none" stroke="url(#g)" stroke-width="7" stroke-linecap="round" stroke-linejoin="round"/>

  <g filter="url(#glow)">
    <circle cx="88" cy="110" r="5.5" fill="#7950E5"/>
    <circle cx="114" cy="88" r="5.5" fill="#5f7ff0"/>
    <circle cx="134" cy="104" r="5.5" fill="#00A2FE"/>
    <circle cx="156" cy="74" r="5.5" fill="#22cfe0"/>
    <circle cx="186" cy="96" r="5.5" fill="#3AE8BD"/>
  </g>
`;
  var LOGO_SVG_SHAPES_MARK = `
  <path filter="url(#shadow)"
        d="M128 28c-38.7 0-70 31.3-70 70 0 55.3 70 130 70 130s70-74.7 70-130c0-38.7-31.3-70-70-70z"
        fill="rgba(255,255,255,0.10)" stroke="rgba(255,255,255,0.24)" stroke-width="4"/>

  <circle cx="128" cy="98" r="46" fill="rgba(255,255,255,0.08)" stroke="rgba(255,255,255,0.18)" stroke-width="3"/>

  <path filter="url(#glow)"
        d="M88 110l26-22 20 16 22-30 30 22"
        fill="none" stroke="url(#g)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>

  <g filter="url(#glow)">
    <circle cx="88" cy="110" r="6.2" fill="#7950E5"/>
    <circle cx="114" cy="88" r="6.2" fill="#5f7ff0"/>
    <circle cx="134" cy="104" r="6.2" fill="#00A2FE"/>
    <circle cx="156" cy="74" r="6.2" fill="#22cfe0"/>
    <circle cx="186" cy="96" r="6.2" fill="#3AE8BD"/>
  </g>
`;
  var LOGO_LIGHT_DEFS = `
  <defs>
    <linearGradient id="neon" x1="64" y1="64" x2="196" y2="196" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#FFFFFF"/>
      <stop offset="0.35" stop-color="#AFA2FF"/>
      <stop offset="0.7" stop-color="#00C8FF"/>
      <stop offset="1" stop-color="#3AE8BD"/>
    </linearGradient>
    <filter id="glow" x="-60%" y="-60%" width="220%" height="220%">
      <feGaussianBlur stdDeviation="7" result="b"/>
      <feMerge>
        <feMergeNode in="b"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  </defs>
`;
  var LOGO_LIGHT_SHAPES = `
  <path d="M128 28c-38.7 0-70 31.3-70 70 0 55.3 70 130 70 130s70-74.7 70-130c0-38.7-31.3-70-70-70z"
        fill="rgba(255,255,255,0.20)" stroke="rgba(255,255,255,0.70)" stroke-width="9"/>

  <circle cx="128" cy="98" r="54" fill="rgba(255,255,255,0.16)" stroke="rgba(255,255,255,0.55)" stroke-width="6"/>

  <path filter="url(#glow)"
        d="M90 110l30-26 26 20 28-36 34 26"
        fill="none" stroke="url(#neon)" stroke-width="13" stroke-linecap="round" stroke-linejoin="round"/>
`;
  function replaceAll(haystack, needle, replacement) {
    return haystack.split(needle).join(replacement);
  }
  function escapeAttr(value) {
    let v = value;
    v = replaceAll(v, "&", "&amp;");
    v = replaceAll(v, '"', "&quot;");
    v = replaceAll(v, "<", "&lt;");
    v = replaceAll(v, ">", "&gt;");
    return v;
  }
  function logoSvgMarkup(opts) {
    const { size, idPrefix, decorative, ariaLabel } = opts;
    const variant = opts.variant ?? "full";
    let inner = "";
    let ids = [];
    if (variant === "light") {
      inner = `${LOGO_LIGHT_DEFS.trim()}
${LOGO_LIGHT_SHAPES.trim()}`.trim();
      ids = ["neon", "glow"];
    } else {
      const bg = variant === "full" ? `<circle cx="128" cy="128" r="112" fill="url(#bg)"/>` : "";
      const shapes = variant === "full" ? LOGO_SVG_SHAPES.trim() : LOGO_SVG_SHAPES_MARK.trim();
      inner = `${LOGO_SVG_DEFS.trim()}
${bg}
${shapes}`.trim();
      ids = ["bg", "g", "shadow", "glow"];
    }
    for (const id of ids) {
      inner = replaceAll(inner, `id="${id}"`, `id="${idPrefix}-${id}"`);
      inner = replaceAll(inner, `url(#${id})`, `url(#${idPrefix}-${id})`);
    }
    const label = (ariaLabel ?? "GeoAnalyzr").trim() || "GeoAnalyzr";
    const aria = decorative ? `aria-hidden="true"` : `role="img" aria-label="${escapeAttr(label)}"`;
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" width="${size}" height="${size}" focusable="false" ${aria}>${inner}</svg>`;
  }

  // src/uiOverlay.ts
  function el(tag) {
    return document.createElement(tag);
  }
  function cssOnce() {
    const id = "geoanalyzr-ui-overlay-css";
    if (document.getElementById(id)) return;
    const style = document.createElement("style");
    style.id = id;
    style.textContent = `
    .ga-ui-icon {
      position: fixed;
      left: 16px;
      bottom: 16px;
      z-index: 999999;
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(20,20,20,0.95);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
    }
    .ga-ui-icon:active { transform: translateY(1px); }

    .ga-ui-panel {
      position: fixed;
      left: 16px;
      bottom: 68px;
      z-index: 999999;
      width: 360px;
      max-width: calc(100vw - 32px);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(20,20,20,0.92);
      color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
      padding: 10px;
      display: none;
    }

    .ga-ui-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .ga-ui-title {
      font-weight: 700;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .ga-ui-title svg { display: block; filter: drop-shadow(0 0 10px rgba(0,162,254,0.35)); }
    .ga-ui-icon svg { display: block; filter: drop-shadow(0 0 14px rgba(0,162,254,0.40)); }
    .ga-ui-close {
      border: none;
      background: transparent;
      color: white;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      padding: 2px 6px;
    }

    .ga-ui-status {
      font-size: 12px;
      opacity: 0.95;
      white-space: pre-wrap;
      margin-bottom: 10px;
    }

    .ga-ui-btn {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.25);
      color: white;
      cursor: pointer;
      font-weight: 600;
      margin-top: 8px;
    }
    .ga-ui-btn:active { transform: translateY(1px); }
    .ga-ui-btn:disabled { opacity: 0.65; cursor: not-allowed; }

    .ga-ui-counts {
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.92;
      white-space: normal;
    }

    .ga-ui-modal {
      position: fixed;
      inset: 0;
      z-index: 1000000;
      background: rgba(0,0,0,0.62);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    .ga-ui-modal-card {
      width: 520px;
      max-width: calc(100vw - 32px);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(20,20,20,0.94);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      color: white;
      padding: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .ga-ui-modal-head {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .ga-ui-modal-head-title { font-weight: 700; }
    .ga-ui-modal-x { border:0; background: transparent; color: white; cursor:pointer; font-size: 18px; line-height: 1; }
    .ga-ui-modal-input {
      width: 100%;
      box-sizing: border-box;
      background: rgba(0,0,0,0.25);
      color: white;
      border: 1px solid rgba(255,255,255,0.20);
      border-radius: 10px;
      padding: 10px 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }
    .ga-ui-modal-help {
      margin-top: 8px;
      font-size: 12px;
      opacity: 0.90;
      white-space: pre-wrap;
    }
    .ga-ui-modal-actions {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-top: 12px;
    }
  `;
    (document.head ?? document.documentElement ?? document.body ?? document).appendChild(style);
  }
  function createUIOverlay() {
    const mount = () => {
      cssOnce();
      if (!document.documentElement.contains(iconBtn)) document.documentElement.appendChild(iconBtn);
      if (!document.documentElement.contains(panel)) document.documentElement.appendChild(panel);
    };
    const iconBtn = el("button");
    iconBtn.className = "ga-ui-icon";
    iconBtn.title = "GeoAnalyzr";
    iconBtn.type = "button";
    iconBtn.innerHTML = logoSvgMarkup({ size: 28, idPrefix: "ga-overlay-icon", variant: "light", decorative: true });
    const panel = el("div");
    panel.className = "ga-ui-panel";
    const header = el("div");
    header.className = "ga-ui-head";
    const title = el("div");
    title.className = "ga-ui-title";
    const titleLogo = el("span");
    titleLogo.innerHTML = logoSvgMarkup({ size: 16, idPrefix: "ga-overlay-title", variant: "light", decorative: true });
    const titleText = el("span");
    titleText.textContent = "GeoAnalyzr";
    title.appendChild(titleLogo);
    title.appendChild(titleText);
    const closeBtn = el("button");
    closeBtn.className = "ga-ui-close";
    closeBtn.type = "button";
    closeBtn.textContent = "x";
    header.appendChild(title);
    header.appendChild(closeBtn);
    const status = el("div");
    status.className = "ga-ui-status";
    status.textContent = "Ready.";
    const mkBtn2 = (label, bg) => {
      const b = el("button");
      b.className = "ga-ui-btn";
      b.type = "button";
      b.textContent = label;
      b.style.background = bg;
      return b;
    };
    const updateBtn = mkBtn2("Fetch Data", "rgba(255,255,255,0.10)");
    const analysisBtn = mkBtn2("Open Analysis Window", "rgba(35,95,160,0.28)");
    const discordBtn = mkBtn2("Join Discord", "rgba(121,80,229,0.30)");
    const tokenBtn = mkBtn2("Set NCFA Token", "rgba(95,95,30,0.35)");
    const exportBtn = mkBtn2("Export Excel", "rgba(40,120,50,0.35)");
    const resetBtn = mkBtn2("Reset Database", "rgba(160,35,35,0.35)");
    const counts = el("div");
    counts.className = "ga-ui-counts";
    counts.textContent = "Data: 0 games, 0 rounds.";
    panel.appendChild(header);
    panel.appendChild(status);
    panel.appendChild(updateBtn);
    panel.appendChild(analysisBtn);
    panel.appendChild(discordBtn);
    panel.appendChild(tokenBtn);
    panel.appendChild(exportBtn);
    panel.appendChild(resetBtn);
    panel.appendChild(counts);
    let open = false;
    const setOpen = (next) => {
      open = next;
      panel.style.display = open ? "block" : "none";
    };
    iconBtn.addEventListener("click", () => setOpen(!open));
    closeBtn.addEventListener("click", () => setOpen(false));
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", mount, { once: true });
    else mount();
    let updateHandler = null;
    let resetHandler = null;
    let exportHandler = null;
    let tokenHandler = null;
    let openAnalysisHandler = null;
    let discordHandler = null;
    updateBtn.addEventListener("click", () => void updateHandler?.());
    tokenBtn.addEventListener("click", () => void tokenHandler?.());
    exportBtn.addEventListener("click", () => void exportHandler?.());
    resetBtn.addEventListener("click", () => void resetHandler?.());
    analysisBtn.addEventListener("click", () => void openAnalysisHandler?.());
    discordBtn.addEventListener("click", () => void discordHandler?.());
    const openNcfaManager = (args) => {
      const overlay = el("div");
      overlay.className = "ga-ui-modal";
      const modal = el("div");
      modal.className = "ga-ui-modal-card";
      overlay.appendChild(modal);
      const head = el("div");
      head.className = "ga-ui-modal-head";
      const ht = el("div");
      ht.className = "ga-ui-modal-head-title";
      ht.textContent = "NCFA token";
      const x = el("button");
      x.className = "ga-ui-modal-x";
      x.type = "button";
      x.textContent = "x";
      head.appendChild(ht);
      head.appendChild(x);
      const input = el("input");
      input.className = "ga-ui-modal-input";
      input.type = "text";
      input.placeholder = "_ncfa value";
      input.value = args.initialToken || "";
      const help = el("div");
      help.className = "ga-ui-modal-help";
      help.textContent = "Set manually or use auto-detect.";
      const actions = el("div");
      actions.className = "ga-ui-modal-actions";
      const mkSmallBtn = (label, bg, onClick) => {
        const b = el("button");
        b.className = "ga-ui-btn";
        b.type = "button";
        b.textContent = label;
        b.style.marginTop = "0";
        b.style.background = bg;
        b.addEventListener("click", onClick);
        return b;
      };
      const saveBtn = mkSmallBtn("Save Manually", "rgba(95,95,30,0.45)", async () => {
        saveBtn.disabled = true;
        try {
          const res = await args.onSave(input.value);
          input.value = res.token || "";
          help.textContent = res.message;
        } catch (e) {
          help.textContent = `Save failed: ${e instanceof Error ? e.message : String(e)}`;
        } finally {
          saveBtn.disabled = false;
        }
      });
      const autoBtn = mkSmallBtn("Auto-Detect", "rgba(35,95,160,0.45)", async () => {
        autoBtn.disabled = true;
        try {
          const res = await args.onAutoDetect();
          if (res.token) input.value = res.token;
          help.textContent = res.message;
        } catch (e) {
          help.textContent = `Auto-detect failed: ${e instanceof Error ? e.message : String(e)}`;
        } finally {
          autoBtn.disabled = false;
        }
      });
      const helpBtn = mkSmallBtn("Show Instructions", "rgba(40,120,50,0.45)", () => {
        window.open(args.repoUrl, "_blank");
      });
      const closeRedBtn = mkSmallBtn("Close", "rgba(160,35,35,0.55)", () => {
        close();
      });
      actions.appendChild(saveBtn);
      actions.appendChild(autoBtn);
      actions.appendChild(helpBtn);
      actions.appendChild(closeRedBtn);
      modal.appendChild(head);
      modal.appendChild(input);
      modal.appendChild(actions);
      modal.appendChild(help);
      const close = () => overlay.remove();
      x.addEventListener("click", close);
      overlay.addEventListener("click", (ev) => {
        if (ev.target === overlay) close();
      });
      (document.body ?? document.documentElement).appendChild(overlay);
    };
    return {
      setVisible(visible) {
        iconBtn.style.display = visible ? "flex" : "none";
        if (!visible) panel.style.display = "none";
      },
      setStatus(msg) {
        status.textContent = msg;
      },
      setCounts(value) {
        counts.textContent = `Data: ${value.games} games, ${value.rounds} rounds.`;
      },
      onUpdateClick(fn) {
        updateHandler = fn;
      },
      onResetClick(fn) {
        resetHandler = fn;
      },
      onExportClick(fn) {
        exportHandler = fn;
      },
      onTokenClick(fn) {
        tokenHandler = fn;
      },
      onOpenAnalysisClick(fn) {
        openAnalysisHandler = fn;
      },
      onDiscordClick(fn) {
        discordHandler = fn;
      },
      openNcfaManager
    };
  }

  // node_modules/dexie/import-wrapper.mjs
  var import_dexie = __toESM(require_dexie(), 1);
  var DexieSymbol = /* @__PURE__ */ Symbol.for("Dexie");
  var Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = import_dexie.default);
  if (import_dexie.default.semVer !== Dexie.semVer) {
    throw new Error(`Two different versions of Dexie loaded in the same app: ${import_dexie.default.semVer} and ${Dexie.semVer}`);
  }
  var {
    liveQuery,
    mergeRanges,
    rangesOverlap,
    RangeSet,
    cmp,
    Entity,
    PropModification,
    replacePrefix,
    add,
    remove,
    DexieYProvider
  } = Dexie;
  var import_wrapper_default = Dexie;

  // src/db.ts
  var GGDB = class extends import_wrapper_default {
    games;
    rounds;
    details;
    meta;
    constructor() {
      super("gg_analyzer_db");
      this.version(1).stores({
        games: "gameId, playedAt, type, mode",
        rounds: "id, gameId, roundNumber",
        meta: "key, updatedAt"
      });
      this.version(2).stores({
        games: "gameId, playedAt, type, mode",
        rounds: "id, gameId, roundNumber",
        details: "gameId, status, fetchedAt",
        meta: "key, updatedAt"
      });
      this.version(3).stores({
        games: "gameId, playedAt, type, mode, gameMode, modeFamily, isTeamDuels",
        rounds: "id, gameId, roundNumber, [gameId+roundNumber]",
        details: "gameId, status, fetchedAt, modeFamily, isTeamDuels",
        meta: "key, updatedAt"
      });
      this.version(4).stores({
        games: "gameId, playedAt, type, mode, gameMode, modeFamily, isTeamDuels",
        rounds: [
          "id",
          "gameId",
          "roundNumber",
          "[gameId+roundNumber]",
          "playedAt",
          "trueCountry",
          "movementType",
          "player_self_score"
        ].join(", "),
        details: [
          "gameId",
          "status",
          "fetchedAt",
          "modeFamily",
          "isTeamDuels",
          "player_self_id",
          "player_mate_id",
          "player_opponent_country"
        ].join(", "),
        meta: "key, updatedAt"
      });
    }
  };
  var db = new GGDB();

  // src/http.ts
  function readNcfaFromDocumentCookie() {
    if (typeof document === "undefined") return void 0;
    const raw = typeof document.cookie === "string" ? document.cookie : "";
    if (!raw) return void 0;
    const parts = raw.split(";");
    for (const part of parts) {
      const [k, ...rest] = part.trim().split("=");
      if (k !== "_ncfa") continue;
      const value = rest.join("=").trim();
      if (value) return value;
    }
    return void 0;
  }
  function hasGmXhr() {
    return typeof globalThis.GM_xmlhttpRequest === "function";
  }
  function gmRequest(url, opts) {
    return new Promise((resolve, reject) => {
      const gm = globalThis.GM_xmlhttpRequest;
      const headers = {
        Accept: "application/json",
        ...opts?.headers || {}
      };
      const ncfa = opts?.ncfa || readNcfaFromDocumentCookie();
      if (ncfa) headers.Cookie = `_ncfa=${ncfa}`;
      gm({
        method: "GET",
        url,
        headers,
        onload: (res) => {
          const text = typeof res?.responseText === "string" ? res.responseText : "";
          resolve({
            status: Number(res?.status) || 0,
            text,
            json: () => JSON.parse(text)
          });
        },
        onerror: (err) => {
          reject(err);
        },
        ontimeout: () => reject(new Error("GM_xmlhttpRequest timeout"))
      });
    });
  }
  async function httpGetJson(url, opts) {
    const ncfa = opts?.ncfa || readNcfaFromDocumentCookie();
    if ((opts?.forceGm || ncfa) && hasGmXhr()) {
      const res2 = await gmRequest(url, { ncfa, headers: opts?.headers });
      return { status: res2.status, data: res2.json() };
    }
    const res = await fetch(url, { credentials: "include", headers: opts?.headers });
    const data = await res.json();
    return { status: res.status, data };
  }

  // src/details.ts
  var cachedOwnPlayerId;
  var profileCache = /* @__PURE__ */ new Map();
  var regionDisplay = typeof Intl !== "undefined" && typeof Intl.DisplayNames === "function" ? new Intl.DisplayNames(["en"], { type: "region" }) : null;
  function etaLabel(ms) {
    const sec = Math.max(0, Math.round(ms / 1e3));
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    if (m > 0) return `${m}m ${String(s).padStart(2, "0")}s`;
    return `${s}s`;
  }
  function toTs(isoMaybe) {
    if (typeof isoMaybe !== "string") return void 0;
    const t = Date.parse(isoMaybe);
    return Number.isFinite(t) ? t : void 0;
  }
  function asNum(v) {
    if (typeof v === "number" && Number.isFinite(v)) return v;
    if (typeof v === "string") {
      const parsed = Number(v);
      if (Number.isFinite(parsed)) return parsed;
    }
    return void 0;
  }
  function asBool(v) {
    if (v === true) return true;
    if (v === false) return false;
    return void 0;
  }
  function getByPath(obj, path) {
    const parts = path.split(".");
    let cur = obj;
    for (const p of parts) {
      if (!cur || typeof cur !== "object" || !(p in cur)) return void 0;
      cur = cur[p];
    }
    return cur;
  }
  function pickFirst(obj, paths) {
    for (const p of paths) {
      const v = getByPath(obj, p);
      if (v !== void 0 && v !== null) return v;
    }
    return void 0;
  }
  function normalizeIso2(v) {
    if (typeof v !== "string") return void 0;
    const x = v.trim().toLowerCase();
    if (!x) return void 0;
    return /^[a-z]{2}$/.test(x) ? x : void 0;
  }
  function extractGuessLatLng(guess) {
    const lat = asNum(
      pickFirst(guess, [
        "lat",
        "latitude",
        "location.lat",
        "position.lat",
        "coordinates.1"
      ])
    );
    const lng = asNum(
      pickFirst(guess, [
        "lng",
        "lon",
        "longitude",
        "location.lng",
        "location.lon",
        "position.lng",
        "position.lon",
        "coordinates.0"
      ])
    );
    return { lat, lng };
  }
  function extractGuessCountryCode(guess) {
    return normalizeIso2(
      pickFirst(guess, [
        "countryCode",
        "country_code",
        "country"
      ])
    );
  }
  function roundId(gameId, roundNumber) {
    return `${gameId}:${roundNumber}`;
  }
  function countryNameFromIso2(iso2) {
    if (typeof iso2 !== "string" || !iso2.trim()) return void 0;
    const upper = iso2.trim().toUpperCase();
    if (!regionDisplay) return upper;
    try {
      const name = regionDisplay.of(upper);
      return typeof name === "string" && name.trim() ? name : upper;
    } catch {
      return upper;
    }
  }
  function toIsoDate(ts) {
    if (!ts) return void 0;
    return new Date(ts).toISOString().slice(0, 10);
  }
  function toIsoTime(ts) {
    if (!ts) return void 0;
    return new Date(ts).toISOString().slice(11, 23);
  }
  function classifyFamily(game) {
    if (game.modeFamily) return game.modeFamily;
    const m = String(game.gameMode || game.mode || "").toLowerCase();
    if (m.includes("team")) return "teamduels";
    if (m.includes("duel")) return "duels";
    return "other";
  }
  async function getOwnPlayerId() {
    if (cachedOwnPlayerId !== void 0) return cachedOwnPlayerId || void 0;
    const candidates = [
      "https://www.geoguessr.com/api/v3/profiles",
      "https://www.geoguessr.com/api/v4/profiles",
      "https://www.geoguessr.com/api/v3/users/me"
    ];
    for (const url of candidates) {
      try {
        const res = await fetch(url, { credentials: "include" });
        if (!res.ok) continue;
        const data = await res.json();
        const id = pickFirst(data, ["user.id", "id", "player.id", "playerId", "user.userId"]);
        if (typeof id === "string" && id.trim()) {
          cachedOwnPlayerId = id.trim();
          return cachedOwnPlayerId;
        }
      } catch {
      }
    }
    cachedOwnPlayerId = null;
    return void 0;
  }
  async function getProfile(playerId, ncfa) {
    if (typeof playerId !== "string" || !playerId.trim()) return void 0;
    const key = playerId.trim();
    if (profileCache.has(key)) return profileCache.get(key);
    try {
      const url = `https://www.geoguessr.com/api/v3/users/${encodeURIComponent(key)}`;
      const res = await httpGetJson(url, { ncfa });
      if (res.status < 200 || res.status >= 300) {
        profileCache.set(key, {});
        return profileCache.get(key);
      }
      const nick = typeof res.data?.nick === "string" ? res.data.nick : void 0;
      const cc = typeof res.data?.countryCode === "string" ? res.data.countryCode : void 0;
      const profile = { nick, countryCode: cc, countryName: countryNameFromIso2(cc) };
      profileCache.set(key, profile);
      return profile;
    } catch {
      profileCache.set(key, {});
      return profileCache.get(key);
    }
  }
  function buildDetailCandidates(gameId, family) {
    const gameServer = [`https://game-server.geoguessr.com/api/duels/${gameId}`];
    const team = [
      ...gameServer,
      `https://www.geoguessr.com/api/team-duels/${gameId}`,
      `https://www.geoguessr.com/api/v3/team-duels/${gameId}`,
      `https://www.geoguessr.com/api/v4/team-duels/${gameId}`,
      `https://www.geoguessr.com/api/v4/competitive-games/${gameId}`,
      `https://www.geoguessr.com/api/v3/games/${gameId}`
    ];
    const duels = [
      ...gameServer,
      `https://www.geoguessr.com/api/duels/${gameId}`,
      `https://www.geoguessr.com/api/v3/duels/${gameId}`,
      `https://www.geoguessr.com/api/v4/duels/${gameId}`,
      `https://www.geoguessr.com/api/v4/competitive-games/${gameId}`,
      `https://www.geoguessr.com/api/v3/games/${gameId}`
    ];
    return family === "teamduels" ? [...team, ...duels] : [...duels, ...team];
  }
  function detectSimpleGameMode(movementOptions) {
    if (!movementOptions || typeof movementOptions !== "object") return void 0;
    const fm = movementOptions.forbidMoving === true;
    const fz = movementOptions.forbidZooming === true;
    const fr = movementOptions.forbidRotating === true;
    if (!fm && !fz && !fr) return "moving";
    if (fm && !fz && !fr) return "no move";
    if (fm && fz && fr) return "nmpz";
    return void 0;
  }
  function extractRatingChange(player) {
    const paths = [
      "progressChange.rankedSystemProgress",
      "progressChange.rankedTeamDuelsProgress",
      "progressChange.rankedProgress",
      "progressChange.ratingProgress"
    ];
    for (const p of paths) {
      const obj = getByPath(player, p);
      const before = asNum(obj?.ratingBefore);
      const after = asNum(obj?.ratingAfter);
      if (before !== void 0 || after !== void 0) return { before, after };
    }
    return {};
  }
  async function fetchDetailJson(game, ncfa) {
    const family = classifyFamily(game);
    const endpoints = buildDetailCandidates(game.gameId, family);
    const failures = [];
    for (const endpoint of endpoints) {
      try {
        const res = await httpGetJson(endpoint, { ncfa });
        if (res.status < 200 || res.status >= 300) {
          failures.push(`${endpoint} -> HTTP ${res.status}`);
          continue;
        }
        return { data: res.data, endpoint };
      } catch (e) {
        failures.push(`${endpoint} -> ${e instanceof Error ? e.message : String(e)}`);
      }
    }
    throw new Error(`No endpoint worked for ${game.gameId}: ${failures.join(" | ")}`);
  }
  function healthByRound(team) {
    const map = /* @__PURE__ */ new Map();
    const rows = Array.isArray(team?.roundResults) ? team.roundResults : [];
    for (const r of rows) {
      const rn = asNum(r?.roundNumber);
      if (rn === void 0) continue;
      const health = asNum(r?.healthAfter);
      if (health !== void 0) map.set(rn, health);
    }
    return map;
  }
  function guessByRound(player) {
    const map = /* @__PURE__ */ new Map();
    const guesses = Array.isArray(player?.guesses) ? player.guesses : [];
    for (const g of guesses) {
      const rn = asNum(g?.roundNumber);
      if (rn === void 0) continue;
      map.set(rn, g);
    }
    return map;
  }
  function readPlayerId(player) {
    const v = player?.playerId ?? player?.id ?? player?.userId ?? player?.user?.id;
    return typeof v === "string" && v.trim() ? v.trim() : void 0;
  }
  function orderedPlayers(gameData, ownPlayerId) {
    const teams = Array.isArray(gameData?.teams) ? gameData.teams : [];
    if (teams.length === 0) return [];
    let ownTeamIndex = 0;
    if (ownPlayerId) {
      const found = teams.findIndex(
        (t) => Array.isArray(t?.players) && t.players.some((p) => readPlayerId(p) === ownPlayerId)
      );
      if (found >= 0) {
        ownTeamIndex = found;
      } else {
        console.warn("[GeoAnalyzr] ownPlayerId not found in teams for game detail payload.", {
          ownPlayerId,
          teamIds: teams.map((t) => String(t?.id || "")),
          teamPlayers: teams.map((t) => Array.isArray(t?.players) ? t.players.map((p) => readPlayerId(p)) : [])
        });
      }
    }
    const ownTeam = teams[ownTeamIndex];
    const otherTeams = teams.filter((_, i) => i !== ownTeamIndex);
    const ownPlayers = Array.isArray(ownTeam?.players) ? [...ownTeam.players] : [];
    const ownHealth = healthByRound(ownTeam);
    if (ownPlayerId) {
      ownPlayers.sort((a, b) => {
        if (readPlayerId(a) === ownPlayerId) return -1;
        if (readPlayerId(b) === ownPlayerId) return 1;
        return 0;
      });
    }
    const out = [];
    for (const p of ownPlayers) out.push({ teamId: String(ownTeam?.id || ""), player: p, healthMap: ownHealth });
    for (const t of otherTeams) {
      const teamHealth = healthByRound(t);
      for (const p of Array.isArray(t?.players) ? t.players : []) {
        out.push({ teamId: String(t?.id || ""), player: p, healthMap: teamHealth });
      }
    }
    return out.slice(0, 4);
  }
  function averageDefined(values) {
    const nums = values.filter((v) => typeof v === "number" && Number.isFinite(v));
    if (!nums.length) return void 0;
    return nums.reduce((a, b) => a + b, 0) / nums.length;
  }
  async function normalizeGameAndRounds(game, gameData, endpoint, ownPlayerId, ncfa) {
    const teams = Array.isArray(gameData?.teams) ? gameData.teams : [];
    const rounds = Array.isArray(gameData?.rounds) ? gameData.rounds : [];
    const startTime = toTs(rounds[0]?.startTime);
    const family = classifyFamily(game);
    const winningTeamId = String(gameData?.result?.winningTeamId || "");
    const damageMultiplierRounds = rounds.filter((r) => (asNum(r?.damageMultiplier) || 1) > 1).map((r) => asNum(r?.roundNumber)).filter((v) => v !== void 0);
    const healingRounds = rounds.filter((r) => Boolean(r?.isHealingRound)).map((r) => asNum(r?.roundNumber)).filter((v) => v !== void 0);
    const mapName = pickFirst(gameData, ["options.map.name"]);
    const mapSlug = pickFirst(gameData, ["options.map.slug"]);
    const isRated = asBool(pickFirst(gameData, ["options.isRated"]));
    const missingFields = [];
    if (typeof mapSlug !== "string" || !mapSlug.trim()) missingFields.push("mapSlug");
    if (typeof mapName !== "string" || !mapName.trim()) missingFields.push("mapName");
    if (isRated === void 0) missingFields.push("isRated");
    const commonBase = {
      gameId: game.gameId,
      status: "ok",
      fetchedAt: Date.now(),
      endpoint,
      gameMode: game.gameMode || game.mode,
      modeFamily: family,
      mapName: typeof mapName === "string" ? mapName : void 0,
      mapSlug: typeof mapSlug === "string" ? mapSlug : void 0,
      isRated,
      missingFields: missingFields.length > 0 ? missingFields : void 0,
      missingFieldsCheckedAt: missingFields.length > 0 ? Date.now() : void 0,
      totalRounds: asNum(gameData?.currentRoundNumber) ?? rounds.length,
      damageMultiplierRounds,
      healingRounds,
      raw: gameData
    };
    const players = orderedPlayers(gameData, ownPlayerId);
    if (family === "teamduels" && ownPlayerId) {
      const p1IdDebug = readPlayerId(players[0]?.player);
      if (p1IdDebug !== ownPlayerId) {
        console.warn("[GeoAnalyzr] TeamDuel ordering mismatch: p1 is not own player.", {
          gameId: game.gameId,
          ownPlayerId,
          p1Id: p1IdDebug,
          orderedIds: players.map((x) => x?.player?.playerId)
        });
      }
    }
    const guessMaps = players.map((x) => guessByRound(x.player));
    const p1 = players[0]?.player;
    const p2 = players[1]?.player;
    const p3 = players[2]?.player;
    const p4 = players[3]?.player;
    const p1Id = readPlayerId(p1);
    const p2Id = readPlayerId(p2);
    const p3Id = readPlayerId(p3);
    const p4Id = readPlayerId(p4);
    const uniqueIds = [...new Set([p1Id, p2Id, p3Id, p4Id].filter((x) => !!x))];
    const profiles = /* @__PURE__ */ new Map();
    await Promise.all(
      uniqueIds.map(async (id) => {
        const p = await getProfile(id, ncfa);
        if (p) profiles.set(id, p);
      })
    );
    const p1Rc = extractRatingChange(p1);
    const p2Rc = extractRatingChange(p2);
    const p3Rc = extractRatingChange(p3);
    const p4Rc = extractRatingChange(p4);
    let detail;
    if (family === "teamduels" && teams.length >= 2) {
      const ownTeamId = players[0]?.teamId || String(teams[0]?.id || "");
      const teamOne = teams.find((t) => String(t?.id || "") === ownTeamId) || teams[0];
      const teamTwo = teams.find((t) => String(t?.id || "") !== String(teamOne?.id || "")) || teams[1];
      const teamOnePlayers = Array.isArray(teamOne?.players) ? teamOne.players : [];
      const teamTwoPlayers = Array.isArray(teamTwo?.players) ? teamTwo.players : [];
      const teamDetail = {
        ...commonBase,
        modeFamily: "teamduels",
        date: toIsoDate(startTime),
        time: toIsoTime(startTime),
        gameModeSimple: detectSimpleGameMode(gameData?.movementOptions),
        // role-based aliases
        player_self_id: p1Id,
        player_self_name: (p1Id ? profiles.get(p1Id)?.nick : void 0) ?? (typeof p1?.nick === "string" ? p1.nick : void 0),
        player_self_country: p1Id ? profiles.get(p1Id)?.countryName : void 0,
        player_self_startRating: p1Rc.before,
        player_self_endRating: p1Rc.after,
        player_mate_id: p2Id,
        player_mate_name: (p2Id ? profiles.get(p2Id)?.nick : void 0) ?? (typeof p2?.nick === "string" ? p2.nick : void 0),
        player_mate_country: p2Id ? profiles.get(p2Id)?.countryName : void 0,
        player_mate_startRating: p2Rc.before,
        player_mate_endRating: p2Rc.after,
        player_opponent_id: p3Id,
        player_opponent_name: (p3Id ? profiles.get(p3Id)?.nick : void 0) ?? (typeof p3?.nick === "string" ? p3.nick : void 0),
        player_opponent_country: p3Id ? profiles.get(p3Id)?.countryName : void 0,
        player_opponent_startRating: p3Rc.before,
        player_opponent_endRating: p3Rc.after,
        player_opponent_mate_id: p4Id,
        player_opponent_mate_name: (p4Id ? profiles.get(p4Id)?.nick : void 0) ?? (typeof p4?.nick === "string" ? p4.nick : void 0),
        player_opponent_mate_country: p4Id ? profiles.get(p4Id)?.countryName : void 0,
        player_opponent_mate_startRating: p4Rc.before,
        player_opponent_mate_endRating: p4Rc.after,
        teamOneId: String(teamOne?.id || ""),
        teamOneVictory: winningTeamId ? String(teamOne?.id || "") === winningTeamId : void 0,
        teamOneFinalHealth: asNum(teamOne?.health),
        teamOneStartRating: averageDefined(teamOnePlayers.map((pl) => extractRatingChange(pl).before)),
        teamOneEndRating: averageDefined(teamOnePlayers.map((pl) => extractRatingChange(pl).after)),
        teamOnePlayerOneId: typeof teamOnePlayers[0]?.playerId === "string" ? teamOnePlayers[0].playerId : void 0,
        teamOnePlayerOneName: (typeof teamOnePlayers[0]?.playerId === "string" ? profiles.get(teamOnePlayers[0].playerId)?.nick : void 0) ?? (typeof teamOnePlayers[0]?.nick === "string" ? teamOnePlayers[0].nick : void 0),
        teamOnePlayerOneCountry: typeof teamOnePlayers[0]?.playerId === "string" ? profiles.get(teamOnePlayers[0].playerId)?.countryName : void 0,
        teamOnePlayerTwoId: typeof teamOnePlayers[1]?.playerId === "string" ? teamOnePlayers[1].playerId : void 0,
        teamOnePlayerTwoName: (typeof teamOnePlayers[1]?.playerId === "string" ? profiles.get(teamOnePlayers[1].playerId)?.nick : void 0) ?? (typeof teamOnePlayers[1]?.nick === "string" ? teamOnePlayers[1].nick : void 0),
        teamOnePlayerTwoCountry: typeof teamOnePlayers[1]?.playerId === "string" ? profiles.get(teamOnePlayers[1].playerId)?.countryName : void 0,
        teamTwoId: String(teamTwo?.id || ""),
        teamTwoVictory: winningTeamId ? String(teamTwo?.id || "") === winningTeamId : void 0,
        teamTwoFinalHealth: asNum(teamTwo?.health),
        teamTwoStartRating: averageDefined(teamTwoPlayers.map((pl) => extractRatingChange(pl).before)),
        teamTwoEndRating: averageDefined(teamTwoPlayers.map((pl) => extractRatingChange(pl).after)),
        teamTwoPlayerOneId: typeof teamTwoPlayers[0]?.playerId === "string" ? teamTwoPlayers[0].playerId : void 0,
        teamTwoPlayerOneName: (typeof teamTwoPlayers[0]?.playerId === "string" ? profiles.get(teamTwoPlayers[0].playerId)?.nick : void 0) ?? (typeof teamTwoPlayers[0]?.nick === "string" ? teamTwoPlayers[0].nick : void 0),
        teamTwoPlayerOneCountry: typeof teamTwoPlayers[0]?.playerId === "string" ? profiles.get(teamTwoPlayers[0].playerId)?.countryName : void 0,
        teamTwoPlayerTwoId: typeof teamTwoPlayers[1]?.playerId === "string" ? teamTwoPlayers[1].playerId : void 0,
        teamTwoPlayerTwoName: (typeof teamTwoPlayers[1]?.playerId === "string" ? profiles.get(teamTwoPlayers[1].playerId)?.nick : void 0) ?? (typeof teamTwoPlayers[1]?.nick === "string" ? teamTwoPlayers[1].nick : void 0),
        teamTwoPlayerTwoCountry: typeof teamTwoPlayers[1]?.playerId === "string" ? profiles.get(teamTwoPlayers[1].playerId)?.countryName : void 0
      };
      detail = teamDetail;
    } else {
      const ownTeamId = players[0]?.teamId || String(teams[0]?.id || "");
      const teamOne = teams.find((t) => String(t?.id || "") === ownTeamId) || teams[0];
      const teamTwo = teams.find((t) => String(t?.id || "") !== String(teamOne?.id || "")) || teams[1];
      const duelDetail = {
        ...commonBase,
        modeFamily: "duels",
        date: toIsoDate(startTime),
        time: toIsoTime(startTime),
        gameModeSimple: detectSimpleGameMode(gameData?.movementOptions),
        // role-based aliases
        player_self_id: p1Id,
        player_self_name: (p1Id ? profiles.get(p1Id)?.nick : void 0) ?? (typeof p1?.nick === "string" ? p1.nick : void 0),
        player_self_country: p1Id ? profiles.get(p1Id)?.countryName : void 0,
        player_self_victory: winningTeamId ? String(teamOne?.id || "") === winningTeamId : void 0,
        player_self_finalHealth: asNum(teamOne?.health),
        player_self_startRating: p1Rc.before,
        player_self_endRating: p1Rc.after,
        player_opponent_id: p2Id,
        player_opponent_name: (p2Id ? profiles.get(p2Id)?.nick : void 0) ?? (typeof p2?.nick === "string" ? p2.nick : void 0),
        player_opponent_country: p2Id ? profiles.get(p2Id)?.countryName : void 0,
        player_opponent_victory: winningTeamId ? String(teamTwo?.id || "") === winningTeamId : void 0,
        player_opponent_finalHealth: asNum(teamTwo?.health),
        player_opponent_startRating: p2Rc.before,
        player_opponent_endRating: p2Rc.after,
        playerOneId: p1Id,
        playerOneName: (p1Id ? profiles.get(p1Id)?.nick : void 0) ?? (typeof p1?.nick === "string" ? p1.nick : void 0),
        playerOneCountry: p1Id ? profiles.get(p1Id)?.countryName : void 0,
        playerOneVictory: winningTeamId ? String(teamOne?.id || "") === winningTeamId : void 0,
        playerOneFinalHealth: asNum(teamOne?.health),
        playerOneStartRating: p1Rc.before,
        playerOneEndRating: p1Rc.after,
        playerTwoId: p2Id,
        playerTwoName: (p2Id ? profiles.get(p2Id)?.nick : void 0) ?? (typeof p2?.nick === "string" ? p2.nick : void 0),
        playerTwoCountry: p2Id ? profiles.get(p2Id)?.countryName : void 0,
        playerTwoVictory: winningTeamId ? String(teamTwo?.id || "") === winningTeamId : void 0,
        playerTwoFinalHealth: asNum(teamTwo?.health),
        playerTwoStartRating: p2Rc.before,
        playerTwoEndRating: p2Rc.after
      };
      detail = duelDetail;
    }
    const normalizedRounds = [];
    for (let i = 0; i < rounds.length; i++) {
      const r = rounds[i];
      const rn = asNum(r?.roundNumber) ?? i + 1;
      const roundBase = {
        id: roundId(game.gameId, rn),
        gameId: game.gameId,
        roundNumber: rn,
        mapName: commonBase.mapName,
        mapSlug: commonBase.mapSlug,
        isRated: commonBase.isRated,
        trueLat: asNum(r?.panorama?.lat),
        trueLng: asNum(r?.panorama?.lng),
        trueCountry: typeof r?.panorama?.countryCode === "string" ? r.panorama.countryCode : void 0,
        damageMultiplier: asNum(r?.damageMultiplier),
        isHealingRound: Boolean(r?.isHealingRound),
        startTime: toTs(r?.startTime),
        endTime: toTs(r?.endTime),
        durationSeconds: (() => {
          const s = toTs(r?.startTime);
          const e = toTs(r?.endTime);
          return s !== void 0 && e !== void 0 && e >= s ? (e - s) / 1e3 : void 0;
        })(),
        raw: r
      };
      if (family === "teamduels") {
        const round = { ...roundBase, modeFamily: "teamduels" };
        const roleByPos = {
          1: "player_self",
          2: "player_mate",
          3: "player_opponent",
          4: "player_opponent_mate"
        };
        for (let p = 0; p < Math.min(players.length, 4); p++) {
          const playerIndex = p + 1;
          const { teamId, player, healthMap } = players[p];
          const role = roleByPos[playerIndex];
          const guess = guessMaps[p].get(rn);
          const guessPos = extractGuessLatLng(guess);
          const guessLat = guessPos.lat;
          const guessLng = guessPos.lng;
          const distanceMeters = asNum(guess?.distance);
          round[`${role}_playerId`] = readPlayerId(player);
          round[`${role}_teamId`] = teamId || void 0;
          round[`${role}_guessLat`] = guessLat;
          round[`${role}_guessLng`] = guessLng;
          round[`${role}_distanceKm`] = distanceMeters !== void 0 ? distanceMeters / 1e3 : void 0;
          round[`${role}_guessCountry`] = extractGuessCountryCode(guess);
          round[`${role}_score`] = asNum(guess?.score);
          round[`${role}_healthAfter`] = healthMap.get(rn);
          round[`${role}_isBestGuess`] = Boolean(guess?.isTeamsBestGuessOnRound);
        }
        normalizedRounds.push(round);
      } else {
        const round = { ...roundBase, modeFamily: "duels" };
        for (let p = 0; p < Math.min(players.length, 2); p++) {
          const role = p === 0 ? "player_self" : "player_opponent";
          const { player, healthMap } = players[p];
          const guess = guessMaps[p].get(rn);
          const guessPos = extractGuessLatLng(guess);
          const guessLat = guessPos.lat;
          const guessLng = guessPos.lng;
          const distanceMeters = asNum(guess?.distance);
          round[`${role}_playerId`] = readPlayerId(player);
          round[`${role}_guessLat`] = guessLat;
          round[`${role}_guessLng`] = guessLng;
          round[`${role}_distanceKm`] = distanceMeters !== void 0 ? distanceMeters / 1e3 : void 0;
          round[`${role}_guessCountry`] = extractGuessCountryCode(guess);
          round[`${role}_score`] = asNum(guess?.score);
          round[`${role}_healthAfter`] = healthMap.get(rn);
        }
        if (typeof round.player_self_healthAfter === "number" && typeof round.player_opponent_healthAfter === "number") {
          round.healthDiffAfter = round.player_self_healthAfter - round.player_opponent_healthAfter;
        }
        normalizedRounds.push(round);
      }
    }
    return { detail, rounds: normalizedRounds };
  }
  async function fetchDetailsForGames(opts) {
    const concurrency = opts.concurrency ?? 4;
    const retryErrors = opts.retryErrors ?? true;
    const verifyCompleteness = opts.verifyCompleteness ?? true;
    const reason = opts.reason ? ` (${opts.reason})` : "";
    const ownPlayerId = await getOwnPlayerId();
    opts.onStatus(`Detected own playerId: ${ownPlayerId ?? "not found"}${reason}`);
    const missingRetryAfterMs = 7 * 24 * 60 * 60 * 1e3;
    const enrichmentRetryAfterMs = 30 * 24 * 60 * 60 * 1e3;
    const candidates = (opts.games || []).filter((g) => {
      const family = classifyFamily(g);
      if (family === "duels" || family === "teamduels") return true;
      const m = String(g.gameMode || g.mode || "").toLowerCase();
      return m.includes("duel");
    });
    if (candidates.length === 0) {
      opts.onStatus(`No duel candidates to fetch.${reason}`);
      return { queued: 0, ok: 0, fail: 0, skipped: 0 };
    }
    const existing = await db.details.bulkGet(candidates.map((g) => g.gameId));
    let roundCountByGame = null;
    if (verifyCompleteness) {
      const ids = candidates.map((g) => g.gameId);
      const rr = await db.rounds.where("gameId").anyOf(ids).toArray();
      roundCountByGame = /* @__PURE__ */ new Map();
      for (const r of rr) {
        const gid = typeof r?.gameId === "string" ? r.gameId : "";
        if (!gid) continue;
        roundCountByGame.set(gid, (roundCountByGame.get(gid) || 0) + 1);
      }
    }
    const shouldRefetchForEnrichment = (detail) => {
      if (!detail || detail.status !== "ok") return false;
      const missing = [];
      if (typeof detail.mapSlug !== "string" || !detail.mapSlug.trim()) missing.push("mapSlug");
      if (typeof detail.mapName !== "string" || !detail.mapName.trim()) missing.push("mapName");
      if (typeof detail.isRated !== "boolean") missing.push("isRated");
      if (missing.length === 0) return false;
      const checkedAt = typeof detail.missingFieldsCheckedAt === "number" ? detail.missingFieldsCheckedAt : 0;
      const prevMissing = Array.isArray(detail.missingFields) ? detail.missingFields : [];
      const alreadyKnown = missing.every((m) => prevMissing.includes(m));
      if (alreadyKnown && checkedAt && Date.now() - checkedAt < enrichmentRetryAfterMs) return false;
      return true;
    };
    const queue = [];
    const markMissing = [];
    let skipped = 0;
    for (let i = 0; i < candidates.length; i++) {
      const game = candidates[i];
      const detail = existing[i];
      if (!detail) {
        markMissing.push({ gameId: game.gameId, status: "missing", modeFamily: classifyFamily(game), gameMode: game.gameMode || game.mode });
        queue.push(game);
        continue;
      }
      if (detail.status === "ok") {
        if (verifyCompleteness && roundCountByGame) {
          const have = roundCountByGame.get(game.gameId) || 0;
          const expected = detail.totalRounds;
          const incomplete = have === 0 || typeof expected === "number" && expected > 0 && have < expected;
          if (incomplete) {
            queue.push(game);
            continue;
          }
        }
        if (shouldRefetchForEnrichment(detail)) {
          queue.push(game);
          continue;
        }
        skipped++;
        continue;
      }
      if (detail.status === "missing") {
        const lastTry = detail.fetchedAt || 0;
        const shouldRetry = !lastTry || Date.now() - lastTry >= missingRetryAfterMs;
        if (shouldRetry) queue.push(game);
        else skipped++;
        continue;
      }
      if (retryErrors && detail.status === "error") {
        queue.push(game);
        continue;
      }
      skipped++;
    }
    if (markMissing.length > 0) await db.details.bulkPut(markMissing);
    if (queue.length === 0) {
      opts.onStatus(`No detail fetch needed (skipped ${skipped}).${reason}`);
      return { queued: 0, ok: 0, fail: 0, skipped };
    }
    opts.onStatus(`Fetching details for ${queue.length} duel games...${reason}`);
    const total = queue.length;
    let done = 0;
    let ok = 0;
    let fail = 0;
    const startedAt = Date.now();
    async function worker() {
      while (queue.length > 0) {
        const game = queue.shift();
        if (!game) return;
        try {
          const { data, endpoint } = await fetchDetailJson(game, opts.ncfa);
          const normalized = await normalizeGameAndRounds(game, data, endpoint, ownPlayerId, opts.ncfa);
          await db.transaction("rw", db.details, db.rounds, async () => {
            await db.details.put(normalized.detail);
            await db.rounds.bulkPut(normalized.rounds);
          });
          ok++;
        } catch (e) {
          const message = e instanceof Error ? e.message : String(e);
          const likelyUnavailable = /HTTP (403|404|410)\b/.test(message);
          await db.details.put({
            gameId: game.gameId,
            status: likelyUnavailable ? "missing" : "error",
            fetchedAt: Date.now(),
            gameMode: game.gameMode || game.mode,
            modeFamily: classifyFamily(game),
            error: message
          });
          if (!likelyUnavailable) fail++;
        } finally {
          done++;
          const elapsed = Date.now() - startedAt;
          const rate = done / Math.max(1, elapsed);
          const etaMs = rate > 0 ? (total - done) / rate : 0;
          opts.onStatus(`Details ${done}/${total} (ok ${ok}, fail ${fail}) ETA ~${etaLabel(etaMs)}${reason}`);
        }
      }
    }
    await Promise.all(Array.from({ length: concurrency }, () => worker()));
    opts.onStatus(`Details done. ok=${ok}, fail=${fail}, skipped=${skipped}${reason}`);
    return { queued: total, ok, fail, skipped };
  }

  // src/sync.ts
  function etaLabel2(ms) {
    const sec = Math.max(0, Math.round(ms / 1e3));
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    if (m > 0) return `${m}m ${String(s).padStart(2, "0")}s`;
    return `${s}s`;
  }
  function getByPath2(obj, path) {
    const parts = path.split(".");
    let cur = obj;
    for (const part of parts) {
      if (!cur || typeof cur !== "object" || !(part in cur)) return void 0;
      cur = cur[part];
    }
    return cur;
  }
  function pickFirst2(obj, paths) {
    for (const p of paths) {
      const v = getByPath2(obj, p);
      if (v !== void 0 && v !== null) return v;
    }
    return void 0;
  }
  function parsePayloadArray(payload) {
    if (Array.isArray(payload)) return payload;
    if (typeof payload === "string") {
      try {
        const parsed = JSON.parse(payload);
        if (Array.isArray(parsed)) return parsed;
      } catch {
        return [];
      }
    }
    return [];
  }
  function normalizeGameMode(modeRaw) {
    if (typeof modeRaw !== "string") return void 0;
    const trimmed = modeRaw.trim();
    return trimmed.length > 0 ? trimmed : void 0;
  }
  function classifyModeFamily(gameMode) {
    const m = String(gameMode || "").toLowerCase();
    if (m.includes("teamduels") || m.includes("team_duels") || m.includes("team-duels")) return "teamduels";
    if (m.includes("duels") || m.includes("duel")) return "duels";
    if (m.includes("standard")) return "standard";
    if (m.includes("streak")) return "streak";
    return "other";
  }
  function classifyModeFamilyFromEvent(ev, gameMode) {
    const byMode = classifyModeFamily(gameMode);
    if (byMode !== "other") return byMode;
    const hintRaw = pickFirst2(ev, [
      "type",
      "__typename",
      "payload.type",
      "payload.__typename",
      "payload.gameType",
      "payload.mode",
      "payload.slug"
    ]);
    const hint = String(hintRaw || "").toLowerCase();
    if (!hint) return "other";
    if (hint.includes("team") && hint.includes("duel")) return "teamduels";
    if (hint.includes("duel")) return "duels";
    if (hint.includes("streak")) return "streak";
    if (hint.includes("standard") || hint.includes("singleplayer") || hint.includes("classic")) return "standard";
    return "other";
  }
  function classifyTypeFromFamily(family) {
    if (family === "duels" || family === "teamduels") return "duels";
    if (family === "standard" || family === "streak") return "classic";
    return "other";
  }
  function extractEvents(entry) {
    const payloadEvents = parsePayloadArray(entry?.payload);
    if (payloadEvents.length > 0) return payloadEvents;
    if (entry && typeof entry === "object") return [entry];
    return [];
  }
  var GAME_ID_PATHS = ["payload.gameId", "gameId", "id", "payload.id"];
  function extractGameIdWithSource(ev) {
    for (const path of GAME_ID_PATHS) {
      const id = getByPath2(ev, path);
      if (typeof id === "string" && id.trim()) {
        return { gameId: id.trim(), source: path };
      }
    }
    return { source: "none" };
  }
  function extractEventTimeMs(ev, entry) {
    const timeCandidate = pickFirst2(ev, ["time", "createdAt", "payload.time"]) ?? entry?.time;
    const parsed = typeof timeCandidate === "string" ? Date.parse(timeCandidate) : NaN;
    return Number.isFinite(parsed) ? parsed : Date.now();
  }
  function extractGameMode(ev, entry) {
    return normalizeGameMode(
      pickFirst2(ev, [
        "payload.gameMode",
        "payload.competitiveGameMode",
        "gameMode",
        "competitiveGameMode",
        "mode"
      ]) ?? pickFirst2(entry, ["payload.gameMode", "payload.competitiveGameMode", "gameMode"])
    );
  }
  async function fetchFeedPage(paginationToken, ncfa) {
    const base = "https://www.geoguessr.com/api/v4/feed/private";
    const url = paginationToken ? `${base}?paginationToken=${encodeURIComponent(paginationToken)}` : base;
    const res = await httpGetJson(url, { ncfa });
    if (res.status < 200 || res.status >= 300) throw new Error(`Feed HTTP ${res.status}`);
    return res.data;
  }
  async function updateData(opts) {
    const maxPages = opts.maxPages ?? 5e3;
    const delayMs = opts.delayMs ?? 150;
    const detailConcurrency = opts.detailConcurrency ?? 4;
    const verifyCompleteness = opts.verifyCompleteness ?? true;
    const retryErrors = opts.retryErrors ?? true;
    const enrichLimit = opts.enrichLimit ?? 1500;
    const startedAt = Date.now();
    const meta = await db.meta.get("sync");
    const lastSeen = meta?.value?.lastSeenTime ? Number(meta?.value?.lastSeenTime) : null;
    let paginationToken;
    let feedPages = 0;
    let feedUpserted = 0;
    let detailsQueued = 0;
    let detailsOk = 0;
    let detailsFail = 0;
    let detailsSkipped = 0;
    const seenPaginationTokens = /* @__PURE__ */ new Set();
    opts.onStatus("Update started (feed + details)...");
    for (let page = 0; page < maxPages; page++) {
      feedPages = page + 1;
      opts.onStatus(`Fetching feed page ${page}...`);
      const data = await fetchFeedPage(paginationToken, opts.ncfa);
      const entries = Array.isArray(data?.entries) ? data.entries : [];
      if (entries.length === 0) {
        opts.onStatus(`Feed page ${page} empty. Stopping.`);
        break;
      }
      const pageRows = [];
      for (const entry of entries) {
        const evs = extractEvents(entry);
        for (const ev of evs) {
          const { gameId } = extractGameIdWithSource(ev);
          if (!gameId) continue;
          const playedAt = extractEventTimeMs(ev, entry);
          const gameMode = extractGameMode(ev, entry);
          const modeFamily = classifyModeFamilyFromEvent(ev, gameMode);
          pageRows.push({
            gameId,
            type: classifyTypeFromFamily(modeFamily),
            playedAt,
            mode: gameMode,
            gameMode,
            modeFamily,
            isTeamDuels: modeFamily === "teamduels",
            raw: ev
          });
        }
      }
      const byId = /* @__PURE__ */ new Map();
      for (const row of pageRows) {
        const prev = byId.get(row.gameId);
        if (!prev || row.playedAt > prev.playedAt) byId.set(row.gameId, row);
      }
      const deduped = [...byId.values()];
      if (deduped.length > 0) {
        await db.games.bulkPut(deduped);
        feedUpserted += deduped.length;
      }
      const newestOnPage = deduped.length > 0 ? deduped.reduce((m, g) => Math.max(m, g.playedAt), 0) : 0;
      const oldestOnPage = deduped.length > 0 ? deduped.reduce((m, g) => Math.min(m, g.playedAt), Number.POSITIVE_INFINITY) : Number.POSITIVE_INFINITY;
      const elapsed = Date.now() - startedAt;
      const newest = Math.max(Number(lastSeen || 0), newestOnPage || 0);
      await db.meta.put({ key: "sync", value: { lastSeenTime: newest }, updatedAt: Date.now() });
      if (deduped.length > 0) {
        const res = await fetchDetailsForGames({
          onStatus: (m) => opts.onStatus(`Page ${page} | ${m}`),
          games: deduped,
          concurrency: detailConcurrency,
          verifyCompleteness,
          retryErrors,
          ncfa: opts.ncfa,
          reason: `feed-page-${page}`
        });
        detailsQueued += res.queued;
        detailsOk += res.ok;
        detailsFail += res.fail;
        detailsSkipped += res.skipped;
      }
      let etaText = "ETA unknown";
      if (lastSeen && Number.isFinite(oldestOnPage) && newestOnPage > 0) {
        const covered = newestOnPage - oldestOnPage;
        const totalSpan = newestOnPage - lastSeen;
        const progress = totalSpan > 0 ? Math.max(0, Math.min(1, covered / totalSpan)) : 1;
        if (progress > 0) {
          const etaMs = elapsed * ((1 - progress) / progress);
          etaText = progress >= 0.999 ? "ETA ~0s" : `ETA ~${etaLabel2(etaMs)}`;
        }
      }
      opts.onStatus(
        `Feed page ${page}: upserted ${deduped.length} games (total ${feedUpserted}). Details queued ${detailsQueued}, ok ${detailsOk}, fail ${detailsFail}. ${etaText}`
      );
      paginationToken = typeof data?.paginationToken === "string" && data.paginationToken ? data.paginationToken : void 0;
      if (!paginationToken) {
        opts.onStatus("Feed has no pagination token. Stopping.");
        break;
      }
      if (seenPaginationTokens.has(paginationToken)) {
        opts.onStatus("Stopped sync due to repeated pagination token (loop protection).");
        break;
      }
      seenPaginationTokens.add(paginationToken);
      if (lastSeen && newestOnPage > 0 && newestOnPage <= lastSeen) {
        opts.onStatus(`Reached previously synced period (${new Date(lastSeen).toLocaleString()}).`);
        break;
      }
      await new Promise((r) => setTimeout(r, delayMs));
    }
    let enrichedQueued = 0;
    let enrichedOk = 0;
    let enrichedFail = 0;
    let enrichedSkipped = 0;
    if (enrichLimit > 0) {
      opts.onStatus(`Enriching existing details (limit ${enrichLimit})...`);
      const recentDetails = await db.details.orderBy("fetchedAt").reverse().limit(enrichLimit).toArray();
      const needIds = recentDetails.filter((d) => d?.status === "ok").filter((d) => {
        const missSlug = typeof d?.mapSlug !== "string" || !d.mapSlug.trim();
        const missName = typeof d?.mapName !== "string" || !d.mapName.trim();
        const missRated = typeof d?.isRated !== "boolean";
        return missSlug || missName || missRated;
      }).map((d) => d.gameId).filter((x) => typeof x === "string" && x);
      if (needIds.length > 0) {
        const games = (await db.games.bulkGet(needIds)).filter((g) => !!g);
        const res = await fetchDetailsForGames({
          onStatus: (m) => opts.onStatus(`Enrich | ${m}`),
          games,
          concurrency: detailConcurrency,
          verifyCompleteness: false,
          retryErrors,
          ncfa: opts.ncfa,
          reason: "enrich-missing-fields"
        });
        enrichedQueued = res.queued;
        enrichedOk = res.ok;
        enrichedFail = res.fail;
        enrichedSkipped = res.skipped;
      } else {
        opts.onStatus("No existing details need enrichment.");
      }
    }
    opts.onStatus("Update complete.");
    return {
      feedPages,
      feedUpserted,
      detailsQueued,
      detailsOk,
      detailsFail,
      detailsSkipped,
      enrichedQueued,
      enrichedOk,
      enrichedFail,
      enrichedSkipped
    };
  }

  // src/migrations/normalizeLegacyRounds.ts
  function hasAnyKeyPrefix(obj, prefix) {
    if (!obj || typeof obj !== "object") return false;
    for (const k of Object.keys(obj)) {
      if (k.startsWith(prefix)) return true;
    }
    return false;
  }
  function inferLegacyModeFamily(r) {
    const mf = String(r?.modeFamily ?? "").toLowerCase();
    if (mf === "teamduels") return "teamduels";
    if (mf === "duels") return "duels";
    if (hasAnyKeyPrefix(r, "p3_") || hasAnyKeyPrefix(r, "p4_")) return "teamduels";
    return "duels";
  }
  function copyIfMissing(dst, dstKey, src, srcKey) {
    if (!dst || !src) return false;
    if (dst[dstKey] !== void 0 && dst[dstKey] !== null) return false;
    const v = src[srcKey];
    if (v === void 0 || v === null) return false;
    dst[dstKey] = v;
    return true;
  }
  function copyMetersToKmIfMissing(dst, dstKey, src, metersKey) {
    if (!dst || !src) return false;
    if (dst[dstKey] !== void 0 && dst[dstKey] !== null) return false;
    const m = src[metersKey];
    if (typeof m !== "number" || !Number.isFinite(m)) return false;
    dst[dstKey] = m / 1e3;
    return true;
  }
  function normalizeLegacyPlayerBlock(dst, src, legacyPrefix, role) {
    let changed = false;
    changed = copyIfMissing(dst, `${role}_playerId`, src, `${legacyPrefix}_playerId`) || changed;
    changed = copyIfMissing(dst, `${role}_teamId`, src, `${legacyPrefix}_teamId`) || changed;
    changed = copyIfMissing(dst, `${role}_guessLat`, src, `${legacyPrefix}_guessLat`) || changed;
    changed = copyIfMissing(dst, `${role}_guessLng`, src, `${legacyPrefix}_guessLng`) || changed;
    changed = copyIfMissing(dst, `${role}_guessCountry`, src, `${legacyPrefix}_guessCountry`) || changed;
    changed = copyIfMissing(dst, `${role}_score`, src, `${legacyPrefix}_score`) || changed;
    changed = copyIfMissing(dst, `${role}_healthAfter`, src, `${legacyPrefix}_healthAfter`) || changed;
    changed = copyIfMissing(dst, `${role}_isBestGuess`, src, `${legacyPrefix}_isBestGuess`) || changed;
    changed = copyIfMissing(dst, `${role}_distanceKm`, src, `${legacyPrefix}_distanceKm`) || changed;
    changed = copyMetersToKmIfMissing(dst, `${role}_distanceKm`, src, `${legacyPrefix}_distanceMeters`) || changed;
    return changed;
  }
  function normalizeLegacyRoundRow(r) {
    if (!r || typeof r !== "object") return null;
    if (!hasAnyKeyPrefix(r, "p1_")) return null;
    const out = { ...r };
    let changed = false;
    const family = inferLegacyModeFamily(r);
    if (family === "duels") {
      changed = normalizeLegacyPlayerBlock(out, r, "p1", "player_self") || changed;
      changed = normalizeLegacyPlayerBlock(out, r, "p2", "player_opponent") || changed;
    } else {
      changed = normalizeLegacyPlayerBlock(out, r, "p1", "player_self") || changed;
      changed = normalizeLegacyPlayerBlock(out, r, "p2", "player_mate") || changed;
      changed = normalizeLegacyPlayerBlock(out, r, "p3", "player_opponent") || changed;
      changed = normalizeLegacyPlayerBlock(out, r, "p4", "player_opponent_mate") || changed;
    }
    return changed ? out : null;
  }
  async function normalizeLegacyRounds(opts) {
    const onStatus = opts.onStatus ?? (() => {
    });
    const batchSize = opts.batchSize ?? 500;
    const metaKey = "migration_legacy_rounds_v1";
    if (!opts.force) {
      const meta = await db.meta.get(metaKey);
      const doneAt = meta?.value?.doneAt;
      if (typeof doneAt === "number" && Number.isFinite(doneAt) && Date.now() - doneAt < 12 * 60 * 60 * 1e3) {
        return { scanned: 0, updated: 0 };
      }
    }
    const total = await db.rounds.count();
    let scanned = 0;
    let updated = 0;
    onStatus(`Normalizing legacy rounds... (0/${total})`);
    for (let offset = 0; offset < total; offset += batchSize) {
      const chunk = await db.rounds.offset(offset).limit(batchSize).toArray();
      scanned += chunk.length;
      const patch = [];
      for (const r of chunk) {
        const normalized = normalizeLegacyRoundRow(r);
        if (normalized) {
          patch.push(normalized);
        }
      }
      if (patch.length > 0) {
        await db.rounds.bulkPut(patch);
        updated += patch.length;
      }
      if (scanned % (batchSize * 5) === 0 || scanned === total) {
        onStatus(`Normalizing legacy rounds... (${scanned}/${total}, updated ${updated})`);
      }
    }
    await db.meta.put({
      key: metaKey,
      value: { doneAt: Date.now(), scanned, updated },
      updatedAt: Date.now()
    });
    return { scanned, updated };
  }

  // src/engine/fieldAccess.ts
  function legacy(obj, ...keys2) {
    for (const key of keys2) {
      if (obj && obj[key] !== void 0 && obj[key] !== null) return obj[key];
    }
    return void 0;
  }
  function getSelfScore(r) {
    const mf = String(r?.modeFamily ?? "").trim().toLowerCase();
    const selfRaw = legacy(r, "player_self_score", "p1_score", "score");
    const self2 = typeof selfRaw === "number" ? selfRaw : void 0;
    if (mf === "teamduels") {
      const mateRaw = legacy(r, "player_mate_score", "p2_score");
      const mate = typeof mateRaw === "number" ? mateRaw : void 0;
      const selfBest = legacy(r, "player_self_isBestGuess", "p1_isBestGuess");
      const mateBest = legacy(r, "player_mate_isBestGuess", "p2_isBestGuess");
      if (mateBest === true && selfBest !== true && typeof mate === "number") return mate;
      if (selfBest === true && mateBest !== true && typeof self2 === "number") return self2;
      if (typeof self2 === "number" && typeof mate === "number") return Math.max(self2, mate);
      if (typeof mate === "number") return mate;
    }
    return typeof self2 === "number" ? self2 : void 0;
  }
  function getPlayedAt(r) {
    return r.playedAt;
  }
  function getTrueCountry(r) {
    return r.trueCountry ?? r.true_country;
  }
  function getMovementType(r) {
    const v = r.movementType ?? r.movement_type;
    return typeof v === "string" ? v : void 0;
  }
  function getDurationSeconds(r) {
    const v = legacy(r, "durationSeconds", "guessDurationSec", "timeSec");
    return typeof v === "number" ? v : void 0;
  }
  function getDistanceKm(r) {
    const v = legacy(r, "distanceKm", "player_self_distanceKm", "p1_distanceKm");
    return typeof v === "number" ? v : void 0;
  }
  function getMateScore(r) {
    const v = legacy(r, "player_mate_score", "p2_score");
    return typeof v === "number" ? v : void 0;
  }
  function getMateDistanceKm(r) {
    const v = legacy(r, "player_mate_distanceKm", "p2_distanceKm");
    return typeof v === "number" ? v : void 0;
  }
  function getTeammateName(r) {
    const v = legacy(r, "teammateName", "player_mate_name");
    return typeof v === "string" ? v : void 0;
  }
  function getGuessCountrySelf(r) {
    const v = legacy(r, "player_self_guessCountry", "p1_guessCountry", "guessCountry");
    return typeof v === "string" ? v : void 0;
  }
  function pick(obj, key) {
    if (!obj) return void 0;
    if (key in obj) return obj[key];
    const camel = key.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
    if (camel in obj) return obj[camel];
    const snake = key.replace(/[A-Z]/g, (c) => `_${c.toLowerCase()}`);
    if (snake in obj) return obj[snake];
    return void 0;
  }
  function pickWithAliases(obj, logicalKey, columnAliases) {
    const aliases = columnAliases?.[logicalKey] ?? [];
    const probeOrder = [logicalKey, ...aliases];
    for (const candidate of probeOrder) {
      const value = pick(obj, candidate);
      if (value !== void 0 && value !== null) return value;
    }
    return void 0;
  }

  // src/engine/dimensions.ts
  function getRowTs(row) {
    const a = row?.playedAt;
    if (typeof a === "number" && Number.isFinite(a)) return a;
    const b = row?.ts;
    if (typeof b === "number" && Number.isFinite(b)) return b;
    return void 0;
  }
  function scoreBucketKey(r) {
    const s = getSelfScore(r);
    if (typeof s !== "number") return null;
    if (s >= 5e3) return "5000";
    const lo = Math.max(0, Math.floor(s / 100) * 100);
    const hi = lo + 99;
    return `${lo}-${hi}`;
  }
  function timeDayKey(r) {
    const ts = getPlayedAt(r);
    if (typeof ts !== "number") return null;
    const d = new Date(ts);
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`;
  }
  function weekdayKey(r) {
    const ts = getPlayedAt(r);
    if (typeof ts !== "number") return null;
    const names = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    return names[new Date(ts).getDay()];
  }
  function hourKey(r) {
    const ts = getPlayedAt(r);
    if (typeof ts !== "number") return null;
    return String(new Date(ts).getHours()).padStart(2, "0");
  }
  function trueCountryKey(r) {
    const c = getTrueCountry(r);
    return typeof c === "string" && c.length ? c : null;
  }
  function movementTypeKey(r) {
    const v = getMovementType(r);
    return typeof v === "string" && v.length ? v : null;
  }
  function isHitKey(r) {
    const truth = getTrueCountry(r);
    if (!truth) return null;
    const guess = getGuessCountrySelf(r);
    return typeof guess === "string" && guess === truth ? "true" : "false";
  }
  function isThrowKey(r) {
    const s = getSelfScore(r);
    if (typeof s !== "number") return null;
    return s < 50 ? "true" : "false";
  }
  function isDamageDealtKey(r) {
    const dmg = r?.damage;
    if (typeof dmg !== "number" || !Number.isFinite(dmg)) return null;
    return dmg > 0 ? "true" : "false";
  }
  function isDamageTakenKey(r) {
    const dmg = r?.damage;
    if (typeof dmg !== "number" || !Number.isFinite(dmg)) return null;
    return dmg < 0 ? "true" : "false";
  }
  function durationBucketKey(r) {
    const s = getDurationSeconds(r);
    if (typeof s !== "number" || !Number.isFinite(s) || s < 0) return null;
    if (s < 20) return "<20 sec";
    if (s < 30) return "20-30 sec";
    if (s < 45) return "30-45 sec";
    if (s < 60) return "45-60 sec";
    if (s < 90) return "60-90 sec";
    if (s < 180) return "90-180 sec";
    return ">180 sec";
  }
  function teammateNameKey(r) {
    const n = getTeammateName(r);
    const v = typeof n === "string" ? n.trim() : "";
    return v.length ? v : null;
  }
  function confusedCountriesKey(r) {
    const truthRaw = getTrueCountry(r);
    const guessRaw = getGuessCountrySelf(r);
    if (typeof truthRaw !== "string" || typeof guessRaw !== "string") return null;
    const truth = truthRaw.trim();
    const guess = guessRaw.trim();
    if (!truth || !guess) return null;
    if (truth === guess) return null;
    const pretty = (v) => v.length <= 3 ? v.toUpperCase() : v;
    return `${pretty(truth)} -> ${pretty(guess)}`;
  }
  function timeDayKeyAny(row) {
    const ts = getRowTs(row);
    if (typeof ts !== "number") return null;
    const d = new Date(ts);
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`;
  }
  function weekdayKeyAny(row) {
    const ts = getRowTs(row);
    if (typeof ts !== "number") return null;
    const names = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    return names[new Date(ts).getDay()];
  }
  function hourKeyAny(row) {
    const ts = getRowTs(row);
    if (typeof ts !== "number") return null;
    return String(new Date(ts).getHours()).padStart(2, "0");
  }
  function asTrimmedString(v) {
    const s = typeof v === "string" ? v.trim() : "";
    return s ? s : void 0;
  }
  function gameModeKeyAny(row) {
    const v = asTrimmedString(row?.gameModeSimple ?? row?.gameMode ?? row?.mode ?? row?.game_mode);
    return v ? v : null;
  }
  function modeFamilyKeyAny(row) {
    const v = asTrimmedString(row?.modeFamily ?? row?.mode_family);
    if (!v) return null;
    if (v === "duels") return "Duel";
    if (v === "teamduels") return "Team Duel";
    if (v === "standard") return "Standard";
    if (v === "streak") return "Streak";
    return v;
  }
  function resultKeyAny(row) {
    const r = asTrimmedString(row?.result);
    if (r) return r;
    const v = typeof row?.player_self_victory === "boolean" ? row.player_self_victory : typeof row?.teamOneVictory === "boolean" ? row.teamOneVictory : typeof row?.playerOneVictory === "boolean" ? row.playerOneVictory : void 0;
    if (typeof v === "boolean") return v ? "Win" : "Loss";
    return null;
  }
  function isFlawlessWinKeyAny(row) {
    const v = row?.isFlawlessWin;
    if (typeof v === "boolean") return v ? "true" : "false";
    return null;
  }
  function mapSlugKeyAny(row) {
    const direct = asTrimmedString(row?.mapSlug ?? row?.map_slug);
    if (direct) return direct;
    const raw = row?.raw;
    const v = asTrimmedString(raw?.options?.map?.slug ?? raw?.mapSlug ?? raw?.map?.slug);
    return v ? v : null;
  }
  function mapNameKeyAny(row) {
    const direct = asTrimmedString(row?.mapName ?? row?.map_name);
    if (direct) return direct;
    const raw = row?.raw;
    const v = asTrimmedString(raw?.options?.map?.name ?? raw?.mapName ?? raw?.map?.name);
    return v ? v : null;
  }
  function isRatedKeyAny(row) {
    const direct = row?.isRated;
    if (direct === true) return "Rated";
    if (direct === false) return "Unrated";
    const raw = row?.raw;
    const v = raw?.options?.isRated;
    if (v === true) return "Rated";
    if (v === false) return "Unrated";
    const a = row?.player_self_startRating;
    const b = row?.player_self_endRating;
    if (typeof a === "number" && Number.isFinite(a) && typeof b === "number" && Number.isFinite(b)) return "Rated";
    return "Unknown";
  }
  function teammateKeyAny(row) {
    const v = asTrimmedString(row?.teammateName ?? row?.teammate_name ?? row?.player_mate_name);
    return v ? v : null;
  }
  function movementTypeKeyAny(row) {
    const v = asTrimmedString(row?.movementType ?? row?.movement_type ?? row?.gameModeSimple ?? row?.gameMode);
    if (!v) return null;
    const k = v.toLowerCase();
    if (k.includes("nmpz")) return "nmpz";
    if (k.includes("no move") || k.includes("no_move") || k.includes("nomove") || k.includes("no moving")) return "no_move";
    if (k.includes("moving")) return "moving";
    return v;
  }
  function guessCountryKey(r) {
    const guess = getGuessCountrySelf(r);
    const v = typeof guess === "string" ? guess.trim() : "";
    return v.length ? v : null;
  }
  function mateLabel(r) {
    const n = getTeammateName(r);
    const v = typeof n === "string" ? n.trim() : "";
    return v.length ? v : "Mate";
  }
  function winnerLabelForCompare(r, a, b, prefer) {
    if (typeof a !== "number" || !Number.isFinite(a) || typeof b !== "number" || !Number.isFinite(b)) return null;
    if (a === b) return "Tie";
    const youWin = prefer === "min" ? a < b : a > b;
    return youWin ? "You" : mateLabel(r);
  }
  var DIMENSION_EXTRACTORS = {
    round: {
      score_bucket: scoreBucketKey,
      round_id: (r) => {
        const gid = typeof r?.gameId === "string" ? r.gameId : "";
        const rn = typeof r?.roundNumber === "number" ? r.roundNumber : null;
        if (!gid || rn === null) return null;
        return `${gid}#${rn}`;
      },
      time_day: timeDayKey,
      weekday: weekdayKey,
      hour: hourKey,
      game_id: (r) => typeof r?.gameId === "string" && r.gameId.trim().length ? r.gameId : null,
      true_country: trueCountryKey,
      movement_type: movementTypeKey,
      is_hit: isHitKey,
      is_throw: isThrowKey,
      is_damage_dealt: isDamageDealtKey,
      is_damage_taken: isDamageTakenKey,
      is_near_perfect: (r) => {
        const s = getSelfScore(r);
        if (typeof s !== "number") return null;
        return s >= 4500 ? "true" : "false";
      },
      is_low_score: (r) => {
        const s = getSelfScore(r);
        if (typeof s !== "number") return null;
        return s < 500 ? "true" : "false";
      },
      duration_bucket: durationBucketKey,
      confused_countries: confusedCountriesKey,
      guess_country: guessCountryKey,
      teammate_name: teammateNameKey,
      map_slug: mapSlugKeyAny,
      map_name: mapNameKeyAny,
      is_rated: isRatedKeyAny,
      mode_family: (r) => {
        const v = typeof r?.modeFamily === "string" ? String(r.modeFamily).trim().toLowerCase() : "";
        if (!v) return null;
        if (v === "duels") return "Duel";
        if (v === "teamduels") return "Team Duel";
        return v;
      },
      team_closer_winner: (r) => winnerLabelForCompare(r, getDistanceKm(r), getMateDistanceKm(r), "min"),
      team_higher_score_winner: (r) => winnerLabelForCompare(r, getSelfScore(r), getMateScore(r), "max"),
      team_fewer_throw_winner: (r) => {
        const a = getSelfScore(r);
        const b = getMateScore(r);
        if (typeof a !== "number" || typeof b !== "number") return null;
        const aThrow = a < 50;
        const bThrow = b < 50;
        if (aThrow === bThrow) return "Tie";
        return aThrow ? mateLabel(r) : "You";
      },
      team_more_5k_winner: (r) => {
        const a = getSelfScore(r);
        const b = getMateScore(r);
        if (typeof a !== "number" || typeof b !== "number") return null;
        const a5 = a >= 5e3;
        const b5 = b >= 5e3;
        if (a5 === b5) return "Tie";
        return a5 ? "You" : mateLabel(r);
      },
      round_number: (r) => typeof r?.roundNumber === "number" ? `#${r.roundNumber}` : null
    },
    game: {
      time_day: timeDayKeyAny,
      weekday: weekdayKeyAny,
      hour: hourKeyAny,
      game_id: (g) => typeof g?.gameId === "string" && g.gameId.trim().length ? g.gameId : null,
      opponent_name: (g) => {
        const s = typeof g?.opponentName === "string" ? g.opponentName.trim() : "";
        return s ? s : null;
      },
      opponent_country: (g) => {
        const s = typeof g?.opponentCountry === "string" ? g.opponentCountry.trim() : "";
        return s ? s : null;
      },
      movement_type: movementTypeKeyAny,
      teammate_name: teammateKeyAny,
      map_slug: mapSlugKeyAny,
      map_name: mapNameKeyAny,
      is_rated: isRatedKeyAny,
      game_mode: gameModeKeyAny,
      mode_family: modeFamilyKeyAny,
      result: resultKeyAny,
      is_flawless_win: isFlawlessWinKeyAny,
      game_length: (g) => {
        const n = g.roundsCount;
        if (typeof n !== "number" || !Number.isFinite(n)) return null;
        if (n < 2) return null;
        return String(Math.round(n));
      }
    },
    session: {
      time_day: (row) => {
        const ts = typeof row?.sessionStartTs === "number" ? row.sessionStartTs : typeof row?.ts === "number" ? row.ts : null;
        if (typeof ts !== "number" || !Number.isFinite(ts)) return null;
        const d = new Date(ts);
        return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`;
      },
      session_index: (row) => typeof row?.sessionIndex === "number" ? String(row.sessionIndex) : null,
      session_start: (row) => {
        const ts = typeof row?.sessionStartTs === "number" ? row.sessionStartTs : typeof row?.ts === "number" ? row.ts : null;
        if (typeof ts !== "number" || !Number.isFinite(ts)) return null;
        const d = new Date(ts);
        const day = String(d.getDate()).padStart(2, "0");
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const y = d.getFullYear();
        const hh = String(d.getHours()).padStart(2, "0");
        const mm = String(d.getMinutes()).padStart(2, "0");
        return `${day}/${m}/${y} ${hh}:${mm}`;
      }
    }
  };
  var ROUND_DIMENSION_EXTRACTORS = DIMENSION_EXTRACTORS.round;

  // src/engine/filters.ts
  function evalClause(value, clause) {
    if (clause.op === "eq") return value === clause.value;
    if (clause.op === "neq") return value !== clause.value;
    if (clause.op === "in") return Array.isArray(clause.values) && clause.values.includes(value);
    if (clause.op === "nin") return Array.isArray(clause.values) && !clause.values.includes(value);
    return true;
  }
  function evalRowFilter(row, clause, grain) {
    const extractor = DIMENSION_EXTRACTORS[grain]?.[clause.dimension];
    if (extractor) {
      return evalClause(extractor(row), clause);
    }
    const direct = row[clause.dimension];
    return evalClause(direct, clause);
  }
  function applyFilters(rows, clauses, grain = "round") {
    if (!clauses || clauses.length === 0) return rows;
    return rows.filter((row) => clauses.every((clause) => evalRowFilter(row, clause, grain)));
  }

  // src/engine/globalFilters.ts
  function normalizeAllString(value) {
    if (value === "all") return null;
    if (typeof value !== "string") return null;
    const v = value.trim();
    return v.length ? v : null;
  }
  function normalizeDateRange(value) {
    if (!value || typeof value !== "object") return { fromTs: null, toTs: null };
    const v = value;
    const fromRaw = v.fromTs === null ? null : Number(v.fromTs);
    const toRaw = v.toTs === null ? null : Number(v.toTs);
    return {
      fromTs: Number.isFinite(fromRaw) ? fromRaw : null,
      toTs: Number.isFinite(toRaw) ? toRaw : null
    };
  }
  function buildAppliedFilters(spec, state, grain, controlIds) {
    const out = { clauses: [] };
    if (!spec?.enabled) return out;
    const allowed = Array.isArray(controlIds) && controlIds.length > 0 ? new Set(controlIds) : null;
    let teammateSelected = null;
    for (const control of spec.controls) {
      if (allowed && !allowed.has(control.id)) continue;
      if (!control.appliesTo.includes(grain)) continue;
      if (control.type === "date_range") {
        const c = control;
        const val = normalizeDateRange(state[c.id] ?? c.default);
        out.date = val;
        continue;
      }
      if (control.type === "select") {
        const c = control;
        const selected = normalizeAllString(state[c.id] ?? c.default);
        if (!selected) continue;
        out.clauses.push({ dimension: c.dimension, op: "eq", value: selected });
        if (c.dimension === "teammate_name") teammateSelected = selected;
        continue;
      }
    }
    if (teammateSelected) {
      const forced = "Team Duel";
      const hasModeClause = out.clauses.some((cl) => cl.dimension === "mode_family");
      const isAlreadyForced = hasModeClause && out.clauses.some((cl) => cl.dimension === "mode_family" && cl.op === "eq" && cl.value === forced);
      if (!isAlreadyForced) {
        out.clauses = out.clauses.filter((cl) => cl.dimension !== "mode_family");
        out.clauses.push({ dimension: "mode_family", op: "eq", value: forced });
      }
    }
    return out;
  }
  function normalizeGlobalFilterKey(spec, state, grain = "round", controlIds) {
    if (!spec?.enabled) return `gf:${grain}:off`;
    const parts = [];
    const allowed = Array.isArray(controlIds) && controlIds.length > 0 ? new Set(controlIds) : null;
    for (const c of spec.controls) {
      if (allowed && !allowed.has(c.id)) continue;
      const v = state[c.id];
      parts.push(`${c.id}=${JSON.stringify(v)}`);
    }
    return `gf:${grain}:${parts.join("|")}`;
  }

  // src/engine/queryEngine.ts
  function normalizeMovementType(raw) {
    if (typeof raw !== "string") return "unknown";
    const s = raw.trim().toLowerCase();
    if (!s) return "unknown";
    if (s.includes("nmpz")) return "nmpz";
    if (s.includes("no move") || s.includes("no_move") || s.includes("nomove") || s.includes("no moving")) return "no_move";
    if (s.includes("moving")) return "moving";
    return "unknown";
  }
  function asTrimmedString2(v) {
    const s = typeof v === "string" ? v.trim() : "";
    return s ? s : void 0;
  }
  function pickFirst3(obj, keys2) {
    for (const k of keys2) {
      if (!obj) continue;
      const v = obj[k];
      if (v !== void 0 && v !== null) return v;
    }
    return void 0;
  }
  var roundsRawCache = null;
  var roundsFilteredCache = /* @__PURE__ */ new Map();
  var gamesRawCache = null;
  var gamesFilteredCache = /* @__PURE__ */ new Map();
  var sessionsRawCache = null;
  var sessionsFilteredCache = /* @__PURE__ */ new Map();
  function invalidateRoundsCache() {
    roundsRawCache = null;
    roundsFilteredCache.clear();
    gamesRawCache = null;
    gamesFilteredCache.clear();
    sessionsRawCache = null;
    sessionsFilteredCache.clear();
  }
  async function hasAnyTeamDuels() {
    const byFamily = await db.games.where("modeFamily").equals("teamduels").count();
    if (byFamily > 0) return true;
    const byFlag = await db.games.where("isTeamDuels").equals(true).count();
    return byFlag > 0;
  }
  function buildSessionsFromRounds(rounds, gapMinutes) {
    const byGame = /* @__PURE__ */ new Map();
    for (const r of rounds) {
      const gid = typeof r.gameId === "string" ? r.gameId : "";
      if (!gid) continue;
      const arr = byGame.get(gid) ?? [];
      arr.push(r);
      byGame.set(gid, arr);
    }
    const games = Array.from(byGame.entries()).map(([gameId, rows]) => {
      const times = rows.map((x) => typeof x.playedAt === "number" ? x.playedAt : typeof x.ts === "number" ? x.ts : null).filter((t) => typeof t === "number" && Number.isFinite(t));
      const ts = times.length ? Math.min(...times) : null;
      const endTs = times.length ? Math.max(...times) : null;
      return ts === null || endTs === null ? null : { gameId, ts, endTs, rows };
    }).filter((x) => !!x).sort((a, b) => a.ts - b.ts);
    if (games.length === 0) return [];
    const gapMs = Math.max(1, Math.floor(gapMinutes * 60 * 1e3));
    const sessions = [];
    let curGames = [];
    const flush = () => {
      if (curGames.length === 0) return;
      const start = curGames[0].ts;
      const end = Math.max(...curGames.map((g) => g.endTs));
      const sessionId = `s${sessions.length + 1}`;
      const sessionIndex = sessions.length + 1;
      const allRounds = curGames.flatMap((g) => g.rows);
      const gameIdSet = new Set(curGames.map((g) => g.gameId));
      const gameIds = Array.from(gameIdSet.values());
      let scoreSum = 0, scoreCount = 0;
      let hitScoreSum = 0, hitScoreCount = 0;
      let durationSum = 0, durationCount = 0;
      let distanceSum = 0, distanceCount = 0;
      let fivekCount = 0, hitCount = 0, throwCount = 0;
      for (const r of allRounds) {
        const s = r.player_self_score;
        if (typeof s === "number" && Number.isFinite(s)) {
          scoreSum += s;
          scoreCount++;
          if (s >= 5e3) fivekCount++;
          if (s < 50) throwCount++;
        }
        const truth = r.trueCountry ?? r.true_country;
        const guess = r.player_self_guessCountry ?? r.p1_guessCountry ?? r.guessCountry;
        const isHit2 = typeof truth === "string" && truth && typeof guess === "string" && guess === truth;
        if (isHit2) {
          hitCount++;
          if (typeof s === "number" && Number.isFinite(s)) {
            hitScoreSum += s;
            hitScoreCount++;
          }
        }
        const dur = r.durationSeconds;
        if (typeof dur === "number" && Number.isFinite(dur) && dur >= 0) {
          durationSum += dur;
          durationCount++;
        }
        const dist = r.distanceKm;
        if (typeof dist === "number" && Number.isFinite(dist) && dist >= 0) {
          distanceSum += dist;
          distanceCount++;
        }
      }
      sessions.push({
        sessionId,
        sessionIndex,
        sessionStartTs: start,
        sessionEndTs: end,
        ts: start,
        gamesCount: gameIdSet.size,
        roundsCount: allRounds.length,
        scoreSum,
        scoreCount,
        hitScoreSum,
        hitScoreCount,
        durationSum,
        durationCount,
        distanceSum,
        distanceCount,
        fivekCount,
        hitCount,
        throwCount,
        gameIds,
        rounds: allRounds
      });
      curGames = [];
    };
    for (const g of games) {
      if (curGames.length === 0) {
        curGames.push(g);
        continue;
      }
      const prevEnd = Math.max(...curGames.map((x) => x.endTs));
      if (g.ts - prevEnd > gapMs) {
        flush();
        curGames.push(g);
      } else {
        curGames.push(g);
      }
    }
    flush();
    return sessions;
  }
  function pickGameTs(g) {
    const ts = typeof g?.ts === "number" ? g.ts : typeof g?.playedAt === "number" ? g.playedAt : null;
    return typeof ts === "number" && Number.isFinite(ts) ? ts : null;
  }
  function extractGameRatings(g) {
    const mfRaw = asTrimmedString2(g?.modeFamily ?? g?.mode_family) ?? "";
    const mf = mfRaw.toLowerCase();
    const isTeam = g?.isTeamDuels === true || mf === "teamduels" || mf.includes("team") && mf.includes("duel");
    const pickNum = (keys2) => {
      const v = pickFirst3(g, keys2);
      return typeof v === "number" && Number.isFinite(v) ? v : void 0;
    };
    if (isTeam) {
      const start2 = pickNum(["teamOneStartRating", "player_self_startRating", "playerOneStartRating", "team1StartRating"]);
      const end2 = pickNum(["teamOneEndRating", "player_self_endRating", "playerOneEndRating", "team1EndRating"]);
      return { start: start2, end: end2 };
    }
    const start = pickNum(["player_self_startRating", "playerOneStartRating"]);
    const end = pickNum(["player_self_endRating", "playerOneEndRating"]);
    return { start, end };
  }
  function getGameOutcome(g) {
    const v = typeof g?.player_self_victory === "boolean" ? g.player_self_victory : typeof g?.teamOneVictory === "boolean" ? g.teamOneVictory : typeof g?.playerOneVictory === "boolean" ? g.playerOneVictory : void 0;
    if (typeof v === "boolean") return v ? "win" : "loss";
    const r = g?.result;
    const s = typeof r === "string" ? r.trim().toLowerCase() : "";
    if (!s) return null;
    if (s === "win" || s === "w" || s === "true") return "win";
    if (s === "loss" || s === "l" || s === "false") return "loss";
    if (s === "tie" || s === "t" || s === "draw") return "tie";
    return null;
  }
  async function attachRatingsToSessions(sessions) {
    if (!sessions.length) return sessions;
    const games = await getGamesRaw();
    const byId = /* @__PURE__ */ new Map();
    for (const g of games) {
      const id = typeof g?.gameId === "string" ? g.gameId : "";
      if (id) byId.set(id, g);
    }
    for (const s of sessions) {
      const ids = Array.isArray(s.gameIds) ? s.gameIds : [];
      const gs = ids.map((id) => byId.get(id)).filter(Boolean);
      if (!gs.length) continue;
      const sorted = [...gs].sort((a, b) => (pickGameTs(a) ?? 0) - (pickGameTs(b) ?? 0));
      let firstRating;
      let lastRating;
      let prevEnd;
      let deltaSum = 0;
      let haveDelta = false;
      let winCount = 0;
      let lossCount = 0;
      let tieCount = 0;
      let gamesWithOutcome = 0;
      for (const g of sorted) {
        const outcome = getGameOutcome(g);
        if (outcome) {
          gamesWithOutcome++;
          if (outcome === "win") winCount++;
          else if (outcome === "loss") lossCount++;
          else tieCount++;
        }
        const r = extractGameRatings(g);
        const start = typeof r.start === "number" && Number.isFinite(r.start) ? r.start : void 0;
        const end = typeof r.end === "number" && Number.isFinite(r.end) ? r.end : void 0;
        const startEff = start ?? prevEnd ?? end;
        if (firstRating === void 0 && typeof startEff === "number" && Number.isFinite(startEff)) firstRating = startEff;
        if (typeof end === "number" && Number.isFinite(end)) {
          lastRating = end;
          prevEnd = end;
        }
        if (typeof startEff === "number" && Number.isFinite(startEff) && typeof end === "number" && Number.isFinite(end)) {
          deltaSum += end - startEff;
          haveDelta = true;
        }
      }
      if (typeof firstRating === "number" && typeof lastRating === "number") {
        s.ratingStart = firstRating;
        s.ratingEnd = lastRating;
        s.ratingDelta = lastRating - firstRating;
      } else if (haveDelta) {
        s.ratingDelta = deltaSum;
      }
      if (gamesWithOutcome > 0) {
        s.winCount = winCount;
        s.lossCount = lossCount;
        s.tieCount = tieCount;
        s.gamesWithOutcome = gamesWithOutcome;
      }
    }
    return sessions;
  }
  async function getSessionsRaw(gapMinutes) {
    if (sessionsRawCache) return sessionsRawCache;
    const rounds = await getRoundsRaw();
    const sessions = buildSessionsFromRounds(rounds, gapMinutes);
    sessionsRawCache = await attachRatingsToSessions(sessions);
    return sessionsRawCache;
  }
  async function getSessions(filters, opts) {
    const gf = filters?.global;
    const spec = gf?.spec;
    const state = gf?.state ?? {};
    const controlIds = gf?.controlIds;
    const gapMinutes = typeof gf?.sessionGapMinutes === "number" && Number.isFinite(gf.sessionGapMinutes) ? gf.sessionGapMinutes : 45;
    const key = normalizeGlobalFilterKey(spec, state, "session", controlIds) + `|gap=${gapMinutes}`;
    const cached = sessionsFilteredCache.get(key);
    if (cached) return cached;
    const raw = opts?.rounds ? await attachRatingsToSessions(buildSessionsFromRounds(opts.rounds, gapMinutes)) : await getSessionsRaw(gapMinutes);
    const applied = buildAppliedFilters(spec, state, "session", controlIds);
    let rows = raw;
    if (applied.date) {
      const fromTs = applied.date.fromTs ?? null;
      const toTs2 = applied.date.toTs ?? null;
      if (fromTs !== null) rows = rows.filter((r) => typeof r.sessionStartTs === "number" && r.sessionStartTs >= fromTs);
      if (toTs2 !== null) rows = rows.filter((r) => typeof r.sessionStartTs === "number" && r.sessionStartTs <= toTs2);
    }
    rows = applyFilters(rows, applied.clauses, "session");
    sessionsFilteredCache.set(key, rows);
    return rows;
  }
  async function getGamePlayedAtBounds() {
    const isInvalidKeyRangeError = (e) => {
      const any = e;
      const name = typeof any?.name === "string" ? any.name : "";
      const message = typeof any?.message === "string" ? any.message : "";
      if (name === "DataError" && message.toLowerCase().includes("idbkeyrange")) return true;
      return message.includes("IDBKeyRange") && message.toLowerCase().includes("valid key");
    };
    try {
      const first = await db.games.orderBy("playedAt").first();
      const last = await db.games.orderBy("playedAt").last();
      const minTs = first && typeof first.playedAt === "number" ? first.playedAt : null;
      const maxTs = last && typeof last.playedAt === "number" ? last.playedAt : null;
      return { minTs, maxTs };
    } catch (e) {
      if (!isInvalidKeyRangeError(e)) throw e;
      const games = await db.games.toArray();
      let minTs = null;
      let maxTs = null;
      for (const g of games) {
        const ts = typeof g?.playedAt === "number" && Number.isFinite(g.playedAt) ? g.playedAt : null;
        if (ts === null) continue;
        minTs = minTs === null ? ts : Math.min(minTs, ts);
        maxTs = maxTs === null ? ts : Math.max(maxTs, ts);
      }
      return { minTs, maxTs };
    }
  }
  async function getRoundsRaw() {
    if (roundsRawCache) return roundsRawCache;
    const [rows, games, details] = await Promise.all([db.rounds.toArray(), db.games.toArray(), db.details.toArray()]);
    const playedAtByGame = /* @__PURE__ */ new Map();
    const modeFamilyByGame = /* @__PURE__ */ new Map();
    const gameModeByGame = /* @__PURE__ */ new Map();
    for (const g of games) {
      if (typeof g.playedAt === "number") playedAtByGame.set(g.gameId, g.playedAt);
      if (typeof g.modeFamily === "string" && g.modeFamily) modeFamilyByGame.set(g.gameId, g.modeFamily);
      const gm = asTrimmedString2(g.gameMode ?? g.mode);
      if (gm) gameModeByGame.set(g.gameId, gm);
    }
    const detailsByGame = /* @__PURE__ */ new Map();
    for (const d of details) {
      if (d && typeof d.gameId === "string") detailsByGame.set(d.gameId, d);
    }
    roundsRawCache = rows.map((r) => {
      const out = { ...r };
      const gameId = String(out.gameId ?? "");
      const d = detailsByGame.get(gameId);
      if (d) {
        if (typeof out.mapSlug !== "string" || !out.mapSlug) {
          const ms = typeof d?.mapSlug === "string" ? d.mapSlug : typeof d?.raw?.options?.map?.slug === "string" ? d.raw.options.map.slug : "";
          if (ms) out.mapSlug = ms;
        }
        if (typeof out.mapName !== "string" || !out.mapName) {
          const mn = typeof d?.mapName === "string" ? d.mapName : typeof d?.raw?.options?.map?.name === "string" ? d.raw.options.map.name : "";
          if (mn) out.mapName = mn;
        }
        if (typeof out.isRated !== "boolean") {
          const ir = d?.isRated;
          const rawIr = d?.raw?.options?.isRated;
          if (ir === true || ir === false) out.isRated = ir;
          else if (rawIr === true || rawIr === false) out.isRated = rawIr;
        }
      }
      const roundStart = typeof out.startTime === "number" && Number.isFinite(out.startTime) ? out.startTime : void 0;
      const roundEnd = typeof out.endTime === "number" && Number.isFinite(out.endTime) ? out.endTime : void 0;
      const gamePlayedAt = playedAtByGame.get(gameId);
      const bestTime = roundStart ?? roundEnd ?? (typeof out.playedAt === "number" ? out.playedAt : void 0) ?? gamePlayedAt;
      if (typeof bestTime === "number" && Number.isFinite(bestTime)) {
        out.playedAt = bestTime;
        out.ts = bestTime;
      }
      let rawDur = typeof out.durationSeconds === "number" && Number.isFinite(out.durationSeconds) && out.durationSeconds > 0 ? out.durationSeconds : null;
      const start = typeof out.startTime === "number" && Number.isFinite(out.startTime) ? out.startTime : null;
      const end = typeof out.endTime === "number" && Number.isFinite(out.endTime) ? out.endTime : null;
      const derived = start !== null && end !== null && end > start ? (end - start) / 1e3 : null;
      const derivedOk = derived !== null && Number.isFinite(derived) && derived > 0 && derived < 60 * 30 ? derived : null;
      if (derivedOk !== null) {
        if (rawDur === null || Math.abs(rawDur - derivedOk) > 6) out.durationSeconds = derivedOk;
      } else if (rawDur === null) {
        delete out.durationSeconds;
      } else if (start === null || end === null) {
        const rounded = Math.round(rawDur);
        if (Math.abs(rawDur - rounded) < 1e-3 && [60, 90, 120, 180, 300].includes(rounded)) {
          delete out.durationSeconds;
          rawDur = null;
        }
      }
      if (typeof out.modeFamily !== "string" || !out.modeFamily) {
        const mf = asTrimmedString2(out.modeFamily) ?? asTrimmedString2(d?.modeFamily) ?? modeFamilyByGame.get(gameId);
        if (mf) out.modeFamily = mf;
      }
      if (typeof out.gameMode !== "string" || !out.gameMode) {
        const gm = asTrimmedString2(out.gameMode) ?? asTrimmedString2(d?.gameModeSimple) ?? asTrimmedString2(d?.gameMode) ?? gameModeByGame.get(gameId);
        if (gm) out.gameMode = gm;
      }
      if (typeof out.movementType !== "string" || !out.movementType) {
        const fromDetail = asTrimmedString2(d?.gameModeSimple);
        const fromGame = gameModeByGame.get(gameId);
        out.movementType = normalizeMovementType(fromDetail ?? fromGame);
      }
      if (d) {
        const v = typeof d.player_self_victory === "boolean" ? d.player_self_victory : typeof d.teamOneVictory === "boolean" ? d.teamOneVictory : typeof d.playerOneVictory === "boolean" ? d.playerOneVictory : void 0;
        if (typeof v === "boolean") out.result = v ? "Win" : "Loss";
        if (typeof out.teammateName !== "string" || !out.teammateName.trim()) {
          const selfId = asTrimmedString2(out.player_self_playerId) ?? asTrimmedString2(out.player_self_id);
          const selfName = asTrimmedString2(out.player_self_name) ?? asTrimmedString2(d.player_self_name);
          const t1id = asTrimmedString2(d.teamOnePlayerOneId);
          const t2id = asTrimmedString2(d.teamOnePlayerTwoId);
          const t1name = asTrimmedString2(d.teamOnePlayerOneName);
          const t2name = asTrimmedString2(d.teamOnePlayerTwoName);
          const u1id = asTrimmedString2(d.teamTwoPlayerOneId);
          const u2id = asTrimmedString2(d.teamTwoPlayerTwoId);
          const u1name = asTrimmedString2(d.teamTwoPlayerOneName);
          const u2name = asTrimmedString2(d.teamTwoPlayerTwoName);
          let mateName;
          if (selfId && selfId === t1id) mateName = t2name;
          else if (selfId && selfId === t2id) mateName = t1name;
          else if (selfId && selfId === u1id) mateName = u2name;
          else if (selfId && selfId === u2id) mateName = u1name;
          else mateName = asTrimmedString2(pickFirst3(d, ["player_mate_name", "teamOnePlayerTwoName", "p2_name"]));
          if (mateName && selfName && mateName.trim() === selfName.trim()) mateName = void 0;
          if (mateName) out.teammateName = mateName;
        }
      }
      if (typeof out.damage !== "number") {
        const mf = String(out.modeFamily ?? "");
        if (mf === "duels") {
          const self2 = out.player_self_score;
          const opp = out.player_opponent_score;
          if (typeof self2 === "number" && Number.isFinite(self2) && typeof opp === "number" && Number.isFinite(opp)) {
            out.damage = Math.max(-5e3, Math.min(5e3, self2 - opp));
          }
        } else if (mf === "teamduels") {
          const s1 = out.player_self_score;
          const s2 = out.player_mate_score;
          const o1 = out.player_opponent_score;
          const o2 = out.player_opponent_mate_score;
          const own = [s1, s2].filter((x) => typeof x === "number");
          const opp = [o1, o2].filter((x) => typeof x === "number");
          if (own.length && opp.length) {
            const bestOwn = Math.max(...own);
            const bestOpp = Math.max(...opp);
            if (Number.isFinite(bestOwn) && Number.isFinite(bestOpp)) {
              out.damage = Math.max(-5e3, Math.min(5e3, bestOwn - bestOpp));
            }
          }
        }
      }
      return out;
    });
    return roundsRawCache;
  }
  async function getRounds(filters) {
    const rowsAll = await getRoundsRaw();
    const gf = filters?.global;
    const spec = gf?.spec;
    const state = gf?.state ?? {};
    const controlIds = gf?.controlIds;
    const key = normalizeGlobalFilterKey(spec, state, "round", controlIds);
    const cached = roundsFilteredCache.get(key);
    if (cached) return cached;
    const applied = buildAppliedFilters(spec, state, "round", controlIds);
    let rows = rowsAll;
    if (applied.date) {
      const fromTs = applied.date.fromTs ?? null;
      const toTs2 = applied.date.toTs ?? null;
      if (fromTs !== null) rows = rows.filter((r) => typeof r.playedAt === "number" && r.playedAt >= fromTs);
      if (toTs2 !== null) rows = rows.filter((r) => typeof r.playedAt === "number" && r.playedAt <= toTs2);
    }
    rows = applyFilters(rows, applied.clauses, "round");
    roundsFilteredCache.set(key, rows);
    return rows;
  }
  async function getGamesRaw() {
    if (gamesRawCache) return gamesRawCache;
    const [games, details, rounds] = await Promise.all([db.games.toArray(), db.details.toArray(), db.rounds.toArray()]);
    const roundsCountByGame = /* @__PURE__ */ new Map();
    const movementByGame = /* @__PURE__ */ new Map();
    const scoreSumByGame = /* @__PURE__ */ new Map();
    const scoreCountByGame = /* @__PURE__ */ new Map();
    const fivekCountByGame = /* @__PURE__ */ new Map();
    const throwCountByGame = /* @__PURE__ */ new Map();
    const hitCountByGame = /* @__PURE__ */ new Map();
    const hitDenomByGame = /* @__PURE__ */ new Map();
    const minStartByGame = /* @__PURE__ */ new Map();
    const maxEndByGame = /* @__PURE__ */ new Map();
    const minHealthAfterByGame = /* @__PURE__ */ new Map();
    const maxHealthAfterByGame = /* @__PURE__ */ new Map();
    const finalHealthAfterByGame = /* @__PURE__ */ new Map();
    const finalHealthMarkerByGame = /* @__PURE__ */ new Map();
    for (const r of rounds) {
      const gid = typeof r?.gameId === "string" ? r.gameId : "";
      if (!gid) continue;
      roundsCountByGame.set(gid, (roundsCountByGame.get(gid) ?? 0) + 1);
      const mv = typeof r?.movementType === "string" ? r.movementType : typeof r?.movement_type === "string" ? r.movement_type : "";
      const cur = movementByGame.get(gid);
      if (mv) {
        if (!cur) {
          movementByGame.set(gid, mv);
        } else if (cur !== mv && cur !== "mixed") {
          movementByGame.set(gid, "mixed");
        }
      }
      const score = typeof r?.player_self_score === "number" ? r.player_self_score : typeof r?.p1_score === "number" ? r.p1_score : typeof r?.score === "number" ? r.score : null;
      if (typeof score === "number" && Number.isFinite(score) && score >= 0) {
        scoreSumByGame.set(gid, (scoreSumByGame.get(gid) ?? 0) + score);
        scoreCountByGame.set(gid, (scoreCountByGame.get(gid) ?? 0) + 1);
        if (score >= 5e3) fivekCountByGame.set(gid, (fivekCountByGame.get(gid) ?? 0) + 1);
        if (score < 50) throwCountByGame.set(gid, (throwCountByGame.get(gid) ?? 0) + 1);
      }
      const truth = typeof r?.trueCountry === "string" ? r.trueCountry : typeof r?.true_country === "string" ? r.true_country : "";
      const guess = typeof r?.player_self_guessCountry === "string" ? r.player_self_guessCountry : typeof r?.p1_guessCountry === "string" ? r.p1_guessCountry : typeof r?.guessCountry === "string" ? r.guessCountry : "";
      if (truth && guess) {
        hitDenomByGame.set(gid, (hitDenomByGame.get(gid) ?? 0) + 1);
        if (guess === truth) hitCountByGame.set(gid, (hitCountByGame.get(gid) ?? 0) + 1);
      }
      const start = typeof r?.startTime === "number" && Number.isFinite(r.startTime) ? r.startTime : null;
      const end = typeof r?.endTime === "number" && Number.isFinite(r.endTime) ? r.endTime : null;
      if (start !== null) {
        const curMin = minStartByGame.get(gid);
        minStartByGame.set(gid, curMin === void 0 ? start : Math.min(curMin, start));
      }
      if (end !== null) {
        const curMax = maxEndByGame.get(gid);
        maxEndByGame.set(gid, curMax === void 0 ? end : Math.max(curMax, end));
      }
      const h = typeof r?.player_self_healthAfter === "number" && Number.isFinite(r.player_self_healthAfter) ? r.player_self_healthAfter : null;
      if (h !== null) {
        const curMin = minHealthAfterByGame.get(gid);
        const curMax = maxHealthAfterByGame.get(gid);
        minHealthAfterByGame.set(gid, curMin === void 0 ? h : Math.min(curMin, h));
        maxHealthAfterByGame.set(gid, curMax === void 0 ? h : Math.max(curMax, h));
        const marker = (typeof r?.endTime === "number" && Number.isFinite(r.endTime) ? r.endTime : null) ?? (typeof r?.startTime === "number" && Number.isFinite(r.startTime) ? r.startTime : null) ?? (typeof r?.roundNumber === "number" && Number.isFinite(r.roundNumber) ? r.roundNumber : null);
        if (marker !== null) {
          const curMarker = finalHealthMarkerByGame.get(gid);
          if (curMarker === void 0 || marker >= curMarker) {
            finalHealthMarkerByGame.set(gid, marker);
            finalHealthAfterByGame.set(gid, h);
          }
        }
      }
    }
    const detailsByGame = /* @__PURE__ */ new Map();
    for (const d of details) {
      if (d && typeof d.gameId === "string") detailsByGame.set(d.gameId, d);
    }
    gamesRawCache = games.map((g) => {
      const d = detailsByGame.get(g.gameId);
      const out = { ...g, ...d ? d : {} };
      if (typeof g.playedAt === "number" && Number.isFinite(g.playedAt)) {
        out.playedAt = g.playedAt;
        out.ts = g.playedAt;
      }
      out.roundsCount = roundsCountByGame.get(g.gameId) ?? 0;
      if (typeof out.movementType !== "string" || !out.movementType) {
        const mv = movementByGame.get(g.gameId);
        if (mv) out.movementType = mv;
      }
      const scoreSum = scoreSumByGame.get(g.gameId);
      const scoreCount = scoreCountByGame.get(g.gameId);
      if (typeof scoreSum === "number") out.scoreSum = scoreSum;
      if (typeof scoreCount === "number") out.scoreCount = scoreCount;
      out.fivekCount = fivekCountByGame.get(g.gameId) ?? 0;
      out.throwCount = throwCountByGame.get(g.gameId) ?? 0;
      out.hitCount = hitCountByGame.get(g.gameId) ?? 0;
      out.hitDenom = hitDenomByGame.get(g.gameId) ?? 0;
      const minStart = minStartByGame.get(g.gameId);
      const maxEnd = maxEndByGame.get(g.gameId);
      if (typeof minStart === "number" && typeof maxEnd === "number" && Number.isFinite(minStart) && Number.isFinite(maxEnd) && maxEnd > minStart) {
        out.gameDurationSeconds = (maxEnd - minStart) / 1e3;
      }
      const minH = minHealthAfterByGame.get(g.gameId);
      const maxH = maxHealthAfterByGame.get(g.gameId);
      if (typeof minH === "number" && typeof maxH === "number" && Number.isFinite(minH) && Number.isFinite(maxH) && minH === maxH && maxH > 0) {
        out.isFlawless = true;
      }
      const finalH = finalHealthAfterByGame.get(g.gameId);
      if (typeof finalH === "number" && Number.isFinite(finalH) && finalH >= 0) {
        out.player_self_finalHealth = finalH;
      }
      if (String(out.modeFamily ?? "").toLowerCase() === "teamduels") {
        const hasMate = typeof out.teammateName === "string" && out.teammateName.trim().length > 0;
        if (!hasMate) {
          const selfId = asTrimmedString2(out.player_self_id ?? out.player_self_playerId);
          const selfName = asTrimmedString2(out.player_self_name) ?? asTrimmedString2(out.playerOneName);
          const t1id = asTrimmedString2(out.teamOnePlayerOneId);
          const t2id = asTrimmedString2(out.teamOnePlayerTwoId);
          const t1name = asTrimmedString2(out.teamOnePlayerOneName);
          const t2name = asTrimmedString2(out.teamOnePlayerTwoName);
          const u1id = asTrimmedString2(out.teamTwoPlayerOneId);
          const u2id = asTrimmedString2(out.teamTwoPlayerTwoId);
          const u1name = asTrimmedString2(out.teamTwoPlayerOneName);
          const u2name = asTrimmedString2(out.teamTwoPlayerTwoName);
          let mateName;
          if (selfId && selfId === t1id) mateName = t2name;
          else if (selfId && selfId === t2id) mateName = t1name;
          else if (selfId && selfId === u1id) mateName = u2name;
          else if (selfId && selfId === u2id) mateName = u1name;
          else mateName = asTrimmedString2(pickFirst3(out, ["player_mate_name", "teamOnePlayerTwoName"]));
          if (mateName && selfName && mateName.trim() === selfName.trim()) mateName = void 0;
          if (mateName) out.teammateName = mateName;
        }
      }
      const v = typeof out.player_self_victory === "boolean" ? out.player_self_victory : typeof out.teamOneVictory === "boolean" ? out.teamOneVictory : typeof out.playerOneVictory === "boolean" ? out.playerOneVictory : void 0;
      if (typeof v === "boolean") out.result = v ? "Win" : "Loss";
      if (out.isFlawless === true) {
        const res = String(out.result ?? "").trim().toLowerCase();
        out.isFlawlessWin = res === "win" || res === "w" || res === "true";
      }
      return out;
    });
    return gamesRawCache;
  }
  async function getGames(filters) {
    const rowsAll = await getGamesRaw();
    const gf = filters?.global;
    const spec = gf?.spec;
    const state = gf?.state ?? {};
    const controlIds = gf?.controlIds;
    const key = normalizeGlobalFilterKey(spec, state, "game", controlIds);
    const cached = gamesFilteredCache.get(key);
    if (cached) return cached;
    const applied = buildAppliedFilters(spec, state, "game", controlIds);
    let rows = rowsAll;
    if (applied.date) {
      const fromTs = applied.date.fromTs ?? null;
      const toTs2 = applied.date.toTs ?? null;
      if (fromTs !== null) rows = rows.filter((r) => typeof r.playedAt === "number" && r.playedAt >= fromTs);
      if (toTs2 !== null) rows = rows.filter((r) => typeof r.playedAt === "number" && r.playedAt <= toTs2);
    }
    rows = applyFilters(rows, applied.clauses, "game");
    gamesFilteredCache.set(key, rows);
    return rows;
  }

  // node_modules/xlsx/xlsx.mjs
  var XLSX = {};
  XLSX.version = "0.18.5";
  var current_codepage = 1200;
  var current_ansi = 1252;
  var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
  var CS2CP = {
    /*::[*/
    0: 1252,
    /* ANSI */
    /*::[*/
    1: 65001,
    /* DEFAULT */
    /*::[*/
    2: 65001,
    /* SYMBOL */
    /*::[*/
    77: 1e4,
    /* MAC */
    /*::[*/
    128: 932,
    /* SHIFTJIS */
    /*::[*/
    129: 949,
    /* HANGUL */
    /*::[*/
    130: 1361,
    /* JOHAB */
    /*::[*/
    134: 936,
    /* GB2312 */
    /*::[*/
    136: 950,
    /* CHINESEBIG5 */
    /*::[*/
    161: 1253,
    /* GREEK */
    /*::[*/
    162: 1254,
    /* TURKISH */
    /*::[*/
    163: 1258,
    /* VIETNAMESE */
    /*::[*/
    177: 1255,
    /* HEBREW */
    /*::[*/
    178: 1256,
    /* ARABIC */
    /*::[*/
    186: 1257,
    /* BALTIC */
    /*::[*/
    204: 1251,
    /* RUSSIAN */
    /*::[*/
    222: 874,
    /* THAI */
    /*::[*/
    238: 1250,
    /* EASTEUROPE */
    /*::[*/
    255: 1252,
    /* OEM */
    /*::[*/
    69: 6969
    /* MISC */
  };
  var set_ansi = function(cp) {
    if (VALID_ANSI.indexOf(cp) == -1) return;
    current_ansi = CS2CP[0] = cp;
  };
  function reset_ansi() {
    set_ansi(1252);
  }
  var set_cp = function(cp) {
    current_codepage = cp;
    set_ansi(cp);
  };
  function reset_cp() {
    set_cp(1200);
    reset_ansi();
  }
  function utf16beread(data) {
    var o = [];
    for (var i = 0; i < data.length >> 1; ++i) o[i] = String.fromCharCode(data.charCodeAt(2 * i + 1) + (data.charCodeAt(2 * i) << 8));
    return o.join("");
  }
  var _getchar = function _gc1(x) {
    return String.fromCharCode(x);
  };
  var _getansi = function _ga1(x) {
    return String.fromCharCode(x);
  };
  var $cptable;
  var DENSE = null;
  var DIF_XL = true;
  var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  function Base64_encode(input) {
    var o = "";
    var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
    for (var i = 0; i < input.length; ) {
      c1 = input.charCodeAt(i++);
      e1 = c1 >> 2;
      c2 = input.charCodeAt(i++);
      e2 = (c1 & 3) << 4 | c2 >> 4;
      c3 = input.charCodeAt(i++);
      e3 = (c2 & 15) << 2 | c3 >> 6;
      e4 = c3 & 63;
      if (isNaN(c2)) {
        e3 = e4 = 64;
      } else if (isNaN(c3)) {
        e4 = 64;
      }
      o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
    }
    return o;
  }
  function Base64_decode(input) {
    var o = "";
    var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
    input = input.replace(/[^\w\+\/\=]/g, "");
    for (var i = 0; i < input.length; ) {
      e1 = Base64_map.indexOf(input.charAt(i++));
      e2 = Base64_map.indexOf(input.charAt(i++));
      c1 = e1 << 2 | e2 >> 4;
      o += String.fromCharCode(c1);
      e3 = Base64_map.indexOf(input.charAt(i++));
      c2 = (e2 & 15) << 4 | e3 >> 2;
      if (e3 !== 64) {
        o += String.fromCharCode(c2);
      }
      e4 = Base64_map.indexOf(input.charAt(i++));
      c3 = (e3 & 3) << 6 | e4;
      if (e4 !== 64) {
        o += String.fromCharCode(c3);
      }
    }
    return o;
  }
  var has_buf = /* @__PURE__ */ (function() {
    return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
  })();
  var Buffer_from = /* @__PURE__ */ (function() {
    if (typeof Buffer !== "undefined") {
      var nbfs = !Buffer.from;
      if (!nbfs) try {
        Buffer.from("foo", "utf8");
      } catch (e) {
        nbfs = true;
      }
      return nbfs ? function(buf, enc) {
        return enc ? new Buffer(buf, enc) : new Buffer(buf);
      } : Buffer.from.bind(Buffer);
    }
    return function() {
    };
  })();
  function new_raw_buf(len) {
    if (has_buf) return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
    return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
  }
  function new_unsafe_buf(len) {
    if (has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
    return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
  }
  var s2a = function s2a2(s) {
    if (has_buf) return Buffer_from(s, "binary");
    return s.split("").map(function(x) {
      return x.charCodeAt(0) & 255;
    });
  };
  function s2ab(s) {
    if (typeof ArrayBuffer === "undefined") return s2a(s);
    var buf = new ArrayBuffer(s.length), view = new Uint8Array(buf);
    for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 255;
    return buf;
  }
  function a2s(data) {
    if (Array.isArray(data)) return data.map(function(c) {
      return String.fromCharCode(c);
    }).join("");
    var o = [];
    for (var i = 0; i < data.length; ++i) o[i] = String.fromCharCode(data[i]);
    return o.join("");
  }
  function a2u(data) {
    if (typeof Uint8Array === "undefined") throw new Error("Unsupported");
    return new Uint8Array(data);
  }
  var bconcat = has_buf ? function(bufs) {
    return Buffer.concat(bufs.map(function(buf) {
      return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
    }));
  } : function(bufs) {
    if (typeof Uint8Array !== "undefined") {
      var i = 0, maxlen = 0;
      for (i = 0; i < bufs.length; ++i) maxlen += bufs[i].length;
      var o = new Uint8Array(maxlen);
      var len = 0;
      for (i = 0, maxlen = 0; i < bufs.length; maxlen += len, ++i) {
        len = bufs[i].length;
        if (bufs[i] instanceof Uint8Array) o.set(bufs[i], maxlen);
        else if (typeof bufs[i] == "string") {
          throw "wtf";
        } else o.set(new Uint8Array(bufs[i]), maxlen);
      }
      return o;
    }
    return [].concat.apply([], bufs.map(function(buf) {
      return Array.isArray(buf) ? buf : [].slice.call(buf);
    }));
  };
  function utf8decode(content) {
    var out = [], widx = 0, L = content.length + 250;
    var o = new_raw_buf(content.length + 255);
    for (var ridx = 0; ridx < content.length; ++ridx) {
      var c = content.charCodeAt(ridx);
      if (c < 128) o[widx++] = c;
      else if (c < 2048) {
        o[widx++] = 192 | c >> 6 & 31;
        o[widx++] = 128 | c & 63;
      } else if (c >= 55296 && c < 57344) {
        c = (c & 1023) + 64;
        var d = content.charCodeAt(++ridx) & 1023;
        o[widx++] = 240 | c >> 8 & 7;
        o[widx++] = 128 | c >> 2 & 63;
        o[widx++] = 128 | d >> 6 & 15 | (c & 3) << 4;
        o[widx++] = 128 | d & 63;
      } else {
        o[widx++] = 224 | c >> 12 & 15;
        o[widx++] = 128 | c >> 6 & 63;
        o[widx++] = 128 | c & 63;
      }
      if (widx > L) {
        out.push(o.slice(0, widx));
        widx = 0;
        o = new_raw_buf(65535);
        L = 65530;
      }
    }
    out.push(o.slice(0, widx));
    return bconcat(out);
  }
  var chr0 = /\u0000/g;
  var chr1 = /[\u0001-\u0006]/g;
  function _strrev(x) {
    var o = "", i = x.length - 1;
    while (i >= 0) o += x.charAt(i--);
    return o;
  }
  function pad0(v, d) {
    var t = "" + v;
    return t.length >= d ? t : fill("0", d - t.length) + t;
  }
  function pad_(v, d) {
    var t = "" + v;
    return t.length >= d ? t : fill(" ", d - t.length) + t;
  }
  function rpad_(v, d) {
    var t = "" + v;
    return t.length >= d ? t : t + fill(" ", d - t.length);
  }
  function pad0r1(v, d) {
    var t = "" + Math.round(v);
    return t.length >= d ? t : fill("0", d - t.length) + t;
  }
  function pad0r2(v, d) {
    var t = "" + v;
    return t.length >= d ? t : fill("0", d - t.length) + t;
  }
  var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
  function pad0r(v, d) {
    if (v > p2_32 || v < -p2_32) return pad0r1(v, d);
    var i = Math.round(v);
    return pad0r2(i, d);
  }
  function SSF_isgeneral(s, i) {
    i = i || 0;
    return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
  }
  var days = [
    ["Sun", "Sunday"],
    ["Mon", "Monday"],
    ["Tue", "Tuesday"],
    ["Wed", "Wednesday"],
    ["Thu", "Thursday"],
    ["Fri", "Friday"],
    ["Sat", "Saturday"]
  ];
  var months = [
    ["J", "Jan", "January"],
    ["F", "Feb", "February"],
    ["M", "Mar", "March"],
    ["A", "Apr", "April"],
    ["M", "May", "May"],
    ["J", "Jun", "June"],
    ["J", "Jul", "July"],
    ["A", "Aug", "August"],
    ["S", "Sep", "September"],
    ["O", "Oct", "October"],
    ["N", "Nov", "November"],
    ["D", "Dec", "December"]
  ];
  function SSF_init_table(t) {
    if (!t) t = {};
    t[0] = "General";
    t[1] = "0";
    t[2] = "0.00";
    t[3] = "#,##0";
    t[4] = "#,##0.00";
    t[9] = "0%";
    t[10] = "0.00%";
    t[11] = "0.00E+00";
    t[12] = "# ?/?";
    t[13] = "# ??/??";
    t[14] = "m/d/yy";
    t[15] = "d-mmm-yy";
    t[16] = "d-mmm";
    t[17] = "mmm-yy";
    t[18] = "h:mm AM/PM";
    t[19] = "h:mm:ss AM/PM";
    t[20] = "h:mm";
    t[21] = "h:mm:ss";
    t[22] = "m/d/yy h:mm";
    t[37] = "#,##0 ;(#,##0)";
    t[38] = "#,##0 ;[Red](#,##0)";
    t[39] = "#,##0.00;(#,##0.00)";
    t[40] = "#,##0.00;[Red](#,##0.00)";
    t[45] = "mm:ss";
    t[46] = "[h]:mm:ss";
    t[47] = "mmss.0";
    t[48] = "##0.0E+0";
    t[49] = "@";
    t[56] = '"\u4E0A\u5348/\u4E0B\u5348 "hh"\u6642"mm"\u5206"ss"\u79D2 "';
    return t;
  }
  var table_fmt = {
    0: "General",
    1: "0",
    2: "0.00",
    3: "#,##0",
    4: "#,##0.00",
    9: "0%",
    10: "0.00%",
    11: "0.00E+00",
    12: "# ?/?",
    13: "# ??/??",
    14: "m/d/yy",
    15: "d-mmm-yy",
    16: "d-mmm",
    17: "mmm-yy",
    18: "h:mm AM/PM",
    19: "h:mm:ss AM/PM",
    20: "h:mm",
    21: "h:mm:ss",
    22: "m/d/yy h:mm",
    37: "#,##0 ;(#,##0)",
    38: "#,##0 ;[Red](#,##0)",
    39: "#,##0.00;(#,##0.00)",
    40: "#,##0.00;[Red](#,##0.00)",
    45: "mm:ss",
    46: "[h]:mm:ss",
    47: "mmss.0",
    48: "##0.0E+0",
    49: "@",
    56: '"\u4E0A\u5348/\u4E0B\u5348 "hh"\u6642"mm"\u5206"ss"\u79D2 "'
  };
  var SSF_default_map = {
    5: 37,
    6: 38,
    7: 39,
    8: 40,
    //  5 -> 37 ...  8 -> 40
    23: 0,
    24: 0,
    25: 0,
    26: 0,
    // 23 ->  0 ... 26 ->  0
    27: 14,
    28: 14,
    29: 14,
    30: 14,
    31: 14,
    // 27 -> 14 ... 31 -> 14
    50: 14,
    51: 14,
    52: 14,
    53: 14,
    54: 14,
    // 50 -> 14 ... 58 -> 14
    55: 14,
    56: 14,
    57: 14,
    58: 14,
    59: 1,
    60: 2,
    61: 3,
    62: 4,
    // 59 ->  1 ... 62 ->  4
    67: 9,
    68: 10,
    // 67 ->  9 ... 68 -> 10
    69: 12,
    70: 13,
    71: 14,
    // 69 -> 12 ... 71 -> 14
    72: 14,
    73: 15,
    74: 16,
    75: 17,
    // 72 -> 14 ... 75 -> 17
    76: 20,
    77: 21,
    78: 22,
    // 76 -> 20 ... 78 -> 22
    79: 45,
    80: 46,
    81: 47,
    // 79 -> 45 ... 81 -> 47
    82: 0
    // 82 ->  0 ... 65536 -> 0 (omitted)
  };
  var SSF_default_str = {
    //  5 -- Currency,   0 decimal, black negative
    5: '"$"#,##0_);\\("$"#,##0\\)',
    63: '"$"#,##0_);\\("$"#,##0\\)',
    //  6 -- Currency,   0 decimal, red   negative
    6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
    64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
    //  7 -- Currency,   2 decimal, black negative
    7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
    65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
    //  8 -- Currency,   2 decimal, red   negative
    8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    // 41 -- Accounting, 0 decimal, No Symbol
    41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
    // 42 -- Accounting, 0 decimal, $  Symbol
    42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
    // 43 -- Accounting, 2 decimal, No Symbol
    43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
    // 44 -- Accounting, 2 decimal, $  Symbol
    44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
  };
  function SSF_frac(x, D, mixed) {
    var sgn = x < 0 ? -1 : 1;
    var B = x * sgn;
    var P_2 = 0, P_1 = 1, P = 0;
    var Q_2 = 1, Q_1 = 0, Q = 0;
    var A = Math.floor(B);
    while (Q_1 < D) {
      A = Math.floor(B);
      P = A * P_1 + P_2;
      Q = A * Q_1 + Q_2;
      if (B - A < 5e-8) break;
      B = 1 / (B - A);
      P_2 = P_1;
      P_1 = P;
      Q_2 = Q_1;
      Q_1 = Q;
    }
    if (Q > D) {
      if (Q_1 > D) {
        Q = Q_2;
        P = P_2;
      } else {
        Q = Q_1;
        P = P_1;
      }
    }
    if (!mixed) return [0, sgn * P, Q];
    var q = Math.floor(sgn * P / Q);
    return [q, sgn * P - q * Q, Q];
  }
  function SSF_parse_date_code(v, opts, b2) {
    if (v > 2958465 || v < 0) return null;
    var date = v | 0, time = Math.floor(86400 * (v - date)), dow = 0;
    var dout = [];
    var out = { D: date, T: time, u: 86400 * (v - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
    if (Math.abs(out.u) < 1e-6) out.u = 0;
    if (opts && opts.date1904) date += 1462;
    if (out.u > 0.9999) {
      out.u = 0;
      if (++time == 86400) {
        out.T = time = 0;
        ++date;
        ++out.D;
      }
    }
    if (date === 60) {
      dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
      dow = 3;
    } else if (date === 0) {
      dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
      dow = 6;
    } else {
      if (date > 60) --date;
      var d = new Date(1900, 0, 1);
      d.setDate(d.getDate() + date - 1);
      dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
      dow = d.getDay();
      if (date < 60) dow = (dow + 6) % 7;
      if (b2) dow = SSF_fix_hijri(d, dout);
    }
    out.y = dout[0];
    out.m = dout[1];
    out.d = dout[2];
    out.S = time % 60;
    time = Math.floor(time / 60);
    out.M = time % 60;
    time = Math.floor(time / 60);
    out.H = time;
    out.q = dow;
    return out;
  }
  var SSFbasedate = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0);
  var SSFdnthresh = /* @__PURE__ */ SSFbasedate.getTime();
  var SSFbase1904 = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
  function datenum_local(v, date1904) {
    var epoch = /* @__PURE__ */ v.getTime();
    if (date1904) epoch -= 1461 * 24 * 60 * 60 * 1e3;
    else if (v >= SSFbase1904) epoch += 24 * 60 * 60 * 1e3;
    return (epoch - (SSFdnthresh + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ SSFbasedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
  }
  function SSF_strip_decimal(o) {
    return o.indexOf(".") == -1 ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
  }
  function SSF_normalize_exp(o) {
    if (o.indexOf("E") == -1) return o;
    return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
  }
  function SSF_small_exp(v) {
    var w = v < 0 ? 12 : 11;
    var o = SSF_strip_decimal(v.toFixed(12));
    if (o.length <= w) return o;
    o = v.toPrecision(10);
    if (o.length <= w) return o;
    return v.toExponential(5);
  }
  function SSF_large_exp(v) {
    var o = SSF_strip_decimal(v.toFixed(11));
    return o.length > (v < 0 ? 12 : 11) || o === "0" || o === "-0" ? v.toPrecision(6) : o;
  }
  function SSF_general_num(v) {
    var V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;
    if (V >= -4 && V <= -1) o = v.toPrecision(10 + V);
    else if (Math.abs(V) <= 9) o = SSF_small_exp(v);
    else if (V === 10) o = v.toFixed(10).substr(0, 12);
    else o = SSF_large_exp(v);
    return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));
  }
  function SSF_general(v, opts) {
    switch (typeof v) {
      case "string":
        return v;
      case "boolean":
        return v ? "TRUE" : "FALSE";
      case "number":
        return (v | 0) === v ? v.toString(10) : SSF_general_num(v);
      case "undefined":
        return "";
      case "object":
        if (v == null) return "";
        if (v instanceof Date) return SSF_format(14, datenum_local(v, opts && opts.date1904), opts);
    }
    throw new Error("unsupported value in General format: " + v);
  }
  function SSF_fix_hijri(date, o) {
    o[0] -= 581;
    var dow = date.getDay();
    if (date < 60) dow = (dow + 6) % 7;
    return dow;
  }
  function SSF_write_date(type, fmt, val, ss0) {
    var o = "", ss = 0, tt = 0, y = val.y, out, outl = 0;
    switch (type) {
      case 98:
        y = val.y + 543;
      /* falls through */
      case 121:
        switch (fmt.length) {
          case 1:
          case 2:
            out = y % 100;
            outl = 2;
            break;
          default:
            out = y % 1e4;
            outl = 4;
            break;
        }
        break;
      case 109:
        switch (fmt.length) {
          case 1:
          case 2:
            out = val.m;
            outl = fmt.length;
            break;
          case 3:
            return months[val.m - 1][1];
          case 5:
            return months[val.m - 1][0];
          default:
            return months[val.m - 1][2];
        }
        break;
      case 100:
        switch (fmt.length) {
          case 1:
          case 2:
            out = val.d;
            outl = fmt.length;
            break;
          case 3:
            return days[val.q][0];
          default:
            return days[val.q][1];
        }
        break;
      case 104:
        switch (fmt.length) {
          case 1:
          case 2:
            out = 1 + (val.H + 11) % 12;
            outl = fmt.length;
            break;
          default:
            throw "bad hour format: " + fmt;
        }
        break;
      case 72:
        switch (fmt.length) {
          case 1:
          case 2:
            out = val.H;
            outl = fmt.length;
            break;
          default:
            throw "bad hour format: " + fmt;
        }
        break;
      case 77:
        switch (fmt.length) {
          case 1:
          case 2:
            out = val.M;
            outl = fmt.length;
            break;
          default:
            throw "bad minute format: " + fmt;
        }
        break;
      case 115:
        if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000") throw "bad second format: " + fmt;
        if (val.u === 0 && (fmt == "s" || fmt == "ss")) return pad0(val.S, fmt.length);
        if (ss0 >= 2) tt = ss0 === 3 ? 1e3 : 100;
        else tt = ss0 === 1 ? 10 : 1;
        ss = Math.round(tt * (val.S + val.u));
        if (ss >= 60 * tt) ss = 0;
        if (fmt === "s") return ss === 0 ? "0" : "" + ss / tt;
        o = pad0(ss, 2 + ss0);
        if (fmt === "ss") return o.substr(0, 2);
        return "." + o.substr(2, fmt.length - 1);
      case 90:
        switch (fmt) {
          case "[h]":
          case "[hh]":
            out = val.D * 24 + val.H;
            break;
          case "[m]":
          case "[mm]":
            out = (val.D * 24 + val.H) * 60 + val.M;
            break;
          case "[s]":
          case "[ss]":
            out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
            break;
          default:
            throw "bad abstime format: " + fmt;
        }
        outl = fmt.length === 3 ? 1 : 2;
        break;
      case 101:
        out = y;
        outl = 1;
        break;
    }
    var outstr = outl > 0 ? pad0(out, outl) : "";
    return outstr;
  }
  function commaify(s) {
    var w = 3;
    if (s.length <= w) return s;
    var j = s.length % w, o = s.substr(0, j);
    for (; j != s.length; j += w) o += (o.length > 0 ? "," : "") + s.substr(j, w);
    return o;
  }
  var pct1 = /%/g;
  function write_num_pct(type, fmt, val) {
    var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
    return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
  }
  function write_num_cm(type, fmt, val) {
    var idx = fmt.length - 1;
    while (fmt.charCodeAt(idx - 1) === 44) --idx;
    return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
  }
  function write_num_exp(fmt, val) {
    var o;
    var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
    if (fmt.match(/^#+0.0E\+0$/)) {
      if (val == 0) return "0.0E+0";
      else if (val < 0) return "-" + write_num_exp(fmt, -val);
      var period = fmt.indexOf(".");
      if (period === -1) period = fmt.indexOf("E");
      var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
      if (ee < 0) ee += period;
      o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
      if (o.indexOf("e") === -1) {
        var fakee = Math.floor(Math.log(val) * Math.LOG10E);
        if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
        else o += "E+" + (fakee - ee);
        while (o.substr(0, 2) === "0.") {
          o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
          o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
        }
        o = o.replace(/\+-/, "-");
      }
      o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
        return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
      });
    } else o = val.toExponential(idx);
    if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
    if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
    return o.replace("e", "E");
  }
  var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
  function write_num_f1(r, aval, sign) {
    var den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
    var myn = rr - base * den, myd = den;
    return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
  }
  function write_num_f2(r, aval, sign) {
    return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length);
  }
  var dec1 = /^#*0*\.([0#]+)/;
  var closeparen = /\).*[0#]/;
  var phone = /\(###\) ###\\?-####/;
  function hashq(str) {
    var o = "", cc;
    for (var i = 0; i != str.length; ++i) switch (cc = str.charCodeAt(i)) {
      case 35:
        break;
      case 63:
        o += " ";
        break;
      case 48:
        o += "0";
        break;
      default:
        o += String.fromCharCode(cc);
    }
    return o;
  }
  function rnd(val, d) {
    var dd = Math.pow(10, d);
    return "" + Math.round(val * dd) / dd;
  }
  function dec(val, d) {
    var _frac = val - Math.floor(val), dd = Math.pow(10, d);
    if (d < ("" + Math.round(_frac * dd)).length) return 0;
    return Math.round(_frac * dd);
  }
  function carry(val, d) {
    if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
      return 1;
    }
    return 0;
  }
  function flr(val) {
    if (val < 2147483647 && val > -2147483648) return "" + (val >= 0 ? val | 0 : val - 1 | 0);
    return "" + Math.floor(val);
  }
  function write_num_flt(type, fmt, val) {
    if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
      var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
      if (val >= 0) return write_num_flt("n", ffmt, val);
      return "(" + write_num_flt("n", ffmt, -val) + ")";
    }
    if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);
    if (fmt.indexOf("%") !== -1) return write_num_pct(type, fmt, val);
    if (fmt.indexOf("E") !== -1) return write_num_exp(fmt, val);
    if (fmt.charCodeAt(0) === 36) return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
    var o;
    var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
    if (fmt.match(/^00+$/)) return sign + pad0r(aval, fmt.length);
    if (fmt.match(/^[#?]+$/)) {
      o = pad0r(val, 0);
      if (o === "0") o = "";
      return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
    }
    if (r = fmt.match(frac1)) return write_num_f1(r, aval, sign);
    if (fmt.match(/^#+0+$/)) return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
    if (r = fmt.match(dec1)) {
      o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
        return "." + $1 + fill("0", hashq(
          /*::(*/
          r[1]
        ).length - $1.length);
      });
      return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
    }
    fmt = fmt.replace(/^#+([0.])/, "$1");
    if (r = fmt.match(/^(0*)\.(#*)$/)) {
      return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
    }
    if (r = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify(pad0r(aval, 0));
    if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
      return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
    }
    if (r = fmt.match(/^#,#*,#0/)) return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
    if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
      o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
      ri = 0;
      return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
        return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
      }));
    }
    if (fmt.match(phone)) {
      o = write_num_flt(type, "##########", val);
      return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
    }
    var oa = "";
    if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
      ri = Math.min(
        /*::String(*/
        r[4].length,
        7
      );
      ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
      o = "" + sign;
      oa = write_num(
        "n",
        /*::String(*/
        r[1],
        ff[1]
      );
      if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
      o += oa + /*::String(*/
      r[2] + "/" + /*::String(*/
      r[3];
      oa = rpad_(ff[2], ri);
      if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
      o += oa;
      return o;
    }
    if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
      ri = Math.min(Math.max(r[1].length, r[4].length), 7);
      ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
      return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
    }
    if (r = fmt.match(/^[#0?]+$/)) {
      o = pad0r(val, 0);
      if (fmt.length <= o.length) return o;
      return hashq(fmt.substr(0, fmt.length - o.length)) + o;
    }
    if (r = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
      o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
      ri = o.indexOf(".");
      var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
      return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
    }
    if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
      ri = dec(val, r[1].length);
      return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
        return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
      }) + "." + pad0(ri, r[1].length);
    }
    switch (fmt) {
      case "###,##0.00":
        return write_num_flt(type, "#,##0.00", val);
      case "###,###":
      case "##,###":
      case "#,###":
        var x = commaify(pad0r(aval, 0));
        return x !== "0" ? sign + x : "";
      case "###,###.00":
        return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
      case "#,###.00":
        return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
      default:
    }
    throw new Error("unsupported format |" + fmt + "|");
  }
  function write_num_cm2(type, fmt, val) {
    var idx = fmt.length - 1;
    while (fmt.charCodeAt(idx - 1) === 44) --idx;
    return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
  }
  function write_num_pct2(type, fmt, val) {
    var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
    return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
  }
  function write_num_exp2(fmt, val) {
    var o;
    var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
    if (fmt.match(/^#+0.0E\+0$/)) {
      if (val == 0) return "0.0E+0";
      else if (val < 0) return "-" + write_num_exp2(fmt, -val);
      var period = fmt.indexOf(".");
      if (period === -1) period = fmt.indexOf("E");
      var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
      if (ee < 0) ee += period;
      o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
      if (!o.match(/[Ee]/)) {
        var fakee = Math.floor(Math.log(val) * Math.LOG10E);
        if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
        else o += "E+" + (fakee - ee);
        o = o.replace(/\+-/, "-");
      }
      o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
        return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
      });
    } else o = val.toExponential(idx);
    if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
    if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
    return o.replace("e", "E");
  }
  function write_num_int(type, fmt, val) {
    if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
      var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
      if (val >= 0) return write_num_int("n", ffmt, val);
      return "(" + write_num_int("n", ffmt, -val) + ")";
    }
    if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
    if (fmt.indexOf("%") !== -1) return write_num_pct2(type, fmt, val);
    if (fmt.indexOf("E") !== -1) return write_num_exp2(fmt, val);
    if (fmt.charCodeAt(0) === 36) return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
    var o;
    var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
    if (fmt.match(/^00+$/)) return sign + pad0(aval, fmt.length);
    if (fmt.match(/^[#?]+$/)) {
      o = "" + val;
      if (val === 0) o = "";
      return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
    }
    if (r = fmt.match(frac1)) return write_num_f2(r, aval, sign);
    if (fmt.match(/^#+0+$/)) return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
    if (r = fmt.match(dec1)) {
      o = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
      o = o.replace(/\.(\d*)$/, function($$, $1) {
        return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
      });
      return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
    }
    fmt = fmt.replace(/^#+([0.])/, "$1");
    if (r = fmt.match(/^(0*)\.(#*)$/)) {
      return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
    }
    if (r = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify("" + aval);
    if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
      return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length);
    }
    if (r = fmt.match(/^#,#*,#0/)) return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
    if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
      o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
      ri = 0;
      return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
        return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
      }));
    }
    if (fmt.match(phone)) {
      o = write_num_int(type, "##########", val);
      return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
    }
    var oa = "";
    if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
      ri = Math.min(
        /*::String(*/
        r[4].length,
        7
      );
      ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
      o = "" + sign;
      oa = write_num(
        "n",
        /*::String(*/
        r[1],
        ff[1]
      );
      if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
      o += oa + /*::String(*/
      r[2] + "/" + /*::String(*/
      r[3];
      oa = rpad_(ff[2], ri);
      if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
      o += oa;
      return o;
    }
    if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
      ri = Math.min(Math.max(r[1].length, r[4].length), 7);
      ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
      return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
    }
    if (r = fmt.match(/^[#0?]+$/)) {
      o = "" + val;
      if (fmt.length <= o.length) return o;
      return hashq(fmt.substr(0, fmt.length - o.length)) + o;
    }
    if (r = fmt.match(/^([#0]+)\.([#0]+)$/)) {
      o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
      ri = o.indexOf(".");
      var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
      return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
    }
    if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
      return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
        return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
      }) + "." + pad0(0, r[1].length);
    }
    switch (fmt) {
      case "###,###":
      case "##,###":
      case "#,###":
        var x = commaify("" + aval);
        return x !== "0" ? sign + x : "";
      default:
        if (fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
    }
    throw new Error("unsupported format |" + fmt + "|");
  }
  function write_num(type, fmt, val) {
    return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
  }
  function SSF_split_fmt(fmt) {
    var out = [];
    var in_str = false;
    for (var i = 0, j = 0; i < fmt.length; ++i) switch (
      /*cc=*/
      fmt.charCodeAt(i)
    ) {
      case 34:
        in_str = !in_str;
        break;
      case 95:
      case 42:
      case 92:
        ++i;
        break;
      case 59:
        out[out.length] = fmt.substr(j, i - j);
        j = i + 1;
    }
    out[out.length] = fmt.substr(j);
    if (in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");
    return out;
  }
  var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
  function fmt_is_date(fmt) {
    var i = 0, c = "", o = "";
    while (i < fmt.length) {
      switch (c = fmt.charAt(i)) {
        case "G":
          if (SSF_isgeneral(fmt, i)) i += 6;
          i++;
          break;
        case '"':
          for (
            ;
            /*cc=*/
            fmt.charCodeAt(++i) !== 34 && i < fmt.length;
          ) {
          }
          ++i;
          break;
        case "\\":
          i += 2;
          break;
        case "_":
          i += 2;
          break;
        case "@":
          ++i;
          break;
        case "B":
        case "b":
          if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") return true;
        /* falls through */
        case "M":
        case "D":
        case "Y":
        case "H":
        case "S":
        case "E":
        /* falls through */
        case "m":
        case "d":
        case "y":
        case "h":
        case "s":
        case "e":
        case "g":
          return true;
        case "A":
        case "a":
        case "\u4E0A":
          if (fmt.substr(i, 3).toUpperCase() === "A/P") return true;
          if (fmt.substr(i, 5).toUpperCase() === "AM/PM") return true;
          if (fmt.substr(i, 5).toUpperCase() === "\u4E0A\u5348/\u4E0B\u5348") return true;
          ++i;
          break;
        case "[":
          o = c;
          while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
          if (o.match(SSF_abstime)) return true;
          break;
        case ".":
        /* falls through */
        case "0":
        case "#":
          while (i < fmt.length && ("0#?.,E+-%".indexOf(c = fmt.charAt(++i)) > -1 || c == "\\" && fmt.charAt(i + 1) == "-" && "0#".indexOf(fmt.charAt(i + 2)) > -1)) {
          }
          break;
        case "?":
          while (fmt.charAt(++i) === c) {
          }
          break;
        case "*":
          ++i;
          if (fmt.charAt(i) == " " || fmt.charAt(i) == "*") ++i;
          break;
        case "(":
        case ")":
          ++i;
          break;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) {
          }
          break;
        case " ":
          ++i;
          break;
        default:
          ++i;
          break;
      }
    }
    return false;
  }
  function eval_fmt(fmt, v, opts, flen) {
    var out = [], o = "", i = 0, c = "", lst = "t", dt, j, cc;
    var hr = "H";
    while (i < fmt.length) {
      switch (c = fmt.charAt(i)) {
        case "G":
          if (!SSF_isgeneral(fmt, i)) throw new Error("unrecognized character " + c + " in " + fmt);
          out[out.length] = { t: "G", v: "General" };
          i += 7;
          break;
        case '"':
          for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; ) o += String.fromCharCode(cc);
          out[out.length] = { t: "t", v: o };
          ++i;
          break;
        case "\\":
          var w = fmt.charAt(++i), t = w === "(" || w === ")" ? w : "t";
          out[out.length] = { t, v: w };
          ++i;
          break;
        case "_":
          out[out.length] = { t: "t", v: " " };
          i += 2;
          break;
        case "@":
          out[out.length] = { t: "T", v };
          ++i;
          break;
        case "B":
        case "b":
          if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") {
            if (dt == null) {
              dt = SSF_parse_date_code(v, opts, fmt.charAt(i + 1) === "2");
              if (dt == null) return "";
            }
            out[out.length] = { t: "X", v: fmt.substr(i, 2) };
            lst = c;
            i += 2;
            break;
          }
        /* falls through */
        case "M":
        case "D":
        case "Y":
        case "H":
        case "S":
        case "E":
          c = c.toLowerCase();
        /* falls through */
        case "m":
        case "d":
        case "y":
        case "h":
        case "s":
        case "e":
        case "g":
          if (v < 0) return "";
          if (dt == null) {
            dt = SSF_parse_date_code(v, opts);
            if (dt == null) return "";
          }
          o = c;
          while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c) o += c;
          if (c === "m" && lst.toLowerCase() === "h") c = "M";
          if (c === "h") c = hr;
          out[out.length] = { t: c, v: o };
          lst = c;
          break;
        case "A":
        case "a":
        case "\u4E0A":
          var q = { t: c, v: c };
          if (dt == null) dt = SSF_parse_date_code(v, opts);
          if (fmt.substr(i, 3).toUpperCase() === "A/P") {
            if (dt != null) q.v = dt.H >= 12 ? "P" : "A";
            q.t = "T";
            hr = "h";
            i += 3;
          } else if (fmt.substr(i, 5).toUpperCase() === "AM/PM") {
            if (dt != null) q.v = dt.H >= 12 ? "PM" : "AM";
            q.t = "T";
            i += 5;
            hr = "h";
          } else if (fmt.substr(i, 5).toUpperCase() === "\u4E0A\u5348/\u4E0B\u5348") {
            if (dt != null) q.v = dt.H >= 12 ? "\u4E0B\u5348" : "\u4E0A\u5348";
            q.t = "T";
            i += 5;
            hr = "h";
          } else {
            q.t = "t";
            ++i;
          }
          if (dt == null && q.t === "T") return "";
          out[out.length] = q;
          lst = c;
          break;
        case "[":
          o = c;
          while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
          if (o.slice(-1) !== "]") throw 'unterminated "[" block: |' + o + "|";
          if (o.match(SSF_abstime)) {
            if (dt == null) {
              dt = SSF_parse_date_code(v, opts);
              if (dt == null) return "";
            }
            out[out.length] = { t: "Z", v: o.toLowerCase() };
            lst = o.charAt(1);
          } else if (o.indexOf("$") > -1) {
            o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
            if (!fmt_is_date(fmt)) out[out.length] = { t: "t", v: o };
          }
          break;
        /* Numbers */
        case ".":
          if (dt != null) {
            o = c;
            while (++i < fmt.length && (c = fmt.charAt(i)) === "0") o += c;
            out[out.length] = { t: "s", v: o };
            break;
          }
        /* falls through */
        case "0":
        case "#":
          o = c;
          while (++i < fmt.length && "0#?.,E+-%".indexOf(c = fmt.charAt(i)) > -1) o += c;
          out[out.length] = { t: "n", v: o };
          break;
        case "?":
          o = c;
          while (fmt.charAt(++i) === c) o += c;
          out[out.length] = { t: c, v: o };
          lst = c;
          break;
        case "*":
          ++i;
          if (fmt.charAt(i) == " " || fmt.charAt(i) == "*") ++i;
          break;
        // **
        case "(":
        case ")":
          out[out.length] = { t: flen === 1 ? "t" : c, v: c };
          ++i;
          break;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          o = c;
          while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) o += fmt.charAt(i);
          out[out.length] = { t: "D", v: o };
          break;
        case " ":
          out[out.length] = { t: c, v: c };
          ++i;
          break;
        case "$":
          out[out.length] = { t: "t", v: "$" };
          ++i;
          break;
        default:
          if (",$-+/():!^&'~{}<>=\u20ACacfijklopqrtuvwxzP".indexOf(c) === -1) throw new Error("unrecognized character " + c + " in " + fmt);
          out[out.length] = { t: "t", v: c };
          ++i;
          break;
      }
    }
    var bt = 0, ss0 = 0, ssm;
    for (i = out.length - 1, lst = "t"; i >= 0; --i) {
      switch (out[i].t) {
        case "h":
        case "H":
          out[i].t = hr;
          lst = "h";
          if (bt < 1) bt = 1;
          break;
        case "s":
          if (ssm = out[i].v.match(/\.0+$/)) ss0 = Math.max(ss0, ssm[0].length - 1);
          if (bt < 3) bt = 3;
        /* falls through */
        case "d":
        case "y":
        case "M":
        case "e":
          lst = out[i].t;
          break;
        case "m":
          if (lst === "s") {
            out[i].t = "M";
            if (bt < 2) bt = 2;
          }
          break;
        case "X":
          break;
        case "Z":
          if (bt < 1 && out[i].v.match(/[Hh]/)) bt = 1;
          if (bt < 2 && out[i].v.match(/[Mm]/)) bt = 2;
          if (bt < 3 && out[i].v.match(/[Ss]/)) bt = 3;
      }
    }
    switch (bt) {
      case 0:
        break;
      case 1:
        if (dt.u >= 0.5) {
          dt.u = 0;
          ++dt.S;
        }
        if (dt.S >= 60) {
          dt.S = 0;
          ++dt.M;
        }
        if (dt.M >= 60) {
          dt.M = 0;
          ++dt.H;
        }
        break;
      case 2:
        if (dt.u >= 0.5) {
          dt.u = 0;
          ++dt.S;
        }
        if (dt.S >= 60) {
          dt.S = 0;
          ++dt.M;
        }
        break;
    }
    var nstr = "", jj;
    for (i = 0; i < out.length; ++i) {
      switch (out[i].t) {
        case "t":
        case "T":
        case " ":
        case "D":
          break;
        case "X":
          out[i].v = "";
          out[i].t = ";";
          break;
        case "d":
        case "m":
        case "y":
        case "h":
        case "H":
        case "M":
        case "s":
        case "e":
        case "b":
        case "Z":
          out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
          out[i].t = "t";
          break;
        case "n":
        case "?":
          jj = i + 1;
          while (out[jj] != null && ((c = out[jj].t) === "?" || c === "D" || (c === " " || c === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c === " " || c === "n" || c === ")") || c === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
            out[i].v += out[jj].v;
            out[jj] = { v: "", t: ";" };
            ++jj;
          }
          nstr += out[i].v;
          i = jj - 1;
          break;
        case "G":
          out[i].t = "t";
          out[i].v = SSF_general(v, opts);
          break;
      }
    }
    var vv = "", myv, ostr;
    if (nstr.length > 0) {
      if (nstr.charCodeAt(0) == 40) {
        myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
        ostr = write_num("n", nstr, myv);
      } else {
        myv = v < 0 && flen > 1 ? -v : v;
        ostr = write_num("n", nstr, myv);
        if (myv < 0 && out[0] && out[0].t == "t") {
          ostr = ostr.substr(1);
          out[0].v = "-" + out[0].v;
        }
      }
      jj = ostr.length - 1;
      var decpt = out.length;
      for (i = 0; i < out.length; ++i) if (out[i] != null && out[i].t != "t" && out[i].v.indexOf(".") > -1) {
        decpt = i;
        break;
      }
      var lasti = out.length;
      if (decpt === out.length && ostr.indexOf("E") === -1) {
        for (i = out.length - 1; i >= 0; --i) {
          if (out[i] == null || "n?".indexOf(out[i].t) === -1) continue;
          if (jj >= out[i].v.length - 1) {
            jj -= out[i].v.length;
            out[i].v = ostr.substr(jj + 1, out[i].v.length);
          } else if (jj < 0) out[i].v = "";
          else {
            out[i].v = ostr.substr(0, jj + 1);
            jj = -1;
          }
          out[i].t = "t";
          lasti = i;
        }
        if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
      } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
        jj = ostr.indexOf(".") - 1;
        for (i = decpt; i >= 0; --i) {
          if (out[i] == null || "n?".indexOf(out[i].t) === -1) continue;
          j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
          vv = out[i].v.substr(j + 1);
          for (; j >= 0; --j) {
            if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#")) vv = ostr.charAt(jj--) + vv;
          }
          out[i].v = vv;
          out[i].t = "t";
          lasti = i;
        }
        if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
        jj = ostr.indexOf(".") + 1;
        for (i = decpt; i < out.length; ++i) {
          if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt) continue;
          j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
          vv = out[i].v.substr(0, j);
          for (; j < out[i].v.length; ++j) {
            if (jj < ostr.length) vv += ostr.charAt(jj++);
          }
          out[i].v = vv;
          out[i].t = "t";
          lasti = i;
        }
      }
    }
    for (i = 0; i < out.length; ++i) if (out[i] != null && "n?".indexOf(out[i].t) > -1) {
      myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
      out[i].v = write_num(out[i].t, out[i].v, myv);
      out[i].t = "t";
    }
    var retval = "";
    for (i = 0; i !== out.length; ++i) if (out[i] != null) retval += out[i].v;
    return retval;
  }
  var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
  function chkcond(v, rr) {
    if (rr == null) return false;
    var thresh = parseFloat(rr[2]);
    switch (rr[1]) {
      case "=":
        if (v == thresh) return true;
        break;
      case ">":
        if (v > thresh) return true;
        break;
      case "<":
        if (v < thresh) return true;
        break;
      case "<>":
        if (v != thresh) return true;
        break;
      case ">=":
        if (v >= thresh) return true;
        break;
      case "<=":
        if (v <= thresh) return true;
        break;
    }
    return false;
  }
  function choose_fmt(f, v) {
    var fmt = SSF_split_fmt(f);
    var l = fmt.length, lat = fmt[l - 1].indexOf("@");
    if (l < 4 && lat > -1) --l;
    if (fmt.length > 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");
    if (typeof v !== "number") return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
    switch (fmt.length) {
      case 1:
        fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
        break;
      case 2:
        fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
        break;
      case 3:
        fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
        break;
      case 4:
        break;
    }
    var ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
    if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1) return [l, ff];
    if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
      var m1 = fmt[0].match(cfregex2);
      var m2 = fmt[1].match(cfregex2);
      return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null && m2 != null ? 2 : 1]];
    }
    return [l, ff];
  }
  function SSF_format(fmt, v, o) {
    if (o == null) o = {};
    var sfmt = "";
    switch (typeof fmt) {
      case "string":
        if (fmt == "m/d/yy" && o.dateNF) sfmt = o.dateNF;
        else sfmt = fmt;
        break;
      case "number":
        if (fmt == 14 && o.dateNF) sfmt = o.dateNF;
        else sfmt = (o.table != null ? o.table : table_fmt)[fmt];
        if (sfmt == null) sfmt = o.table && o.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
        if (sfmt == null) sfmt = SSF_default_str[fmt] || "General";
        break;
    }
    if (SSF_isgeneral(sfmt, 0)) return SSF_general(v, o);
    if (v instanceof Date) v = datenum_local(v, o.date1904);
    var f = choose_fmt(sfmt, v);
    if (SSF_isgeneral(f[1])) return SSF_general(v, o);
    if (v === true) v = "TRUE";
    else if (v === false) v = "FALSE";
    else if (v === "" || v == null) return "";
    return eval_fmt(f[1], v, o, f[0]);
  }
  function SSF_load(fmt, idx) {
    if (typeof idx != "number") {
      idx = +idx || -1;
      for (var i = 0; i < 392; ++i) {
        if (table_fmt[i] == void 0) {
          if (idx < 0) idx = i;
          continue;
        }
        if (table_fmt[i] == fmt) {
          idx = i;
          break;
        }
      }
      if (idx < 0) idx = 391;
    }
    table_fmt[idx] = fmt;
    return idx;
  }
  function SSF_load_table(tbl) {
    for (var i = 0; i != 392; ++i)
      if (tbl[i] !== void 0) SSF_load(tbl[i], i);
  }
  function make_ssf() {
    table_fmt = SSF_init_table();
  }
  var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
  function dateNF_regex(dateNF) {
    var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
    fmt = fmt.replace(dateNFregex, "(\\d+)");
    return new RegExp("^" + fmt + "$");
  }
  function dateNF_fix(str, dateNF, match) {
    var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;
    (dateNF.match(dateNFregex) || []).forEach(function(n, i) {
      var v = parseInt(match[i + 1], 10);
      switch (n.toLowerCase().charAt(0)) {
        case "y":
          Y = v;
          break;
        case "d":
          d = v;
          break;
        case "h":
          H = v;
          break;
        case "s":
          S = v;
          break;
        case "m":
          if (H >= 0) M = v;
          else m = v;
          break;
      }
    });
    if (S >= 0 && M == -1 && m >= 0) {
      M = m;
      m = -1;
    }
    var datestr = ("" + (Y >= 0 ? Y : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m >= 1 ? m : 1)).slice(-2) + "-" + ("00" + (d >= 1 ? d : 1)).slice(-2);
    if (datestr.length == 7) datestr = "0" + datestr;
    if (datestr.length == 8) datestr = "20" + datestr;
    var timestr = ("00" + (H >= 0 ? H : 0)).slice(-2) + ":" + ("00" + (M >= 0 ? M : 0)).slice(-2) + ":" + ("00" + (S >= 0 ? S : 0)).slice(-2);
    if (H == -1 && M == -1 && S == -1) return datestr;
    if (Y == -1 && m == -1 && d == -1) return timestr;
    return datestr + "T" + timestr;
  }
  var CRC32 = /* @__PURE__ */ (function() {
    var CRC322 = {};
    CRC322.version = "1.2.0";
    function signed_crc_table() {
      var c = 0, table = new Array(256);
      for (var n = 0; n != 256; ++n) {
        c = n;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }
      return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
      for (n = 0; n != 256; ++n) table[n] = T[n];
      for (n = 0; n != 256; ++n) {
        v = T[n];
        for (c = 256 + n; c < 4096; c += 256) v = table[c] = v >>> 8 ^ T[v & 255];
      }
      var out = [];
      for (n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      return out;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length; i < L; ) C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (; i < L; ) C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L) C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
        c = str.charCodeAt(i++);
        if (c < 128) {
          C = C >>> 8 ^ T0[(C ^ c) & 255];
        } else if (c < 2048) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        } else if (c >= 55296 && c < 57344) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        }
      }
      return ~C;
    }
    CRC322.table = T0;
    CRC322.bstr = crc32_bstr;
    CRC322.buf = crc32_buf;
    CRC322.str = crc32_str;
    return CRC322;
  })();
  var CFB = /* @__PURE__ */ (function _CFB() {
    var exports = {};
    exports.version = "1.2.1";
    function namecmp(l, r) {
      var L = l.split("/"), R = r.split("/");
      for (var i2 = 0, c = 0, Z = Math.min(L.length, R.length); i2 < Z; ++i2) {
        if (c = L[i2].length - R[i2].length) return c;
        if (L[i2] != R[i2]) return L[i2] < R[i2] ? -1 : 1;
      }
      return L.length - R.length;
    }
    function dirname(p) {
      if (p.charAt(p.length - 1) == "/") return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
      var c = p.lastIndexOf("/");
      return c === -1 ? p : p.slice(0, c + 1);
    }
    function filename(p) {
      if (p.charAt(p.length - 1) == "/") return filename(p.slice(0, -1));
      var c = p.lastIndexOf("/");
      return c === -1 ? p : p.slice(c + 1);
    }
    function write_dos_date(buf, date) {
      if (typeof date === "string") date = new Date(date);
      var hms = date.getHours();
      hms = hms << 6 | date.getMinutes();
      hms = hms << 5 | date.getSeconds() >>> 1;
      buf.write_shift(2, hms);
      var ymd = date.getFullYear() - 1980;
      ymd = ymd << 4 | date.getMonth() + 1;
      ymd = ymd << 5 | date.getDate();
      buf.write_shift(2, ymd);
    }
    function parse_dos_date(buf) {
      var hms = buf.read_shift(2) & 65535;
      var ymd = buf.read_shift(2) & 65535;
      var val = /* @__PURE__ */ new Date();
      var d = ymd & 31;
      ymd >>>= 5;
      var m = ymd & 15;
      ymd >>>= 4;
      val.setMilliseconds(0);
      val.setFullYear(ymd + 1980);
      val.setMonth(m - 1);
      val.setDate(d);
      var S = hms & 31;
      hms >>>= 5;
      var M = hms & 63;
      hms >>>= 6;
      val.setHours(hms);
      val.setMinutes(M);
      val.setSeconds(S << 1);
      return val;
    }
    function parse_extra_field(blob) {
      prep_blob(blob, 0);
      var o = (
        /*::(*/
        {}
      );
      var flags = 0;
      while (blob.l <= blob.length - 4) {
        var type = blob.read_shift(2);
        var sz = blob.read_shift(2), tgt = blob.l + sz;
        var p = {};
        switch (type) {
          /* UNIX-style Timestamps */
          case 21589:
            {
              flags = blob.read_shift(1);
              if (flags & 1) p.mtime = blob.read_shift(4);
              if (sz > 5) {
                if (flags & 2) p.atime = blob.read_shift(4);
                if (flags & 4) p.ctime = blob.read_shift(4);
              }
              if (p.mtime) p.mt = new Date(p.mtime * 1e3);
            }
            break;
        }
        blob.l = tgt;
        o[type] = p;
      }
      return o;
    }
    var fs;
    function get_fs() {
      return fs || (fs = {});
    }
    function parse(file, options) {
      if (file[0] == 80 && file[1] == 75) return parse_zip(file, options);
      if ((file[0] | 32) == 109 && (file[1] | 32) == 105) return parse_mad(file, options);
      if (file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
      var mver = 3;
      var ssz = 512;
      var nmfs = 0;
      var difat_sec_cnt = 0;
      var dir_start = 0;
      var minifat_start = 0;
      var difat_start = 0;
      var fat_addrs = [];
      var blob = (
        /*::(*/
        file.slice(0, 512)
      );
      prep_blob(blob, 0);
      var mv = check_get_mver(blob);
      mver = mv[0];
      switch (mver) {
        case 3:
          ssz = 512;
          break;
        case 4:
          ssz = 4096;
          break;
        case 0:
          if (mv[1] == 0) return parse_zip(file, options);
        /* falls through */
        default:
          throw new Error("Major Version: Expected 3 or 4 saw " + mver);
      }
      if (ssz !== 512) {
        blob = /*::(*/
        file.slice(0, ssz);
        prep_blob(
          blob,
          28
          /* blob.l */
        );
      }
      var header = file.slice(0, ssz);
      check_shifts(blob, mver);
      var dir_cnt = blob.read_shift(4, "i");
      if (mver === 3 && dir_cnt !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
      blob.l += 4;
      dir_start = blob.read_shift(4, "i");
      blob.l += 4;
      blob.chk("00100000", "Mini Stream Cutoff Size: ");
      minifat_start = blob.read_shift(4, "i");
      nmfs = blob.read_shift(4, "i");
      difat_start = blob.read_shift(4, "i");
      difat_sec_cnt = blob.read_shift(4, "i");
      for (var q2 = -1, j = 0; j < 109; ++j) {
        q2 = blob.read_shift(4, "i");
        if (q2 < 0) break;
        fat_addrs[j] = q2;
      }
      var sectors = sectorify(file, ssz);
      sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
      var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
      sector_list[dir_start].name = "!Directory";
      if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
      sector_list[fat_addrs[0]].name = "!FAT";
      sector_list.fat_addrs = fat_addrs;
      sector_list.ssz = ssz;
      var files = {}, Paths = [], FileIndex = [], FullPaths = [];
      read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
      build_full_paths(FileIndex, FullPaths, Paths);
      Paths.shift();
      var o = {
        FileIndex,
        FullPaths
      };
      if (options && options.raw) o.raw = { header, sectors };
      return o;
    }
    function check_get_mver(blob) {
      if (blob[blob.l] == 80 && blob[blob.l + 1] == 75) return [0, 0];
      blob.chk(HEADER_SIGNATURE, "Header Signature: ");
      blob.l += 16;
      var mver = blob.read_shift(2, "u");
      return [blob.read_shift(2, "u"), mver];
    }
    function check_shifts(blob, mver) {
      var shift = 9;
      blob.l += 2;
      switch (shift = blob.read_shift(2)) {
        case 9:
          if (mver != 3) throw new Error("Sector Shift: Expected 9 saw " + shift);
          break;
        case 12:
          if (mver != 4) throw new Error("Sector Shift: Expected 12 saw " + shift);
          break;
        default:
          throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
      }
      blob.chk("0600", "Mini Sector Shift: ");
      blob.chk("000000000000", "Reserved: ");
    }
    function sectorify(file, ssz) {
      var nsectors = Math.ceil(file.length / ssz) - 1;
      var sectors = [];
      for (var i2 = 1; i2 < nsectors; ++i2) sectors[i2 - 1] = file.slice(i2 * ssz, (i2 + 1) * ssz);
      sectors[nsectors - 1] = file.slice(nsectors * ssz);
      return sectors;
    }
    function build_full_paths(FI, FP, Paths) {
      var i2 = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
      var dad = [], q2 = [];
      for (; i2 < pl; ++i2) {
        dad[i2] = q2[i2] = i2;
        FP[i2] = Paths[i2];
      }
      for (; j < q2.length; ++j) {
        i2 = q2[j];
        L = FI[i2].L;
        R = FI[i2].R;
        C = FI[i2].C;
        if (dad[i2] === i2) {
          if (L !== -1 && dad[L] !== L) dad[i2] = dad[L];
          if (R !== -1 && dad[R] !== R) dad[i2] = dad[R];
        }
        if (C !== -1) dad[C] = i2;
        if (L !== -1 && i2 != dad[i2]) {
          dad[L] = dad[i2];
          if (q2.lastIndexOf(L) < j) q2.push(L);
        }
        if (R !== -1 && i2 != dad[i2]) {
          dad[R] = dad[i2];
          if (q2.lastIndexOf(R) < j) q2.push(R);
        }
      }
      for (i2 = 1; i2 < pl; ++i2) if (dad[i2] === i2) {
        if (R !== -1 && dad[R] !== R) dad[i2] = dad[R];
        else if (L !== -1 && dad[L] !== L) dad[i2] = dad[L];
      }
      for (i2 = 1; i2 < pl; ++i2) {
        if (FI[i2].type === 0) continue;
        j = i2;
        if (j != dad[j]) do {
          j = dad[j];
          FP[i2] = FP[j] + "/" + FP[i2];
        } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
        dad[i2] = -1;
      }
      FP[0] += "/";
      for (i2 = 1; i2 < pl; ++i2) {
        if (FI[i2].type !== 2) FP[i2] += "/";
      }
    }
    function get_mfat_entry(entry, payload, mini) {
      var start = entry.start, size = entry.size;
      var o = [];
      var idx = start;
      while (mini && size > 0 && idx >= 0) {
        o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
        size -= MSSZ;
        idx = __readInt32LE(mini, idx * 4);
      }
      if (o.length === 0) return new_buf(0);
      return bconcat(o).slice(0, entry.size);
    }
    function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
      var q2 = ENDOFCHAIN;
      if (idx === ENDOFCHAIN) {
        if (cnt !== 0) throw new Error("DIFAT chain shorter than expected");
      } else if (idx !== -1) {
        var sector = sectors[idx], m = (ssz >>> 2) - 1;
        if (!sector) return;
        for (var i2 = 0; i2 < m; ++i2) {
          if ((q2 = __readInt32LE(sector, i2 * 4)) === ENDOFCHAIN) break;
          fat_addrs.push(q2);
        }
        sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
      }
    }
    function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
      var buf = [], buf_chain = [];
      if (!chkd) chkd = [];
      var modulus = ssz - 1, j = 0, jj = 0;
      for (j = start; j >= 0; ) {
        chkd[j] = true;
        buf[buf.length] = j;
        buf_chain.push(sectors[j]);
        var addr = fat_addrs[Math.floor(j * 4 / ssz)];
        jj = j * 4 & modulus;
        if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
        if (!sectors[addr]) break;
        j = __readInt32LE(sectors[addr], jj);
      }
      return { nodes: buf, data: __toBuffer([buf_chain]) };
    }
    function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
      var sl = sectors.length, sector_list = [];
      var chkd = [], buf = [], buf_chain = [];
      var modulus = ssz - 1, i2 = 0, j = 0, k = 0, jj = 0;
      for (i2 = 0; i2 < sl; ++i2) {
        buf = [];
        k = i2 + dir_start;
        if (k >= sl) k -= sl;
        if (chkd[k]) continue;
        buf_chain = [];
        var seen = [];
        for (j = k; j >= 0; ) {
          seen[j] = true;
          chkd[j] = true;
          buf[buf.length] = j;
          buf_chain.push(sectors[j]);
          var addr = fat_addrs[Math.floor(j * 4 / ssz)];
          jj = j * 4 & modulus;
          if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
          if (!sectors[addr]) break;
          j = __readInt32LE(sectors[addr], jj);
          if (seen[j]) break;
        }
        sector_list[k] = { nodes: buf, data: __toBuffer([buf_chain]) };
      }
      return sector_list;
    }
    function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
      var minifat_store = 0, pl = Paths.length ? 2 : 0;
      var sector = sector_list[dir_start].data;
      var i2 = 0, namelen = 0, name;
      for (; i2 < sector.length; i2 += 128) {
        var blob = (
          /*::(*/
          sector.slice(i2, i2 + 128)
        );
        prep_blob(blob, 64);
        namelen = blob.read_shift(2);
        name = __utf16le(blob, 0, namelen - pl);
        Paths.push(name);
        var o = {
          name,
          type: blob.read_shift(1),
          color: blob.read_shift(1),
          L: blob.read_shift(4, "i"),
          R: blob.read_shift(4, "i"),
          C: blob.read_shift(4, "i"),
          clsid: blob.read_shift(16),
          state: blob.read_shift(4, "i"),
          start: 0,
          size: 0
        };
        var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
        if (ctime !== 0) o.ct = read_date(blob, blob.l - 8);
        var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
        if (mtime !== 0) o.mt = read_date(blob, blob.l - 8);
        o.start = blob.read_shift(4, "i");
        o.size = blob.read_shift(4, "i");
        if (o.size < 0 && o.start < 0) {
          o.size = o.type = 0;
          o.start = ENDOFCHAIN;
          o.name = "";
        }
        if (o.type === 5) {
          minifat_store = o.start;
          if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
        } else if (o.size >= 4096) {
          o.storage = "fat";
          if (sector_list[o.start] === void 0) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
          sector_list[o.start].name = o.name;
          o.content = sector_list[o.start].data.slice(0, o.size);
        } else {
          o.storage = "minifat";
          if (o.size < 0) o.size = 0;
          else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
            o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
          }
        }
        if (o.content) prep_blob(o.content, 0);
        files[name] = o;
        FileIndex.push(o);
      }
    }
    function read_date(blob, offset) {
      return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
    }
    function read_file(filename2, options) {
      get_fs();
      return parse(fs.readFileSync(filename2), options);
    }
    function read(blob, options) {
      var type = options && options.type;
      if (!type) {
        if (has_buf && Buffer.isBuffer(blob)) type = "buffer";
      }
      switch (type || "base64") {
        case "file":
          return read_file(blob, options);
        case "base64":
          return parse(s2a(Base64_decode(blob)), options);
        case "binary":
          return parse(s2a(blob), options);
      }
      return parse(
        /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
        blob,
        options
      );
    }
    function init_cfb(cfb, opts) {
      var o = opts || {}, root = o.root || "Root Entry";
      if (!cfb.FullPaths) cfb.FullPaths = [];
      if (!cfb.FileIndex) cfb.FileIndex = [];
      if (cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");
      if (cfb.FullPaths.length === 0) {
        cfb.FullPaths[0] = root + "/";
        cfb.FileIndex[0] = { name: root, type: 5 };
      }
      if (o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;
      seed_cfb(cfb);
    }
    function seed_cfb(cfb) {
      var nm = "Sh33tJ5";
      if (CFB.find(cfb, "/" + nm)) return;
      var p = new_buf(4);
      p[0] = 55;
      p[1] = p[3] = 50;
      p[2] = 54;
      cfb.FileIndex.push({ name: nm, type: 2, content: p, size: 4, L: 69, R: 69, C: 69 });
      cfb.FullPaths.push(cfb.FullPaths[0] + nm);
      rebuild_cfb(cfb);
    }
    function rebuild_cfb(cfb, f) {
      init_cfb(cfb);
      var gc = false, s = false;
      for (var i2 = cfb.FullPaths.length - 1; i2 >= 0; --i2) {
        var _file = cfb.FileIndex[i2];
        switch (_file.type) {
          case 0:
            if (s) gc = true;
            else {
              cfb.FileIndex.pop();
              cfb.FullPaths.pop();
            }
            break;
          case 1:
          case 2:
          case 5:
            s = true;
            if (isNaN(_file.R * _file.L * _file.C)) gc = true;
            if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;
            break;
          default:
            gc = true;
            break;
        }
      }
      if (!gc && !f) return;
      var now = new Date(1987, 1, 19), j = 0;
      var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
      var data = [];
      for (i2 = 0; i2 < cfb.FullPaths.length; ++i2) {
        fullPaths[cfb.FullPaths[i2]] = true;
        if (cfb.FileIndex[i2].type === 0) continue;
        data.push([cfb.FullPaths[i2], cfb.FileIndex[i2]]);
      }
      for (i2 = 0; i2 < data.length; ++i2) {
        var dad = dirname(data[i2][0]);
        s = fullPaths[dad];
        if (!s) {
          data.push([dad, {
            name: filename(dad).replace("/", ""),
            type: 1,
            clsid: HEADER_CLSID,
            ct: now,
            mt: now,
            content: null
          }]);
          fullPaths[dad] = true;
        }
      }
      data.sort(function(x, y) {
        return namecmp(x[0], y[0]);
      });
      cfb.FullPaths = [];
      cfb.FileIndex = [];
      for (i2 = 0; i2 < data.length; ++i2) {
        cfb.FullPaths[i2] = data[i2][0];
        cfb.FileIndex[i2] = data[i2][1];
      }
      for (i2 = 0; i2 < data.length; ++i2) {
        var elt = cfb.FileIndex[i2];
        var nm = cfb.FullPaths[i2];
        elt.name = filename(nm).replace("/", "");
        elt.L = elt.R = elt.C = -(elt.color = 1);
        elt.size = elt.content ? elt.content.length : 0;
        elt.start = 0;
        elt.clsid = elt.clsid || HEADER_CLSID;
        if (i2 === 0) {
          elt.C = data.length > 1 ? 1 : -1;
          elt.size = 0;
          elt.type = 5;
        } else if (nm.slice(-1) == "/") {
          for (j = i2 + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == nm) break;
          elt.C = j >= data.length ? -1 : j;
          for (j = i2 + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == dirname(nm)) break;
          elt.R = j >= data.length ? -1 : j;
          elt.type = 1;
        } else {
          if (dirname(cfb.FullPaths[i2 + 1] || "") == dirname(nm)) elt.R = i2 + 1;
          elt.type = 2;
        }
      }
    }
    function _write(cfb, options) {
      var _opts = options || {};
      if (_opts.fileType == "mad") return write_mad(cfb, _opts);
      rebuild_cfb(cfb);
      switch (_opts.fileType) {
        case "zip":
          return write_zip2(cfb, _opts);
      }
      var L = (function(cfb2) {
        var mini_size = 0, fat_size = 0;
        for (var i3 = 0; i3 < cfb2.FileIndex.length; ++i3) {
          var file2 = cfb2.FileIndex[i3];
          if (!file2.content) continue;
          var flen2 = file2.content.length;
          if (flen2 > 0) {
            if (flen2 < 4096) mini_size += flen2 + 63 >> 6;
            else fat_size += flen2 + 511 >> 9;
          }
        }
        var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
        var mini_cnt = mini_size + 7 >> 3;
        var mfat_cnt = mini_size + 127 >> 7;
        var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
        var fat_cnt = fat_base + 127 >> 7;
        var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
        while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt) difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
        var L2 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
        cfb2.FileIndex[0].size = mini_size << 6;
        L2[7] = (cfb2.FileIndex[0].start = L2[0] + L2[1] + L2[2] + L2[3] + L2[4] + L2[5]) + (L2[6] + 7 >> 3);
        return L2;
      })(cfb);
      var o = new_buf(L[7] << 9);
      var i2 = 0, T = 0;
      {
        for (i2 = 0; i2 < 8; ++i2) o.write_shift(1, HEADER_SIG[i2]);
        for (i2 = 0; i2 < 8; ++i2) o.write_shift(2, 0);
        o.write_shift(2, 62);
        o.write_shift(2, 3);
        o.write_shift(2, 65534);
        o.write_shift(2, 9);
        o.write_shift(2, 6);
        for (i2 = 0; i2 < 3; ++i2) o.write_shift(2, 0);
        o.write_shift(4, 0);
        o.write_shift(4, L[2]);
        o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
        o.write_shift(4, 0);
        o.write_shift(4, 1 << 12);
        o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
        o.write_shift(4, L[3]);
        o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
        o.write_shift(4, L[1]);
        for (i2 = 0; i2 < 109; ++i2) o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
      }
      if (L[1]) {
        for (T = 0; T < L[1]; ++T) {
          for (; i2 < 236 + T * 127; ++i2) o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
          o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
        }
      }
      var chainit = function(w) {
        for (T += w; i2 < T - 1; ++i2) o.write_shift(-4, i2 + 1);
        if (w) {
          ++i2;
          o.write_shift(-4, ENDOFCHAIN);
        }
      };
      T = i2 = 0;
      for (T += L[1]; i2 < T; ++i2) o.write_shift(-4, consts.DIFSECT);
      for (T += L[2]; i2 < T; ++i2) o.write_shift(-4, consts.FATSECT);
      chainit(L[3]);
      chainit(L[4]);
      var j = 0, flen = 0;
      var file = cfb.FileIndex[0];
      for (; j < cfb.FileIndex.length; ++j) {
        file = cfb.FileIndex[j];
        if (!file.content) continue;
        flen = file.content.length;
        if (flen < 4096) continue;
        file.start = T;
        chainit(flen + 511 >> 9);
      }
      chainit(L[6] + 7 >> 3);
      while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
      T = i2 = 0;
      for (j = 0; j < cfb.FileIndex.length; ++j) {
        file = cfb.FileIndex[j];
        if (!file.content) continue;
        flen = file.content.length;
        if (!flen || flen >= 4096) continue;
        file.start = T;
        chainit(flen + 63 >> 6);
      }
      while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
      for (i2 = 0; i2 < L[4] << 2; ++i2) {
        var nm = cfb.FullPaths[i2];
        if (!nm || nm.length === 0) {
          for (j = 0; j < 17; ++j) o.write_shift(4, 0);
          for (j = 0; j < 3; ++j) o.write_shift(4, -1);
          for (j = 0; j < 12; ++j) o.write_shift(4, 0);
          continue;
        }
        file = cfb.FileIndex[i2];
        if (i2 === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
        var _nm = i2 === 0 && _opts.root || file.name;
        flen = 2 * (_nm.length + 1);
        o.write_shift(64, _nm, "utf16le");
        o.write_shift(2, flen);
        o.write_shift(1, file.type);
        o.write_shift(1, file.color);
        o.write_shift(-4, file.L);
        o.write_shift(-4, file.R);
        o.write_shift(-4, file.C);
        if (!file.clsid) for (j = 0; j < 4; ++j) o.write_shift(4, 0);
        else o.write_shift(16, file.clsid, "hex");
        o.write_shift(4, file.state || 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(4, file.start);
        o.write_shift(4, file.size);
        o.write_shift(4, 0);
      }
      for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
        file = cfb.FileIndex[i2];
        if (file.size >= 4096) {
          o.l = file.start + 1 << 9;
          if (has_buf && Buffer.isBuffer(file.content)) {
            file.content.copy(o, o.l, 0, file.size);
            o.l += file.size + 511 & -512;
          } else {
            for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
            for (; j & 511; ++j) o.write_shift(1, 0);
          }
        }
      }
      for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
        file = cfb.FileIndex[i2];
        if (file.size > 0 && file.size < 4096) {
          if (has_buf && Buffer.isBuffer(file.content)) {
            file.content.copy(o, o.l, 0, file.size);
            o.l += file.size + 63 & -64;
          } else {
            for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
            for (; j & 63; ++j) o.write_shift(1, 0);
          }
        }
      }
      if (has_buf) {
        o.l = o.length;
      } else {
        while (o.l < o.length) o.write_shift(1, 0);
      }
      return o;
    }
    function find(cfb, path) {
      var UCFullPaths = cfb.FullPaths.map(function(x) {
        return x.toUpperCase();
      });
      var UCPaths = UCFullPaths.map(function(x) {
        var y = x.split("/");
        return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
      });
      var k = false;
      if (path.charCodeAt(0) === 47) {
        k = true;
        path = UCFullPaths[0].slice(0, -1) + path;
      } else k = path.indexOf("/") !== -1;
      var UCPath = path.toUpperCase();
      var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
      if (w !== -1) return cfb.FileIndex[w];
      var m = !UCPath.match(chr1);
      UCPath = UCPath.replace(chr0, "");
      if (m) UCPath = UCPath.replace(chr1, "!");
      for (w = 0; w < UCFullPaths.length; ++w) {
        if ((m ? UCFullPaths[w].replace(chr1, "!") : UCFullPaths[w]).replace(chr0, "") == UCPath) return cfb.FileIndex[w];
        if ((m ? UCPaths[w].replace(chr1, "!") : UCPaths[w]).replace(chr0, "") == UCPath) return cfb.FileIndex[w];
      }
      return null;
    }
    var MSSZ = 64;
    var ENDOFCHAIN = -2;
    var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
    var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
    var HEADER_CLSID = "00000000000000000000000000000000";
    var consts = {
      /* 2.1 Compund File Sector Numbers and Types */
      MAXREGSECT: -6,
      DIFSECT: -4,
      FATSECT: -3,
      ENDOFCHAIN,
      FREESECT: -1,
      /* 2.2 Compound File Header */
      HEADER_SIGNATURE,
      HEADER_MINOR_VERSION: "3e00",
      MAXREGSID: -6,
      NOSTREAM: -1,
      HEADER_CLSID,
      /* 2.6.1 Compound File Directory Entry */
      EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
    };
    function write_file(cfb, filename2, options) {
      get_fs();
      var o = _write(cfb, options);
      fs.writeFileSync(filename2, o);
    }
    function a2s2(o) {
      var out = new Array(o.length);
      for (var i2 = 0; i2 < o.length; ++i2) out[i2] = String.fromCharCode(o[i2]);
      return out.join("");
    }
    function write(cfb, options) {
      var o = _write(cfb, options);
      switch (options && options.type || "buffer") {
        case "file":
          get_fs();
          fs.writeFileSync(options.filename, o);
          return o;
        case "binary":
          return typeof o == "string" ? o : a2s2(o);
        case "base64":
          return Base64_encode(typeof o == "string" ? o : a2s2(o));
        case "buffer":
          if (has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);
        /* falls through */
        case "array":
          return typeof o == "string" ? s2a(o) : o;
      }
      return o;
    }
    var _zlib;
    function use_zlib(zlib) {
      try {
        var InflateRaw = zlib.InflateRaw;
        var InflRaw = new InflateRaw();
        InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
        if (InflRaw.bytesRead) _zlib = zlib;
        else throw new Error("zlib does not expose bytesRead");
      } catch (e) {
        console.error("cannot use native zlib: " + (e.message || e));
      }
    }
    function _inflateRawSync(payload, usz) {
      if (!_zlib) return _inflate(payload, usz);
      var InflateRaw = _zlib.InflateRaw;
      var InflRaw = new InflateRaw();
      var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
      payload.l += InflRaw.bytesRead;
      return out;
    }
    function _deflateRawSync(payload) {
      return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
    }
    var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
    var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    function bit_swap_8(n) {
      var t = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
      return (t >> 16 | t >> 8 | t) & 255;
    }
    var use_typed_arrays = typeof Uint8Array !== "undefined";
    var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
    for (var q = 0; q < 1 << 8; ++q) bitswap8[q] = bit_swap_8(q);
    function bit_swap_n(n, b) {
      var rev = bitswap8[n & 255];
      if (b <= 8) return rev >>> 8 - b;
      rev = rev << 8 | bitswap8[n >> 8 & 255];
      if (b <= 16) return rev >>> 16 - b;
      rev = rev << 8 | bitswap8[n >> 16 & 255];
      return rev >>> 24 - b;
    }
    function read_bits_2(buf, bl) {
      var w = bl & 7, h = bl >>> 3;
      return (buf[h] | (w <= 6 ? 0 : buf[h + 1] << 8)) >>> w & 3;
    }
    function read_bits_3(buf, bl) {
      var w = bl & 7, h = bl >>> 3;
      return (buf[h] | (w <= 5 ? 0 : buf[h + 1] << 8)) >>> w & 7;
    }
    function read_bits_4(buf, bl) {
      var w = bl & 7, h = bl >>> 3;
      return (buf[h] | (w <= 4 ? 0 : buf[h + 1] << 8)) >>> w & 15;
    }
    function read_bits_5(buf, bl) {
      var w = bl & 7, h = bl >>> 3;
      return (buf[h] | (w <= 3 ? 0 : buf[h + 1] << 8)) >>> w & 31;
    }
    function read_bits_7(buf, bl) {
      var w = bl & 7, h = bl >>> 3;
      return (buf[h] | (w <= 1 ? 0 : buf[h + 1] << 8)) >>> w & 127;
    }
    function read_bits_n(buf, bl, n) {
      var w = bl & 7, h = bl >>> 3, f = (1 << n) - 1;
      var v = buf[h] >>> w;
      if (n < 8 - w) return v & f;
      v |= buf[h + 1] << 8 - w;
      if (n < 16 - w) return v & f;
      v |= buf[h + 2] << 16 - w;
      if (n < 24 - w) return v & f;
      v |= buf[h + 3] << 24 - w;
      return v & f;
    }
    function write_bits_3(buf, bl, v) {
      var w = bl & 7, h = bl >>> 3;
      if (w <= 5) buf[h] |= (v & 7) << w;
      else {
        buf[h] |= v << w & 255;
        buf[h + 1] = (v & 7) >> 8 - w;
      }
      return bl + 3;
    }
    function write_bits_1(buf, bl, v) {
      var w = bl & 7, h = bl >>> 3;
      v = (v & 1) << w;
      buf[h] |= v;
      return bl + 1;
    }
    function write_bits_8(buf, bl, v) {
      var w = bl & 7, h = bl >>> 3;
      v <<= w;
      buf[h] |= v & 255;
      v >>>= 8;
      buf[h + 1] = v;
      return bl + 8;
    }
    function write_bits_16(buf, bl, v) {
      var w = bl & 7, h = bl >>> 3;
      v <<= w;
      buf[h] |= v & 255;
      v >>>= 8;
      buf[h + 1] = v & 255;
      buf[h + 2] = v >>> 8;
      return bl + 16;
    }
    function realloc(b, sz) {
      var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i2 = 0;
      if (L >= sz) return b;
      if (has_buf) {
        var o = new_unsafe_buf(M);
        if (b.copy) b.copy(o);
        else for (; i2 < b.length; ++i2) o[i2] = b[i2];
        return o;
      } else if (use_typed_arrays) {
        var a = new Uint8Array(M);
        if (a.set) a.set(b);
        else for (; i2 < L; ++i2) a[i2] = b[i2];
        return a;
      }
      b.length = M;
      return b;
    }
    function zero_fill_array(n) {
      var o = new Array(n);
      for (var i2 = 0; i2 < n; ++i2) o[i2] = 0;
      return o;
    }
    function build_tree(clens, cmap, MAX) {
      var maxlen = 1, w = 0, i2 = 0, j = 0, ccode = 0, L = clens.length;
      var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
      for (i2 = 0; i2 < 32; ++i2) bl_count[i2] = 0;
      for (i2 = L; i2 < MAX; ++i2) clens[i2] = 0;
      L = clens.length;
      var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
      for (i2 = 0; i2 < L; ++i2) {
        bl_count[w = clens[i2]]++;
        if (maxlen < w) maxlen = w;
        ctree[i2] = 0;
      }
      bl_count[0] = 0;
      for (i2 = 1; i2 <= maxlen; ++i2) bl_count[i2 + 16] = ccode = ccode + bl_count[i2 - 1] << 1;
      for (i2 = 0; i2 < L; ++i2) {
        ccode = clens[i2];
        if (ccode != 0) ctree[i2] = bl_count[ccode + 16]++;
      }
      var cleni = 0;
      for (i2 = 0; i2 < L; ++i2) {
        cleni = clens[i2];
        if (cleni != 0) {
          ccode = bit_swap_n(ctree[i2], maxlen) >> maxlen - cleni;
          for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j)
            cmap[ccode | j << cleni] = cleni & 15 | i2 << 4;
        }
      }
      return maxlen;
    }
    var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
    var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
    if (!use_typed_arrays) {
      for (var i = 0; i < 512; ++i) fix_lmap[i] = 0;
      for (i = 0; i < 32; ++i) fix_dmap[i] = 0;
    }
    (function() {
      var dlens = [];
      var i2 = 0;
      for (; i2 < 32; i2++) dlens.push(5);
      build_tree(dlens, fix_dmap, 32);
      var clens = [];
      i2 = 0;
      for (; i2 <= 143; i2++) clens.push(8);
      for (; i2 <= 255; i2++) clens.push(9);
      for (; i2 <= 279; i2++) clens.push(7);
      for (; i2 <= 287; i2++) clens.push(8);
      build_tree(clens, fix_lmap, 288);
    })();
    var _deflateRaw = /* @__PURE__ */ (function _deflateRawIIFE() {
      var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
      var j = 0, k = 0;
      for (; j < DST_LN.length - 1; ++j) {
        for (; k < DST_LN[j + 1]; ++k) DST_LN_RE[k] = j;
      }
      for (; k < 32768; ++k) DST_LN_RE[k] = 29;
      var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
      for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
        for (; k < LEN_LN[j + 1]; ++k) LEN_LN_RE[k] = j;
      }
      function write_stored(data, out) {
        var boff = 0;
        while (boff < data.length) {
          var L = Math.min(65535, data.length - boff);
          var h = boff + L == data.length;
          out.write_shift(1, +h);
          out.write_shift(2, L);
          out.write_shift(2, ~L & 65535);
          while (L-- > 0) out[out.l++] = data[boff++];
        }
        return out.l;
      }
      function write_huff_fixed(data, out) {
        var bl = 0;
        var boff = 0;
        var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
        while (boff < data.length) {
          var L = (
            /* data.length - boff; */
            Math.min(65535, data.length - boff)
          );
          if (L < 10) {
            bl = write_bits_3(out, bl, +!!(boff + L == data.length));
            if (bl & 7) bl += 8 - (bl & 7);
            out.l = bl / 8 | 0;
            out.write_shift(2, L);
            out.write_shift(2, ~L & 65535);
            while (L-- > 0) out[out.l++] = data[boff++];
            bl = out.l * 8;
            continue;
          }
          bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2);
          var hash = 0;
          while (L-- > 0) {
            var d = data[boff];
            hash = (hash << 5 ^ d) & 32767;
            var match = -1, mlen = 0;
            if (match = addrs[hash]) {
              match |= boff & ~32767;
              if (match > boff) match -= 32768;
              if (match < boff) while (data[match + mlen] == data[boff + mlen] && mlen < 250) ++mlen;
            }
            if (mlen > 2) {
              d = LEN_LN_RE[mlen];
              if (d <= 22) bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;
              else {
                write_bits_8(out, bl, 3);
                bl += 5;
                write_bits_8(out, bl, bitswap8[d - 23] >> 5);
                bl += 3;
              }
              var len_eb = d < 8 ? 0 : d - 4 >> 2;
              if (len_eb > 0) {
                write_bits_16(out, bl, mlen - LEN_LN[d]);
                bl += len_eb;
              }
              d = DST_LN_RE[boff - match];
              bl = write_bits_8(out, bl, bitswap8[d] >> 3);
              bl -= 3;
              var dst_eb = d < 4 ? 0 : d - 2 >> 1;
              if (dst_eb > 0) {
                write_bits_16(out, bl, boff - match - DST_LN[d]);
                bl += dst_eb;
              }
              for (var q2 = 0; q2 < mlen; ++q2) {
                addrs[hash] = boff & 32767;
                hash = (hash << 5 ^ data[boff]) & 32767;
                ++boff;
              }
              L -= mlen - 1;
            } else {
              if (d <= 143) d = d + 48;
              else bl = write_bits_1(out, bl, 1);
              bl = write_bits_8(out, bl, bitswap8[d]);
              addrs[hash] = boff & 32767;
              ++boff;
            }
          }
          bl = write_bits_8(out, bl, 0) - 1;
        }
        out.l = (bl + 7) / 8 | 0;
        return out.l;
      }
      return function _deflateRaw2(data, out) {
        if (data.length < 8) return write_stored(data, out);
        return write_huff_fixed(data, out);
      };
    })();
    function _deflate(data) {
      var buf = new_buf(50 + Math.floor(data.length * 1.1));
      var off = _deflateRaw(data, buf);
      return buf.slice(0, off);
    }
    var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
    var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
    var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
    var dyn_len_1 = 1, dyn_len_2 = 1;
    function dyn(data, boff) {
      var _HLIT = read_bits_5(data, boff) + 257;
      boff += 5;
      var _HDIST = read_bits_5(data, boff) + 1;
      boff += 5;
      var _HCLEN = read_bits_4(data, boff) + 4;
      boff += 4;
      var w = 0;
      var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
      var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      var maxlen = 1;
      var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
      var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
      var L = clens.length;
      for (var i2 = 0; i2 < _HCLEN; ++i2) {
        clens[CLEN_ORDER[i2]] = w = read_bits_3(data, boff);
        if (maxlen < w) maxlen = w;
        bl_count[w]++;
        boff += 3;
      }
      var ccode = 0;
      bl_count[0] = 0;
      for (i2 = 1; i2 <= maxlen; ++i2) next_code[i2] = ccode = ccode + bl_count[i2 - 1] << 1;
      for (i2 = 0; i2 < L; ++i2) if ((ccode = clens[i2]) != 0) ctree[i2] = next_code[ccode]++;
      var cleni = 0;
      for (i2 = 0; i2 < L; ++i2) {
        cleni = clens[i2];
        if (cleni != 0) {
          ccode = bitswap8[ctree[i2]] >> 8 - cleni;
          for (var j = (1 << 7 - cleni) - 1; j >= 0; --j) dyn_cmap[ccode | j << cleni] = cleni & 7 | i2 << 3;
        }
      }
      var hcodes = [];
      maxlen = 1;
      for (; hcodes.length < _HLIT + _HDIST; ) {
        ccode = dyn_cmap[read_bits_7(data, boff)];
        boff += ccode & 7;
        switch (ccode >>>= 3) {
          case 16:
            w = 3 + read_bits_2(data, boff);
            boff += 2;
            ccode = hcodes[hcodes.length - 1];
            while (w-- > 0) hcodes.push(ccode);
            break;
          case 17:
            w = 3 + read_bits_3(data, boff);
            boff += 3;
            while (w-- > 0) hcodes.push(0);
            break;
          case 18:
            w = 11 + read_bits_7(data, boff);
            boff += 7;
            while (w-- > 0) hcodes.push(0);
            break;
          default:
            hcodes.push(ccode);
            if (maxlen < ccode) maxlen = ccode;
            break;
        }
      }
      var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
      for (i2 = _HLIT; i2 < 286; ++i2) h1[i2] = 0;
      for (i2 = _HDIST; i2 < 30; ++i2) h2[i2] = 0;
      dyn_len_1 = build_tree(h1, dyn_lmap, 286);
      dyn_len_2 = build_tree(h2, dyn_dmap, 30);
      return boff;
    }
    function inflate(data, usz) {
      if (data[0] == 3 && !(data[1] & 3)) {
        return [new_raw_buf(usz), 2];
      }
      var boff = 0;
      var header = 0;
      var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
      var woff = 0;
      var OL = outbuf.length >>> 0;
      var max_len_1 = 0, max_len_2 = 0;
      while ((header & 1) == 0) {
        header = read_bits_3(data, boff);
        boff += 3;
        if (header >>> 1 == 0) {
          if (boff & 7) boff += 8 - (boff & 7);
          var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
          boff += 32;
          if (sz > 0) {
            if (!usz && OL < woff + sz) {
              outbuf = realloc(outbuf, woff + sz);
              OL = outbuf.length;
            }
            while (sz-- > 0) {
              outbuf[woff++] = data[boff >>> 3];
              boff += 8;
            }
          }
          continue;
        } else if (header >> 1 == 1) {
          max_len_1 = 9;
          max_len_2 = 5;
        } else {
          boff = dyn(data, boff);
          max_len_1 = dyn_len_1;
          max_len_2 = dyn_len_2;
        }
        for (; ; ) {
          if (!usz && OL < woff + 32767) {
            outbuf = realloc(outbuf, woff + 32767);
            OL = outbuf.length;
          }
          var bits = read_bits_n(data, boff, max_len_1);
          var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
          boff += code & 15;
          code >>>= 4;
          if ((code >>> 8 & 255) === 0) outbuf[woff++] = code;
          else if (code == 256) break;
          else {
            code -= 257;
            var len_eb = code < 8 ? 0 : code - 4 >> 2;
            if (len_eb > 5) len_eb = 0;
            var tgt = woff + LEN_LN[code];
            if (len_eb > 0) {
              tgt += read_bits_n(data, boff, len_eb);
              boff += len_eb;
            }
            bits = read_bits_n(data, boff, max_len_2);
            code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
            boff += code & 15;
            code >>>= 4;
            var dst_eb = code < 4 ? 0 : code - 2 >> 1;
            var dst = DST_LN[code];
            if (dst_eb > 0) {
              dst += read_bits_n(data, boff, dst_eb);
              boff += dst_eb;
            }
            if (!usz && OL < tgt) {
              outbuf = realloc(outbuf, tgt + 100);
              OL = outbuf.length;
            }
            while (woff < tgt) {
              outbuf[woff] = outbuf[woff - dst];
              ++woff;
            }
          }
        }
      }
      if (usz) return [outbuf, boff + 7 >>> 3];
      return [outbuf.slice(0, woff), boff + 7 >>> 3];
    }
    function _inflate(payload, usz) {
      var data = payload.slice(payload.l || 0);
      var out = inflate(data, usz);
      payload.l += out[1];
      return out[0];
    }
    function warn_or_throw(wrn, msg) {
      if (wrn) {
        if (typeof console !== "undefined") console.error(msg);
      } else throw new Error(msg);
    }
    function parse_zip(file, options) {
      var blob = (
        /*::(*/
        file
      );
      prep_blob(blob, 0);
      var FileIndex = [], FullPaths = [];
      var o = {
        FileIndex,
        FullPaths
      };
      init_cfb(o, { root: options.root });
      var i2 = blob.length - 4;
      while ((blob[i2] != 80 || blob[i2 + 1] != 75 || blob[i2 + 2] != 5 || blob[i2 + 3] != 6) && i2 >= 0) --i2;
      blob.l = i2 + 4;
      blob.l += 4;
      var fcnt = blob.read_shift(2);
      blob.l += 6;
      var start_cd = blob.read_shift(4);
      blob.l = start_cd;
      for (i2 = 0; i2 < fcnt; ++i2) {
        blob.l += 20;
        var csz = blob.read_shift(4);
        var usz = blob.read_shift(4);
        var namelen = blob.read_shift(2);
        var efsz = blob.read_shift(2);
        var fcsz = blob.read_shift(2);
        blob.l += 8;
        var offset = blob.read_shift(4);
        var EF = parse_extra_field(
          /*::(*/
          blob.slice(blob.l + namelen, blob.l + namelen + efsz)
          /*:: :any)*/
        );
        blob.l += namelen + efsz + fcsz;
        var L = blob.l;
        blob.l = offset + 4;
        parse_local_file(blob, csz, usz, o, EF);
        blob.l = L;
      }
      return o;
    }
    function parse_local_file(blob, csz, usz, o, EF) {
      blob.l += 2;
      var flags = blob.read_shift(2);
      var meth = blob.read_shift(2);
      var date = parse_dos_date(blob);
      if (flags & 8257) throw new Error("Unsupported ZIP encryption");
      var crc32 = blob.read_shift(4);
      var _csz = blob.read_shift(4);
      var _usz = blob.read_shift(4);
      var namelen = blob.read_shift(2);
      var efsz = blob.read_shift(2);
      var name = "";
      for (var i2 = 0; i2 < namelen; ++i2) name += String.fromCharCode(blob[blob.l++]);
      if (efsz) {
        var ef = parse_extra_field(
          /*::(*/
          blob.slice(blob.l, blob.l + efsz)
          /*:: :any)*/
        );
        if ((ef[21589] || {}).mt) date = ef[21589].mt;
        if (((EF || {})[21589] || {}).mt) date = EF[21589].mt;
      }
      blob.l += efsz;
      var data = blob.slice(blob.l, blob.l + _csz);
      switch (meth) {
        case 8:
          data = _inflateRawSync(blob, _usz);
          break;
        case 0:
          break;
        // TODO: scan for magic number
        default:
          throw new Error("Unsupported ZIP Compression method " + meth);
      }
      var wrn = false;
      if (flags & 8) {
        crc32 = blob.read_shift(4);
        if (crc32 == 134695760) {
          crc32 = blob.read_shift(4);
          wrn = true;
        }
        _csz = blob.read_shift(4);
        _usz = blob.read_shift(4);
      }
      if (_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
      if (_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
      cfb_add(o, name, data, { unsafe: true, mt: date });
    }
    function write_zip2(cfb, options) {
      var _opts = options || {};
      var out = [], cdirs = [];
      var o = new_buf(1);
      var method = _opts.compression ? 8 : 0, flags = 0;
      var desc = false;
      if (desc) flags |= 8;
      var i2 = 0, j = 0;
      var start_cd = 0, fcnt = 0;
      var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
      var crcs = [];
      var sz_cd = 0;
      for (i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
        fp = cfb.FullPaths[i2].slice(root.length);
        fi = cfb.FileIndex[i2];
        if (!fi.size || !fi.content || fp == "Sh33tJ5") continue;
        var start = start_cd;
        var namebuf = new_buf(fp.length);
        for (j = 0; j < fp.length; ++j) namebuf.write_shift(1, fp.charCodeAt(j) & 127);
        namebuf = namebuf.slice(0, namebuf.l);
        crcs[fcnt] = CRC32.buf(
          /*::((*/
          fi.content,
          0
        );
        var outbuf = fi.content;
        if (method == 8) outbuf = _deflateRawSync(outbuf);
        o = new_buf(30);
        o.write_shift(4, 67324752);
        o.write_shift(2, 20);
        o.write_shift(2, flags);
        o.write_shift(2, method);
        if (fi.mt) write_dos_date(o, fi.mt);
        else o.write_shift(4, 0);
        o.write_shift(-4, flags & 8 ? 0 : crcs[fcnt]);
        o.write_shift(4, flags & 8 ? 0 : outbuf.length);
        o.write_shift(4, flags & 8 ? 0 : (
          /*::(*/
          fi.content.length
        ));
        o.write_shift(2, namebuf.length);
        o.write_shift(2, 0);
        start_cd += o.length;
        out.push(o);
        start_cd += namebuf.length;
        out.push(namebuf);
        start_cd += outbuf.length;
        out.push(outbuf);
        if (flags & 8) {
          o = new_buf(12);
          o.write_shift(-4, crcs[fcnt]);
          o.write_shift(4, outbuf.length);
          o.write_shift(
            4,
            /*::(*/
            fi.content.length
          );
          start_cd += o.l;
          out.push(o);
        }
        o = new_buf(46);
        o.write_shift(4, 33639248);
        o.write_shift(2, 0);
        o.write_shift(2, 20);
        o.write_shift(2, flags);
        o.write_shift(2, method);
        o.write_shift(4, 0);
        o.write_shift(-4, crcs[fcnt]);
        o.write_shift(4, outbuf.length);
        o.write_shift(
          4,
          /*::(*/
          fi.content.length
        );
        o.write_shift(2, namebuf.length);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(4, 0);
        o.write_shift(4, start);
        sz_cd += o.l;
        cdirs.push(o);
        sz_cd += namebuf.length;
        cdirs.push(namebuf);
        ++fcnt;
      }
      o = new_buf(22);
      o.write_shift(4, 101010256);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, fcnt);
      o.write_shift(2, fcnt);
      o.write_shift(4, sz_cd);
      o.write_shift(4, start_cd);
      o.write_shift(2, 0);
      return bconcat([bconcat(out), bconcat(cdirs), o]);
    }
    var ContentTypeMap = {
      "htm": "text/html",
      "xml": "text/xml",
      "gif": "image/gif",
      "jpg": "image/jpeg",
      "png": "image/png",
      "mso": "application/x-mso",
      "thmx": "application/vnd.ms-officetheme",
      "sh33tj5": "application/octet-stream"
    };
    function get_content_type(fi, fp) {
      if (fi.ctype) return fi.ctype;
      var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
      if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
      if (fp) {
        m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
        if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
      }
      return "application/octet-stream";
    }
    function write_base64_76(bstr) {
      var data = Base64_encode(bstr);
      var o = [];
      for (var i2 = 0; i2 < data.length; i2 += 76) o.push(data.slice(i2, i2 + 76));
      return o.join("\r\n") + "\r\n";
    }
    function write_quoted_printable(text) {
      var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {
        var w = c.charCodeAt(0).toString(16).toUpperCase();
        return "=" + (w.length == 1 ? "0" + w : w);
      });
      encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
      if (encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);
      encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
      var o = [], split = encoded.split("\r\n");
      for (var si = 0; si < split.length; ++si) {
        var str = split[si];
        if (str.length == 0) {
          o.push("");
          continue;
        }
        for (var i2 = 0; i2 < str.length; ) {
          var end = 76;
          var tmp = str.slice(i2, i2 + end);
          if (tmp.charAt(end - 1) == "=") end--;
          else if (tmp.charAt(end - 2) == "=") end -= 2;
          else if (tmp.charAt(end - 3) == "=") end -= 3;
          tmp = str.slice(i2, i2 + end);
          i2 += end;
          if (i2 < str.length) tmp += "=";
          o.push(tmp);
        }
      }
      return o.join("\r\n");
    }
    function parse_quoted_printable(data) {
      var o = [];
      for (var di = 0; di < data.length; ++di) {
        var line = data[di];
        while (di <= data.length && line.charAt(line.length - 1) == "=") line = line.slice(0, line.length - 1) + data[++di];
        o.push(line);
      }
      for (var oi = 0; oi < o.length; ++oi) o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
        return String.fromCharCode(parseInt($$.slice(1), 16));
      });
      return s2a(o.join("\r\n"));
    }
    function parse_mime(cfb, data, root) {
      var fname = "", cte = "", ctype = "", fdata;
      var di = 0;
      for (; di < 10; ++di) {
        var line = data[di];
        if (!line || line.match(/^\s*$/)) break;
        var m = line.match(/^(.*?):\s*([^\s].*)$/);
        if (m) switch (m[1].toLowerCase()) {
          case "content-location":
            fname = m[2].trim();
            break;
          case "content-type":
            ctype = m[2].trim();
            break;
          case "content-transfer-encoding":
            cte = m[2].trim();
            break;
        }
      }
      ++di;
      switch (cte.toLowerCase()) {
        case "base64":
          fdata = s2a(Base64_decode(data.slice(di).join("")));
          break;
        case "quoted-printable":
          fdata = parse_quoted_printable(data.slice(di));
          break;
        default:
          throw new Error("Unsupported Content-Transfer-Encoding " + cte);
      }
      var file = cfb_add(cfb, fname.slice(root.length), fdata, { unsafe: true });
      if (ctype) file.ctype = ctype;
    }
    function parse_mad(file, options) {
      if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
      var root = options && options.root || "";
      var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
      var di = 0, row = "";
      for (di = 0; di < data.length; ++di) {
        row = data[di];
        if (!/^Content-Location:/i.test(row)) continue;
        row = row.slice(row.indexOf("file"));
        if (!root) root = row.slice(0, row.lastIndexOf("/") + 1);
        if (row.slice(0, root.length) == root) continue;
        while (root.length > 0) {
          root = root.slice(0, root.length - 1);
          root = root.slice(0, root.lastIndexOf("/") + 1);
          if (row.slice(0, root.length) == root) break;
        }
      }
      var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
      if (!mboundary) throw new Error("MAD cannot find boundary");
      var boundary = "--" + (mboundary[1] || "");
      var FileIndex = [], FullPaths = [];
      var o = {
        FileIndex,
        FullPaths
      };
      init_cfb(o);
      var start_di, fcnt = 0;
      for (di = 0; di < data.length; ++di) {
        var line = data[di];
        if (line !== boundary && line !== boundary + "--") continue;
        if (fcnt++) parse_mime(o, data.slice(start_di, di), root);
        start_di = di;
      }
      return o;
    }
    function write_mad(cfb, options) {
      var opts = options || {};
      var boundary = opts.boundary || "SheetJS";
      boundary = "------=" + boundary;
      var out = [
        "MIME-Version: 1.0",
        'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
        "",
        "",
        ""
      ];
      var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
      for (var i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
        fp = cfb.FullPaths[i2].slice(root.length);
        fi = cfb.FileIndex[i2];
        if (!fi.size || !fi.content || fp == "Sh33tJ5") continue;
        fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {
          return "_x" + c.charCodeAt(0).toString(16) + "_";
        }).replace(/[\u0080-\uFFFF]/g, function(u) {
          return "_u" + u.charCodeAt(0).toString(16) + "_";
        });
        var ca = fi.content;
        var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s2(ca);
        var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
        for (var csl = 0; csl <= L; ++csl) if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128) ++dispcnt;
        var qp = dispcnt >= L * 4 / 5;
        out.push(boundary);
        out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
        out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
        out.push("Content-Type: " + get_content_type(fi, fp));
        out.push("");
        out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
      }
      out.push(boundary + "--\r\n");
      return out.join("\r\n");
    }
    function cfb_new(opts) {
      var o = {};
      init_cfb(o, opts);
      return o;
    }
    function cfb_add(cfb, name, content, opts) {
      var unsafe = opts && opts.unsafe;
      if (!unsafe) init_cfb(cfb);
      var file = !unsafe && CFB.find(cfb, name);
      if (!file) {
        var fpath = cfb.FullPaths[0];
        if (name.slice(0, fpath.length) == fpath) fpath = name;
        else {
          if (fpath.slice(-1) != "/") fpath += "/";
          fpath = (fpath + name).replace("//", "/");
        }
        file = { name: filename(name), type: 2 };
        cfb.FileIndex.push(file);
        cfb.FullPaths.push(fpath);
        if (!unsafe) CFB.utils.cfb_gc(cfb);
      }
      file.content = content;
      file.size = content ? content.length : 0;
      if (opts) {
        if (opts.CLSID) file.clsid = opts.CLSID;
        if (opts.mt) file.mt = opts.mt;
        if (opts.ct) file.ct = opts.ct;
      }
      return file;
    }
    function cfb_del(cfb, name) {
      init_cfb(cfb);
      var file = CFB.find(cfb, name);
      if (file) {
        for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {
          cfb.FileIndex.splice(j, 1);
          cfb.FullPaths.splice(j, 1);
          return true;
        }
      }
      return false;
    }
    function cfb_mov(cfb, old_name, new_name) {
      init_cfb(cfb);
      var file = CFB.find(cfb, old_name);
      if (file) {
        for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {
          cfb.FileIndex[j].name = filename(new_name);
          cfb.FullPaths[j] = new_name;
          return true;
        }
      }
      return false;
    }
    function cfb_gc(cfb) {
      rebuild_cfb(cfb, true);
    }
    exports.find = find;
    exports.read = read;
    exports.parse = parse;
    exports.write = write;
    exports.writeFile = write_file;
    exports.utils = {
      cfb_new,
      cfb_add,
      cfb_del,
      cfb_mov,
      cfb_gc,
      ReadShift,
      CheckField,
      prep_blob,
      bconcat,
      use_zlib,
      _deflateRaw: _deflate,
      _inflateRaw: _inflate,
      consts
    };
    return exports;
  })();
  var _fs = void 0;
  function blobify(data) {
    if (typeof data === "string") return s2ab(data);
    if (Array.isArray(data)) return a2u(data);
    return data;
  }
  function write_dl(fname, payload, enc) {
    if (typeof _fs !== "undefined" && _fs.writeFileSync) return enc ? _fs.writeFileSync(fname, payload, enc) : _fs.writeFileSync(fname, payload);
    if (typeof Deno !== "undefined") {
      if (enc && typeof payload == "string") switch (enc) {
        case "utf8":
          payload = new TextEncoder(enc).encode(payload);
          break;
        case "binary":
          payload = s2ab(payload);
          break;
        /* TODO: binary equivalent */
        default:
          throw new Error("Unsupported encoding " + enc);
      }
      return Deno.writeFileSync(fname, payload);
    }
    var data = enc == "utf8" ? utf8write(payload) : payload;
    if (typeof IE_SaveFile !== "undefined") return IE_SaveFile(data, fname);
    if (typeof Blob !== "undefined") {
      var blob = new Blob([blobify(data)], { type: "application/octet-stream" });
      if (typeof navigator !== "undefined" && navigator.msSaveBlob) return navigator.msSaveBlob(blob, fname);
      if (typeof saveAs !== "undefined") return saveAs(blob, fname);
      if (typeof URL !== "undefined" && typeof document !== "undefined" && document.createElement && URL.createObjectURL) {
        var url = URL.createObjectURL(blob);
        if (typeof chrome === "object" && typeof (chrome.downloads || {}).download == "function") {
          if (URL.revokeObjectURL && typeof setTimeout !== "undefined") setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
          return chrome.downloads.download({ url, filename: fname, saveAs: true });
        }
        var a = document.createElement("a");
        if (a.download != null) {
          a.download = fname;
          a.href = url;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          if (URL.revokeObjectURL && typeof setTimeout !== "undefined") setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
          return url;
        }
      }
    }
    if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined") try {
      var out = File(fname);
      out.open("w");
      out.encoding = "binary";
      if (Array.isArray(payload)) payload = a2s(payload);
      out.write(payload);
      out.close();
      return payload;
    } catch (e) {
      if (!e.message || !e.message.match(/onstruct/)) throw e;
    }
    throw new Error("cannot save file " + fname);
  }
  function keys(o) {
    var ks = Object.keys(o), o2 = [];
    for (var i = 0; i < ks.length; ++i) if (Object.prototype.hasOwnProperty.call(o, ks[i])) o2.push(ks[i]);
    return o2;
  }
  function evert_key(obj, key) {
    var o = [], K = keys(obj);
    for (var i = 0; i !== K.length; ++i) if (o[obj[K[i]][key]] == null) o[obj[K[i]][key]] = K[i];
    return o;
  }
  function evert(obj) {
    var o = [], K = keys(obj);
    for (var i = 0; i !== K.length; ++i) o[obj[K[i]]] = K[i];
    return o;
  }
  function evert_num(obj) {
    var o = [], K = keys(obj);
    for (var i = 0; i !== K.length; ++i) o[obj[K[i]]] = parseInt(K[i], 10);
    return o;
  }
  function evert_arr(obj) {
    var o = [], K = keys(obj);
    for (var i = 0; i !== K.length; ++i) {
      if (o[obj[K[i]]] == null) o[obj[K[i]]] = [];
      o[obj[K[i]]].push(K[i]);
    }
    return o;
  }
  var basedate = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
  function datenum(v, date1904) {
    var epoch = /* @__PURE__ */ v.getTime();
    if (date1904) epoch -= 1462 * 24 * 60 * 60 * 1e3;
    var dnthresh2 = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
    return (epoch - dnthresh2) / (24 * 60 * 60 * 1e3);
  }
  var refdate = /* @__PURE__ */ new Date();
  var dnthresh = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ refdate.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
  var refoffset = /* @__PURE__ */ refdate.getTimezoneOffset();
  function numdate(v) {
    var out = /* @__PURE__ */ new Date();
    out.setTime(v * 24 * 60 * 60 * 1e3 + dnthresh);
    if (out.getTimezoneOffset() !== refoffset) {
      out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 6e4);
    }
    return out;
  }
  var good_pd_date_1 = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
  var good_pd_date = /* @__PURE__ */ isNaN(/* @__PURE__ */ good_pd_date_1.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : good_pd_date_1;
  var good_pd = /* @__PURE__ */ good_pd_date.getFullYear() == 2017;
  function parseDate(str, fixdate) {
    var d = new Date(str);
    if (good_pd) {
      if (fixdate > 0) d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1e3);
      else if (fixdate < 0) d.setTime(d.getTime() - d.getTimezoneOffset() * 60 * 1e3);
      return d;
    }
    if (str instanceof Date) return str;
    if (good_pd_date.getFullYear() == 1917 && !isNaN(d.getFullYear())) {
      var s = d.getFullYear();
      if (str.indexOf("" + s) > -1) return d;
      d.setFullYear(d.getFullYear() + 100);
      return d;
    }
    var n = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
    var out = new Date(+n[0], +n[1] - 1, +n[2], +n[3] || 0, +n[4] || 0, +n[5] || 0);
    if (str.indexOf("Z") > -1) out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
    return out;
  }
  function cc2str(arr, debomit) {
    if (has_buf && Buffer.isBuffer(arr)) {
      if (debomit) {
        if (arr[0] == 255 && arr[1] == 254) return utf8write(arr.slice(2).toString("utf16le"));
        if (arr[1] == 254 && arr[2] == 255) return utf8write(utf16beread(arr.slice(2).toString("binary")));
      }
      return arr.toString("binary");
    }
    if (typeof TextDecoder !== "undefined") try {
      if (debomit) {
        if (arr[0] == 255 && arr[1] == 254) return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
        if (arr[0] == 254 && arr[1] == 255) return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
      }
      var rev = {
        "\u20AC": "\x80",
        "\u201A": "\x82",
        "\u0192": "\x83",
        "\u201E": "\x84",
        "\u2026": "\x85",
        "\u2020": "\x86",
        "\u2021": "\x87",
        "\u02C6": "\x88",
        "\u2030": "\x89",
        "\u0160": "\x8A",
        "\u2039": "\x8B",
        "\u0152": "\x8C",
        "\u017D": "\x8E",
        "\u2018": "\x91",
        "\u2019": "\x92",
        "\u201C": "\x93",
        "\u201D": "\x94",
        "\u2022": "\x95",
        "\u2013": "\x96",
        "\u2014": "\x97",
        "\u02DC": "\x98",
        "\u2122": "\x99",
        "\u0161": "\x9A",
        "\u203A": "\x9B",
        "\u0153": "\x9C",
        "\u017E": "\x9E",
        "\u0178": "\x9F"
      };
      if (Array.isArray(arr)) arr = new Uint8Array(arr);
      return new TextDecoder("latin1").decode(arr).replace(/[]/g, function(c) {
        return rev[c] || c;
      });
    } catch (e) {
    }
    var o = [];
    for (var i = 0; i != arr.length; ++i) o.push(String.fromCharCode(arr[i]));
    return o.join("");
  }
  function dup(o) {
    if (typeof JSON != "undefined" && !Array.isArray(o)) return JSON.parse(JSON.stringify(o));
    if (typeof o != "object" || o == null) return o;
    if (o instanceof Date) return new Date(o.getTime());
    var out = {};
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) out[k] = dup(o[k]);
    return out;
  }
  function fill(c, l) {
    var o = "";
    while (o.length < l) o += c;
    return o;
  }
  function fuzzynum(s) {
    var v = Number(s);
    if (!isNaN(v)) return isFinite(v) ? v : NaN;
    if (!/\d/.test(s)) return v;
    var wt = 1;
    var ss = s.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
      wt *= 100;
      return "";
    });
    if (!isNaN(v = Number(ss))) return v / wt;
    ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
      wt = -wt;
      return $1;
    });
    if (!isNaN(v = Number(ss))) return v / wt;
    return v;
  }
  var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
  function fuzzydate(s) {
    var o = new Date(s), n = /* @__PURE__ */ new Date(NaN);
    var y = o.getYear(), m = o.getMonth(), d = o.getDate();
    if (isNaN(d)) return n;
    var lower = s.toLowerCase();
    if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
      lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
      if (lower.length > 3 && lower_months.indexOf(lower) == -1) return n;
    } else if (lower.match(/[a-z]/)) return n;
    if (y < 0 || y > 8099) return n;
    if ((m > 0 || d > 1) && y != 101) return o;
    if (s.match(/[^-0-9:,\/\\]/)) return n;
    return o;
  }
  function zip_add_file(zip, path, content) {
    if (zip.FullPaths) {
      if (typeof content == "string") {
        var res;
        if (has_buf) res = Buffer_from(content);
        else res = utf8decode(content);
        return CFB.utils.cfb_add(zip, path, res);
      }
      CFB.utils.cfb_add(zip, path, content);
    } else zip.file(path, content);
  }
  function zip_new() {
    return CFB.utils.cfb_new();
  }
  var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
  var encodings = {
    "&quot;": '"',
    "&apos;": "'",
    "&gt;": ">",
    "&lt;": "<",
    "&amp;": "&"
  };
  var rencoding = /* @__PURE__ */ evert(encodings);
  var decregex = /[&<>'"]/g;
  var charegex = /[\u0000-\u0008\u000b-\u001f]/g;
  function escapexml(text) {
    var s = text + "";
    return s.replace(decregex, function(y) {
      return rencoding[y];
    }).replace(charegex, function(s2) {
      return "_x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + "_";
    });
  }
  function escapexmltag(text) {
    return escapexml(text).replace(/ /g, "_x0020_");
  }
  var htmlcharegex = /[\u0000-\u001f]/g;
  function escapehtml(text) {
    var s = text + "";
    return s.replace(decregex, function(y) {
      return rencoding[y];
    }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s2) {
      return "&#x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + ";";
    });
  }
  function escapexlml(text) {
    var s = text + "";
    return s.replace(decregex, function(y) {
      return rencoding[y];
    }).replace(htmlcharegex, function(s2) {
      return "&#x" + s2.charCodeAt(0).toString(16).toUpperCase() + ";";
    });
  }
  function xlml_unfixstr(str) {
    return str.replace(/(\r\n|[\r\n])/g, "&#10;");
  }
  function parsexmlbool(value) {
    switch (value) {
      case 1:
      case true:
      case "1":
      case "true":
      case "TRUE":
        return true;
      /* case '0': case 'false': case 'FALSE':*/
      default:
        return false;
    }
  }
  function utf8reada(orig) {
    var out = "", i = 0, c = 0, d = 0, e = 0, f = 0, w = 0;
    while (i < orig.length) {
      c = orig.charCodeAt(i++);
      if (c < 128) {
        out += String.fromCharCode(c);
        continue;
      }
      d = orig.charCodeAt(i++);
      if (c > 191 && c < 224) {
        f = (c & 31) << 6;
        f |= d & 63;
        out += String.fromCharCode(f);
        continue;
      }
      e = orig.charCodeAt(i++);
      if (c < 240) {
        out += String.fromCharCode((c & 15) << 12 | (d & 63) << 6 | e & 63);
        continue;
      }
      f = orig.charCodeAt(i++);
      w = ((c & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;
      out += String.fromCharCode(55296 + (w >>> 10 & 1023));
      out += String.fromCharCode(56320 + (w & 1023));
    }
    return out;
  }
  function utf8readb(data) {
    var out = new_raw_buf(2 * data.length), w, i, j = 1, k = 0, ww = 0, c;
    for (i = 0; i < data.length; i += j) {
      j = 1;
      if ((c = data.charCodeAt(i)) < 128) w = c;
      else if (c < 224) {
        w = (c & 31) * 64 + (data.charCodeAt(i + 1) & 63);
        j = 2;
      } else if (c < 240) {
        w = (c & 15) * 4096 + (data.charCodeAt(i + 1) & 63) * 64 + (data.charCodeAt(i + 2) & 63);
        j = 3;
      } else {
        j = 4;
        w = (c & 7) * 262144 + (data.charCodeAt(i + 1) & 63) * 4096 + (data.charCodeAt(i + 2) & 63) * 64 + (data.charCodeAt(i + 3) & 63);
        w -= 65536;
        ww = 55296 + (w >>> 10 & 1023);
        w = 56320 + (w & 1023);
      }
      if (ww !== 0) {
        out[k++] = ww & 255;
        out[k++] = ww >>> 8;
        ww = 0;
      }
      out[k++] = w % 256;
      out[k++] = w >>> 8;
    }
    return out.slice(0, k).toString("ucs2");
  }
  function utf8readc(data) {
    return Buffer_from(data, "binary").toString("utf8");
  }
  var utf8corpus = "foo bar baz\xE2\x98\x83\xF0\x9F\x8D\xA3";
  var utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada;
  var utf8write = has_buf ? function(data) {
    return Buffer_from(data, "utf8").toString("binary");
  } : function(orig) {
    var out = [], i = 0, c = 0, d = 0;
    while (i < orig.length) {
      c = orig.charCodeAt(i++);
      switch (true) {
        case c < 128:
          out.push(String.fromCharCode(c));
          break;
        case c < 2048:
          out.push(String.fromCharCode(192 + (c >> 6)));
          out.push(String.fromCharCode(128 + (c & 63)));
          break;
        case (c >= 55296 && c < 57344):
          c -= 55296;
          d = orig.charCodeAt(i++) - 56320 + (c << 10);
          out.push(String.fromCharCode(240 + (d >> 18 & 7)));
          out.push(String.fromCharCode(144 + (d >> 12 & 63)));
          out.push(String.fromCharCode(128 + (d >> 6 & 63)));
          out.push(String.fromCharCode(128 + (d & 63)));
          break;
        default:
          out.push(String.fromCharCode(224 + (c >> 12)));
          out.push(String.fromCharCode(128 + (c >> 6 & 63)));
          out.push(String.fromCharCode(128 + (c & 63)));
      }
    }
    return out.join("");
  };
  var htmldecode = /* @__PURE__ */ (function() {
    var entities = [
      ["nbsp", " "],
      ["middot", "\xB7"],
      ["quot", '"'],
      ["apos", "'"],
      ["gt", ">"],
      ["lt", "<"],
      ["amp", "&"]
    ].map(function(x) {
      return [new RegExp("&" + x[0] + ";", "ig"), x[1]];
    });
    return function htmldecode2(str) {
      var o = str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, "");
      for (var i = 0; i < entities.length; ++i) o = o.replace(entities[i][0], entities[i][1]);
      return o;
    };
  })();
  var wtregex = /(^\s|\s$|\n)/;
  function writetag(f, g) {
    return "<" + f + (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f + ">";
  }
  function wxt_helper(h) {
    return keys(h).map(function(k) {
      return " " + k + '="' + h[k] + '"';
    }).join("");
  }
  function writextag(f, g, h) {
    return "<" + f + (h != null ? wxt_helper(h) : "") + (g != null ? (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f : "/") + ">";
  }
  function write_w3cdtf(d, t) {
    try {
      return d.toISOString().replace(/\.\d*/, "");
    } catch (e) {
      if (t) throw e;
    }
    return "";
  }
  function write_vt(s, xlsx) {
    switch (typeof s) {
      case "string":
        var o = writextag("vt:lpwstr", escapexml(s));
        if (xlsx) o = o.replace(/&quot;/g, "_x0022_");
        return o;
      case "number":
        return writextag((s | 0) == s ? "vt:i4" : "vt:r8", escapexml(String(s)));
      case "boolean":
        return writextag("vt:bool", s ? "true" : "false");
    }
    if (s instanceof Date) return writextag("vt:filetime", write_w3cdtf(s));
    throw new Error("Unable to serialize " + s);
  }
  var XMLNS = {
    CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
    CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
    EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
    CT: "http://schemas.openxmlformats.org/package/2006/content-types",
    RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
    TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
    "dc": "http://purl.org/dc/elements/1.1/",
    "dcterms": "http://purl.org/dc/terms/",
    "dcmitype": "http://purl.org/dc/dcmitype/",
    "mx": "http://schemas.microsoft.com/office/mac/excel/2008/main",
    "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    "sjs": "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
    "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
    "xsi": "http://www.w3.org/2001/XMLSchema-instance",
    "xsd": "http://www.w3.org/2001/XMLSchema"
  };
  var XMLNS_main = [
    "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "http://purl.oclc.org/ooxml/spreadsheetml/main",
    "http://schemas.microsoft.com/office/excel/2006/main",
    "http://schemas.microsoft.com/office/excel/2006/2"
  ];
  var XLMLNS = {
    "o": "urn:schemas-microsoft-com:office:office",
    "x": "urn:schemas-microsoft-com:office:excel",
    "ss": "urn:schemas-microsoft-com:office:spreadsheet",
    "dt": "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
    "mv": "http://macVmlSchemaUri",
    "v": "urn:schemas-microsoft-com:vml",
    "html": "http://www.w3.org/TR/REC-html40"
  };
  function read_double_le(b, idx) {
    var s = 1 - 2 * (b[idx + 7] >>> 7);
    var e = ((b[idx + 7] & 127) << 4) + (b[idx + 6] >>> 4 & 15);
    var m = b[idx + 6] & 15;
    for (var i = 5; i >= 0; --i) m = m * 256 + b[idx + i];
    if (e == 2047) return m == 0 ? s * Infinity : NaN;
    if (e == 0) e = -1022;
    else {
      e -= 1023;
      m += Math.pow(2, 52);
    }
    return s * Math.pow(2, e - 52) * m;
  }
  function write_double_le(b, v, idx) {
    var bs = (v < 0 || 1 / v == -Infinity ? 1 : 0) << 7, e = 0, m = 0;
    var av = bs ? -v : v;
    if (!isFinite(av)) {
      e = 2047;
      m = isNaN(v) ? 26985 : 0;
    } else if (av == 0) e = m = 0;
    else {
      e = Math.floor(Math.log(av) / Math.LN2);
      m = av * Math.pow(2, 52 - e);
      if (e <= -1023 && (!isFinite(m) || m < Math.pow(2, 52))) {
        e = -1022;
      } else {
        m -= Math.pow(2, 52);
        e += 1023;
      }
    }
    for (var i = 0; i <= 5; ++i, m /= 256) b[idx + i] = m & 255;
    b[idx + 6] = (e & 15) << 4 | m & 15;
    b[idx + 7] = e >> 4 | bs;
  }
  var ___toBuffer = function(bufs) {
    var x = [], w = 10240;
    for (var i = 0; i < bufs[0].length; ++i) if (bufs[0][i]) for (var j = 0, L = bufs[0][i].length; j < L; j += w) x.push.apply(x, bufs[0][i].slice(j, j + w));
    return x;
  };
  var __toBuffer = has_buf ? function(bufs) {
    return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x) {
      return Buffer.isBuffer(x) ? x : Buffer_from(x);
    })) : ___toBuffer(bufs);
  } : ___toBuffer;
  var ___utf16le = function(b, s, e) {
    var ss = [];
    for (var i = s; i < e; i += 2) ss.push(String.fromCharCode(__readUInt16LE(b, i)));
    return ss.join("").replace(chr0, "");
  };
  var __utf16le = has_buf ? function(b, s, e) {
    if (!Buffer.isBuffer(b)) return ___utf16le(b, s, e);
    return b.toString("utf16le", s, e).replace(chr0, "");
  } : ___utf16le;
  var ___hexlify = function(b, s, l) {
    var ss = [];
    for (var i = s; i < s + l; ++i) ss.push(("0" + b[i].toString(16)).slice(-2));
    return ss.join("");
  };
  var __hexlify = has_buf ? function(b, s, l) {
    return Buffer.isBuffer(b) ? b.toString("hex", s, s + l) : ___hexlify(b, s, l);
  } : ___hexlify;
  var ___utf8 = function(b, s, e) {
    var ss = [];
    for (var i = s; i < e; i++) ss.push(String.fromCharCode(__readUInt8(b, i)));
    return ss.join("");
  };
  var __utf8 = has_buf ? function utf8_b(b, s, e) {
    return Buffer.isBuffer(b) ? b.toString("utf8", s, e) : ___utf8(b, s, e);
  } : ___utf8;
  var ___lpstr = function(b, i) {
    var len = __readUInt32LE(b, i);
    return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
  };
  var __lpstr = ___lpstr;
  var ___cpstr = function(b, i) {
    var len = __readUInt32LE(b, i);
    return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
  };
  var __cpstr = ___cpstr;
  var ___lpwstr = function(b, i) {
    var len = 2 * __readUInt32LE(b, i);
    return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
  };
  var __lpwstr = ___lpwstr;
  var ___lpp4 = function lpp4_(b, i) {
    var len = __readUInt32LE(b, i);
    return len > 0 ? __utf16le(b, i + 4, i + 4 + len) : "";
  };
  var __lpp4 = ___lpp4;
  var ___8lpp4 = function(b, i) {
    var len = __readUInt32LE(b, i);
    return len > 0 ? __utf8(b, i + 4, i + 4 + len) : "";
  };
  var __8lpp4 = ___8lpp4;
  var ___double = function(b, idx) {
    return read_double_le(b, idx);
  };
  var __double = ___double;
  var is_buf = function is_buf_a(a) {
    return Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
  };
  if (has_buf) {
    __lpstr = function lpstr_b(b, i) {
      if (!Buffer.isBuffer(b)) return ___lpstr(b, i);
      var len = b.readUInt32LE(i);
      return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
    };
    __cpstr = function cpstr_b(b, i) {
      if (!Buffer.isBuffer(b)) return ___cpstr(b, i);
      var len = b.readUInt32LE(i);
      return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
    };
    __lpwstr = function lpwstr_b(b, i) {
      if (!Buffer.isBuffer(b)) return ___lpwstr(b, i);
      var len = 2 * b.readUInt32LE(i);
      return b.toString("utf16le", i + 4, i + 4 + len - 1);
    };
    __lpp4 = function lpp4_b(b, i) {
      if (!Buffer.isBuffer(b)) return ___lpp4(b, i);
      var len = b.readUInt32LE(i);
      return b.toString("utf16le", i + 4, i + 4 + len);
    };
    __8lpp4 = function lpp4_8b(b, i) {
      if (!Buffer.isBuffer(b)) return ___8lpp4(b, i);
      var len = b.readUInt32LE(i);
      return b.toString("utf8", i + 4, i + 4 + len);
    };
    __double = function double_(b, i) {
      if (Buffer.isBuffer(b)) return b.readDoubleLE(i);
      return ___double(b, i);
    };
    is_buf = function is_buf_b(a) {
      return Buffer.isBuffer(a) || Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
    };
  }
  function cpdoit() {
    __utf16le = function(b, s, e) {
      return $cptable.utils.decode(1200, b.slice(s, e)).replace(chr0, "");
    };
    __utf8 = function(b, s, e) {
      return $cptable.utils.decode(65001, b.slice(s, e));
    };
    __lpstr = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(current_ansi, b.slice(i + 4, i + 4 + len - 1)) : "";
    };
    __cpstr = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(current_codepage, b.slice(i + 4, i + 4 + len - 1)) : "";
    };
    __lpwstr = function(b, i) {
      var len = 2 * __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(1200, b.slice(i + 4, i + 4 + len - 1)) : "";
    };
    __lpp4 = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(1200, b.slice(i + 4, i + 4 + len)) : "";
    };
    __8lpp4 = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(65001, b.slice(i + 4, i + 4 + len)) : "";
    };
  }
  if (typeof $cptable !== "undefined") cpdoit();
  var __readUInt8 = function(b, idx) {
    return b[idx];
  };
  var __readUInt16LE = function(b, idx) {
    return b[idx + 1] * (1 << 8) + b[idx];
  };
  var __readInt16LE = function(b, idx) {
    var u = b[idx + 1] * (1 << 8) + b[idx];
    return u < 32768 ? u : (65535 - u + 1) * -1;
  };
  var __readUInt32LE = function(b, idx) {
    return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
  };
  var __readInt32LE = function(b, idx) {
    return b[idx + 3] << 24 | b[idx + 2] << 16 | b[idx + 1] << 8 | b[idx];
  };
  var __readInt32BE = function(b, idx) {
    return b[idx] << 24 | b[idx + 1] << 16 | b[idx + 2] << 8 | b[idx + 3];
  };
  function ReadShift(size, t) {
    var o = "", oI, oR, oo = [], w, vv, i, loc;
    switch (t) {
      case "dbcs":
        loc = this.l;
        if (has_buf && Buffer.isBuffer(this)) o = this.slice(this.l, this.l + 2 * size).toString("utf16le");
        else for (i = 0; i < size; ++i) {
          o += String.fromCharCode(__readUInt16LE(this, loc));
          loc += 2;
        }
        size *= 2;
        break;
      case "utf8":
        o = __utf8(this, this.l, this.l + size);
        break;
      case "utf16le":
        size *= 2;
        o = __utf16le(this, this.l, this.l + size);
        break;
      case "wstr":
        if (typeof $cptable !== "undefined") o = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + 2 * size));
        else return ReadShift.call(this, size, "dbcs");
        size = 2 * size;
        break;
      /* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */
      case "lpstr-ansi":
        o = __lpstr(this, this.l);
        size = 4 + __readUInt32LE(this, this.l);
        break;
      case "lpstr-cp":
        o = __cpstr(this, this.l);
        size = 4 + __readUInt32LE(this, this.l);
        break;
      /* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */
      case "lpwstr":
        o = __lpwstr(this, this.l);
        size = 4 + 2 * __readUInt32LE(this, this.l);
        break;
      /* [MS-OFFCRYPTO] 2.1.2 Length-Prefixed Padded Unicode String (UNICODE-LP-P4) */
      case "lpp4":
        size = 4 + __readUInt32LE(this, this.l);
        o = __lpp4(this, this.l);
        if (size & 2) size += 2;
        break;
      /* [MS-OFFCRYPTO] 2.1.3 Length-Prefixed UTF-8 String (UTF-8-LP-P4) */
      case "8lpp4":
        size = 4 + __readUInt32LE(this, this.l);
        o = __8lpp4(this, this.l);
        if (size & 3) size += 4 - (size & 3);
        break;
      case "cstr":
        size = 0;
        o = "";
        while ((w = __readUInt8(this, this.l + size++)) !== 0) oo.push(_getchar(w));
        o = oo.join("");
        break;
      case "_wstr":
        size = 0;
        o = "";
        while ((w = __readUInt16LE(this, this.l + size)) !== 0) {
          oo.push(_getchar(w));
          size += 2;
        }
        size += 2;
        o = oo.join("");
        break;
      /* sbcs and dbcs support continue records in the SST way TODO codepages */
      case "dbcs-cont":
        o = "";
        loc = this.l;
        for (i = 0; i < size; ++i) {
          if (this.lens && this.lens.indexOf(loc) !== -1) {
            w = __readUInt8(this, loc);
            this.l = loc + 1;
            vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
            return oo.join("") + vv;
          }
          oo.push(_getchar(__readUInt16LE(this, loc)));
          loc += 2;
        }
        o = oo.join("");
        size *= 2;
        break;
      case "cpstr":
        if (typeof $cptable !== "undefined") {
          o = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + size));
          break;
        }
      /* falls through */
      case "sbcs-cont":
        o = "";
        loc = this.l;
        for (i = 0; i != size; ++i) {
          if (this.lens && this.lens.indexOf(loc) !== -1) {
            w = __readUInt8(this, loc);
            this.l = loc + 1;
            vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
            return oo.join("") + vv;
          }
          oo.push(_getchar(__readUInt8(this, loc)));
          loc += 1;
        }
        o = oo.join("");
        break;
      default:
        switch (size) {
          case 1:
            oI = __readUInt8(this, this.l);
            this.l++;
            return oI;
          case 2:
            oI = (t === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
            this.l += 2;
            return oI;
          case 4:
          case -4:
            if (t === "i" || (this[this.l + 3] & 128) === 0) {
              oI = (size > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
              this.l += 4;
              return oI;
            } else {
              oR = __readUInt32LE(this, this.l);
              this.l += 4;
            }
            return oR;
          case 8:
          case -8:
            if (t === "f") {
              if (size == 8) oR = __double(this, this.l);
              else oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
              this.l += 8;
              return oR;
            } else size = 8;
          /* falls through */
          case 16:
            o = __hexlify(this, this.l, size);
            break;
        }
    }
    this.l += size;
    return o;
  }
  var __writeUInt32LE = function(b, val, idx) {
    b[idx] = val & 255;
    b[idx + 1] = val >>> 8 & 255;
    b[idx + 2] = val >>> 16 & 255;
    b[idx + 3] = val >>> 24 & 255;
  };
  var __writeInt32LE = function(b, val, idx) {
    b[idx] = val & 255;
    b[idx + 1] = val >> 8 & 255;
    b[idx + 2] = val >> 16 & 255;
    b[idx + 3] = val >> 24 & 255;
  };
  var __writeUInt16LE = function(b, val, idx) {
    b[idx] = val & 255;
    b[idx + 1] = val >>> 8 & 255;
  };
  function WriteShift(t, val, f) {
    var size = 0, i = 0;
    if (f === "dbcs") {
      for (i = 0; i != val.length; ++i) __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);
      size = 2 * val.length;
    } else if (f === "sbcs") {
      if (typeof $cptable !== "undefined" && current_ansi == 874) {
        for (i = 0; i != val.length; ++i) {
          var cppayload = $cptable.utils.encode(current_ansi, val.charAt(i));
          this[this.l + i] = cppayload[0];
        }
      } else {
        val = val.replace(/[^\x00-\x7F]/g, "_");
        for (i = 0; i != val.length; ++i) this[this.l + i] = val.charCodeAt(i) & 255;
      }
      size = val.length;
    } else if (f === "hex") {
      for (; i < t; ++i) {
        this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
      }
      return this;
    } else if (f === "utf16le") {
      var end = Math.min(this.l + t, this.length);
      for (i = 0; i < Math.min(val.length, t); ++i) {
        var cc = val.charCodeAt(i);
        this[this.l++] = cc & 255;
        this[this.l++] = cc >> 8;
      }
      while (this.l < end) this[this.l++] = 0;
      return this;
    } else switch (t) {
      case 1:
        size = 1;
        this[this.l] = val & 255;
        break;
      case 2:
        size = 2;
        this[this.l] = val & 255;
        val >>>= 8;
        this[this.l + 1] = val & 255;
        break;
      case 3:
        size = 3;
        this[this.l] = val & 255;
        val >>>= 8;
        this[this.l + 1] = val & 255;
        val >>>= 8;
        this[this.l + 2] = val & 255;
        break;
      case 4:
        size = 4;
        __writeUInt32LE(this, val, this.l);
        break;
      case 8:
        size = 8;
        if (f === "f") {
          write_double_le(this, val, this.l);
          break;
        }
      /* falls through */
      case 16:
        break;
      case -4:
        size = 4;
        __writeInt32LE(this, val, this.l);
        break;
    }
    this.l += size;
    return this;
  }
  function CheckField(hexstr, fld) {
    var m = __hexlify(this, this.l, hexstr.length >> 1);
    if (m !== hexstr) throw new Error(fld + "Expected " + hexstr + " saw " + m);
    this.l += hexstr.length >> 1;
  }
  function prep_blob(blob, pos) {
    blob.l = pos;
    blob.read_shift = /*::(*/
    ReadShift;
    blob.chk = CheckField;
    blob.write_shift = WriteShift;
  }
  function parsenoop(blob, length) {
    blob.l += length;
  }
  function new_buf(sz) {
    var o = new_raw_buf(sz);
    prep_blob(o, 0);
    return o;
  }
  function buf_array() {
    var bufs = [], blksz = has_buf ? 256 : 2048;
    var newblk = function ba_newblk(sz) {
      var o = new_buf(sz);
      prep_blob(o, 0);
      return o;
    };
    var curbuf = newblk(blksz);
    var endbuf = function ba_endbuf() {
      if (!curbuf) return;
      if (curbuf.length > curbuf.l) {
        curbuf = curbuf.slice(0, curbuf.l);
        curbuf.l = curbuf.length;
      }
      if (curbuf.length > 0) bufs.push(curbuf);
      curbuf = null;
    };
    var next = function ba_next(sz) {
      if (curbuf && sz < curbuf.length - curbuf.l) return curbuf;
      endbuf();
      return curbuf = newblk(Math.max(sz + 1, blksz));
    };
    var end = function ba_end() {
      endbuf();
      return bconcat(bufs);
    };
    var push = function ba_push(buf) {
      endbuf();
      curbuf = buf;
      if (curbuf.l == null) curbuf.l = curbuf.length;
      next(blksz);
    };
    return { next, push, end, _bufs: bufs };
  }
  function write_record(ba, type, payload, length) {
    var t = +type, l;
    if (isNaN(t)) return;
    if (!length) length = XLSBRecordEnum[t].p || (payload || []).length || 0;
    l = 1 + (t >= 128 ? 1 : 0) + 1;
    if (length >= 128) ++l;
    if (length >= 16384) ++l;
    if (length >= 2097152) ++l;
    var o = ba.next(l);
    if (t <= 127) o.write_shift(1, t);
    else {
      o.write_shift(1, (t & 127) + 128);
      o.write_shift(1, t >> 7);
    }
    for (var i = 0; i != 4; ++i) {
      if (length >= 128) {
        o.write_shift(1, (length & 127) + 128);
        length >>= 7;
      } else {
        o.write_shift(1, length);
        break;
      }
    }
    if (
      /*:: length != null &&*/
      length > 0 && is_buf(payload)
    ) ba.push(payload);
  }
  function shift_cell_xls(cell, tgt, opts) {
    var out = dup(cell);
    if (tgt.s) {
      if (out.cRel) out.c += tgt.s.c;
      if (out.rRel) out.r += tgt.s.r;
    } else {
      if (out.cRel) out.c += tgt.c;
      if (out.rRel) out.r += tgt.r;
    }
    if (!opts || opts.biff < 12) {
      while (out.c >= 256) out.c -= 256;
      while (out.r >= 65536) out.r -= 65536;
    }
    return out;
  }
  function shift_range_xls(cell, range, opts) {
    var out = dup(cell);
    out.s = shift_cell_xls(out.s, range.s, opts);
    out.e = shift_cell_xls(out.e, range.s, opts);
    return out;
  }
  function encode_cell_xls(c, biff) {
    if (c.cRel && c.c < 0) {
      c = dup(c);
      while (c.c < 0) c.c += biff > 8 ? 16384 : 256;
    }
    if (c.rRel && c.r < 0) {
      c = dup(c);
      while (c.r < 0) c.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
    }
    var s = encode_cell(c);
    if (!c.cRel && c.cRel != null) s = fix_col(s);
    if (!c.rRel && c.rRel != null) s = fix_row(s);
    return s;
  }
  function encode_range_xls(r, opts) {
    if (r.s.r == 0 && !r.s.rRel) {
      if (r.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r.e.rRel) {
        return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);
      }
    }
    if (r.s.c == 0 && !r.s.cRel) {
      if (r.e.c == (opts.biff >= 12 ? 16383 : 255) && !r.e.cRel) {
        return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);
      }
    }
    return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);
  }
  function decode_row(rowstr) {
    return parseInt(unfix_row(rowstr), 10) - 1;
  }
  function encode_row(row) {
    return "" + (row + 1);
  }
  function fix_row(cstr) {
    return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
  }
  function unfix_row(cstr) {
    return cstr.replace(/\$(\d+)$/, "$1");
  }
  function decode_col(colstr) {
    var c = unfix_col(colstr), d = 0, i = 0;
    for (; i !== c.length; ++i) d = 26 * d + c.charCodeAt(i) - 64;
    return d - 1;
  }
  function encode_col(col) {
    if (col < 0) throw new Error("invalid column " + col);
    var s = "";
    for (++col; col; col = Math.floor((col - 1) / 26)) s = String.fromCharCode((col - 1) % 26 + 65) + s;
    return s;
  }
  function fix_col(cstr) {
    return cstr.replace(/^([A-Z])/, "$$$1");
  }
  function unfix_col(cstr) {
    return cstr.replace(/^\$([A-Z])/, "$1");
  }
  function split_cell(cstr) {
    return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
  }
  function decode_cell(cstr) {
    var R = 0, C = 0;
    for (var i = 0; i < cstr.length; ++i) {
      var cc = cstr.charCodeAt(i);
      if (cc >= 48 && cc <= 57) R = 10 * R + (cc - 48);
      else if (cc >= 65 && cc <= 90) C = 26 * C + (cc - 64);
    }
    return { c: C - 1, r: R - 1 };
  }
  function encode_cell(cell) {
    var col = cell.c + 1;
    var s = "";
    for (; col; col = (col - 1) / 26 | 0) s = String.fromCharCode((col - 1) % 26 + 65) + s;
    return s + (cell.r + 1);
  }
  function decode_range(range) {
    var idx = range.indexOf(":");
    if (idx == -1) return { s: decode_cell(range), e: decode_cell(range) };
    return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
  }
  function encode_range(cs, ce) {
    if (typeof ce === "undefined" || typeof ce === "number") {
      return encode_range(cs.s, cs.e);
    }
    if (typeof cs !== "string") cs = encode_cell(cs);
    if (typeof ce !== "string") ce = encode_cell(ce);
    return cs == ce ? cs : cs + ":" + ce;
  }
  function safe_decode_range(range) {
    var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    var idx = 0, i = 0, cc = 0;
    var len = range.length;
    for (idx = 0; i < len; ++i) {
      if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
      idx = 26 * idx + cc;
    }
    o.s.c = --idx;
    for (idx = 0; i < len; ++i) {
      if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
      idx = 10 * idx + cc;
    }
    o.s.r = --idx;
    if (i === len || cc != 10) {
      o.e.c = o.s.c;
      o.e.r = o.s.r;
      return o;
    }
    ++i;
    for (idx = 0; i != len; ++i) {
      if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
      idx = 26 * idx + cc;
    }
    o.e.c = --idx;
    for (idx = 0; i != len; ++i) {
      if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
      idx = 10 * idx + cc;
    }
    o.e.r = --idx;
    return o;
  }
  function safe_format_cell(cell, v) {
    var q = cell.t == "d" && v instanceof Date;
    if (cell.z != null) try {
      return cell.w = SSF_format(cell.z, q ? datenum(v) : v);
    } catch (e) {
    }
    try {
      return cell.w = SSF_format((cell.XF || {}).numFmtId || (q ? 14 : 0), q ? datenum(v) : v);
    } catch (e) {
      return "" + v;
    }
  }
  function format_cell(cell, v, o) {
    if (cell == null || cell.t == null || cell.t == "z") return "";
    if (cell.w !== void 0) return cell.w;
    if (cell.t == "d" && !cell.z && o && o.dateNF) cell.z = o.dateNF;
    if (cell.t == "e") return BErr[cell.v] || cell.v;
    if (v == void 0) return safe_format_cell(cell, cell.v);
    return safe_format_cell(cell, v);
  }
  function sheet_to_workbook(sheet, opts) {
    var n = opts && opts.sheet ? opts.sheet : "Sheet1";
    var sheets = {};
    sheets[n] = sheet;
    return { SheetNames: [n], Sheets: sheets };
  }
  function sheet_add_aoa(_ws, data, opts) {
    var o = opts || {};
    var dense = _ws ? Array.isArray(_ws) : o.dense;
    if (DENSE != null && dense == null) dense = DENSE;
    var ws = _ws || (dense ? [] : {});
    var _R = 0, _C = 0;
    if (ws && o.origin != null) {
      if (typeof o.origin == "number") _R = o.origin;
      else {
        var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
        _R = _origin.r;
        _C = _origin.c;
      }
      if (!ws["!ref"]) ws["!ref"] = "A1:A1";
    }
    var range = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
    if (ws["!ref"]) {
      var _range = safe_decode_range(ws["!ref"]);
      range.s.c = _range.s.c;
      range.s.r = _range.s.r;
      range.e.c = Math.max(range.e.c, _range.e.c);
      range.e.r = Math.max(range.e.r, _range.e.r);
      if (_R == -1) range.e.r = _R = _range.e.r + 1;
    }
    for (var R = 0; R != data.length; ++R) {
      if (!data[R]) continue;
      if (!Array.isArray(data[R])) throw new Error("aoa_to_sheet expects an array of arrays");
      for (var C = 0; C != data[R].length; ++C) {
        if (typeof data[R][C] === "undefined") continue;
        var cell = { v: data[R][C] };
        var __R = _R + R, __C = _C + C;
        if (range.s.r > __R) range.s.r = __R;
        if (range.s.c > __C) range.s.c = __C;
        if (range.e.r < __R) range.e.r = __R;
        if (range.e.c < __C) range.e.c = __C;
        if (data[R][C] && typeof data[R][C] === "object" && !Array.isArray(data[R][C]) && !(data[R][C] instanceof Date)) cell = data[R][C];
        else {
          if (Array.isArray(cell.v)) {
            cell.f = data[R][C][1];
            cell.v = cell.v[0];
          }
          if (cell.v === null) {
            if (cell.f) cell.t = "n";
            else if (o.nullError) {
              cell.t = "e";
              cell.v = 0;
            } else if (!o.sheetStubs) continue;
            else cell.t = "z";
          } else if (typeof cell.v === "number") cell.t = "n";
          else if (typeof cell.v === "boolean") cell.t = "b";
          else if (cell.v instanceof Date) {
            cell.z = o.dateNF || table_fmt[14];
            if (o.cellDates) {
              cell.t = "d";
              cell.w = SSF_format(cell.z, datenum(cell.v));
            } else {
              cell.t = "n";
              cell.v = datenum(cell.v);
              cell.w = SSF_format(cell.z, cell.v);
            }
          } else cell.t = "s";
        }
        if (dense) {
          if (!ws[__R]) ws[__R] = [];
          if (ws[__R][__C] && ws[__R][__C].z) cell.z = ws[__R][__C].z;
          ws[__R][__C] = cell;
        } else {
          var cell_ref = encode_cell({ c: __C, r: __R });
          if (ws[cell_ref] && ws[cell_ref].z) cell.z = ws[cell_ref].z;
          ws[cell_ref] = cell;
        }
      }
    }
    if (range.s.c < 1e7) ws["!ref"] = encode_range(range);
    return ws;
  }
  function aoa_to_sheet(data, opts) {
    return sheet_add_aoa(null, data, opts);
  }
  function parse_Int32LE(data) {
    return data.read_shift(4, "i");
  }
  function write_UInt32LE(x, o) {
    if (!o) o = new_buf(4);
    o.write_shift(4, x);
    return o;
  }
  function parse_XLWideString(data) {
    var cchCharacters = data.read_shift(4);
    return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
  }
  function write_XLWideString(data, o) {
    var _null = false;
    if (o == null) {
      _null = true;
      o = new_buf(4 + 2 * data.length);
    }
    o.write_shift(4, data.length);
    if (data.length > 0) o.write_shift(0, data, "dbcs");
    return _null ? o.slice(0, o.l) : o;
  }
  function parse_StrRun(data) {
    return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
  }
  function write_StrRun(run, o) {
    if (!o) o = new_buf(4);
    o.write_shift(2, run.ich || 0);
    o.write_shift(2, run.ifnt || 0);
    return o;
  }
  function parse_RichStr(data, length) {
    var start = data.l;
    var flags = data.read_shift(1);
    var str = parse_XLWideString(data);
    var rgsStrRun = [];
    var z = { t: str, h: str };
    if ((flags & 1) !== 0) {
      var dwSizeStrRun = data.read_shift(4);
      for (var i = 0; i != dwSizeStrRun; ++i) rgsStrRun.push(parse_StrRun(data));
      z.r = rgsStrRun;
    } else z.r = [{ ich: 0, ifnt: 0 }];
    data.l = start + length;
    return z;
  }
  function write_RichStr(str, o) {
    var _null = false;
    if (o == null) {
      _null = true;
      o = new_buf(15 + 4 * str.t.length);
    }
    o.write_shift(1, 0);
    write_XLWideString(str.t, o);
    return _null ? o.slice(0, o.l) : o;
  }
  var parse_BrtCommentText = parse_RichStr;
  function write_BrtCommentText(str, o) {
    var _null = false;
    if (o == null) {
      _null = true;
      o = new_buf(23 + 4 * str.t.length);
    }
    o.write_shift(1, 1);
    write_XLWideString(str.t, o);
    o.write_shift(4, 1);
    write_StrRun({ ich: 0, ifnt: 0 }, o);
    return _null ? o.slice(0, o.l) : o;
  }
  function parse_XLSBCell(data) {
    var col = data.read_shift(4);
    var iStyleRef = data.read_shift(2);
    iStyleRef += data.read_shift(1) << 16;
    data.l++;
    return { c: col, iStyleRef };
  }
  function write_XLSBCell(cell, o) {
    if (o == null) o = new_buf(8);
    o.write_shift(-4, cell.c);
    o.write_shift(3, cell.iStyleRef || cell.s);
    o.write_shift(1, 0);
    return o;
  }
  function parse_XLSBShortCell(data) {
    var iStyleRef = data.read_shift(2);
    iStyleRef += data.read_shift(1) << 16;
    data.l++;
    return { c: -1, iStyleRef };
  }
  function write_XLSBShortCell(cell, o) {
    if (o == null) o = new_buf(4);
    o.write_shift(3, cell.iStyleRef || cell.s);
    o.write_shift(1, 0);
    return o;
  }
  var parse_XLSBCodeName = parse_XLWideString;
  var write_XLSBCodeName = write_XLWideString;
  function parse_XLNullableWideString(data) {
    var cchCharacters = data.read_shift(4);
    return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
  }
  function write_XLNullableWideString(data, o) {
    var _null = false;
    if (o == null) {
      _null = true;
      o = new_buf(127);
    }
    o.write_shift(4, data.length > 0 ? data.length : 4294967295);
    if (data.length > 0) o.write_shift(0, data, "dbcs");
    return _null ? o.slice(0, o.l) : o;
  }
  var parse_XLNameWideString = parse_XLWideString;
  var parse_RelID = parse_XLNullableWideString;
  var write_RelID = write_XLNullableWideString;
  function parse_RkNumber(data) {
    var b = data.slice(data.l, data.l + 4);
    var fX100 = b[0] & 1, fInt = b[0] & 2;
    data.l += 4;
    var RK = fInt === 0 ? __double([0, 0, 0, 0, b[0] & 252, b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) >> 2;
    return fX100 ? RK / 100 : RK;
  }
  function write_RkNumber(data, o) {
    if (o == null) o = new_buf(4);
    var fX100 = 0, fInt = 0, d100 = data * 100;
    if (data == (data | 0) && data >= -(1 << 29) && data < 1 << 29) {
      fInt = 1;
    } else if (d100 == (d100 | 0) && d100 >= -(1 << 29) && d100 < 1 << 29) {
      fInt = 1;
      fX100 = 1;
    }
    if (fInt) o.write_shift(-4, ((fX100 ? d100 : data) << 2) + (fX100 + 2));
    else throw new Error("unsupported RkNumber " + data);
  }
  function parse_RfX(data) {
    var cell = { s: {}, e: {} };
    cell.s.r = data.read_shift(4);
    cell.e.r = data.read_shift(4);
    cell.s.c = data.read_shift(4);
    cell.e.c = data.read_shift(4);
    return cell;
  }
  function write_RfX(r, o) {
    if (!o) o = new_buf(16);
    o.write_shift(4, r.s.r);
    o.write_shift(4, r.e.r);
    o.write_shift(4, r.s.c);
    o.write_shift(4, r.e.c);
    return o;
  }
  var parse_UncheckedRfX = parse_RfX;
  var write_UncheckedRfX = write_RfX;
  function parse_Xnum(data) {
    if (data.length - data.l < 8) throw "XLS Xnum Buffer underflow";
    return data.read_shift(8, "f");
  }
  function write_Xnum(data, o) {
    return (o || new_buf(8)).write_shift(8, data, "f");
  }
  function parse_BrtColor(data) {
    var out = {};
    var d = data.read_shift(1);
    var xColorType = d >>> 1;
    var index = data.read_shift(1);
    var nTS = data.read_shift(2, "i");
    var bR = data.read_shift(1);
    var bG = data.read_shift(1);
    var bB = data.read_shift(1);
    data.l++;
    switch (xColorType) {
      case 0:
        out.auto = 1;
        break;
      case 1:
        out.index = index;
        var icv = XLSIcv[index];
        if (icv) out.rgb = rgb2Hex(icv);
        break;
      case 2:
        out.rgb = rgb2Hex([bR, bG, bB]);
        break;
      case 3:
        out.theme = index;
        break;
    }
    if (nTS != 0) out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
    return out;
  }
  function write_BrtColor(color, o) {
    if (!o) o = new_buf(8);
    if (!color || color.auto) {
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      return o;
    }
    if (color.index != null) {
      o.write_shift(1, 2);
      o.write_shift(1, color.index);
    } else if (color.theme != null) {
      o.write_shift(1, 6);
      o.write_shift(1, color.theme);
    } else {
      o.write_shift(1, 5);
      o.write_shift(1, 0);
    }
    var nTS = color.tint || 0;
    if (nTS > 0) nTS *= 32767;
    else if (nTS < 0) nTS *= 32768;
    o.write_shift(2, nTS);
    if (!color.rgb || color.theme != null) {
      o.write_shift(2, 0);
      o.write_shift(1, 0);
      o.write_shift(1, 0);
    } else {
      var rgb = color.rgb || "FFFFFF";
      if (typeof rgb == "number") rgb = ("000000" + rgb.toString(16)).slice(-6);
      o.write_shift(1, parseInt(rgb.slice(0, 2), 16));
      o.write_shift(1, parseInt(rgb.slice(2, 4), 16));
      o.write_shift(1, parseInt(rgb.slice(4, 6), 16));
      o.write_shift(1, 255);
    }
    return o;
  }
  function parse_FontFlags(data) {
    var d = data.read_shift(1);
    data.l++;
    var out = {
      fBold: d & 1,
      fItalic: d & 2,
      fUnderline: d & 4,
      fStrikeout: d & 8,
      fOutline: d & 16,
      fShadow: d & 32,
      fCondense: d & 64,
      fExtend: d & 128
    };
    return out;
  }
  function write_FontFlags(font, o) {
    if (!o) o = new_buf(2);
    var grbit = (font.italic ? 2 : 0) | (font.strike ? 8 : 0) | (font.outline ? 16 : 0) | (font.shadow ? 32 : 0) | (font.condense ? 64 : 0) | (font.extend ? 128 : 0);
    o.write_shift(1, grbit);
    o.write_shift(1, 0);
    return o;
  }
  var VT_I2 = 2;
  var VT_I4 = 3;
  var VT_BOOL = 11;
  var VT_UI4 = 19;
  var VT_FILETIME = 64;
  var VT_BLOB = 65;
  var VT_CF = 71;
  var VT_VECTOR_VARIANT = 4108;
  var VT_VECTOR_LPSTR = 4126;
  var VT_STRING = 80;
  var DocSummaryPIDDSI = {
    /*::[*/
    1: { n: "CodePage", t: VT_I2 },
    /*::[*/
    2: { n: "Category", t: VT_STRING },
    /*::[*/
    3: { n: "PresentationFormat", t: VT_STRING },
    /*::[*/
    4: { n: "ByteCount", t: VT_I4 },
    /*::[*/
    5: { n: "LineCount", t: VT_I4 },
    /*::[*/
    6: { n: "ParagraphCount", t: VT_I4 },
    /*::[*/
    7: { n: "SlideCount", t: VT_I4 },
    /*::[*/
    8: { n: "NoteCount", t: VT_I4 },
    /*::[*/
    9: { n: "HiddenCount", t: VT_I4 },
    /*::[*/
    10: { n: "MultimediaClipCount", t: VT_I4 },
    /*::[*/
    11: { n: "ScaleCrop", t: VT_BOOL },
    /*::[*/
    12: {
      n: "HeadingPairs",
      t: VT_VECTOR_VARIANT
      /* VT_VECTOR | VT_VARIANT */
    },
    /*::[*/
    13: {
      n: "TitlesOfParts",
      t: VT_VECTOR_LPSTR
      /* VT_VECTOR | VT_LPSTR */
    },
    /*::[*/
    14: { n: "Manager", t: VT_STRING },
    /*::[*/
    15: { n: "Company", t: VT_STRING },
    /*::[*/
    16: { n: "LinksUpToDate", t: VT_BOOL },
    /*::[*/
    17: { n: "CharacterCount", t: VT_I4 },
    /*::[*/
    19: { n: "SharedDoc", t: VT_BOOL },
    /*::[*/
    22: { n: "HyperlinksChanged", t: VT_BOOL },
    /*::[*/
    23: { n: "AppVersion", t: VT_I4, p: "version" },
    /*::[*/
    24: { n: "DigSig", t: VT_BLOB },
    /*::[*/
    26: { n: "ContentType", t: VT_STRING },
    /*::[*/
    27: { n: "ContentStatus", t: VT_STRING },
    /*::[*/
    28: { n: "Language", t: VT_STRING },
    /*::[*/
    29: { n: "Version", t: VT_STRING },
    /*::[*/
    255: {},
    /* [MS-OLEPS] 2.18 */
    /*::[*/
    2147483648: { n: "Locale", t: VT_UI4 },
    /*::[*/
    2147483651: { n: "Behavior", t: VT_UI4 },
    /*::[*/
    1919054434: {}
  };
  var SummaryPIDSI = {
    /*::[*/
    1: { n: "CodePage", t: VT_I2 },
    /*::[*/
    2: { n: "Title", t: VT_STRING },
    /*::[*/
    3: { n: "Subject", t: VT_STRING },
    /*::[*/
    4: { n: "Author", t: VT_STRING },
    /*::[*/
    5: { n: "Keywords", t: VT_STRING },
    /*::[*/
    6: { n: "Comments", t: VT_STRING },
    /*::[*/
    7: { n: "Template", t: VT_STRING },
    /*::[*/
    8: { n: "LastAuthor", t: VT_STRING },
    /*::[*/
    9: { n: "RevNumber", t: VT_STRING },
    /*::[*/
    10: { n: "EditTime", t: VT_FILETIME },
    /*::[*/
    11: { n: "LastPrinted", t: VT_FILETIME },
    /*::[*/
    12: { n: "CreatedDate", t: VT_FILETIME },
    /*::[*/
    13: { n: "ModifiedDate", t: VT_FILETIME },
    /*::[*/
    14: { n: "PageCount", t: VT_I4 },
    /*::[*/
    15: { n: "WordCount", t: VT_I4 },
    /*::[*/
    16: { n: "CharCount", t: VT_I4 },
    /*::[*/
    17: { n: "Thumbnail", t: VT_CF },
    /*::[*/
    18: { n: "Application", t: VT_STRING },
    /*::[*/
    19: { n: "DocSecurity", t: VT_I4 },
    /*::[*/
    255: {},
    /* [MS-OLEPS] 2.18 */
    /*::[*/
    2147483648: { n: "Locale", t: VT_UI4 },
    /*::[*/
    2147483651: { n: "Behavior", t: VT_UI4 },
    /*::[*/
    1919054434: {}
  };
  function rgbify(arr) {
    return arr.map(function(x) {
      return [x >> 16 & 255, x >> 8 & 255, x & 255];
    });
  }
  var _XLSIcv = /* @__PURE__ */ rgbify([
    /* Color Constants */
    0,
    16777215,
    16711680,
    65280,
    255,
    16776960,
    16711935,
    65535,
    /* Overridable Defaults */
    0,
    16777215,
    16711680,
    65280,
    255,
    16776960,
    16711935,
    65535,
    8388608,
    32768,
    128,
    8421376,
    8388736,
    32896,
    12632256,
    8421504,
    10066431,
    10040166,
    16777164,
    13434879,
    6684774,
    16744576,
    26316,
    13421823,
    128,
    16711935,
    16776960,
    65535,
    8388736,
    8388608,
    32896,
    255,
    52479,
    13434879,
    13434828,
    16777113,
    10079487,
    16751052,
    13408767,
    16764057,
    3368703,
    3394764,
    10079232,
    16763904,
    16750848,
    16737792,
    6710937,
    9868950,
    13158,
    3381606,
    13056,
    3355392,
    10040064,
    10040166,
    3355545,
    3355443,
    /* Other entries to appease BIFF8/12 */
    16777215,
    /* 0x40 icvForeground ?? */
    0,
    /* 0x41 icvBackground ?? */
    0,
    /* 0x42 icvFrame ?? */
    0,
    /* 0x43 icv3D ?? */
    0,
    /* 0x44 icv3DText ?? */
    0,
    /* 0x45 icv3DHilite ?? */
    0,
    /* 0x46 icv3DShadow ?? */
    0,
    /* 0x47 icvHilite ?? */
    0,
    /* 0x48 icvCtlText ?? */
    0,
    /* 0x49 icvCtlScrl ?? */
    0,
    /* 0x4A icvCtlInv ?? */
    0,
    /* 0x4B icvCtlBody ?? */
    0,
    /* 0x4C icvCtlFrame ?? */
    0,
    /* 0x4D icvCtlFore ?? */
    0,
    /* 0x4E icvCtlBack ?? */
    0,
    /* 0x4F icvCtlNeutral */
    0,
    /* 0x50 icvInfoBk ?? */
    0
    /* 0x51 icvInfoText ?? */
  ]);
  var XLSIcv = /* @__PURE__ */ dup(_XLSIcv);
  var BErr = {
    /*::[*/
    0: "#NULL!",
    /*::[*/
    7: "#DIV/0!",
    /*::[*/
    15: "#VALUE!",
    /*::[*/
    23: "#REF!",
    /*::[*/
    29: "#NAME?",
    /*::[*/
    36: "#NUM!",
    /*::[*/
    42: "#N/A",
    /*::[*/
    43: "#GETTING_DATA",
    /*::[*/
    255: "#WTF?"
  };
  var ct2type = {
    /* Workbook */
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
    "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
    "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
    "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
    /* Worksheet */
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
    "application/vnd.ms-excel.worksheet": "sheets",
    "application/vnd.ms-excel.binIndexWs": "TODO",
    /* Binary Index */
    /* Chartsheet */
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
    "application/vnd.ms-excel.chartsheet": "charts",
    /* Macrosheet */
    "application/vnd.ms-excel.macrosheet+xml": "macros",
    "application/vnd.ms-excel.macrosheet": "macros",
    "application/vnd.ms-excel.intlmacrosheet": "TODO",
    "application/vnd.ms-excel.binIndexMs": "TODO",
    /* Binary Index */
    /* Dialogsheet */
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
    "application/vnd.ms-excel.dialogsheet": "dialogs",
    /* Shared Strings */
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
    "application/vnd.ms-excel.sharedStrings": "strs",
    /* Styles */
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
    "application/vnd.ms-excel.styles": "styles",
    /* File Properties */
    "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
    /* Custom Data Properties */
    "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
    /* Comments */
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
    "application/vnd.ms-excel.comments": "comments",
    "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
    "application/vnd.ms-excel.person+xml": "people",
    /* Metadata (Stock/Geography and Dynamic Array) */
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
    "application/vnd.ms-excel.sheetMetadata": "metadata",
    /* PivotTable */
    "application/vnd.ms-excel.pivotTable": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
    /* Chart Objects */
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
    /* Chart Colors */
    "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
    /* Chart Style */
    "application/vnd.ms-office.chartstyle+xml": "TODO",
    /* Chart Advanced */
    "application/vnd.ms-office.chartex+xml": "TODO",
    /* Calculation Chain */
    "application/vnd.ms-excel.calcChain": "calcchains",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
    /* Printer Settings */
    "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
    /* ActiveX */
    "application/vnd.ms-office.activeX": "TODO",
    "application/vnd.ms-office.activeX+xml": "TODO",
    /* Custom Toolbars */
    "application/vnd.ms-excel.attachedToolbars": "TODO",
    /* External Data Connections */
    "application/vnd.ms-excel.connections": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
    /* External Links */
    "application/vnd.ms-excel.externalLink": "links",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
    /* PivotCache */
    "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
    "application/vnd.ms-excel.pivotCacheRecords": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
    /* Query Table */
    "application/vnd.ms-excel.queryTable": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
    /* Shared Workbook */
    "application/vnd.ms-excel.userNames": "TODO",
    "application/vnd.ms-excel.revisionHeaders": "TODO",
    "application/vnd.ms-excel.revisionLog": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
    /* Single Cell Table */
    "application/vnd.ms-excel.tableSingleCells": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
    /* Slicer */
    "application/vnd.ms-excel.slicer": "TODO",
    "application/vnd.ms-excel.slicerCache": "TODO",
    "application/vnd.ms-excel.slicer+xml": "TODO",
    "application/vnd.ms-excel.slicerCache+xml": "TODO",
    /* Sort Map */
    "application/vnd.ms-excel.wsSortMap": "TODO",
    /* Table */
    "application/vnd.ms-excel.table": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
    /* Themes */
    "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
    /* Theme Override */
    "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
    /* Timeline */
    "application/vnd.ms-excel.Timeline+xml": "TODO",
    /* verify */
    "application/vnd.ms-excel.TimelineCache+xml": "TODO",
    /* verify */
    /* VBA */
    "application/vnd.ms-office.vbaProject": "vba",
    "application/vnd.ms-office.vbaProjectSignature": "TODO",
    /* Volatile Dependencies */
    "application/vnd.ms-office.volatileDependencies": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
    /* Control Properties */
    "application/vnd.ms-excel.controlproperties+xml": "TODO",
    /* Data Model */
    "application/vnd.openxmlformats-officedocument.model+data": "TODO",
    /* Survey */
    "application/vnd.ms-excel.Survey+xml": "TODO",
    /* Drawing */
    "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
    /* VML */
    "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
    "application/vnd.openxmlformats-package.relationships+xml": "rels",
    "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
    /* Image */
    "image/png": "TODO",
    "sheet": "js"
  };
  var CT_LIST = {
    workbooks: {
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
      xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
      xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
      xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
      xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
    },
    strs: {
      /* Shared Strings */
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
      xlsb: "application/vnd.ms-excel.sharedStrings"
    },
    comments: {
      /* Comments */
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
      xlsb: "application/vnd.ms-excel.comments"
    },
    sheets: {
      /* Worksheet */
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
      xlsb: "application/vnd.ms-excel.worksheet"
    },
    charts: {
      /* Chartsheet */
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
      xlsb: "application/vnd.ms-excel.chartsheet"
    },
    dialogs: {
      /* Dialogsheet */
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
      xlsb: "application/vnd.ms-excel.dialogsheet"
    },
    macros: {
      /* Macrosheet (Excel 4.0 Macros) */
      xlsx: "application/vnd.ms-excel.macrosheet+xml",
      xlsb: "application/vnd.ms-excel.macrosheet"
    },
    metadata: {
      /* Metadata (Stock/Geography and Dynamic Array) */
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
      xlsb: "application/vnd.ms-excel.sheetMetadata"
    },
    styles: {
      /* Styles */
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
      xlsb: "application/vnd.ms-excel.styles"
    }
  };
  function new_ct() {
    return {
      workbooks: [],
      sheets: [],
      charts: [],
      dialogs: [],
      macros: [],
      rels: [],
      strs: [],
      comments: [],
      threadedcomments: [],
      links: [],
      coreprops: [],
      extprops: [],
      custprops: [],
      themes: [],
      styles: [],
      calcchains: [],
      vba: [],
      drawings: [],
      metadata: [],
      people: [],
      TODO: [],
      xmlns: ""
    };
  }
  function write_ct(ct, opts) {
    var type2ct = evert_arr(ct2type);
    var o = [], v;
    o[o.length] = XML_HEADER;
    o[o.length] = writextag("Types", null, {
      "xmlns": XMLNS.CT,
      "xmlns:xsd": XMLNS.xsd,
      "xmlns:xsi": XMLNS.xsi
    });
    o = o.concat([
      ["xml", "application/xml"],
      ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
      ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
      ["data", "application/vnd.openxmlformats-officedocument.model+data"],
      /* from test files */
      ["bmp", "image/bmp"],
      ["png", "image/png"],
      ["gif", "image/gif"],
      ["emf", "image/x-emf"],
      ["wmf", "image/x-wmf"],
      ["jpg", "image/jpeg"],
      ["jpeg", "image/jpeg"],
      ["tif", "image/tiff"],
      ["tiff", "image/tiff"],
      ["pdf", "application/pdf"],
      ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
    ].map(function(x) {
      return writextag("Default", null, { "Extension": x[0], "ContentType": x[1] });
    }));
    var f1 = function(w) {
      if (ct[w] && ct[w].length > 0) {
        v = ct[w][0];
        o[o.length] = writextag("Override", null, {
          "PartName": (v[0] == "/" ? "" : "/") + v,
          "ContentType": CT_LIST[w][opts.bookType] || CT_LIST[w]["xlsx"]
        });
      }
    };
    var f2 = function(w) {
      (ct[w] || []).forEach(function(v2) {
        o[o.length] = writextag("Override", null, {
          "PartName": (v2[0] == "/" ? "" : "/") + v2,
          "ContentType": CT_LIST[w][opts.bookType] || CT_LIST[w]["xlsx"]
        });
      });
    };
    var f3 = function(t) {
      (ct[t] || []).forEach(function(v2) {
        o[o.length] = writextag("Override", null, {
          "PartName": (v2[0] == "/" ? "" : "/") + v2,
          "ContentType": type2ct[t][0]
        });
      });
    };
    f1("workbooks");
    f2("sheets");
    f2("charts");
    f3("themes");
    ["strs", "styles"].forEach(f1);
    ["coreprops", "extprops", "custprops"].forEach(f3);
    f3("vba");
    f3("comments");
    f3("threadedcomments");
    f3("drawings");
    f2("metadata");
    f3("people");
    if (o.length > 2) {
      o[o.length] = "</Types>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  var RELS = {
    WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
    SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
    HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
    VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
    XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
    XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
    XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
    CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
    CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
    CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
    CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
    EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
    CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
    SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
    STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
    THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
    CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
    CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
    CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
    WS: [
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
      "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
    ],
    DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
    MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
    IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
    DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
    XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
    TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
    PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
    VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
  };
  function get_rels_path(file) {
    var n = file.lastIndexOf("/");
    return file.slice(0, n + 1) + "_rels/" + file.slice(n + 1) + ".rels";
  }
  function write_rels(rels) {
    var o = [XML_HEADER, writextag("Relationships", null, {
      //'xmlns:ns0': XMLNS.RELS,
      "xmlns": XMLNS.RELS
    })];
    keys(rels["!id"]).forEach(function(rid) {
      o[o.length] = writextag("Relationship", null, rels["!id"][rid]);
    });
    if (o.length > 2) {
      o[o.length] = "</Relationships>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function add_rels(rels, rId, f, type, relobj, targetmode) {
    if (!relobj) relobj = {};
    if (!rels["!id"]) rels["!id"] = {};
    if (!rels["!idx"]) rels["!idx"] = 1;
    if (rId < 0) for (rId = rels["!idx"]; rels["!id"]["rId" + rId]; ++rId) {
    }
    rels["!idx"] = rId + 1;
    relobj.Id = "rId" + rId;
    relobj.Type = type;
    relobj.Target = f;
    if (targetmode) relobj.TargetMode = targetmode;
    else if ([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) > -1) relobj.TargetMode = "External";
    if (rels["!id"][relobj.Id]) throw new Error("Cannot rewrite rId " + rId);
    rels["!id"][relobj.Id] = relobj;
    rels[("/" + relobj.Target).replace("//", "/")] = relobj;
    return rId;
  }
  function write_manifest(manifest) {
    var o = [XML_HEADER];
    o.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');
    o.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
    for (var i = 0; i < manifest.length; ++i) o.push('  <manifest:file-entry manifest:full-path="' + manifest[i][0] + '" manifest:media-type="' + manifest[i][1] + '"/>\n');
    o.push("</manifest:manifest>");
    return o.join("");
  }
  function write_rdf_type(file, res, tag) {
    return [
      '  <rdf:Description rdf:about="' + file + '">\n',
      '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + "#" + res + '"/>\n',
      "  </rdf:Description>\n"
    ].join("");
  }
  function write_rdf_has(base, file) {
    return [
      '  <rdf:Description rdf:about="' + base + '">\n',
      '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/>\n',
      "  </rdf:Description>\n"
    ].join("");
  }
  function write_rdf(rdf) {
    var o = [XML_HEADER];
    o.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
    for (var i = 0; i != rdf.length; ++i) {
      o.push(write_rdf_type(rdf[i][0], rdf[i][1]));
      o.push(write_rdf_has("", rdf[i][0]));
    }
    o.push(write_rdf_type("", "Document", "pkg"));
    o.push("</rdf:RDF>");
    return o.join("");
  }
  function write_meta_ods() {
    return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
  }
  var CORE_PROPS = [
    ["cp:category", "Category"],
    ["cp:contentStatus", "ContentStatus"],
    ["cp:keywords", "Keywords"],
    ["cp:lastModifiedBy", "LastAuthor"],
    ["cp:lastPrinted", "LastPrinted"],
    ["cp:revision", "RevNumber"],
    ["cp:version", "Version"],
    ["dc:creator", "Author"],
    ["dc:description", "Comments"],
    ["dc:identifier", "Identifier"],
    ["dc:language", "Language"],
    ["dc:subject", "Subject"],
    ["dc:title", "Title"],
    ["dcterms:created", "CreatedDate", "date"],
    ["dcterms:modified", "ModifiedDate", "date"]
  ];
  function cp_doit(f, g, h, o, p) {
    if (p[f] != null || g == null || g === "") return;
    p[f] = g;
    g = escapexml(g);
    o[o.length] = h ? writextag(f, g, h) : writetag(f, g);
  }
  function write_core_props(cp, _opts) {
    var opts = _opts || {};
    var o = [XML_HEADER, writextag("cp:coreProperties", null, {
      //'xmlns': XMLNS.CORE_PROPS,
      "xmlns:cp": XMLNS.CORE_PROPS,
      "xmlns:dc": XMLNS.dc,
      "xmlns:dcterms": XMLNS.dcterms,
      "xmlns:dcmitype": XMLNS.dcmitype,
      "xmlns:xsi": XMLNS.xsi
    })], p = {};
    if (!cp && !opts.Props) return o.join("");
    if (cp) {
      if (cp.CreatedDate != null) cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p);
      if (cp.ModifiedDate != null) cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p);
    }
    for (var i = 0; i != CORE_PROPS.length; ++i) {
      var f = CORE_PROPS[i];
      var v = opts.Props && opts.Props[f[1]] != null ? opts.Props[f[1]] : cp ? cp[f[1]] : null;
      if (v === true) v = "1";
      else if (v === false) v = "0";
      else if (typeof v == "number") v = String(v);
      if (v != null) cp_doit(f[0], v, null, o, p);
    }
    if (o.length > 2) {
      o[o.length] = "</cp:coreProperties>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  var EXT_PROPS = [
    ["Application", "Application", "string"],
    ["AppVersion", "AppVersion", "string"],
    ["Company", "Company", "string"],
    ["DocSecurity", "DocSecurity", "string"],
    ["Manager", "Manager", "string"],
    ["HyperlinksChanged", "HyperlinksChanged", "bool"],
    ["SharedDoc", "SharedDoc", "bool"],
    ["LinksUpToDate", "LinksUpToDate", "bool"],
    ["ScaleCrop", "ScaleCrop", "bool"],
    ["HeadingPairs", "HeadingPairs", "raw"],
    ["TitlesOfParts", "TitlesOfParts", "raw"]
  ];
  var PseudoPropsPairs = [
    "Worksheets",
    "SheetNames",
    "NamedRanges",
    "DefinedNames",
    "Chartsheets",
    "ChartNames"
  ];
  function write_ext_props(cp) {
    var o = [], W = writextag;
    if (!cp) cp = {};
    cp.Application = "SheetJS";
    o[o.length] = XML_HEADER;
    o[o.length] = writextag("Properties", null, {
      "xmlns": XMLNS.EXT_PROPS,
      "xmlns:vt": XMLNS.vt
    });
    EXT_PROPS.forEach(function(f) {
      if (cp[f[1]] === void 0) return;
      var v;
      switch (f[2]) {
        case "string":
          v = escapexml(String(cp[f[1]]));
          break;
        case "bool":
          v = cp[f[1]] ? "true" : "false";
          break;
      }
      if (v !== void 0) o[o.length] = W(f[0], v);
    });
    o[o.length] = W("HeadingPairs", W("vt:vector", W("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + W("vt:variant", W("vt:i4", String(cp.Worksheets))), { size: 2, baseType: "variant" }));
    o[o.length] = W("TitlesOfParts", W("vt:vector", cp.SheetNames.map(function(s) {
      return "<vt:lpstr>" + escapexml(s) + "</vt:lpstr>";
    }).join(""), { size: cp.Worksheets, baseType: "lpstr" }));
    if (o.length > 2) {
      o[o.length] = "</Properties>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function write_cust_props(cp) {
    var o = [XML_HEADER, writextag("Properties", null, {
      "xmlns": XMLNS.CUST_PROPS,
      "xmlns:vt": XMLNS.vt
    })];
    if (!cp) return o.join("");
    var pid = 1;
    keys(cp).forEach(function custprop(k) {
      ++pid;
      o[o.length] = writextag("property", write_vt(cp[k], true), {
        "fmtid": "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
        "pid": pid,
        "name": escapexml(k)
      });
    });
    if (o.length > 2) {
      o[o.length] = "</Properties>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  var XLMLDocPropsMap = {
    Title: "Title",
    Subject: "Subject",
    Author: "Author",
    Keywords: "Keywords",
    Comments: "Description",
    LastAuthor: "LastAuthor",
    RevNumber: "Revision",
    Application: "AppName",
    /* TotalTime: 'TotalTime', */
    LastPrinted: "LastPrinted",
    CreatedDate: "Created",
    ModifiedDate: "LastSaved",
    /* Pages */
    /* Words */
    /* Characters */
    Category: "Category",
    /* PresentationFormat */
    Manager: "Manager",
    Company: "Company",
    /* Guid */
    /* HyperlinkBase */
    /* Bytes */
    /* Lines */
    /* Paragraphs */
    /* CharactersWithSpaces */
    AppVersion: "Version",
    ContentStatus: "ContentStatus",
    /* NOTE: missing from schema */
    Identifier: "Identifier",
    /* NOTE: missing from schema */
    Language: "Language"
    /* NOTE: missing from schema */
  };
  function xlml_write_docprops(Props, opts) {
    var o = [];
    keys(XLMLDocPropsMap).map(function(m) {
      for (var i = 0; i < CORE_PROPS.length; ++i) if (CORE_PROPS[i][1] == m) return CORE_PROPS[i];
      for (i = 0; i < EXT_PROPS.length; ++i) if (EXT_PROPS[i][1] == m) return EXT_PROPS[i];
      throw m;
    }).forEach(function(p) {
      if (Props[p[1]] == null) return;
      var m = opts && opts.Props && opts.Props[p[1]] != null ? opts.Props[p[1]] : Props[p[1]];
      switch (p[2]) {
        case "date":
          m = new Date(m).toISOString().replace(/\.\d*Z/, "Z");
          break;
      }
      if (typeof m == "number") m = String(m);
      else if (m === true || m === false) {
        m = m ? "1" : "0";
      } else if (m instanceof Date) m = new Date(m).toISOString().replace(/\.\d*Z/, "");
      o.push(writetag(XLMLDocPropsMap[p[1]] || p[1], m));
    });
    return writextag("DocumentProperties", o.join(""), { xmlns: XLMLNS.o });
  }
  function xlml_write_custprops(Props, Custprops) {
    var BLACKLIST = ["Worksheets", "SheetNames"];
    var T = "CustomDocumentProperties";
    var o = [];
    if (Props) keys(Props).forEach(function(k) {
      if (!Object.prototype.hasOwnProperty.call(Props, k)) return;
      for (var i = 0; i < CORE_PROPS.length; ++i) if (k == CORE_PROPS[i][1]) return;
      for (i = 0; i < EXT_PROPS.length; ++i) if (k == EXT_PROPS[i][1]) return;
      for (i = 0; i < BLACKLIST.length; ++i) if (k == BLACKLIST[i]) return;
      var m = Props[k];
      var t = "string";
      if (typeof m == "number") {
        t = "float";
        m = String(m);
      } else if (m === true || m === false) {
        t = "boolean";
        m = m ? "1" : "0";
      } else m = String(m);
      o.push(writextag(escapexmltag(k), m, { "dt:dt": t }));
    });
    if (Custprops) keys(Custprops).forEach(function(k) {
      if (!Object.prototype.hasOwnProperty.call(Custprops, k)) return;
      if (Props && Object.prototype.hasOwnProperty.call(Props, k)) return;
      var m = Custprops[k];
      var t = "string";
      if (typeof m == "number") {
        t = "float";
        m = String(m);
      } else if (m === true || m === false) {
        t = "boolean";
        m = m ? "1" : "0";
      } else if (m instanceof Date) {
        t = "dateTime.tz";
        m = m.toISOString();
      } else m = String(m);
      o.push(writextag(escapexmltag(k), m, { "dt:dt": t }));
    });
    return "<" + T + ' xmlns="' + XLMLNS.o + '">' + o.join("") + "</" + T + ">";
  }
  function write_FILETIME(time) {
    var date = typeof time == "string" ? new Date(Date.parse(time)) : time;
    var t = date.getTime() / 1e3 + 11644473600;
    var l = t % Math.pow(2, 32), h = (t - l) / Math.pow(2, 32);
    l *= 1e7;
    h *= 1e7;
    var w = l / Math.pow(2, 32) | 0;
    if (w > 0) {
      l = l % Math.pow(2, 32);
      h += w;
    }
    var o = new_buf(8);
    o.write_shift(4, l);
    o.write_shift(4, h);
    return o;
  }
  function write_TypedPropertyValue(type, value) {
    var o = new_buf(4), p = new_buf(4);
    o.write_shift(4, type == 80 ? 31 : type);
    switch (type) {
      case 3:
        p.write_shift(-4, value);
        break;
      case 5:
        p = new_buf(8);
        p.write_shift(8, value, "f");
        break;
      case 11:
        p.write_shift(4, value ? 1 : 0);
        break;
      case 64:
        p = write_FILETIME(value);
        break;
      case 31:
      case 80:
        p = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
        p.write_shift(4, value.length + 1);
        p.write_shift(0, value, "dbcs");
        while (p.l != p.length) p.write_shift(1, 0);
        break;
      default:
        throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);
    }
    return bconcat([o, p]);
  }
  var XLSPSSkip = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
  function guess_property_type(val) {
    switch (typeof val) {
      case "boolean":
        return 11;
      case "number":
        return (val | 0) == val ? 3 : 5;
      case "string":
        return 31;
      case "object":
        if (val instanceof Date) return 64;
        break;
    }
    return -1;
  }
  function write_PropertySet(entries, RE, PIDSI) {
    var hdr = new_buf(8), piao = [], prop = [];
    var sz = 8, i = 0;
    var pr = new_buf(8), pio = new_buf(8);
    pr.write_shift(4, 2);
    pr.write_shift(4, 1200);
    pio.write_shift(4, 1);
    prop.push(pr);
    piao.push(pio);
    sz += 8 + pr.length;
    if (!RE) {
      pio = new_buf(8);
      pio.write_shift(4, 0);
      piao.unshift(pio);
      var bufs = [new_buf(4)];
      bufs[0].write_shift(4, entries.length);
      for (i = 0; i < entries.length; ++i) {
        var value = entries[i][0];
        pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
        pr.write_shift(4, i + 2);
        pr.write_shift(4, value.length + 1);
        pr.write_shift(0, value, "dbcs");
        while (pr.l != pr.length) pr.write_shift(1, 0);
        bufs.push(pr);
      }
      pr = bconcat(bufs);
      prop.unshift(pr);
      sz += 8 + pr.length;
    }
    for (i = 0; i < entries.length; ++i) {
      if (RE && !RE[entries[i][0]]) continue;
      if (XLSPSSkip.indexOf(entries[i][0]) > -1 || PseudoPropsPairs.indexOf(entries[i][0]) > -1) continue;
      if (entries[i][1] == null) continue;
      var val = entries[i][1], idx = 0;
      if (RE) {
        idx = +RE[entries[i][0]];
        var pinfo = PIDSI[idx];
        if (pinfo.p == "version" && typeof val == "string") {
          var arr = val.split(".");
          val = (+arr[0] << 16) + (+arr[1] || 0);
        }
        pr = write_TypedPropertyValue(pinfo.t, val);
      } else {
        var T = guess_property_type(val);
        if (T == -1) {
          T = 31;
          val = String(val);
        }
        pr = write_TypedPropertyValue(T, val);
      }
      prop.push(pr);
      pio = new_buf(8);
      pio.write_shift(4, !RE ? 2 + i : idx);
      piao.push(pio);
      sz += 8 + pr.length;
    }
    var w = 8 * (prop.length + 1);
    for (i = 0; i < prop.length; ++i) {
      piao[i].write_shift(4, w);
      w += prop[i].length;
    }
    hdr.write_shift(4, sz);
    hdr.write_shift(4, prop.length);
    return bconcat([hdr].concat(piao).concat(prop));
  }
  function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {
    var hdr = new_buf(entries2 ? 68 : 48);
    var bufs = [hdr];
    hdr.write_shift(2, 65534);
    hdr.write_shift(2, 0);
    hdr.write_shift(4, 842412599);
    hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");
    hdr.write_shift(4, entries2 ? 2 : 1);
    hdr.write_shift(16, clsid, "hex");
    hdr.write_shift(4, entries2 ? 68 : 48);
    var ps0 = write_PropertySet(entries, RE, PIDSI);
    bufs.push(ps0);
    if (entries2) {
      var ps1 = write_PropertySet(entries2, null, null);
      hdr.write_shift(16, clsid2, "hex");
      hdr.write_shift(4, 68 + ps0.length);
      bufs.push(ps1);
    }
    return bconcat(bufs);
  }
  function writezeroes(n, o) {
    if (!o) o = new_buf(n);
    for (var j = 0; j < n; ++j) o.write_shift(1, 0);
    return o;
  }
  function parsebool(blob, length) {
    return blob.read_shift(length) === 1;
  }
  function writebool(v, o) {
    if (!o) o = new_buf(2);
    o.write_shift(2, +!!v);
    return o;
  }
  function parseuint16(blob) {
    return blob.read_shift(2, "u");
  }
  function writeuint16(v, o) {
    if (!o) o = new_buf(2);
    o.write_shift(2, v);
    return o;
  }
  function write_Bes(v, t, o) {
    if (!o) o = new_buf(2);
    o.write_shift(1, t == "e" ? +v : +!!v);
    o.write_shift(1, t == "e" ? 1 : 0);
    return o;
  }
  function parse_ShortXLUnicodeString(blob, length, opts) {
    var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
    var encoding = "sbcs-cont";
    var cp = current_codepage;
    if (opts && opts.biff >= 8) current_codepage = 1200;
    if (!opts || opts.biff == 8) {
      var fHighByte = blob.read_shift(1);
      if (fHighByte) {
        encoding = "dbcs-cont";
      }
    } else if (opts.biff == 12) {
      encoding = "wstr";
    }
    if (opts.biff >= 2 && opts.biff <= 5) encoding = "cpstr";
    var o = cch ? blob.read_shift(cch, encoding) : "";
    current_codepage = cp;
    return o;
  }
  function write_XLUnicodeRichExtendedString(xlstr) {
    var str = xlstr.t || "", nfmts = 1;
    var hdr = new_buf(3 + (nfmts > 1 ? 2 : 0));
    hdr.write_shift(2, str.length);
    hdr.write_shift(1, (nfmts > 1 ? 8 : 0) | 1);
    if (nfmts > 1) hdr.write_shift(2, nfmts);
    var otext = new_buf(2 * str.length);
    otext.write_shift(2 * str.length, str, "utf16le");
    var out = [hdr, otext];
    return bconcat(out);
  }
  function parse_XLUnicodeStringNoCch(blob, cch, opts) {
    var retval;
    if (opts) {
      if (opts.biff >= 2 && opts.biff <= 5) return blob.read_shift(cch, "cpstr");
      if (opts.biff >= 12) return blob.read_shift(cch, "dbcs-cont");
    }
    var fHighByte = blob.read_shift(1);
    if (fHighByte === 0) {
      retval = blob.read_shift(cch, "sbcs-cont");
    } else {
      retval = blob.read_shift(cch, "dbcs-cont");
    }
    return retval;
  }
  function parse_XLUnicodeString(blob, length, opts) {
    var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    if (cch === 0) {
      blob.l++;
      return "";
    }
    return parse_XLUnicodeStringNoCch(blob, cch, opts);
  }
  function parse_XLUnicodeString2(blob, length, opts) {
    if (opts.biff > 5) return parse_XLUnicodeString(blob, length, opts);
    var cch = blob.read_shift(1);
    if (cch === 0) {
      blob.l++;
      return "";
    }
    return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
  }
  function write_XLUnicodeString(str, opts, o) {
    if (!o) o = new_buf(3 + 2 * str.length);
    o.write_shift(2, str.length);
    o.write_shift(1, 1);
    o.write_shift(31, str, "utf16le");
    return o;
  }
  function write_HyperlinkString(str, o) {
    if (!o) o = new_buf(6 + str.length * 2);
    o.write_shift(4, 1 + str.length);
    for (var i = 0; i < str.length; ++i) o.write_shift(2, str.charCodeAt(i));
    o.write_shift(2, 0);
    return o;
  }
  function write_Hyperlink(hl) {
    var out = new_buf(512), i = 0;
    var Target = hl.Target;
    if (Target.slice(0, 7) == "file://") Target = Target.slice(7);
    var hashidx = Target.indexOf("#");
    var F = hashidx > -1 ? 31 : 23;
    switch (Target.charAt(0)) {
      case "#":
        F = 28;
        break;
      case ".":
        F &= ~2;
        break;
    }
    out.write_shift(4, 2);
    out.write_shift(4, F);
    var data = [8, 6815827, 6619237, 4849780, 83];
    for (i = 0; i < data.length; ++i) out.write_shift(4, data[i]);
    if (F == 28) {
      Target = Target.slice(1);
      write_HyperlinkString(Target, out);
    } else if (F & 2) {
      data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
      for (i = 0; i < data.length; ++i) out.write_shift(1, parseInt(data[i], 16));
      var Pretarget = hashidx > -1 ? Target.slice(0, hashidx) : Target;
      out.write_shift(4, 2 * (Pretarget.length + 1));
      for (i = 0; i < Pretarget.length; ++i) out.write_shift(2, Pretarget.charCodeAt(i));
      out.write_shift(2, 0);
      if (F & 8) write_HyperlinkString(hashidx > -1 ? Target.slice(hashidx + 1) : "", out);
    } else {
      data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");
      for (i = 0; i < data.length; ++i) out.write_shift(1, parseInt(data[i], 16));
      var P = 0;
      while (Target.slice(P * 3, P * 3 + 3) == "../" || Target.slice(P * 3, P * 3 + 3) == "..\\") ++P;
      out.write_shift(2, P);
      out.write_shift(4, Target.length - 3 * P + 1);
      for (i = 0; i < Target.length - 3 * P; ++i) out.write_shift(1, Target.charCodeAt(i + 3 * P) & 255);
      out.write_shift(1, 0);
      out.write_shift(2, 65535);
      out.write_shift(2, 57005);
      for (i = 0; i < 6; ++i) out.write_shift(4, 0);
    }
    return out.slice(0, out.l);
  }
  function write_XLSCell(R, C, ixfe, o) {
    if (!o) o = new_buf(6);
    o.write_shift(2, R);
    o.write_shift(2, C);
    o.write_shift(2, ixfe || 0);
    return o;
  }
  function parse_XTI(blob, length, opts) {
    var w = opts.biff > 8 ? 4 : 2;
    var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w, "i"), itabLast = blob.read_shift(w, "i");
    return [iSupBook, itabFirst, itabLast];
  }
  function parse_Ref8U(blob) {
    var rwFirst = blob.read_shift(2);
    var rwLast = blob.read_shift(2);
    var colFirst = blob.read_shift(2);
    var colLast = blob.read_shift(2);
    return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
  }
  function write_Ref8U(r, o) {
    if (!o) o = new_buf(8);
    o.write_shift(2, r.s.r);
    o.write_shift(2, r.e.r);
    o.write_shift(2, r.s.c);
    o.write_shift(2, r.e.c);
    return o;
  }
  function write_BOF(wb, t, o) {
    var h = 1536, w = 16;
    switch (o.bookType) {
      case "biff8":
        break;
      case "biff5":
        h = 1280;
        w = 8;
        break;
      case "biff4":
        h = 4;
        w = 6;
        break;
      case "biff3":
        h = 3;
        w = 6;
        break;
      case "biff2":
        h = 2;
        w = 4;
        break;
      case "xla":
        break;
      default:
        throw new Error("unsupported BIFF version");
    }
    var out = new_buf(w);
    out.write_shift(2, h);
    out.write_shift(2, t);
    if (w > 4) out.write_shift(2, 29282);
    if (w > 6) out.write_shift(2, 1997);
    if (w > 8) {
      out.write_shift(2, 49161);
      out.write_shift(2, 1);
      out.write_shift(2, 1798);
      out.write_shift(2, 0);
    }
    return out;
  }
  function write_WriteAccess(s, opts) {
    var b8 = !opts || opts.biff == 8;
    var o = new_buf(b8 ? 112 : 54);
    o.write_shift(opts.biff == 8 ? 2 : 1, 7);
    if (b8) o.write_shift(1, 0);
    o.write_shift(4, 859007059);
    o.write_shift(4, 5458548 | (b8 ? 0 : 536870912));
    while (o.l < o.length) o.write_shift(1, b8 ? 0 : 32);
    return o;
  }
  function write_BoundSheet8(data, opts) {
    var w = !opts || opts.biff >= 8 ? 2 : 1;
    var o = new_buf(8 + w * data.name.length);
    o.write_shift(4, data.pos);
    o.write_shift(1, data.hs || 0);
    o.write_shift(1, data.dt);
    o.write_shift(1, data.name.length);
    if (opts.biff >= 8) o.write_shift(1, 1);
    o.write_shift(w * data.name.length, data.name, opts.biff < 8 ? "sbcs" : "utf16le");
    var out = o.slice(0, o.l);
    out.l = o.l;
    return out;
  }
  function write_SST(sst, opts) {
    var header = new_buf(8);
    header.write_shift(4, sst.Count);
    header.write_shift(4, sst.Unique);
    var strs = [];
    for (var j = 0; j < sst.length; ++j) strs[j] = write_XLUnicodeRichExtendedString(sst[j], opts);
    var o = bconcat([header].concat(strs));
    o.parts = [header.length].concat(strs.map(function(str) {
      return str.length;
    }));
    return o;
  }
  function write_Window1() {
    var o = new_buf(18);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 29280);
    o.write_shift(2, 17600);
    o.write_shift(2, 56);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 1);
    o.write_shift(2, 500);
    return o;
  }
  function write_Window2(view) {
    var o = new_buf(18), f = 1718;
    if (view && view.RTL) f |= 64;
    o.write_shift(2, f);
    o.write_shift(4, 0);
    o.write_shift(4, 64);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    return o;
  }
  function write_Font(data, opts) {
    var name = data.name || "Arial";
    var b5 = opts && opts.biff == 5, w = b5 ? 15 + name.length : 16 + 2 * name.length;
    var o = new_buf(w);
    o.write_shift(2, (data.sz || 12) * 20);
    o.write_shift(4, 0);
    o.write_shift(2, 400);
    o.write_shift(4, 0);
    o.write_shift(2, 0);
    o.write_shift(1, name.length);
    if (!b5) o.write_shift(1, 1);
    o.write_shift((b5 ? 1 : 2) * name.length, name, b5 ? "sbcs" : "utf16le");
    return o;
  }
  function write_LabelSst(R, C, v, os) {
    var o = new_buf(10);
    write_XLSCell(R, C, os, o);
    o.write_shift(4, v);
    return o;
  }
  function write_Label(R, C, v, os, opts) {
    var b8 = !opts || opts.biff == 8;
    var o = new_buf(6 + 2 + +b8 + (1 + b8) * v.length);
    write_XLSCell(R, C, os, o);
    o.write_shift(2, v.length);
    if (b8) o.write_shift(1, 1);
    o.write_shift((1 + b8) * v.length, v, b8 ? "utf16le" : "sbcs");
    return o;
  }
  function write_Format(i, f, opts, o) {
    var b5 = opts && opts.biff == 5;
    if (!o) o = new_buf(b5 ? 3 + f.length : 5 + 2 * f.length);
    o.write_shift(2, i);
    o.write_shift(b5 ? 1 : 2, f.length);
    if (!b5) o.write_shift(1, 1);
    o.write_shift((b5 ? 1 : 2) * f.length, f, b5 ? "sbcs" : "utf16le");
    var out = o.length > o.l ? o.slice(0, o.l) : o;
    if (out.l == null) out.l = out.length;
    return out;
  }
  function write_Dimensions(range, opts) {
    var w = opts.biff == 8 || !opts.biff ? 4 : 2;
    var o = new_buf(2 * w + 6);
    o.write_shift(w, range.s.r);
    o.write_shift(w, range.e.r + 1);
    o.write_shift(2, range.s.c);
    o.write_shift(2, range.e.c + 1);
    o.write_shift(2, 0);
    return o;
  }
  function write_XF(data, ixfeP, opts, o) {
    var b5 = opts && opts.biff == 5;
    if (!o) o = new_buf(b5 ? 16 : 20);
    o.write_shift(2, 0);
    if (data.style) {
      o.write_shift(2, data.numFmtId || 0);
      o.write_shift(2, 65524);
    } else {
      o.write_shift(2, data.numFmtId || 0);
      o.write_shift(2, ixfeP << 4);
    }
    var f = 0;
    if (data.numFmtId > 0 && b5) f |= 1024;
    o.write_shift(4, f);
    o.write_shift(4, 0);
    if (!b5) o.write_shift(4, 0);
    o.write_shift(2, 0);
    return o;
  }
  function write_Guts(guts) {
    var o = new_buf(8);
    o.write_shift(4, 0);
    o.write_shift(2, guts[0] ? guts[0] + 1 : 0);
    o.write_shift(2, guts[1] ? guts[1] + 1 : 0);
    return o;
  }
  function write_BoolErr(R, C, v, os, opts, t) {
    var o = new_buf(8);
    write_XLSCell(R, C, os, o);
    write_Bes(v, t, o);
    return o;
  }
  function write_Number(R, C, v, os) {
    var o = new_buf(14);
    write_XLSCell(R, C, os, o);
    write_Xnum(v, o);
    return o;
  }
  function parse_ExternSheet(blob, length, opts) {
    if (opts.biff < 8) return parse_BIFF5ExternSheet(blob, length, opts);
    var o = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
    while (len-- !== 0) o.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
    if (blob.l != target) throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
    return o;
  }
  function parse_BIFF5ExternSheet(blob, length, opts) {
    if (blob[blob.l + 1] == 3) blob[blob.l]++;
    var o = parse_ShortXLUnicodeString(blob, length, opts);
    return o.charCodeAt(0) == 3 ? o.slice(1) : o;
  }
  function write_MergeCells(merges) {
    var o = new_buf(2 + merges.length * 8);
    o.write_shift(2, merges.length);
    for (var i = 0; i < merges.length; ++i) write_Ref8U(merges[i], o);
    return o;
  }
  function write_HLink(hl) {
    var O = new_buf(24);
    var ref = decode_cell(hl[0]);
    O.write_shift(2, ref.r);
    O.write_shift(2, ref.r);
    O.write_shift(2, ref.c);
    O.write_shift(2, ref.c);
    var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
    for (var i = 0; i < 16; ++i) O.write_shift(1, parseInt(clsid[i], 16));
    return bconcat([O, write_Hyperlink(hl[1])]);
  }
  function write_HLinkTooltip(hl) {
    var TT = hl[1].Tooltip;
    var O = new_buf(10 + 2 * (TT.length + 1));
    O.write_shift(2, 2048);
    var ref = decode_cell(hl[0]);
    O.write_shift(2, ref.r);
    O.write_shift(2, ref.r);
    O.write_shift(2, ref.c);
    O.write_shift(2, ref.c);
    for (var i = 0; i < TT.length; ++i) O.write_shift(2, TT.charCodeAt(i));
    O.write_shift(2, 0);
    return O;
  }
  function write_Country(o) {
    if (!o) o = new_buf(4);
    o.write_shift(2, 1);
    o.write_shift(2, 1);
    return o;
  }
  function parse_ColInfo(blob, length, opts) {
    if (!opts.cellStyles) return parsenoop(blob, length);
    var w = opts && opts.biff >= 12 ? 4 : 2;
    var colFirst = blob.read_shift(w);
    var colLast = blob.read_shift(w);
    var coldx = blob.read_shift(w);
    var ixfe = blob.read_shift(w);
    var flags = blob.read_shift(2);
    if (w == 2) blob.l += 2;
    var o = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
    if (opts.biff >= 5 || !opts.biff) o.level = flags >> 8 & 7;
    return o;
  }
  function write_ColInfo(col, idx) {
    var o = new_buf(12);
    o.write_shift(2, idx);
    o.write_shift(2, idx);
    o.write_shift(2, col.width * 256);
    o.write_shift(2, 0);
    var f = 0;
    if (col.hidden) f |= 1;
    o.write_shift(1, f);
    f = col.level || 0;
    o.write_shift(1, f);
    o.write_shift(2, 0);
    return o;
  }
  function write_RRTabId(n) {
    var out = new_buf(2 * n);
    for (var i = 0; i < n; ++i) out.write_shift(2, i + 1);
    return out;
  }
  function write_BIFF2NUM(r, c, val) {
    var out = new_buf(15);
    write_BIFF2Cell(out, r, c);
    out.write_shift(8, val, "f");
    return out;
  }
  function write_BIFF2INT(r, c, val) {
    var out = new_buf(9);
    write_BIFF2Cell(out, r, c);
    out.write_shift(2, val);
    return out;
  }
  var DBF = /* @__PURE__ */ (function() {
    var dbf_codepage_map = {
      /* Code Pages Supported by Visual FoxPro */
      /*::[*/
      1: 437,
      /*::[*/
      2: 850,
      /*::[*/
      3: 1252,
      /*::[*/
      4: 1e4,
      /*::[*/
      100: 852,
      /*::[*/
      101: 866,
      /*::[*/
      102: 865,
      /*::[*/
      103: 861,
      /*::[*/
      104: 895,
      /*::[*/
      105: 620,
      /*::[*/
      106: 737,
      /*::[*/
      107: 857,
      /*::[*/
      120: 950,
      /*::[*/
      121: 949,
      /*::[*/
      122: 936,
      /*::[*/
      123: 932,
      /*::[*/
      124: 874,
      /*::[*/
      125: 1255,
      /*::[*/
      126: 1256,
      /*::[*/
      150: 10007,
      /*::[*/
      151: 10029,
      /*::[*/
      152: 10006,
      /*::[*/
      200: 1250,
      /*::[*/
      201: 1251,
      /*::[*/
      202: 1254,
      /*::[*/
      203: 1253,
      /* shapefile DBF extension */
      /*::[*/
      0: 20127,
      /*::[*/
      8: 865,
      /*::[*/
      9: 437,
      /*::[*/
      10: 850,
      /*::[*/
      11: 437,
      /*::[*/
      13: 437,
      /*::[*/
      14: 850,
      /*::[*/
      15: 437,
      /*::[*/
      16: 850,
      /*::[*/
      17: 437,
      /*::[*/
      18: 850,
      /*::[*/
      19: 932,
      /*::[*/
      20: 850,
      /*::[*/
      21: 437,
      /*::[*/
      22: 850,
      /*::[*/
      23: 865,
      /*::[*/
      24: 437,
      /*::[*/
      25: 437,
      /*::[*/
      26: 850,
      /*::[*/
      27: 437,
      /*::[*/
      28: 863,
      /*::[*/
      29: 850,
      /*::[*/
      31: 852,
      /*::[*/
      34: 852,
      /*::[*/
      35: 852,
      /*::[*/
      36: 860,
      /*::[*/
      37: 850,
      /*::[*/
      38: 866,
      /*::[*/
      55: 850,
      /*::[*/
      64: 852,
      /*::[*/
      77: 936,
      /*::[*/
      78: 949,
      /*::[*/
      79: 950,
      /*::[*/
      80: 874,
      /*::[*/
      87: 1252,
      /*::[*/
      88: 1252,
      /*::[*/
      89: 1252,
      /*::[*/
      108: 863,
      /*::[*/
      134: 737,
      /*::[*/
      135: 852,
      /*::[*/
      136: 857,
      /*::[*/
      204: 1257,
      /*::[*/
      255: 16969
    };
    var dbf_reverse_map = evert({
      /*::[*/
      1: 437,
      /*::[*/
      2: 850,
      /*::[*/
      3: 1252,
      /*::[*/
      4: 1e4,
      /*::[*/
      100: 852,
      /*::[*/
      101: 866,
      /*::[*/
      102: 865,
      /*::[*/
      103: 861,
      /*::[*/
      104: 895,
      /*::[*/
      105: 620,
      /*::[*/
      106: 737,
      /*::[*/
      107: 857,
      /*::[*/
      120: 950,
      /*::[*/
      121: 949,
      /*::[*/
      122: 936,
      /*::[*/
      123: 932,
      /*::[*/
      124: 874,
      /*::[*/
      125: 1255,
      /*::[*/
      126: 1256,
      /*::[*/
      150: 10007,
      /*::[*/
      151: 10029,
      /*::[*/
      152: 10006,
      /*::[*/
      200: 1250,
      /*::[*/
      201: 1251,
      /*::[*/
      202: 1254,
      /*::[*/
      203: 1253,
      /*::[*/
      0: 20127
    });
    function dbf_to_aoa(buf, opts) {
      var out = [];
      var d = new_raw_buf(1);
      switch (opts.type) {
        case "base64":
          d = s2a(Base64_decode(buf));
          break;
        case "binary":
          d = s2a(buf);
          break;
        case "buffer":
        case "array":
          d = buf;
          break;
      }
      prep_blob(d, 0);
      var ft = d.read_shift(1);
      var memo = !!(ft & 136);
      var vfp = false, l7 = false;
      switch (ft) {
        case 2:
          break;
        // dBASE II
        case 3:
          break;
        // dBASE III
        case 48:
          vfp = true;
          memo = true;
          break;
        // VFP
        case 49:
          vfp = true;
          memo = true;
          break;
        // VFP with autoincrement
        // 0x43 dBASE IV SQL table files
        // 0x63 dBASE IV SQL system files
        case 131:
          break;
        // dBASE III with memo
        case 139:
          break;
        // dBASE IV with memo
        case 140:
          l7 = true;
          break;
        // dBASE Level 7 with memo
        // case 0xCB dBASE IV SQL table files with memo
        case 245:
          break;
        // FoxPro 2.x with memo
        // case 0xFB FoxBASE
        default:
          throw new Error("DBF Unsupported Version: " + ft.toString(16));
      }
      var nrow = 0, fpos = 521;
      if (ft == 2) nrow = d.read_shift(2);
      d.l += 3;
      if (ft != 2) nrow = d.read_shift(4);
      if (nrow > 1048576) nrow = 1e6;
      if (ft != 2) fpos = d.read_shift(2);
      var rlen = d.read_shift(2);
      var current_cp = opts.codepage || 1252;
      if (ft != 2) {
        d.l += 16;
        d.read_shift(1);
        if (d[d.l] !== 0) current_cp = dbf_codepage_map[d[d.l]];
        d.l += 1;
        d.l += 2;
      }
      if (l7) d.l += 36;
      var fields = [], field = {};
      var hend = Math.min(d.length, ft == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
      var ww = l7 ? 32 : 11;
      while (d.l < hend && d[d.l] != 13) {
        field = {};
        field.name = $cptable.utils.decode(current_cp, d.slice(d.l, d.l + ww)).replace(/[\u0000\r\n].*$/g, "");
        d.l += ww;
        field.type = String.fromCharCode(d.read_shift(1));
        if (ft != 2 && !l7) field.offset = d.read_shift(4);
        field.len = d.read_shift(1);
        if (ft == 2) field.offset = d.read_shift(2);
        field.dec = d.read_shift(1);
        if (field.name.length) fields.push(field);
        if (ft != 2) d.l += l7 ? 13 : 14;
        switch (field.type) {
          case "B":
            if ((!vfp || field.len != 8) && opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
            break;
          case "G":
          // General (FoxPro and dBASE L7)
          case "P":
            if (opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
            break;
          case "+":
          // Autoincrement (dBASE L7 only)
          case "0":
          // _NullFlags (VFP only)
          case "@":
          // Timestamp (dBASE L7 only)
          case "C":
          // Character (dBASE II)
          case "D":
          // Date (dBASE III)
          case "F":
          // Float (dBASE IV)
          case "I":
          // Long (VFP and dBASE L7)
          case "L":
          // Logical (dBASE II)
          case "M":
          // Memo (dBASE III)
          case "N":
          // Number (dBASE II)
          case "O":
          // Double (dBASE L7 only)
          case "T":
          // Datetime (VFP only)
          case "Y":
            break;
          default:
            throw new Error("Unknown Field Type: " + field.type);
        }
      }
      if (d[d.l] !== 13) d.l = fpos - 1;
      if (d.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
      d.l = fpos;
      var R = 0, C = 0;
      out[0] = [];
      for (C = 0; C != fields.length; ++C) out[0][C] = fields[C].name;
      while (nrow-- > 0) {
        if (d[d.l] === 42) {
          d.l += rlen;
          continue;
        }
        ++d.l;
        out[++R] = [];
        C = 0;
        for (C = 0; C != fields.length; ++C) {
          var dd = d.slice(d.l, d.l + fields[C].len);
          d.l += fields[C].len;
          prep_blob(dd, 0);
          var s = $cptable.utils.decode(current_cp, dd);
          switch (fields[C].type) {
            case "C":
              if (s.trim().length) out[R][C] = s.replace(/\s+$/, "");
              break;
            case "D":
              if (s.length === 8) out[R][C] = new Date(+s.slice(0, 4), +s.slice(4, 6) - 1, +s.slice(6, 8));
              else out[R][C] = s;
              break;
            case "F":
              out[R][C] = parseFloat(s.trim());
              break;
            case "+":
            case "I":
              out[R][C] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
              break;
            case "L":
              switch (s.trim().toUpperCase()) {
                case "Y":
                case "T":
                  out[R][C] = true;
                  break;
                case "N":
                case "F":
                  out[R][C] = false;
                  break;
                case "":
                case "?":
                  break;
                default:
                  throw new Error("DBF Unrecognized L:|" + s + "|");
              }
              break;
            case "M":
              if (!memo) throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
              out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10) : dd.read_shift(4));
              break;
            case "N":
              s = s.replace(/\u0000/g, "").trim();
              if (s && s != ".") out[R][C] = +s || 0;
              break;
            case "@":
              out[R][C] = new Date(dd.read_shift(-8, "f") - 621356832e5);
              break;
            case "T":
              out[R][C] = new Date((dd.read_shift(4) - 2440588) * 864e5 + dd.read_shift(4));
              break;
            case "Y":
              out[R][C] = dd.read_shift(4, "i") / 1e4 + dd.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
              break;
            case "O":
              out[R][C] = -dd.read_shift(-8, "f");
              break;
            case "B":
              if (vfp && fields[C].len == 8) {
                out[R][C] = dd.read_shift(8, "f");
                break;
              }
            /* falls through */
            case "G":
            case "P":
              dd.l += fields[C].len;
              break;
            case "0":
              if (fields[C].name === "_NullFlags") break;
            /* falls through */
            default:
              throw new Error("DBF Unsupported data type " + fields[C].type);
          }
        }
      }
      if (ft != 2) {
        if (d.l < d.length && d[d.l++] != 26) throw new Error("DBF EOF Marker missing " + (d.l - 1) + " of " + d.length + " " + d[d.l - 1].toString(16));
      }
      if (opts && opts.sheetRows) out = out.slice(0, opts.sheetRows);
      opts.DBF = fields;
      return out;
    }
    function dbf_to_sheet(buf, opts) {
      var o = opts || {};
      if (!o.dateNF) o.dateNF = "yyyymmdd";
      var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);
      ws["!cols"] = o.DBF.map(function(field) {
        return {
          wch: field.len,
          DBF: field
        };
      });
      delete o.DBF;
      return ws;
    }
    function dbf_to_workbook(buf, opts) {
      try {
        return sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
      } catch (e) {
        if (opts && opts.WTF) throw e;
      }
      return { SheetNames: [], Sheets: {} };
    }
    var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
    function sheet_to_dbf(ws, opts) {
      var o = opts || {};
      if (+o.codepage >= 0) set_cp(+o.codepage);
      if (o.type == "string") throw new Error("Cannot write DBF to JS string");
      var ba = buf_array();
      var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
      var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
      var i = 0, j = 0, hcnt = 0, rlen = 1;
      for (i = 0; i < headers.length; ++i) {
        if (((cols[i] || {}).DBF || {}).name) {
          headers[i] = cols[i].DBF.name;
          ++hcnt;
          continue;
        }
        if (headers[i] == null) continue;
        ++hcnt;
        if (typeof headers[i] === "number") headers[i] = headers[i].toString(10);
        if (typeof headers[i] !== "string") throw new Error("DBF Invalid column name " + headers[i] + " |" + typeof headers[i] + "|");
        if (headers.indexOf(headers[i]) !== i) {
          for (j = 0; j < 1024; ++j)
            if (headers.indexOf(headers[i] + "_" + j) == -1) {
              headers[i] += "_" + j;
              break;
            }
        }
      }
      var range = safe_decode_range(ws["!ref"]);
      var coltypes = [];
      var colwidths = [];
      var coldecimals = [];
      for (i = 0; i <= range.e.c - range.s.c; ++i) {
        var guess = "", _guess = "", maxlen = 0;
        var col = [];
        for (j = 0; j < data.length; ++j) {
          if (data[j][i] != null) col.push(data[j][i]);
        }
        if (col.length == 0 || headers[i] == null) {
          coltypes[i] = "?";
          continue;
        }
        for (j = 0; j < col.length; ++j) {
          switch (typeof col[j]) {
            /* TODO: check if L2 compat is desired */
            case "number":
              _guess = "B";
              break;
            case "string":
              _guess = "C";
              break;
            case "boolean":
              _guess = "L";
              break;
            case "object":
              _guess = col[j] instanceof Date ? "D" : "C";
              break;
            default:
              _guess = "C";
          }
          maxlen = Math.max(maxlen, String(col[j]).length);
          guess = guess && guess != _guess ? "C" : _guess;
        }
        if (maxlen > 250) maxlen = 250;
        _guess = ((cols[i] || {}).DBF || {}).type;
        if (_guess == "C") {
          if (cols[i].DBF.len > maxlen) maxlen = cols[i].DBF.len;
        }
        if (guess == "B" && _guess == "N") {
          guess = "N";
          coldecimals[i] = cols[i].DBF.dec;
          maxlen = cols[i].DBF.len;
        }
        colwidths[i] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
        rlen += colwidths[i];
        coltypes[i] = guess;
      }
      var h = ba.next(32);
      h.write_shift(4, 318902576);
      h.write_shift(4, data.length);
      h.write_shift(2, 296 + 32 * hcnt);
      h.write_shift(2, rlen);
      for (i = 0; i < 4; ++i) h.write_shift(4, 0);
      h.write_shift(4, 0 | (+dbf_reverse_map[
        /*::String(*/
        current_ansi
        /*::)*/
      ] || 3) << 8);
      for (i = 0, j = 0; i < headers.length; ++i) {
        if (headers[i] == null) continue;
        var hf = ba.next(32);
        var _f = (headers[i].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
        hf.write_shift(1, _f, "sbcs");
        hf.write_shift(1, coltypes[i] == "?" ? "C" : coltypes[i], "sbcs");
        hf.write_shift(4, j);
        hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);
        hf.write_shift(1, coldecimals[i] || 0);
        hf.write_shift(1, 2);
        hf.write_shift(4, 0);
        hf.write_shift(1, 0);
        hf.write_shift(4, 0);
        hf.write_shift(4, 0);
        j += colwidths[i] || _RLEN[coltypes[i]] || 0;
      }
      var hb = ba.next(264);
      hb.write_shift(4, 13);
      for (i = 0; i < 65; ++i) hb.write_shift(4, 0);
      for (i = 0; i < data.length; ++i) {
        var rout = ba.next(rlen);
        rout.write_shift(1, 0);
        for (j = 0; j < headers.length; ++j) {
          if (headers[j] == null) continue;
          switch (coltypes[j]) {
            case "L":
              rout.write_shift(1, data[i][j] == null ? 63 : data[i][j] ? 84 : 70);
              break;
            case "B":
              rout.write_shift(8, data[i][j] || 0, "f");
              break;
            case "N":
              var _n = "0";
              if (typeof data[i][j] == "number") _n = data[i][j].toFixed(coldecimals[j] || 0);
              for (hcnt = 0; hcnt < colwidths[j] - _n.length; ++hcnt) rout.write_shift(1, 32);
              rout.write_shift(1, _n, "sbcs");
              break;
            case "D":
              if (!data[i][j]) rout.write_shift(8, "00000000", "sbcs");
              else {
                rout.write_shift(4, ("0000" + data[i][j].getFullYear()).slice(-4), "sbcs");
                rout.write_shift(2, ("00" + (data[i][j].getMonth() + 1)).slice(-2), "sbcs");
                rout.write_shift(2, ("00" + data[i][j].getDate()).slice(-2), "sbcs");
              }
              break;
            case "C":
              var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);
              rout.write_shift(1, _s, "sbcs");
              for (hcnt = 0; hcnt < colwidths[j] - _s.length; ++hcnt) rout.write_shift(1, 32);
              break;
          }
        }
      }
      ba.next(1).write_shift(1, 26);
      return ba.end();
    }
    return {
      to_workbook: dbf_to_workbook,
      to_sheet: dbf_to_sheet,
      from_sheet: sheet_to_dbf
    };
  })();
  var SYLK = /* @__PURE__ */ (function() {
    var sylk_escapes = {
      AA: "\xC0",
      BA: "\xC1",
      CA: "\xC2",
      DA: 195,
      HA: "\xC4",
      JA: 197,
      AE: "\xC8",
      BE: "\xC9",
      CE: "\xCA",
      HE: "\xCB",
      AI: "\xCC",
      BI: "\xCD",
      CI: "\xCE",
      HI: "\xCF",
      AO: "\xD2",
      BO: "\xD3",
      CO: "\xD4",
      DO: 213,
      HO: "\xD6",
      AU: "\xD9",
      BU: "\xDA",
      CU: "\xDB",
      HU: "\xDC",
      Aa: "\xE0",
      Ba: "\xE1",
      Ca: "\xE2",
      Da: 227,
      Ha: "\xE4",
      Ja: 229,
      Ae: "\xE8",
      Be: "\xE9",
      Ce: "\xEA",
      He: "\xEB",
      Ai: "\xEC",
      Bi: "\xED",
      Ci: "\xEE",
      Hi: "\xEF",
      Ao: "\xF2",
      Bo: "\xF3",
      Co: "\xF4",
      Do: 245,
      Ho: "\xF6",
      Au: "\xF9",
      Bu: "\xFA",
      Cu: "\xFB",
      Hu: "\xFC",
      KC: "\xC7",
      Kc: "\xE7",
      q: "\xE6",
      z: "\u0153",
      a: "\xC6",
      j: "\u0152",
      DN: 209,
      Dn: 241,
      Hy: 255,
      S: 169,
      c: 170,
      R: 174,
      "B ": 180,
      /*::[*/
      0: 176,
      /*::[*/
      1: 177,
      /*::[*/
      2: 178,
      /*::[*/
      3: 179,
      /*::[*/
      5: 181,
      /*::[*/
      6: 182,
      /*::[*/
      7: 183,
      Q: 185,
      k: 186,
      b: 208,
      i: 216,
      l: 222,
      s: 240,
      y: 248,
      "!": 161,
      '"': 162,
      "#": 163,
      "(": 164,
      "%": 165,
      "'": 167,
      "H ": 168,
      "+": 171,
      ";": 187,
      "<": 188,
      "=": 189,
      ">": 190,
      "?": 191,
      "{": 223
    };
    var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
    var sylk_char_fn = function(_, $1) {
      var o = sylk_escapes[$1];
      return typeof o == "number" ? _getansi(o) : o;
    };
    var decode_sylk_char = function($$, $1, $2) {
      var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
      return newcc == 59 ? $$ : _getansi(newcc);
    };
    sylk_escapes["|"] = 254;
    function sylk_to_aoa(d, opts) {
      switch (opts.type) {
        case "base64":
          return sylk_to_aoa_str(Base64_decode(d), opts);
        case "binary":
          return sylk_to_aoa_str(d, opts);
        case "buffer":
          return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
        case "array":
          return sylk_to_aoa_str(cc2str(d), opts);
      }
      throw new Error("Unrecognized type " + opts.type);
    }
    function sylk_to_aoa_str(str, opts) {
      var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr = [];
      var formats = [];
      var next_cell_format = null;
      var sht = {}, rowinfo = [], colinfo = [], cw = [];
      var Mval = 0, j;
      if (+opts.codepage >= 0) set_cp(+opts.codepage);
      for (; ri !== records.length; ++ri) {
        Mval = 0;
        var rstr = records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
        var record = rstr.replace(/;;/g, "\0").split(";").map(function(x) {
          return x.replace(/\u0000/g, ";");
        });
        var RT = record[0], val;
        if (rstr.length > 0) switch (RT) {
          case "ID":
            break;
          /* header */
          case "E":
            break;
          /* EOF */
          case "B":
            break;
          /* dimensions */
          case "O":
            break;
          /* options? */
          case "W":
            break;
          /* window? */
          case "P":
            if (record[1].charAt(0) == "P")
              formats.push(rstr.slice(3).replace(/;;/g, ";"));
            break;
          case "C":
            var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1;
            for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
              case "A":
                break;
              // TODO: comment
              case "X":
                C = parseInt(record[rj].slice(1)) - 1;
                C_seen_X = true;
                break;
              case "Y":
                R = parseInt(record[rj].slice(1)) - 1;
                if (!C_seen_X) C = 0;
                for (j = arr.length; j <= R; ++j) arr[j] = [];
                break;
              case "K":
                val = record[rj].slice(1);
                if (val.charAt(0) === '"') val = val.slice(1, val.length - 1);
                else if (val === "TRUE") val = true;
                else if (val === "FALSE") val = false;
                else if (!isNaN(fuzzynum(val))) {
                  val = fuzzynum(val);
                  if (next_cell_format !== null && fmt_is_date(next_cell_format)) val = numdate(val);
                } else if (!isNaN(fuzzydate(val).getDate())) {
                  val = parseDate(val);
                }
                if (typeof $cptable !== "undefined" && typeof val == "string" && (opts || {}).type != "string" && (opts || {}).codepage) val = $cptable.utils.decode(opts.codepage, val);
                C_seen_K = true;
                break;
              case "E":
                C_seen_E = true;
                var formula = rc_to_a1(record[rj].slice(1), { r: R, c: C });
                arr[R][C] = [arr[R][C], formula];
                break;
              case "S":
                C_seen_S = true;
                arr[R][C] = [arr[R][C], "S5S"];
                break;
              case "G":
                break;
              // unknown
              case "R":
                _R = parseInt(record[rj].slice(1)) - 1;
                break;
              case "C":
                _C = parseInt(record[rj].slice(1)) - 1;
                break;
              default:
                if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
            }
            if (C_seen_K) {
              if (arr[R][C] && arr[R][C].length == 2) arr[R][C][0] = val;
              else arr[R][C] = val;
              next_cell_format = null;
            }
            if (C_seen_S) {
              if (C_seen_E) throw new Error("SYLK shared formula cannot have own formula");
              var shrbase = _R > -1 && arr[_R][_C];
              if (!shrbase || !shrbase[1]) throw new Error("SYLK shared formula cannot find base");
              arr[R][C][1] = shift_formula_str(shrbase[1], { r: R - _R, c: C - _C });
            }
            break;
          case "F":
            var F_seen = 0;
            for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
              case "X":
                C = parseInt(record[rj].slice(1)) - 1;
                ++F_seen;
                break;
              case "Y":
                R = parseInt(record[rj].slice(1)) - 1;
                for (j = arr.length; j <= R; ++j) arr[j] = [];
                break;
              case "M":
                Mval = parseInt(record[rj].slice(1)) / 20;
                break;
              case "F":
                break;
              /* ??? */
              case "G":
                break;
              /* hide grid */
              case "P":
                next_cell_format = formats[parseInt(record[rj].slice(1))];
                break;
              case "S":
                break;
              /* cell style */
              case "D":
                break;
              /* column */
              case "N":
                break;
              /* font */
              case "W":
                cw = record[rj].slice(1).split(" ");
                for (j = parseInt(cw[0], 10); j <= parseInt(cw[1], 10); ++j) {
                  Mval = parseInt(cw[2], 10);
                  colinfo[j - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
                  process_col(colinfo[j - 1]);
                }
                break;
              case "C":
                C = parseInt(record[rj].slice(1)) - 1;
                if (!colinfo[C]) colinfo[C] = {};
                break;
              case "R":
                R = parseInt(record[rj].slice(1)) - 1;
                if (!rowinfo[R]) rowinfo[R] = {};
                if (Mval > 0) {
                  rowinfo[R].hpt = Mval;
                  rowinfo[R].hpx = pt2px(Mval);
                } else if (Mval === 0) rowinfo[R].hidden = true;
                break;
              default:
                if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
            }
            if (F_seen < 1) next_cell_format = null;
            break;
          default:
            if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
        }
      }
      if (rowinfo.length > 0) sht["!rows"] = rowinfo;
      if (colinfo.length > 0) sht["!cols"] = colinfo;
      if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
      return [arr, sht];
    }
    function sylk_to_sheet(d, opts) {
      var aoasht = sylk_to_aoa(d, opts);
      var aoa = aoasht[0], ws = aoasht[1];
      var o = aoa_to_sheet(aoa, opts);
      keys(ws).forEach(function(k) {
        o[k] = ws[k];
      });
      return o;
    }
    function sylk_to_workbook(d, opts) {
      return sheet_to_workbook(sylk_to_sheet(d, opts), opts);
    }
    function write_ws_cell_sylk(cell, ws, R, C) {
      var o = "C;Y" + (R + 1) + ";X" + (C + 1) + ";K";
      switch (cell.t) {
        case "n":
          o += cell.v || 0;
          if (cell.f && !cell.F) o += ";E" + a1_to_rc(cell.f, { r: R, c: C });
          break;
        case "b":
          o += cell.v ? "TRUE" : "FALSE";
          break;
        case "e":
          o += cell.w || cell.v;
          break;
        case "d":
          o += '"' + (cell.w || cell.v) + '"';
          break;
        case "s":
          o += '"' + cell.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
          break;
      }
      return o;
    }
    function write_ws_cols_sylk(out, cols) {
      cols.forEach(function(col, i) {
        var rec = "F;W" + (i + 1) + " " + (i + 1) + " ";
        if (col.hidden) rec += "0";
        else {
          if (typeof col.width == "number" && !col.wpx) col.wpx = width2px(col.width);
          if (typeof col.wpx == "number" && !col.wch) col.wch = px2char(col.wpx);
          if (typeof col.wch == "number") rec += Math.round(col.wch);
        }
        if (rec.charAt(rec.length - 1) != " ") out.push(rec);
      });
    }
    function write_ws_rows_sylk(out, rows) {
      rows.forEach(function(row, i) {
        var rec = "F;";
        if (row.hidden) rec += "M0;";
        else if (row.hpt) rec += "M" + 20 * row.hpt + ";";
        else if (row.hpx) rec += "M" + 20 * px2pt(row.hpx) + ";";
        if (rec.length > 2) out.push(rec + "R" + (i + 1));
      });
    }
    function sheet_to_sylk(ws, opts) {
      var preamble = ["ID;PWXL;N;E"], o = [];
      var r = safe_decode_range(ws["!ref"]), cell;
      var dense = Array.isArray(ws);
      var RS = "\r\n";
      preamble.push("P;PGeneral");
      preamble.push("F;P0;DG0G8;M255");
      if (ws["!cols"]) write_ws_cols_sylk(preamble, ws["!cols"]);
      if (ws["!rows"]) write_ws_rows_sylk(preamble, ws["!rows"]);
      preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c, r.s.r, r.e.c, r.e.r].join(" "));
      for (var R = r.s.r; R <= r.e.r; ++R) {
        for (var C = r.s.c; C <= r.e.c; ++C) {
          var coord = encode_cell({ r: R, c: C });
          cell = dense ? (ws[R] || [])[C] : ws[coord];
          if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
          o.push(write_ws_cell_sylk(cell, ws, R, C, opts));
        }
      }
      return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;
    }
    return {
      to_workbook: sylk_to_workbook,
      to_sheet: sylk_to_sheet,
      from_sheet: sheet_to_sylk
    };
  })();
  var DIF = /* @__PURE__ */ (function() {
    function dif_to_aoa(d, opts) {
      switch (opts.type) {
        case "base64":
          return dif_to_aoa_str(Base64_decode(d), opts);
        case "binary":
          return dif_to_aoa_str(d, opts);
        case "buffer":
          return dif_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
        case "array":
          return dif_to_aoa_str(cc2str(d), opts);
      }
      throw new Error("Unrecognized type " + opts.type);
    }
    function dif_to_aoa_str(str, opts) {
      var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
      for (; ri !== records.length; ++ri) {
        if (records[ri].trim() === "BOT") {
          arr[++R] = [];
          C = 0;
          continue;
        }
        if (R < 0) continue;
        var metadata = records[ri].trim().split(",");
        var type = metadata[0], value = metadata[1];
        ++ri;
        var data = records[ri] || "";
        while ((data.match(/["]/g) || []).length & 1 && ri < records.length - 1) data += "\n" + records[++ri];
        data = data.trim();
        switch (+type) {
          case -1:
            if (data === "BOT") {
              arr[++R] = [];
              C = 0;
              continue;
            } else if (data !== "EOD") throw new Error("Unrecognized DIF special command " + data);
            break;
          case 0:
            if (data === "TRUE") arr[R][C] = true;
            else if (data === "FALSE") arr[R][C] = false;
            else if (!isNaN(fuzzynum(value))) arr[R][C] = fuzzynum(value);
            else if (!isNaN(fuzzydate(value).getDate())) arr[R][C] = parseDate(value);
            else arr[R][C] = value;
            ++C;
            break;
          case 1:
            data = data.slice(1, data.length - 1);
            data = data.replace(/""/g, '"');
            if (DIF_XL && data && data.match(/^=".*"$/)) data = data.slice(2, -1);
            arr[R][C++] = data !== "" ? data : null;
            break;
        }
        if (data === "EOD") break;
      }
      if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
      return arr;
    }
    function dif_to_sheet(str, opts) {
      return aoa_to_sheet(dif_to_aoa(str, opts), opts);
    }
    function dif_to_workbook(str, opts) {
      return sheet_to_workbook(dif_to_sheet(str, opts), opts);
    }
    var sheet_to_dif = /* @__PURE__ */ (function() {
      var push_field = function pf(o, topic, v, n, s) {
        o.push(topic);
        o.push(v + "," + n);
        o.push('"' + s.replace(/"/g, '""') + '"');
      };
      var push_value = function po(o, type, v, s) {
        o.push(type + "," + v);
        o.push(type == 1 ? '"' + s.replace(/"/g, '""') + '"' : s);
      };
      return function sheet_to_dif2(ws) {
        var o = [];
        var r = safe_decode_range(ws["!ref"]), cell;
        var dense = Array.isArray(ws);
        push_field(o, "TABLE", 0, 1, "sheetjs");
        push_field(o, "VECTORS", 0, r.e.r - r.s.r + 1, "");
        push_field(o, "TUPLES", 0, r.e.c - r.s.c + 1, "");
        push_field(o, "DATA", 0, 0, "");
        for (var R = r.s.r; R <= r.e.r; ++R) {
          push_value(o, -1, 0, "BOT");
          for (var C = r.s.c; C <= r.e.c; ++C) {
            var coord = encode_cell({ r: R, c: C });
            cell = dense ? (ws[R] || [])[C] : ws[coord];
            if (!cell) {
              push_value(o, 1, 0, "");
              continue;
            }
            switch (cell.t) {
              case "n":
                var val = DIF_XL ? cell.w : cell.v;
                if (!val && cell.v != null) val = cell.v;
                if (val == null) {
                  if (DIF_XL && cell.f && !cell.F) push_value(o, 1, 0, "=" + cell.f);
                  else push_value(o, 1, 0, "");
                } else push_value(o, 0, val, "V");
                break;
              case "b":
                push_value(o, 0, cell.v ? 1 : 0, cell.v ? "TRUE" : "FALSE");
                break;
              case "s":
                push_value(o, 1, 0, !DIF_XL || isNaN(cell.v) ? cell.v : '="' + cell.v + '"');
                break;
              case "d":
                if (!cell.w) cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
                if (DIF_XL) push_value(o, 0, cell.w, "V");
                else push_value(o, 1, 0, cell.w);
                break;
              default:
                push_value(o, 1, 0, "");
            }
          }
        }
        push_value(o, -1, 0, "EOD");
        var RS = "\r\n";
        var oo = o.join(RS);
        return oo;
      };
    })();
    return {
      to_workbook: dif_to_workbook,
      to_sheet: dif_to_sheet,
      from_sheet: sheet_to_dif
    };
  })();
  var ETH = /* @__PURE__ */ (function() {
    function decode(s) {
      return s.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
    }
    function encode(s) {
      return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
    }
    function eth_to_aoa(str, opts) {
      var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
      for (; ri !== records.length; ++ri) {
        var record = records[ri].trim().split(":");
        if (record[0] !== "cell") continue;
        var addr = decode_cell(record[1]);
        if (arr.length <= addr.r) {
          for (R = arr.length; R <= addr.r; ++R) if (!arr[R]) arr[R] = [];
        }
        R = addr.r;
        C = addr.c;
        switch (record[2]) {
          case "t":
            arr[R][C] = decode(record[3]);
            break;
          case "v":
            arr[R][C] = +record[3];
            break;
          case "vtf":
            var _f = record[record.length - 1];
          /* falls through */
          case "vtc":
            switch (record[3]) {
              case "nl":
                arr[R][C] = +record[4] ? true : false;
                break;
              default:
                arr[R][C] = +record[4];
                break;
            }
            if (record[2] == "vtf") arr[R][C] = [arr[R][C], _f];
        }
      }
      if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
      return arr;
    }
    function eth_to_sheet(d, opts) {
      return aoa_to_sheet(eth_to_aoa(d, opts), opts);
    }
    function eth_to_workbook(d, opts) {
      return sheet_to_workbook(eth_to_sheet(d, opts), opts);
    }
    var header = [
      "socialcalc:version:1.5",
      "MIME-Version: 1.0",
      "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
    ].join("\n");
    var sep = [
      "--SocialCalcSpreadsheetControlSave",
      "Content-type: text/plain; charset=UTF-8"
    ].join("\n") + "\n";
    var meta = [
      "# SocialCalc Spreadsheet Control Save",
      "part:sheet"
    ].join("\n");
    var end = "--SocialCalcSpreadsheetControlSave--";
    function sheet_to_eth_data(ws) {
      if (!ws || !ws["!ref"]) return "";
      var o = [], oo = [], cell, coord = "";
      var r = decode_range(ws["!ref"]);
      var dense = Array.isArray(ws);
      for (var R = r.s.r; R <= r.e.r; ++R) {
        for (var C = r.s.c; C <= r.e.c; ++C) {
          coord = encode_cell({ r: R, c: C });
          cell = dense ? (ws[R] || [])[C] : ws[coord];
          if (!cell || cell.v == null || cell.t === "z") continue;
          oo = ["cell", coord, "t"];
          switch (cell.t) {
            case "s":
            case "str":
              oo.push(encode(cell.v));
              break;
            case "n":
              if (!cell.f) {
                oo[2] = "v";
                oo[3] = cell.v;
              } else {
                oo[2] = "vtf";
                oo[3] = "n";
                oo[4] = cell.v;
                oo[5] = encode(cell.f);
              }
              break;
            case "b":
              oo[2] = "vt" + (cell.f ? "f" : "c");
              oo[3] = "nl";
              oo[4] = cell.v ? "1" : "0";
              oo[5] = encode(cell.f || (cell.v ? "TRUE" : "FALSE"));
              break;
            case "d":
              var t = datenum(parseDate(cell.v));
              oo[2] = "vtc";
              oo[3] = "nd";
              oo[4] = "" + t;
              oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t);
              break;
            case "e":
              continue;
          }
          o.push(oo.join(":"));
        }
      }
      o.push("sheet:c:" + (r.e.c - r.s.c + 1) + ":r:" + (r.e.r - r.s.r + 1) + ":tvf:1");
      o.push("valueformat:1:text-wiki");
      return o.join("\n");
    }
    function sheet_to_eth(ws) {
      return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
    }
    return {
      to_workbook: eth_to_workbook,
      to_sheet: eth_to_sheet,
      from_sheet: sheet_to_eth
    };
  })();
  var PRN = /* @__PURE__ */ (function() {
    function set_text_arr(data, arr, R, C, o) {
      if (o.raw) arr[R][C] = data;
      else if (data === "") {
      } else if (data === "TRUE") arr[R][C] = true;
      else if (data === "FALSE") arr[R][C] = false;
      else if (!isNaN(fuzzynum(data))) arr[R][C] = fuzzynum(data);
      else if (!isNaN(fuzzydate(data).getDate())) arr[R][C] = parseDate(data);
      else arr[R][C] = data;
    }
    function prn_to_aoa_str(f, opts) {
      var o = opts || {};
      var arr = [];
      if (!f || f.length === 0) return arr;
      var lines = f.split(/[\r\n]/);
      var L = lines.length - 1;
      while (L >= 0 && lines[L].length === 0) --L;
      var start = 10, idx = 0;
      var R = 0;
      for (; R <= L; ++R) {
        idx = lines[R].indexOf(" ");
        if (idx == -1) idx = lines[R].length;
        else idx++;
        start = Math.max(start, idx);
      }
      for (R = 0; R <= L; ++R) {
        arr[R] = [];
        var C = 0;
        set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);
        for (C = 1; C <= (lines[R].length - start) / 10 + 1; ++C)
          set_text_arr(lines[R].slice(start + (C - 1) * 10, start + C * 10).trim(), arr, R, C, o);
      }
      if (o.sheetRows) arr = arr.slice(0, o.sheetRows);
      return arr;
    }
    var guess_seps = {
      /*::[*/
      44: ",",
      /*::[*/
      9: "	",
      /*::[*/
      59: ";",
      /*::[*/
      124: "|"
    };
    var guess_sep_weights = {
      /*::[*/
      44: 3,
      /*::[*/
      9: 2,
      /*::[*/
      59: 1,
      /*::[*/
      124: 0
    };
    function guess_sep(str) {
      var cnt = {}, instr = false, end = 0, cc = 0;
      for (; end < str.length; ++end) {
        if ((cc = str.charCodeAt(end)) == 34) instr = !instr;
        else if (!instr && cc in guess_seps) cnt[cc] = (cnt[cc] || 0) + 1;
      }
      cc = [];
      for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
        cc.push([cnt[end], end]);
      }
      if (!cc.length) {
        cnt = guess_sep_weights;
        for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
          cc.push([cnt[end], end]);
        }
      }
      cc.sort(function(a, b) {
        return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]];
      });
      return guess_seps[cc.pop()[1]] || 44;
    }
    function dsv_to_sheet_str(str, opts) {
      var o = opts || {};
      var sep = "";
      if (DENSE != null && o.dense == null) o.dense = DENSE;
      var ws = o.dense ? [] : {};
      var range = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
      if (str.slice(0, 4) == "sep=") {
        if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
          sep = str.charAt(4);
          str = str.slice(7);
        } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
          sep = str.charAt(4);
          str = str.slice(6);
        } else sep = guess_sep(str.slice(0, 1024));
      } else if (o && o.FS) sep = o.FS;
      else sep = guess_sep(str.slice(0, 1024));
      var R = 0, C = 0, v = 0;
      var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0, startcc = str.charCodeAt(0);
      str = str.replace(/\r\n/mg, "\n");
      var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;
      function finish_cell() {
        var s = str.slice(start, end);
        var cell = {};
        if (s.charAt(0) == '"' && s.charAt(s.length - 1) == '"') s = s.slice(1, -1).replace(/""/g, '"');
        if (s.length === 0) cell.t = "z";
        else if (o.raw) {
          cell.t = "s";
          cell.v = s;
        } else if (s.trim().length === 0) {
          cell.t = "s";
          cell.v = s;
        } else if (s.charCodeAt(0) == 61) {
          if (s.charCodeAt(1) == 34 && s.charCodeAt(s.length - 1) == 34) {
            cell.t = "s";
            cell.v = s.slice(2, -1).replace(/""/g, '"');
          } else if (fuzzyfmla(s)) {
            cell.t = "n";
            cell.f = s.slice(1);
          } else {
            cell.t = "s";
            cell.v = s;
          }
        } else if (s == "TRUE") {
          cell.t = "b";
          cell.v = true;
        } else if (s == "FALSE") {
          cell.t = "b";
          cell.v = false;
        } else if (!isNaN(v = fuzzynum(s))) {
          cell.t = "n";
          if (o.cellText !== false) cell.w = s;
          cell.v = v;
        } else if (!isNaN(fuzzydate(s).getDate()) || _re && s.match(_re)) {
          cell.z = o.dateNF || table_fmt[14];
          var k = 0;
          if (_re && s.match(_re)) {
            s = dateNF_fix(s, o.dateNF, s.match(_re) || []);
            k = 1;
          }
          if (o.cellDates) {
            cell.t = "d";
            cell.v = parseDate(s, k);
          } else {
            cell.t = "n";
            cell.v = datenum(parseDate(s, k));
          }
          if (o.cellText !== false) cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v) : cell.v);
          if (!o.cellNF) delete cell.z;
        } else {
          cell.t = "s";
          cell.v = s;
        }
        if (cell.t == "z") {
        } else if (o.dense) {
          if (!ws[R]) ws[R] = [];
          ws[R][C] = cell;
        } else ws[encode_cell({ c: C, r: R })] = cell;
        start = end + 1;
        startcc = str.charCodeAt(start);
        if (range.e.c < C) range.e.c = C;
        if (range.e.r < R) range.e.r = R;
        if (cc == sepcc) ++C;
        else {
          C = 0;
          ++R;
          if (o.sheetRows && o.sheetRows <= R) return true;
        }
      }
      outer: for (; end < str.length; ++end) switch (cc = str.charCodeAt(end)) {
        case 34:
          if (startcc === 34) instr = !instr;
          break;
        case sepcc:
        case 10:
        case 13:
          if (!instr && finish_cell()) break outer;
          break;
        default:
          break;
      }
      if (end - start > 0) finish_cell();
      ws["!ref"] = encode_range(range);
      return ws;
    }
    function prn_to_sheet_str(str, opts) {
      if (!(opts && opts.PRN)) return dsv_to_sheet_str(str, opts);
      if (opts.FS) return dsv_to_sheet_str(str, opts);
      if (str.slice(0, 4) == "sep=") return dsv_to_sheet_str(str, opts);
      if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0) return dsv_to_sheet_str(str, opts);
      return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
    }
    function prn_to_sheet(d, opts) {
      var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d, opts);
      switch (opts.type) {
        case "base64":
          str = Base64_decode(d);
          break;
        case "binary":
          str = d;
          break;
        case "buffer":
          if (opts.codepage == 65001) str = d.toString("utf8");
          else if (opts.codepage && typeof $cptable !== "undefined") str = $cptable.utils.decode(opts.codepage, d);
          else str = has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d);
          break;
        case "array":
          str = cc2str(d);
          break;
        case "string":
          str = d;
          break;
        default:
          throw new Error("Unrecognized type " + opts.type);
      }
      if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str.slice(3));
      else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001) str = utf8read(str);
      else if (opts.type == "binary" && typeof $cptable !== "undefined" && opts.codepage) str = $cptable.utils.decode(opts.codepage, $cptable.utils.encode(28591, str));
      if (str.slice(0, 19) == "socialcalc:version:") return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
      return prn_to_sheet_str(str, opts);
    }
    function prn_to_workbook(d, opts) {
      return sheet_to_workbook(prn_to_sheet(d, opts), opts);
    }
    function sheet_to_prn(ws) {
      var o = [];
      var r = safe_decode_range(ws["!ref"]), cell;
      var dense = Array.isArray(ws);
      for (var R = r.s.r; R <= r.e.r; ++R) {
        var oo = [];
        for (var C = r.s.c; C <= r.e.c; ++C) {
          var coord = encode_cell({ r: R, c: C });
          cell = dense ? (ws[R] || [])[C] : ws[coord];
          if (!cell || cell.v == null) {
            oo.push("          ");
            continue;
          }
          var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
          while (w.length < 10) w += " ";
          oo.push(w + (C === 0 ? " " : ""));
        }
        o.push(oo.join(""));
      }
      return o.join("\n");
    }
    return {
      to_workbook: prn_to_workbook,
      to_sheet: prn_to_sheet,
      from_sheet: sheet_to_prn
    };
  })();
  var WK_ = /* @__PURE__ */ (function() {
    function lotushopper(data, cb, opts) {
      if (!data) return;
      prep_blob(data, data.l || 0);
      var Enum = opts.Enum || WK1Enum;
      while (data.l < data.length) {
        var RT = data.read_shift(2);
        var R = Enum[RT] || Enum[65535];
        var length = data.read_shift(2);
        var tgt = data.l + length;
        var d = R.f && R.f(data, length, opts);
        data.l = tgt;
        if (cb(d, R, RT)) return;
      }
    }
    function lotus_to_workbook(d, opts) {
      switch (opts.type) {
        case "base64":
          return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);
        case "binary":
          return lotus_to_workbook_buf(s2a(d), opts);
        case "buffer":
        case "array":
          return lotus_to_workbook_buf(d, opts);
      }
      throw "Unsupported type " + opts.type;
    }
    function lotus_to_workbook_buf(d, opts) {
      if (!d) return d;
      var o = opts || {};
      if (DENSE != null && o.dense == null) o.dense = DENSE;
      var s = o.dense ? [] : {}, n = "Sheet1", next_n = "", sidx = 0;
      var sheets = {}, snames = [], realnames = [];
      var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
      var sheetRows = o.sheetRows || 0;
      if (d[2] == 0) {
        if (d[3] == 8 || d[3] == 9) {
          if (d.length >= 16 && d[14] == 5 && d[15] === 108) throw new Error("Unsupported Works 3 for Mac file");
        }
      }
      if (d[2] == 2) {
        o.Enum = WK1Enum;
        lotushopper(d, function(val, R, RT) {
          switch (RT) {
            case 0:
              o.vers = val;
              if (val >= 4096) o.qpro = true;
              break;
            case 6:
              refguess = val;
              break;
            /* RANGE */
            case 204:
              if (val) next_n = val;
              break;
            /* SHEETNAMECS */
            case 222:
              next_n = val;
              break;
            /* SHEETNAMELP */
            case 15:
            /* LABEL */
            case 51:
              if (!o.qpro) val[1].v = val[1].v.slice(1);
            /* falls through */
            case 13:
            /* INTEGER */
            case 14:
            /* NUMBER */
            case 16:
              if (RT == 14 && (val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
                val[1].z = o.dateNF || table_fmt[14];
                if (o.cellDates) {
                  val[1].t = "d";
                  val[1].v = numdate(val[1].v);
                }
              }
              if (o.qpro) {
                if (val[3] > sidx) {
                  s["!ref"] = encode_range(refguess);
                  sheets[n] = s;
                  snames.push(n);
                  s = o.dense ? [] : {};
                  refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                  sidx = val[3];
                  n = next_n || "Sheet" + (sidx + 1);
                  next_n = "";
                }
              }
              var tmpcell = o.dense ? (s[val[0].r] || [])[val[0].c] : s[encode_cell(val[0])];
              if (tmpcell) {
                tmpcell.t = val[1].t;
                tmpcell.v = val[1].v;
                if (val[1].z != null) tmpcell.z = val[1].z;
                if (val[1].f != null) tmpcell.f = val[1].f;
                break;
              }
              if (o.dense) {
                if (!s[val[0].r]) s[val[0].r] = [];
                s[val[0].r][val[0].c] = val[1];
              } else s[encode_cell(val[0])] = val[1];
              break;
            default:
          }
        }, o);
      } else if (d[2] == 26 || d[2] == 14) {
        o.Enum = WK3Enum;
        if (d[2] == 14) {
          o.qpro = true;
          d.l = 0;
        }
        lotushopper(d, function(val, R, RT) {
          switch (RT) {
            case 204:
              n = val;
              break;
            /* SHEETNAMECS */
            case 22:
              val[1].v = val[1].v.slice(1);
            /* falls through */
            case 23:
            /* NUMBER17 */
            case 24:
            /* NUMBER18 */
            case 25:
            /* FORMULA19 */
            case 37:
            /* NUMBER25 */
            case 39:
            /* NUMBER27 */
            case 40:
              if (val[3] > sidx) {
                s["!ref"] = encode_range(refguess);
                sheets[n] = s;
                snames.push(n);
                s = o.dense ? [] : {};
                refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                sidx = val[3];
                n = "Sheet" + (sidx + 1);
              }
              if (sheetRows > 0 && val[0].r >= sheetRows) break;
              if (o.dense) {
                if (!s[val[0].r]) s[val[0].r] = [];
                s[val[0].r][val[0].c] = val[1];
              } else s[encode_cell(val[0])] = val[1];
              if (refguess.e.c < val[0].c) refguess.e.c = val[0].c;
              if (refguess.e.r < val[0].r) refguess.e.r = val[0].r;
              break;
            case 27:
              if (val[14e3]) realnames[val[14e3][0]] = val[14e3][1];
              break;
            case 1537:
              realnames[val[0]] = val[1];
              if (val[0] == sidx) n = val[1];
              break;
            default:
              break;
          }
        }, o);
      } else throw new Error("Unrecognized LOTUS BOF " + d[2]);
      s["!ref"] = encode_range(refguess);
      sheets[next_n || n] = s;
      snames.push(next_n || n);
      if (!realnames.length) return { SheetNames: snames, Sheets: sheets };
      var osheets = {}, rnames = [];
      for (var i = 0; i < realnames.length; ++i) if (sheets[snames[i]]) {
        rnames.push(realnames[i] || snames[i]);
        osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];
      } else {
        rnames.push(realnames[i]);
        osheets[realnames[i]] = { "!ref": "A1" };
      }
      return { SheetNames: rnames, Sheets: osheets };
    }
    function sheet_to_wk1(ws, opts) {
      var o = opts || {};
      if (+o.codepage >= 0) set_cp(+o.codepage);
      if (o.type == "string") throw new Error("Cannot write WK1 to JS string");
      var ba = buf_array();
      var range = safe_decode_range(ws["!ref"]);
      var dense = Array.isArray(ws);
      var cols = [];
      write_biff_rec(ba, 0, write_BOF_WK1(1030));
      write_biff_rec(ba, 6, write_RANGE(range));
      var max_R = Math.min(range.e.r, 8191);
      for (var R = range.s.r; R <= max_R; ++R) {
        var rr = encode_row(R);
        for (var C = range.s.c; C <= range.e.c; ++C) {
          if (R === range.s.r) cols[C] = encode_col(C);
          var ref = cols[C] + rr;
          var cell = dense ? (ws[R] || [])[C] : ws[ref];
          if (!cell || cell.t == "z") continue;
          if (cell.t == "n") {
            if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767) write_biff_rec(ba, 13, write_INTEGER(R, C, cell.v));
            else write_biff_rec(ba, 14, write_NUMBER(R, C, cell.v));
          } else {
            var str = format_cell(cell);
            write_biff_rec(ba, 15, write_LABEL(R, C, str.slice(0, 239)));
          }
        }
      }
      write_biff_rec(ba, 1);
      return ba.end();
    }
    function book_to_wk3(wb, opts) {
      var o = opts || {};
      if (+o.codepage >= 0) set_cp(+o.codepage);
      if (o.type == "string") throw new Error("Cannot write WK3 to JS string");
      var ba = buf_array();
      write_biff_rec(ba, 0, write_BOF_WK3(wb));
      for (var i = 0, cnt = 0; i < wb.SheetNames.length; ++i) if ((wb.Sheets[wb.SheetNames[i]] || {})["!ref"]) write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));
      var wsidx = 0;
      for (i = 0; i < wb.SheetNames.length; ++i) {
        var ws = wb.Sheets[wb.SheetNames[i]];
        if (!ws || !ws["!ref"]) continue;
        var range = safe_decode_range(ws["!ref"]);
        var dense = Array.isArray(ws);
        var cols = [];
        var max_R = Math.min(range.e.r, 8191);
        for (var R = range.s.r; R <= max_R; ++R) {
          var rr = encode_row(R);
          for (var C = range.s.c; C <= range.e.c; ++C) {
            if (R === range.s.r) cols[C] = encode_col(C);
            var ref = cols[C] + rr;
            var cell = dense ? (ws[R] || [])[C] : ws[ref];
            if (!cell || cell.t == "z") continue;
            if (cell.t == "n") {
              write_biff_rec(ba, 23, write_NUMBER_17(R, C, wsidx, cell.v));
            } else {
              var str = format_cell(cell);
              write_biff_rec(ba, 22, write_LABEL_16(R, C, wsidx, str.slice(0, 239)));
            }
          }
        }
        ++wsidx;
      }
      write_biff_rec(ba, 1);
      return ba.end();
    }
    function write_BOF_WK1(v) {
      var out = new_buf(2);
      out.write_shift(2, v);
      return out;
    }
    function write_BOF_WK3(wb) {
      var out = new_buf(26);
      out.write_shift(2, 4096);
      out.write_shift(2, 4);
      out.write_shift(4, 0);
      var rows = 0, cols = 0, wscnt = 0;
      for (var i = 0; i < wb.SheetNames.length; ++i) {
        var name = wb.SheetNames[i];
        var ws = wb.Sheets[name];
        if (!ws || !ws["!ref"]) continue;
        ++wscnt;
        var range = decode_range(ws["!ref"]);
        if (rows < range.e.r) rows = range.e.r;
        if (cols < range.e.c) cols = range.e.c;
      }
      if (rows > 8191) rows = 8191;
      out.write_shift(2, rows);
      out.write_shift(1, wscnt);
      out.write_shift(1, cols);
      out.write_shift(2, 0);
      out.write_shift(2, 0);
      out.write_shift(1, 1);
      out.write_shift(1, 2);
      out.write_shift(4, 0);
      out.write_shift(4, 0);
      return out;
    }
    function parse_RANGE(blob, length, opts) {
      var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
      if (length == 8 && opts.qpro) {
        o.s.c = blob.read_shift(1);
        blob.l++;
        o.s.r = blob.read_shift(2);
        o.e.c = blob.read_shift(1);
        blob.l++;
        o.e.r = blob.read_shift(2);
        return o;
      }
      o.s.c = blob.read_shift(2);
      o.s.r = blob.read_shift(2);
      if (length == 12 && opts.qpro) blob.l += 2;
      o.e.c = blob.read_shift(2);
      o.e.r = blob.read_shift(2);
      if (length == 12 && opts.qpro) blob.l += 2;
      if (o.s.c == 65535) o.s.c = o.e.c = o.s.r = o.e.r = 0;
      return o;
    }
    function write_RANGE(range) {
      var out = new_buf(8);
      out.write_shift(2, range.s.c);
      out.write_shift(2, range.s.r);
      out.write_shift(2, range.e.c);
      out.write_shift(2, range.e.r);
      return out;
    }
    function parse_cell(blob, length, opts) {
      var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
      if (opts.qpro && opts.vers != 20768) {
        o[0].c = blob.read_shift(1);
        o[3] = blob.read_shift(1);
        o[0].r = blob.read_shift(2);
        blob.l += 2;
      } else {
        o[2] = blob.read_shift(1);
        o[0].c = blob.read_shift(2);
        o[0].r = blob.read_shift(2);
      }
      return o;
    }
    function parse_LABEL(blob, length, opts) {
      var tgt = blob.l + length;
      var o = parse_cell(blob, length, opts);
      o[1].t = "s";
      if (opts.vers == 20768) {
        blob.l++;
        var len = blob.read_shift(1);
        o[1].v = blob.read_shift(len, "utf8");
        return o;
      }
      if (opts.qpro) blob.l++;
      o[1].v = blob.read_shift(tgt - blob.l, "cstr");
      return o;
    }
    function write_LABEL(R, C, s) {
      var o = new_buf(7 + s.length);
      o.write_shift(1, 255);
      o.write_shift(2, C);
      o.write_shift(2, R);
      o.write_shift(1, 39);
      for (var i = 0; i < o.length; ++i) {
        var cc = s.charCodeAt(i);
        o.write_shift(1, cc >= 128 ? 95 : cc);
      }
      o.write_shift(1, 0);
      return o;
    }
    function parse_INTEGER(blob, length, opts) {
      var o = parse_cell(blob, length, opts);
      o[1].v = blob.read_shift(2, "i");
      return o;
    }
    function write_INTEGER(R, C, v) {
      var o = new_buf(7);
      o.write_shift(1, 255);
      o.write_shift(2, C);
      o.write_shift(2, R);
      o.write_shift(2, v, "i");
      return o;
    }
    function parse_NUMBER(blob, length, opts) {
      var o = parse_cell(blob, length, opts);
      o[1].v = blob.read_shift(8, "f");
      return o;
    }
    function write_NUMBER(R, C, v) {
      var o = new_buf(13);
      o.write_shift(1, 255);
      o.write_shift(2, C);
      o.write_shift(2, R);
      o.write_shift(8, v, "f");
      return o;
    }
    function parse_FORMULA(blob, length, opts) {
      var tgt = blob.l + length;
      var o = parse_cell(blob, length, opts);
      o[1].v = blob.read_shift(8, "f");
      if (opts.qpro) blob.l = tgt;
      else {
        var flen = blob.read_shift(2);
        wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o);
        blob.l += flen;
      }
      return o;
    }
    function wk1_parse_rc(B, V, col) {
      var rel = V & 32768;
      V &= ~32768;
      V = (rel ? B : 0) + (V >= 8192 ? V - 16384 : V);
      return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));
    }
    var FuncTab = {
      51: ["FALSE", 0],
      52: ["TRUE", 0],
      70: ["LEN", 1],
      80: ["SUM", 69],
      81: ["AVERAGEA", 69],
      82: ["COUNTA", 69],
      83: ["MINA", 69],
      84: ["MAXA", 69],
      111: ["T", 1]
    };
    var BinOpTab = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // eslint-disable-line no-mixed-spaces-and-tabs
      "",
      "+",
      "-",
      "*",
      "/",
      "^",
      "=",
      "<>",
      // eslint-disable-line no-mixed-spaces-and-tabs
      "<=",
      ">=",
      "<",
      ">",
      "",
      "",
      "",
      "",
      // eslint-disable-line no-mixed-spaces-and-tabs
      "&",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
      // eslint-disable-line no-mixed-spaces-and-tabs
    ];
    function wk1_fmla_to_csf(blob, o) {
      prep_blob(blob, 0);
      var out = [], argc = 0, R = "", C = "", argL = "", argR = "";
      while (blob.l < blob.length) {
        var cc = blob[blob.l++];
        switch (cc) {
          case 0:
            out.push(blob.read_shift(8, "f"));
            break;
          case 1:
            {
              C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
              R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
              out.push(C + R);
            }
            break;
          case 2:
            {
              var c = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
              var r = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
              C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
              R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
              out.push(c + r + ":" + C + R);
            }
            break;
          case 3:
            if (blob.l < blob.length) {
              console.error("WK1 premature formula end");
              return;
            }
            break;
          case 4:
            out.push("(" + out.pop() + ")");
            break;
          case 5:
            out.push(blob.read_shift(2));
            break;
          case 6:
            {
              var Z = "";
              while (cc = blob[blob.l++]) Z += String.fromCharCode(cc);
              out.push('"' + Z.replace(/"/g, '""') + '"');
            }
            break;
          case 8:
            out.push("-" + out.pop());
            break;
          case 23:
            out.push("+" + out.pop());
            break;
          case 22:
            out.push("NOT(" + out.pop() + ")");
            break;
          case 20:
          case 21:
            {
              argR = out.pop();
              argL = out.pop();
              out.push(["AND", "OR"][cc - 20] + "(" + argL + "," + argR + ")");
            }
            break;
          default:
            if (cc < 32 && BinOpTab[cc]) {
              argR = out.pop();
              argL = out.pop();
              out.push(argL + BinOpTab[cc] + argR);
            } else if (FuncTab[cc]) {
              argc = FuncTab[cc][1];
              if (argc == 69) argc = blob[blob.l++];
              if (argc > out.length) {
                console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|");
                return;
              }
              var args = out.slice(-argc);
              out.length -= argc;
              out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
            } else if (cc <= 7) return console.error("WK1 invalid opcode " + cc.toString(16));
            else if (cc <= 24) return console.error("WK1 unsupported op " + cc.toString(16));
            else if (cc <= 30) return console.error("WK1 invalid opcode " + cc.toString(16));
            else if (cc <= 115) return console.error("WK1 unsupported function opcode " + cc.toString(16));
            else return console.error("WK1 unrecognized opcode " + cc.toString(16));
        }
      }
      if (out.length == 1) o[1].f = "" + out[0];
      else console.error("WK1 bad formula parse |" + out.join("|") + "|");
    }
    function parse_cell_3(blob) {
      var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
      o[0].r = blob.read_shift(2);
      o[3] = blob[blob.l++];
      o[0].c = blob[blob.l++];
      return o;
    }
    function parse_LABEL_16(blob, length) {
      var o = parse_cell_3(blob, length);
      o[1].t = "s";
      o[1].v = blob.read_shift(length - 4, "cstr");
      return o;
    }
    function write_LABEL_16(R, C, wsidx, s) {
      var o = new_buf(6 + s.length);
      o.write_shift(2, R);
      o.write_shift(1, wsidx);
      o.write_shift(1, C);
      o.write_shift(1, 39);
      for (var i = 0; i < s.length; ++i) {
        var cc = s.charCodeAt(i);
        o.write_shift(1, cc >= 128 ? 95 : cc);
      }
      o.write_shift(1, 0);
      return o;
    }
    function parse_NUMBER_18(blob, length) {
      var o = parse_cell_3(blob, length);
      o[1].v = blob.read_shift(2);
      var v = o[1].v >> 1;
      if (o[1].v & 1) {
        switch (v & 7) {
          case 0:
            v = (v >> 3) * 5e3;
            break;
          case 1:
            v = (v >> 3) * 500;
            break;
          case 2:
            v = (v >> 3) / 20;
            break;
          case 3:
            v = (v >> 3) / 200;
            break;
          case 4:
            v = (v >> 3) / 2e3;
            break;
          case 5:
            v = (v >> 3) / 2e4;
            break;
          case 6:
            v = (v >> 3) / 16;
            break;
          case 7:
            v = (v >> 3) / 64;
            break;
        }
      }
      o[1].v = v;
      return o;
    }
    function parse_NUMBER_17(blob, length) {
      var o = parse_cell_3(blob, length);
      var v1 = blob.read_shift(4);
      var v2 = blob.read_shift(4);
      var e = blob.read_shift(2);
      if (e == 65535) {
        if (v1 === 0 && v2 === 3221225472) {
          o[1].t = "e";
          o[1].v = 15;
        } else if (v1 === 0 && v2 === 3489660928) {
          o[1].t = "e";
          o[1].v = 42;
        } else o[1].v = 0;
        return o;
      }
      var s = e & 32768;
      e = (e & 32767) - 16446;
      o[1].v = (1 - s * 2) * (v2 * Math.pow(2, e + 32) + v1 * Math.pow(2, e));
      return o;
    }
    function write_NUMBER_17(R, C, wsidx, v) {
      var o = new_buf(14);
      o.write_shift(2, R);
      o.write_shift(1, wsidx);
      o.write_shift(1, C);
      if (v == 0) {
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(2, 65535);
        return o;
      }
      var s = 0, e = 0, v1 = 0, v2 = 0;
      if (v < 0) {
        s = 1;
        v = -v;
      }
      e = Math.log2(v) | 0;
      v /= Math.pow(2, e - 31);
      v2 = v >>> 0;
      if ((v2 & 2147483648) == 0) {
        v /= 2;
        ++e;
        v2 = v >>> 0;
      }
      v -= v2;
      v2 |= 2147483648;
      v2 >>>= 0;
      v *= Math.pow(2, 32);
      v1 = v >>> 0;
      o.write_shift(4, v1);
      o.write_shift(4, v2);
      e += 16383 + (s ? 32768 : 0);
      o.write_shift(2, e);
      return o;
    }
    function parse_FORMULA_19(blob, length) {
      var o = parse_NUMBER_17(blob, 14);
      blob.l += length - 14;
      return o;
    }
    function parse_NUMBER_25(blob, length) {
      var o = parse_cell_3(blob, length);
      var v1 = blob.read_shift(4);
      o[1].v = v1 >> 6;
      return o;
    }
    function parse_NUMBER_27(blob, length) {
      var o = parse_cell_3(blob, length);
      var v1 = blob.read_shift(8, "f");
      o[1].v = v1;
      return o;
    }
    function parse_FORMULA_28(blob, length) {
      var o = parse_NUMBER_27(blob, 14);
      blob.l += length - 10;
      return o;
    }
    function parse_SHEETNAMECS(blob, length) {
      return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, "cstr") : "";
    }
    function parse_SHEETNAMELP(blob, length) {
      var len = blob[blob.l++];
      if (len > length - 1) len = length - 1;
      var o = "";
      while (o.length < len) o += String.fromCharCode(blob[blob.l++]);
      return o;
    }
    function parse_SHEETINFOQP(blob, length, opts) {
      if (!opts.qpro || length < 21) return;
      var id = blob.read_shift(1);
      blob.l += 17;
      blob.l += 1;
      blob.l += 2;
      var nm = blob.read_shift(length - 21, "cstr");
      return [id, nm];
    }
    function parse_XFORMAT(blob, length) {
      var o = {}, tgt = blob.l + length;
      while (blob.l < tgt) {
        var dt = blob.read_shift(2);
        if (dt == 14e3) {
          o[dt] = [0, ""];
          o[dt][0] = blob.read_shift(2);
          while (blob[blob.l]) {
            o[dt][1] += String.fromCharCode(blob[blob.l]);
            blob.l++;
          }
          blob.l++;
        }
      }
      return o;
    }
    function write_XFORMAT_SHEETNAME(name, wsidx) {
      var out = new_buf(5 + name.length);
      out.write_shift(2, 14e3);
      out.write_shift(2, wsidx);
      for (var i = 0; i < name.length; ++i) {
        var cc = name.charCodeAt(i);
        out[out.l++] = cc > 127 ? 95 : cc;
      }
      out[out.l++] = 0;
      return out;
    }
    var WK1Enum = {
      /*::[*/
      0: { n: "BOF", f: parseuint16 },
      /*::[*/
      1: { n: "EOF" },
      /*::[*/
      2: { n: "CALCMODE" },
      /*::[*/
      3: { n: "CALCORDER" },
      /*::[*/
      4: { n: "SPLIT" },
      /*::[*/
      5: { n: "SYNC" },
      /*::[*/
      6: { n: "RANGE", f: parse_RANGE },
      /*::[*/
      7: { n: "WINDOW1" },
      /*::[*/
      8: { n: "COLW1" },
      /*::[*/
      9: { n: "WINTWO" },
      /*::[*/
      10: { n: "COLW2" },
      /*::[*/
      11: { n: "NAME" },
      /*::[*/
      12: { n: "BLANK" },
      /*::[*/
      13: { n: "INTEGER", f: parse_INTEGER },
      /*::[*/
      14: { n: "NUMBER", f: parse_NUMBER },
      /*::[*/
      15: { n: "LABEL", f: parse_LABEL },
      /*::[*/
      16: { n: "FORMULA", f: parse_FORMULA },
      /*::[*/
      24: { n: "TABLE" },
      /*::[*/
      25: { n: "ORANGE" },
      /*::[*/
      26: { n: "PRANGE" },
      /*::[*/
      27: { n: "SRANGE" },
      /*::[*/
      28: { n: "FRANGE" },
      /*::[*/
      29: { n: "KRANGE1" },
      /*::[*/
      32: { n: "HRANGE" },
      /*::[*/
      35: { n: "KRANGE2" },
      /*::[*/
      36: { n: "PROTEC" },
      /*::[*/
      37: { n: "FOOTER" },
      /*::[*/
      38: { n: "HEADER" },
      /*::[*/
      39: { n: "SETUP" },
      /*::[*/
      40: { n: "MARGINS" },
      /*::[*/
      41: { n: "LABELFMT" },
      /*::[*/
      42: { n: "TITLES" },
      /*::[*/
      43: { n: "SHEETJS" },
      /*::[*/
      45: { n: "GRAPH" },
      /*::[*/
      46: { n: "NGRAPH" },
      /*::[*/
      47: { n: "CALCCOUNT" },
      /*::[*/
      48: { n: "UNFORMATTED" },
      /*::[*/
      49: { n: "CURSORW12" },
      /*::[*/
      50: { n: "WINDOW" },
      /*::[*/
      51: { n: "STRING", f: parse_LABEL },
      /*::[*/
      55: { n: "PASSWORD" },
      /*::[*/
      56: { n: "LOCKED" },
      /*::[*/
      60: { n: "QUERY" },
      /*::[*/
      61: { n: "QUERYNAME" },
      /*::[*/
      62: { n: "PRINT" },
      /*::[*/
      63: { n: "PRINTNAME" },
      /*::[*/
      64: { n: "GRAPH2" },
      /*::[*/
      65: { n: "GRAPHNAME" },
      /*::[*/
      66: { n: "ZOOM" },
      /*::[*/
      67: { n: "SYMSPLIT" },
      /*::[*/
      68: { n: "NSROWS" },
      /*::[*/
      69: { n: "NSCOLS" },
      /*::[*/
      70: { n: "RULER" },
      /*::[*/
      71: { n: "NNAME" },
      /*::[*/
      72: { n: "ACOMM" },
      /*::[*/
      73: { n: "AMACRO" },
      /*::[*/
      74: { n: "PARSE" },
      /*::[*/
      102: { n: "PRANGES??" },
      /*::[*/
      103: { n: "RRANGES??" },
      /*::[*/
      104: { n: "FNAME??" },
      /*::[*/
      105: { n: "MRANGES??" },
      /*::[*/
      204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
      /*::[*/
      222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
      /*::[*/
      65535: { n: "" }
    };
    var WK3Enum = {
      /*::[*/
      0: { n: "BOF" },
      /*::[*/
      1: { n: "EOF" },
      /*::[*/
      2: { n: "PASSWORD" },
      /*::[*/
      3: { n: "CALCSET" },
      /*::[*/
      4: { n: "WINDOWSET" },
      /*::[*/
      5: { n: "SHEETCELLPTR" },
      /*::[*/
      6: { n: "SHEETLAYOUT" },
      /*::[*/
      7: { n: "COLUMNWIDTH" },
      /*::[*/
      8: { n: "HIDDENCOLUMN" },
      /*::[*/
      9: { n: "USERRANGE" },
      /*::[*/
      10: { n: "SYSTEMRANGE" },
      /*::[*/
      11: { n: "ZEROFORCE" },
      /*::[*/
      12: { n: "SORTKEYDIR" },
      /*::[*/
      13: { n: "FILESEAL" },
      /*::[*/
      14: { n: "DATAFILLNUMS" },
      /*::[*/
      15: { n: "PRINTMAIN" },
      /*::[*/
      16: { n: "PRINTSTRING" },
      /*::[*/
      17: { n: "GRAPHMAIN" },
      /*::[*/
      18: { n: "GRAPHSTRING" },
      /*::[*/
      19: { n: "??" },
      /*::[*/
      20: { n: "ERRCELL" },
      /*::[*/
      21: { n: "NACELL" },
      /*::[*/
      22: { n: "LABEL16", f: parse_LABEL_16 },
      /*::[*/
      23: { n: "NUMBER17", f: parse_NUMBER_17 },
      /*::[*/
      24: { n: "NUMBER18", f: parse_NUMBER_18 },
      /*::[*/
      25: { n: "FORMULA19", f: parse_FORMULA_19 },
      /*::[*/
      26: { n: "FORMULA1A" },
      /*::[*/
      27: { n: "XFORMAT", f: parse_XFORMAT },
      /*::[*/
      28: { n: "DTLABELMISC" },
      /*::[*/
      29: { n: "DTLABELCELL" },
      /*::[*/
      30: { n: "GRAPHWINDOW" },
      /*::[*/
      31: { n: "CPA" },
      /*::[*/
      32: { n: "LPLAUTO" },
      /*::[*/
      33: { n: "QUERY" },
      /*::[*/
      34: { n: "HIDDENSHEET" },
      /*::[*/
      35: { n: "??" },
      /*::[*/
      37: { n: "NUMBER25", f: parse_NUMBER_25 },
      /*::[*/
      38: { n: "??" },
      /*::[*/
      39: { n: "NUMBER27", f: parse_NUMBER_27 },
      /*::[*/
      40: { n: "FORMULA28", f: parse_FORMULA_28 },
      /*::[*/
      142: { n: "??" },
      /*::[*/
      147: { n: "??" },
      /*::[*/
      150: { n: "??" },
      /*::[*/
      151: { n: "??" },
      /*::[*/
      152: { n: "??" },
      /*::[*/
      153: { n: "??" },
      /*::[*/
      154: { n: "??" },
      /*::[*/
      155: { n: "??" },
      /*::[*/
      156: { n: "??" },
      /*::[*/
      163: { n: "??" },
      /*::[*/
      174: { n: "??" },
      /*::[*/
      175: { n: "??" },
      /*::[*/
      176: { n: "??" },
      /*::[*/
      177: { n: "??" },
      /*::[*/
      184: { n: "??" },
      /*::[*/
      185: { n: "??" },
      /*::[*/
      186: { n: "??" },
      /*::[*/
      187: { n: "??" },
      /*::[*/
      188: { n: "??" },
      /*::[*/
      195: { n: "??" },
      /*::[*/
      201: { n: "??" },
      /*::[*/
      204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
      /*::[*/
      205: { n: "??" },
      /*::[*/
      206: { n: "??" },
      /*::[*/
      207: { n: "??" },
      /*::[*/
      208: { n: "??" },
      /*::[*/
      256: { n: "??" },
      /*::[*/
      259: { n: "??" },
      /*::[*/
      260: { n: "??" },
      /*::[*/
      261: { n: "??" },
      /*::[*/
      262: { n: "??" },
      /*::[*/
      263: { n: "??" },
      /*::[*/
      265: { n: "??" },
      /*::[*/
      266: { n: "??" },
      /*::[*/
      267: { n: "??" },
      /*::[*/
      268: { n: "??" },
      /*::[*/
      270: { n: "??" },
      /*::[*/
      271: { n: "??" },
      /*::[*/
      384: { n: "??" },
      /*::[*/
      389: { n: "??" },
      /*::[*/
      390: { n: "??" },
      /*::[*/
      393: { n: "??" },
      /*::[*/
      396: { n: "??" },
      /*::[*/
      512: { n: "??" },
      /*::[*/
      514: { n: "??" },
      /*::[*/
      513: { n: "??" },
      /*::[*/
      516: { n: "??" },
      /*::[*/
      517: { n: "??" },
      /*::[*/
      640: { n: "??" },
      /*::[*/
      641: { n: "??" },
      /*::[*/
      642: { n: "??" },
      /*::[*/
      643: { n: "??" },
      /*::[*/
      644: { n: "??" },
      /*::[*/
      645: { n: "??" },
      /*::[*/
      646: { n: "??" },
      /*::[*/
      647: { n: "??" },
      /*::[*/
      648: { n: "??" },
      /*::[*/
      658: { n: "??" },
      /*::[*/
      659: { n: "??" },
      /*::[*/
      660: { n: "??" },
      /*::[*/
      661: { n: "??" },
      /*::[*/
      662: { n: "??" },
      /*::[*/
      665: { n: "??" },
      /*::[*/
      666: { n: "??" },
      /*::[*/
      768: { n: "??" },
      /*::[*/
      772: { n: "??" },
      /*::[*/
      1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
      /*::[*/
      1600: { n: "??" },
      /*::[*/
      1602: { n: "??" },
      /*::[*/
      1793: { n: "??" },
      /*::[*/
      1794: { n: "??" },
      /*::[*/
      1795: { n: "??" },
      /*::[*/
      1796: { n: "??" },
      /*::[*/
      1920: { n: "??" },
      /*::[*/
      2048: { n: "??" },
      /*::[*/
      2049: { n: "??" },
      /*::[*/
      2052: { n: "??" },
      /*::[*/
      2688: { n: "??" },
      /*::[*/
      10998: { n: "??" },
      /*::[*/
      12849: { n: "??" },
      /*::[*/
      28233: { n: "??" },
      /*::[*/
      28484: { n: "??" },
      /*::[*/
      65535: { n: "" }
    };
    return {
      sheet_to_wk1,
      book_to_wk3,
      to_workbook: lotus_to_workbook
    };
  })();
  var straywsregex = /^\s|\s$|[\t\n\r]/;
  function write_sst_xml(sst, opts) {
    if (!opts.bookSST) return "";
    var o = [XML_HEADER];
    o[o.length] = writextag("sst", null, {
      xmlns: XMLNS_main[0],
      count: sst.Count,
      uniqueCount: sst.Unique
    });
    for (var i = 0; i != sst.length; ++i) {
      if (sst[i] == null) continue;
      var s = sst[i];
      var sitag = "<si>";
      if (s.r) sitag += s.r;
      else {
        sitag += "<t";
        if (!s.t) s.t = "";
        if (s.t.match(straywsregex)) sitag += ' xml:space="preserve"';
        sitag += ">" + escapexml(s.t) + "</t>";
      }
      sitag += "</si>";
      o[o.length] = sitag;
    }
    if (o.length > 2) {
      o[o.length] = "</sst>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function parse_BrtBeginSst(data) {
    return [data.read_shift(4), data.read_shift(4)];
  }
  function write_BrtBeginSst(sst, o) {
    if (!o) o = new_buf(8);
    o.write_shift(4, sst.Count);
    o.write_shift(4, sst.Unique);
    return o;
  }
  var write_BrtSSTItem = write_RichStr;
  function write_sst_bin(sst) {
    var ba = buf_array();
    write_record(ba, 159, write_BrtBeginSst(sst));
    for (var i = 0; i < sst.length; ++i) write_record(ba, 19, write_BrtSSTItem(sst[i]));
    write_record(
      ba,
      160
      /* BrtEndSst */
    );
    return ba.end();
  }
  function _JS2ANSI(str) {
    if (typeof $cptable !== "undefined") return $cptable.utils.encode(current_ansi, str);
    var o = [], oo = str.split("");
    for (var i = 0; i < oo.length; ++i) o[i] = oo[i].charCodeAt(0);
    return o;
  }
  function crypto_CreatePasswordVerifier_Method1(Password) {
    var Verifier = 0, PasswordArray;
    var PasswordDecoded = _JS2ANSI(Password);
    var len = PasswordDecoded.length + 1, i, PasswordByte;
    var Intermediate1, Intermediate2, Intermediate3;
    PasswordArray = new_raw_buf(len);
    PasswordArray[0] = PasswordDecoded.length;
    for (i = 1; i != len; ++i) PasswordArray[i] = PasswordDecoded[i - 1];
    for (i = len - 1; i >= 0; --i) {
      PasswordByte = PasswordArray[i];
      Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
      Intermediate2 = Verifier << 1 & 32767;
      Intermediate3 = Intermediate1 | Intermediate2;
      Verifier = Intermediate3 ^ PasswordByte;
    }
    return Verifier ^ 52811;
  }
  var RTF = /* @__PURE__ */ (function() {
    function rtf_to_sheet(d, opts) {
      switch (opts.type) {
        case "base64":
          return rtf_to_sheet_str(Base64_decode(d), opts);
        case "binary":
          return rtf_to_sheet_str(d, opts);
        case "buffer":
          return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
        case "array":
          return rtf_to_sheet_str(cc2str(d), opts);
      }
      throw new Error("Unrecognized type " + opts.type);
    }
    function rtf_to_sheet_str(str, opts) {
      var o = opts || {};
      var ws = o.dense ? [] : {};
      var rows = str.match(/\\trowd.*?\\row\b/g);
      if (!rows.length) throw new Error("RTF missing table");
      var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
      rows.forEach(function(rowtf, R) {
        if (Array.isArray(ws)) ws[R] = [];
        var rtfre = /\\\w+\b/g;
        var last_index = 0;
        var res;
        var C = -1;
        while (res = rtfre.exec(rowtf)) {
          switch (res[0]) {
            case "\\cell":
              var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
              if (data[0] == " ") data = data.slice(1);
              ++C;
              if (data.length) {
                var cell = { v: data, t: "s" };
                if (Array.isArray(ws)) ws[R][C] = cell;
                else ws[encode_cell({ r: R, c: C })] = cell;
              }
              break;
          }
          last_index = rtfre.lastIndex;
        }
        if (C > range.e.c) range.e.c = C;
      });
      ws["!ref"] = encode_range(range);
      return ws;
    }
    function rtf_to_workbook(d, opts) {
      return sheet_to_workbook(rtf_to_sheet(d, opts), opts);
    }
    function sheet_to_rtf(ws) {
      var o = ["{\\rtf1\\ansi"];
      var r = safe_decode_range(ws["!ref"]), cell;
      var dense = Array.isArray(ws);
      for (var R = r.s.r; R <= r.e.r; ++R) {
        o.push("\\trowd\\trautofit1");
        for (var C = r.s.c; C <= r.e.c; ++C) o.push("\\cellx" + (C + 1));
        o.push("\\pard\\intbl");
        for (C = r.s.c; C <= r.e.c; ++C) {
          var coord = encode_cell({ r: R, c: C });
          cell = dense ? (ws[R] || [])[C] : ws[coord];
          if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
          o.push(" " + (cell.w || (format_cell(cell), cell.w)));
          o.push("\\cell");
        }
        o.push("\\pard\\intbl\\row");
      }
      return o.join("") + "}";
    }
    return {
      to_workbook: rtf_to_workbook,
      to_sheet: rtf_to_sheet,
      from_sheet: sheet_to_rtf
    };
  })();
  function rgb2Hex(rgb) {
    for (var i = 0, o = 1; i != 3; ++i) o = o * 256 + (rgb[i] > 255 ? 255 : rgb[i] < 0 ? 0 : rgb[i]);
    return o.toString(16).toUpperCase().slice(1);
  }
  var DEF_MDW = 6;
  var MDW = DEF_MDW;
  function width2px(width) {
    return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
  }
  function px2char(px) {
    return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
  }
  function char2width(chr) {
    return Math.round((chr * MDW + 5) / MDW * 256) / 256;
  }
  function process_col(coll) {
    if (coll.width) {
      coll.wpx = width2px(coll.width);
      coll.wch = px2char(coll.wpx);
      coll.MDW = MDW;
    } else if (coll.wpx) {
      coll.wch = px2char(coll.wpx);
      coll.width = char2width(coll.wch);
      coll.MDW = MDW;
    } else if (typeof coll.wch == "number") {
      coll.width = char2width(coll.wch);
      coll.wpx = width2px(coll.width);
      coll.MDW = MDW;
    }
    if (coll.customWidth) delete coll.customWidth;
  }
  var DEF_PPI = 96;
  var PPI = DEF_PPI;
  function px2pt(px) {
    return px * 96 / PPI;
  }
  function pt2px(pt) {
    return pt * PPI / 96;
  }
  function write_numFmts(NF) {
    var o = ["<numFmts>"];
    [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(r) {
      for (var i = r[0]; i <= r[1]; ++i) if (NF[i] != null) o[o.length] = writextag("numFmt", null, { numFmtId: i, formatCode: escapexml(NF[i]) });
    });
    if (o.length === 1) return "";
    o[o.length] = "</numFmts>";
    o[0] = writextag("numFmts", null, { count: o.length - 2 }).replace("/>", ">");
    return o.join("");
  }
  function write_cellXfs(cellXfs) {
    var o = [];
    o[o.length] = writextag("cellXfs", null);
    cellXfs.forEach(function(c) {
      o[o.length] = writextag("xf", null, c);
    });
    o[o.length] = "</cellXfs>";
    if (o.length === 2) return "";
    o[0] = writextag("cellXfs", null, { count: o.length - 2 }).replace("/>", ">");
    return o.join("");
  }
  function write_sty_xml(wb, opts) {
    var o = [XML_HEADER, writextag("styleSheet", null, {
      "xmlns": XMLNS_main[0],
      "xmlns:vt": XMLNS.vt
    })], w;
    if (wb.SSF && (w = write_numFmts(wb.SSF)) != null) o[o.length] = w;
    o[o.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';
    o[o.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';
    o[o.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';
    o[o.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
    if (w = write_cellXfs(opts.cellXfs)) o[o.length] = w;
    o[o.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';
    o[o.length] = '<dxfs count="0"/>';
    o[o.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';
    if (o.length > 2) {
      o[o.length] = "</styleSheet>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function parse_BrtFmt(data, length) {
    var numFmtId = data.read_shift(2);
    var stFmtCode = parse_XLWideString(data, length - 2);
    return [numFmtId, stFmtCode];
  }
  function write_BrtFmt(i, f, o) {
    if (!o) o = new_buf(6 + 4 * f.length);
    o.write_shift(2, i);
    write_XLWideString(f, o);
    var out = o.length > o.l ? o.slice(0, o.l) : o;
    if (o.l == null) o.l = o.length;
    return out;
  }
  function parse_BrtFont(data, length, opts) {
    var out = {};
    out.sz = data.read_shift(2) / 20;
    var grbit = parse_FontFlags(data, 2, opts);
    if (grbit.fItalic) out.italic = 1;
    if (grbit.fCondense) out.condense = 1;
    if (grbit.fExtend) out.extend = 1;
    if (grbit.fShadow) out.shadow = 1;
    if (grbit.fOutline) out.outline = 1;
    if (grbit.fStrikeout) out.strike = 1;
    var bls = data.read_shift(2);
    if (bls === 700) out.bold = 1;
    switch (data.read_shift(2)) {
      /* case 0: out.vertAlign = "baseline"; break; */
      case 1:
        out.vertAlign = "superscript";
        break;
      case 2:
        out.vertAlign = "subscript";
        break;
    }
    var underline = data.read_shift(1);
    if (underline != 0) out.underline = underline;
    var family = data.read_shift(1);
    if (family > 0) out.family = family;
    var bCharSet = data.read_shift(1);
    if (bCharSet > 0) out.charset = bCharSet;
    data.l++;
    out.color = parse_BrtColor(data, 8);
    switch (data.read_shift(1)) {
      /* case 0: out.scheme = "none": break; */
      case 1:
        out.scheme = "major";
        break;
      case 2:
        out.scheme = "minor";
        break;
    }
    out.name = parse_XLWideString(data, length - 21);
    return out;
  }
  function write_BrtFont(font, o) {
    if (!o) o = new_buf(25 + 4 * 32);
    o.write_shift(2, font.sz * 20);
    write_FontFlags(font, o);
    o.write_shift(2, font.bold ? 700 : 400);
    var sss = 0;
    if (font.vertAlign == "superscript") sss = 1;
    else if (font.vertAlign == "subscript") sss = 2;
    o.write_shift(2, sss);
    o.write_shift(1, font.underline || 0);
    o.write_shift(1, font.family || 0);
    o.write_shift(1, font.charset || 0);
    o.write_shift(1, 0);
    write_BrtColor(font.color, o);
    var scheme = 0;
    if (font.scheme == "major") scheme = 1;
    if (font.scheme == "minor") scheme = 2;
    o.write_shift(1, scheme);
    write_XLWideString(font.name, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  var XLSBFillPTNames = [
    "none",
    "solid",
    "mediumGray",
    "darkGray",
    "lightGray",
    "darkHorizontal",
    "darkVertical",
    "darkDown",
    "darkUp",
    "darkGrid",
    "darkTrellis",
    "lightHorizontal",
    "lightVertical",
    "lightDown",
    "lightUp",
    "lightGrid",
    "lightTrellis",
    "gray125",
    "gray0625"
  ];
  var rev_XLSBFillPTNames;
  var parse_BrtFill = parsenoop;
  function write_BrtFill(fill2, o) {
    if (!o) o = new_buf(4 * 3 + 8 * 7 + 16 * 1);
    if (!rev_XLSBFillPTNames) rev_XLSBFillPTNames = evert(XLSBFillPTNames);
    var fls = rev_XLSBFillPTNames[fill2.patternType];
    if (fls == null) fls = 40;
    o.write_shift(4, fls);
    var j = 0;
    if (fls != 40) {
      write_BrtColor({ auto: 1 }, o);
      write_BrtColor({ auto: 1 }, o);
      for (; j < 12; ++j) o.write_shift(4, 0);
    } else {
      for (; j < 4; ++j) o.write_shift(4, 0);
      for (; j < 12; ++j) o.write_shift(4, 0);
    }
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_BrtXF(data, length) {
    var tgt = data.l + length;
    var ixfeParent = data.read_shift(2);
    var ifmt = data.read_shift(2);
    data.l = tgt;
    return { ixfe: ixfeParent, numFmtId: ifmt };
  }
  function write_BrtXF(data, ixfeP, o) {
    if (!o) o = new_buf(16);
    o.write_shift(2, ixfeP || 0);
    o.write_shift(2, data.numFmtId || 0);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    var flow = 0;
    o.write_shift(1, flow);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    return o;
  }
  function write_Blxf(data, o) {
    if (!o) o = new_buf(10);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    return o;
  }
  var parse_BrtBorder = parsenoop;
  function write_BrtBorder(border, o) {
    if (!o) o = new_buf(51);
    o.write_shift(1, 0);
    write_Blxf(null, o);
    write_Blxf(null, o);
    write_Blxf(null, o);
    write_Blxf(null, o);
    write_Blxf(null, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_BrtStyle(style, o) {
    if (!o) o = new_buf(12 + 4 * 10);
    o.write_shift(4, style.xfId);
    o.write_shift(2, 1);
    o.write_shift(1, +style.builtinId);
    o.write_shift(1, 0);
    write_XLNullableWideString(style.name || "", o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {
    var o = new_buf(4 + 256 * 2 * 4);
    o.write_shift(4, cnt);
    write_XLNullableWideString(defTableStyle, o);
    write_XLNullableWideString(defPivotStyle, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_FMTS_bin(ba, NF) {
    if (!NF) return;
    var cnt = 0;
    [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(r) {
      for (var i = r[0]; i <= r[1]; ++i) if (NF[i] != null) ++cnt;
    });
    if (cnt == 0) return;
    write_record(ba, 615, write_UInt32LE(cnt));
    [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(r) {
      for (var i = r[0]; i <= r[1]; ++i) if (NF[i] != null) write_record(ba, 44, write_BrtFmt(i, NF[i]));
    });
    write_record(
      ba,
      616
      /* BrtEndFmts */
    );
  }
  function write_FONTS_bin(ba) {
    var cnt = 1;
    if (cnt == 0) return;
    write_record(ba, 611, write_UInt32LE(cnt));
    write_record(ba, 43, write_BrtFont({
      sz: 12,
      color: { theme: 1 },
      name: "Calibri",
      family: 2,
      scheme: "minor"
    }));
    write_record(
      ba,
      612
      /* BrtEndFonts */
    );
  }
  function write_FILLS_bin(ba) {
    var cnt = 2;
    if (cnt == 0) return;
    write_record(ba, 603, write_UInt32LE(cnt));
    write_record(ba, 45, write_BrtFill({ patternType: "none" }));
    write_record(ba, 45, write_BrtFill({ patternType: "gray125" }));
    write_record(
      ba,
      604
      /* BrtEndFills */
    );
  }
  function write_BORDERS_bin(ba) {
    var cnt = 1;
    if (cnt == 0) return;
    write_record(ba, 613, write_UInt32LE(cnt));
    write_record(ba, 46, write_BrtBorder({}));
    write_record(
      ba,
      614
      /* BrtEndBorders */
    );
  }
  function write_CELLSTYLEXFS_bin(ba) {
    var cnt = 1;
    write_record(ba, 626, write_UInt32LE(cnt));
    write_record(ba, 47, write_BrtXF({
      numFmtId: 0,
      fontId: 0,
      fillId: 0,
      borderId: 0
    }, 65535));
    write_record(
      ba,
      627
      /* BrtEndCellStyleXFs */
    );
  }
  function write_CELLXFS_bin(ba, data) {
    write_record(ba, 617, write_UInt32LE(data.length));
    data.forEach(function(c) {
      write_record(ba, 47, write_BrtXF(c, 0));
    });
    write_record(
      ba,
      618
      /* BrtEndCellXFs */
    );
  }
  function write_STYLES_bin(ba) {
    var cnt = 1;
    write_record(ba, 619, write_UInt32LE(cnt));
    write_record(ba, 48, write_BrtStyle({
      xfId: 0,
      builtinId: 0,
      name: "Normal"
    }));
    write_record(
      ba,
      620
      /* BrtEndStyles */
    );
  }
  function write_DXFS_bin(ba) {
    var cnt = 0;
    write_record(ba, 505, write_UInt32LE(cnt));
    write_record(
      ba,
      506
      /* BrtEndDXFs */
    );
  }
  function write_TABLESTYLES_bin(ba) {
    var cnt = 0;
    write_record(ba, 508, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));
    write_record(
      ba,
      509
      /* BrtEndTableStyles */
    );
  }
  function write_COLORPALETTE_bin() {
    return;
  }
  function write_sty_bin(wb, opts) {
    var ba = buf_array();
    write_record(
      ba,
      278
      /* BrtBeginStyleSheet */
    );
    write_FMTS_bin(ba, wb.SSF);
    write_FONTS_bin(ba, wb);
    write_FILLS_bin(ba, wb);
    write_BORDERS_bin(ba, wb);
    write_CELLSTYLEXFS_bin(ba, wb);
    write_CELLXFS_bin(ba, opts.cellXfs);
    write_STYLES_bin(ba, wb);
    write_DXFS_bin(ba, wb);
    write_TABLESTYLES_bin(ba, wb);
    write_COLORPALETTE_bin(ba, wb);
    write_record(
      ba,
      279
      /* BrtEndStyleSheet */
    );
    return ba.end();
  }
  function write_theme(Themes, opts) {
    if (opts && opts.themeXLSX) return opts.themeXLSX;
    if (Themes && typeof Themes.raw == "string") return Themes.raw;
    var o = [XML_HEADER];
    o[o.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
    o[o.length] = "<a:themeElements>";
    o[o.length] = '<a:clrScheme name="Office">';
    o[o.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
    o[o.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
    o[o.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
    o[o.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
    o[o.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
    o[o.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
    o[o.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
    o[o.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
    o[o.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
    o[o.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
    o[o.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
    o[o.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
    o[o.length] = "</a:clrScheme>";
    o[o.length] = '<a:fontScheme name="Office">';
    o[o.length] = "<a:majorFont>";
    o[o.length] = '<a:latin typeface="Cambria"/>';
    o[o.length] = '<a:ea typeface=""/>';
    o[o.length] = '<a:cs typeface=""/>';
    o[o.length] = '<a:font script="Jpan" typeface="\uFF2D\uFF33 \uFF30\u30B4\u30B7\u30C3\u30AF"/>';
    o[o.length] = '<a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/>';
    o[o.length] = '<a:font script="Hans" typeface="\u5B8B\u4F53"/>';
    o[o.length] = '<a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/>';
    o[o.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
    o[o.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
    o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
    o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
    o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
    o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
    o[o.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
    o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
    o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
    o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
    o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
    o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
    o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
    o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
    o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
    o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
    o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
    o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
    o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
    o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
    o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
    o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
    o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
    o[o.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
    o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
    o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
    o[o.length] = "</a:majorFont>";
    o[o.length] = "<a:minorFont>";
    o[o.length] = '<a:latin typeface="Calibri"/>';
    o[o.length] = '<a:ea typeface=""/>';
    o[o.length] = '<a:cs typeface=""/>';
    o[o.length] = '<a:font script="Jpan" typeface="\uFF2D\uFF33 \uFF30\u30B4\u30B7\u30C3\u30AF"/>';
    o[o.length] = '<a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/>';
    o[o.length] = '<a:font script="Hans" typeface="\u5B8B\u4F53"/>';
    o[o.length] = '<a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/>';
    o[o.length] = '<a:font script="Arab" typeface="Arial"/>';
    o[o.length] = '<a:font script="Hebr" typeface="Arial"/>';
    o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
    o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
    o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
    o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
    o[o.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
    o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
    o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
    o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
    o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
    o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
    o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
    o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
    o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
    o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
    o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
    o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
    o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
    o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
    o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
    o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
    o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
    o[o.length] = '<a:font script="Viet" typeface="Arial"/>';
    o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
    o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
    o[o.length] = "</a:minorFont>";
    o[o.length] = "</a:fontScheme>";
    o[o.length] = '<a:fmtScheme name="Office">';
    o[o.length] = "<a:fillStyleLst>";
    o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
    o[o.length] = '<a:gradFill rotWithShape="1">';
    o[o.length] = "<a:gsLst>";
    o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
    o[o.length] = "</a:gsLst>";
    o[o.length] = '<a:lin ang="16200000" scaled="1"/>';
    o[o.length] = "</a:gradFill>";
    o[o.length] = '<a:gradFill rotWithShape="1">';
    o[o.length] = "<a:gsLst>";
    o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
    o[o.length] = "</a:gsLst>";
    o[o.length] = '<a:lin ang="16200000" scaled="0"/>';
    o[o.length] = "</a:gradFill>";
    o[o.length] = "</a:fillStyleLst>";
    o[o.length] = "<a:lnStyleLst>";
    o[o.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
    o[o.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
    o[o.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
    o[o.length] = "</a:lnStyleLst>";
    o[o.length] = "<a:effectStyleLst>";
    o[o.length] = "<a:effectStyle>";
    o[o.length] = "<a:effectLst>";
    o[o.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
    o[o.length] = "</a:effectLst>";
    o[o.length] = "</a:effectStyle>";
    o[o.length] = "<a:effectStyle>";
    o[o.length] = "<a:effectLst>";
    o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
    o[o.length] = "</a:effectLst>";
    o[o.length] = "</a:effectStyle>";
    o[o.length] = "<a:effectStyle>";
    o[o.length] = "<a:effectLst>";
    o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
    o[o.length] = "</a:effectLst>";
    o[o.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
    o[o.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
    o[o.length] = "</a:effectStyle>";
    o[o.length] = "</a:effectStyleLst>";
    o[o.length] = "<a:bgFillStyleLst>";
    o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
    o[o.length] = '<a:gradFill rotWithShape="1">';
    o[o.length] = "<a:gsLst>";
    o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
    o[o.length] = "</a:gsLst>";
    o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
    o[o.length] = "</a:gradFill>";
    o[o.length] = '<a:gradFill rotWithShape="1">';
    o[o.length] = "<a:gsLst>";
    o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
    o[o.length] = "</a:gsLst>";
    o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
    o[o.length] = "</a:gradFill>";
    o[o.length] = "</a:bgFillStyleLst>";
    o[o.length] = "</a:fmtScheme>";
    o[o.length] = "</a:themeElements>";
    o[o.length] = "<a:objectDefaults>";
    o[o.length] = "<a:spDef>";
    o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
    o[o.length] = "</a:spDef>";
    o[o.length] = "<a:lnDef>";
    o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
    o[o.length] = "</a:lnDef>";
    o[o.length] = "</a:objectDefaults>";
    o[o.length] = "<a:extraClrSchemeLst/>";
    o[o.length] = "</a:theme>";
    return o.join("");
  }
  function parse_BrtMdtinfo(data, length) {
    return {
      flags: data.read_shift(4),
      version: data.read_shift(4),
      name: parse_XLWideString(data, length - 8)
    };
  }
  function write_BrtMdtinfo(data) {
    var o = new_buf(12 + 2 * data.name.length);
    o.write_shift(4, data.flags);
    o.write_shift(4, data.version);
    write_XLWideString(data.name, o);
    return o.slice(0, o.l);
  }
  function parse_BrtMdb(data) {
    var out = [];
    var cnt = data.read_shift(4);
    while (cnt-- > 0)
      out.push([data.read_shift(4), data.read_shift(4)]);
    return out;
  }
  function write_BrtMdb(mdb) {
    var o = new_buf(4 + 8 * mdb.length);
    o.write_shift(4, mdb.length);
    for (var i = 0; i < mdb.length; ++i) {
      o.write_shift(4, mdb[i][0]);
      o.write_shift(4, mdb[i][1]);
    }
    return o;
  }
  function write_BrtBeginEsfmd(cnt, name) {
    var o = new_buf(8 + 2 * name.length);
    o.write_shift(4, cnt);
    write_XLWideString(name, o);
    return o.slice(0, o.l);
  }
  function parse_BrtBeginEsmdb(data) {
    data.l += 4;
    return data.read_shift(4) != 0;
  }
  function write_BrtBeginEsmdb(cnt, cm) {
    var o = new_buf(8);
    o.write_shift(4, cnt);
    o.write_shift(4, cm ? 1 : 0);
    return o;
  }
  function write_xlmeta_bin() {
    var ba = buf_array();
    write_record(ba, 332);
    write_record(ba, 334, write_UInt32LE(1));
    write_record(ba, 335, write_BrtMdtinfo({
      name: "XLDAPR",
      version: 12e4,
      flags: 3496657072
    }));
    write_record(ba, 336);
    write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));
    write_record(ba, 52);
    write_record(ba, 35, write_UInt32LE(514));
    write_record(ba, 4096, write_UInt32LE(0));
    write_record(ba, 4097, writeuint16(1));
    write_record(ba, 36);
    write_record(ba, 53);
    write_record(ba, 340);
    write_record(ba, 337, write_BrtBeginEsmdb(1, true));
    write_record(ba, 51, write_BrtMdb([[1, 0]]));
    write_record(ba, 338);
    write_record(ba, 333);
    return ba.end();
  }
  function write_xlmeta_xml() {
    var o = [XML_HEADER];
    o.push('<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">\n  <metadataTypes count="1">\n    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>\n  </metadataTypes>\n  <futureMetadata name="XLDAPR" count="1">\n    <bk>\n      <extLst>\n        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">\n          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>\n        </ext>\n      </extLst>\n    </bk>\n  </futureMetadata>\n  <cellMetadata count="1">\n    <bk>\n      <rc t="1" v="0"/>\n    </bk>\n  </cellMetadata>\n</metadata>');
    return o.join("");
  }
  function parse_BrtCalcChainItem$(data) {
    var out = {};
    out.i = data.read_shift(4);
    var cell = {};
    cell.r = data.read_shift(4);
    cell.c = data.read_shift(4);
    out.r = encode_cell(cell);
    var flags = data.read_shift(1);
    if (flags & 2) out.l = "1";
    if (flags & 8) out.a = "1";
    return out;
  }
  var _shapeid = 1024;
  function write_comments_vml(rId, comments) {
    var csize = [21600, 21600];
    var bbox = ["m0,0l0", csize[1], csize[0], csize[1], csize[0], "0xe"].join(",");
    var o = [
      writextag("xml", null, { "xmlns:v": XLMLNS.v, "xmlns:o": XLMLNS.o, "xmlns:x": XLMLNS.x, "xmlns:mv": XLMLNS.mv }).replace(/\/>/, ">"),
      writextag("o:shapelayout", writextag("o:idmap", null, { "v:ext": "edit", "data": rId }), { "v:ext": "edit" }),
      writextag("v:shapetype", [
        writextag("v:stroke", null, { joinstyle: "miter" }),
        writextag("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
      ].join(""), { id: "_x0000_t202", "o:spt": 202, coordsize: csize.join(","), path: bbox })
    ];
    while (_shapeid < rId * 1e3) _shapeid += 1e3;
    comments.forEach(function(x) {
      var c = decode_cell(x[0]);
      var fillopts = (
        /*::(*/
        { "color2": "#BEFF82", "type": "gradient" }
      );
      if (fillopts.type == "gradient") fillopts.angle = "-180";
      var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null;
      var fillxml = writextag("v:fill", fillparm, fillopts);
      var shadata = { on: "t", "obscured": "t" };
      ++_shapeid;
      o = o.concat([
        "<v:shape" + wxt_helper({
          id: "_x0000_s" + _shapeid,
          type: "#_x0000_t202",
          style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x[1].hidden ? ";visibility:hidden" : ""),
          fillcolor: "#ECFAD4",
          strokecolor: "#edeaa1"
        }) + ">",
        fillxml,
        writextag("v:shadow", null, shadata),
        writextag("v:path", null, { "o:connecttype": "none" }),
        '<v:textbox><div style="text-align:left"></div></v:textbox>',
        '<x:ClientData ObjectType="Note">',
        "<x:MoveWithCells/>",
        "<x:SizeWithCells/>",
        /* Part 4 19.4.2.3 Anchor (Anchor) */
        writetag("x:Anchor", [c.c + 1, 0, c.r + 1, 0, c.c + 3, 20, c.r + 5, 20].join(",")),
        writetag("x:AutoFill", "False"),
        writetag("x:Row", String(c.r)),
        writetag("x:Column", String(c.c)),
        x[1].hidden ? "" : "<x:Visible/>",
        "</x:ClientData>",
        "</v:shape>"
      ]);
    });
    o.push("</xml>");
    return o.join("");
  }
  function write_comments_xml(data) {
    var o = [XML_HEADER, writextag("comments", null, { "xmlns": XMLNS_main[0] })];
    var iauthor = [];
    o.push("<authors>");
    data.forEach(function(x) {
      x[1].forEach(function(w) {
        var a = escapexml(w.a);
        if (iauthor.indexOf(a) == -1) {
          iauthor.push(a);
          o.push("<author>" + a + "</author>");
        }
        if (w.T && w.ID && iauthor.indexOf("tc=" + w.ID) == -1) {
          iauthor.push("tc=" + w.ID);
          o.push("<author>tc=" + w.ID + "</author>");
        }
      });
    });
    if (iauthor.length == 0) {
      iauthor.push("SheetJ5");
      o.push("<author>SheetJ5</author>");
    }
    o.push("</authors>");
    o.push("<commentList>");
    data.forEach(function(d) {
      var lastauthor = 0, ts = [];
      if (d[1][0] && d[1][0].T && d[1][0].ID) lastauthor = iauthor.indexOf("tc=" + d[1][0].ID);
      else d[1].forEach(function(c) {
        if (c.a) lastauthor = iauthor.indexOf(escapexml(c.a));
        ts.push(c.t || "");
      });
      o.push('<comment ref="' + d[0] + '" authorId="' + lastauthor + '"><text>');
      if (ts.length <= 1) o.push(writetag("t", escapexml(ts[0] || "")));
      else {
        var t = "Comment:\n    " + ts[0] + "\n";
        for (var i = 1; i < ts.length; ++i) t += "Reply:\n    " + ts[i] + "\n";
        o.push(writetag("t", escapexml(t)));
      }
      o.push("</text></comment>");
    });
    o.push("</commentList>");
    if (o.length > 2) {
      o[o.length] = "</comments>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function write_tcmnt_xml(comments, people, opts) {
    var o = [XML_HEADER, writextag("ThreadedComments", null, { "xmlns": XMLNS.TCMNT }).replace(/[\/]>/, ">")];
    comments.forEach(function(carr) {
      var rootid = "";
      (carr[1] || []).forEach(function(c, idx) {
        if (!c.T) {
          delete c.ID;
          return;
        }
        if (c.a && people.indexOf(c.a) == -1) people.push(c.a);
        var tcopts = {
          ref: carr[0],
          id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"
        };
        if (idx == 0) rootid = tcopts.id;
        else tcopts.parentId = rootid;
        c.ID = tcopts.id;
        if (c.a) tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c.a)).slice(-12) + "}";
        o.push(writextag("threadedComment", writetag("text", c.t || ""), tcopts));
      });
    });
    o.push("</ThreadedComments>");
    return o.join("");
  }
  function write_people_xml(people) {
    var o = [XML_HEADER, writextag("personList", null, {
      "xmlns": XMLNS.TCMNT,
      "xmlns:x": XMLNS_main[0]
    }).replace(/[\/]>/, ">")];
    people.forEach(function(person, idx) {
      o.push(writextag("person", null, {
        displayName: person,
        id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",
        userId: person,
        providerId: "None"
      }));
    });
    o.push("</personList>");
    return o.join("");
  }
  function parse_BrtBeginComment(data) {
    var out = {};
    out.iauthor = data.read_shift(4);
    var rfx = parse_UncheckedRfX(data, 16);
    out.rfx = rfx.s;
    out.ref = encode_cell(rfx.s);
    data.l += 16;
    return out;
  }
  function write_BrtBeginComment(data, o) {
    if (o == null) o = new_buf(36);
    o.write_shift(4, data[1].iauthor);
    write_UncheckedRfX(data[0], o);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    return o;
  }
  var parse_BrtCommentAuthor = parse_XLWideString;
  function write_BrtCommentAuthor(data) {
    return write_XLWideString(data.slice(0, 54));
  }
  function write_comments_bin(data) {
    var ba = buf_array();
    var iauthor = [];
    write_record(
      ba,
      628
      /* BrtBeginComments */
    );
    write_record(
      ba,
      630
      /* BrtBeginCommentAuthors */
    );
    data.forEach(function(comment) {
      comment[1].forEach(function(c) {
        if (iauthor.indexOf(c.a) > -1) return;
        iauthor.push(c.a.slice(0, 54));
        write_record(ba, 632, write_BrtCommentAuthor(c.a));
      });
    });
    write_record(
      ba,
      631
      /* BrtEndCommentAuthors */
    );
    write_record(
      ba,
      633
      /* BrtBeginCommentList */
    );
    data.forEach(function(comment) {
      comment[1].forEach(function(c) {
        c.iauthor = iauthor.indexOf(c.a);
        var range = { s: decode_cell(comment[0]), e: decode_cell(comment[0]) };
        write_record(ba, 635, write_BrtBeginComment([range, c]));
        if (c.t && c.t.length > 0) write_record(ba, 637, write_BrtCommentText(c));
        write_record(
          ba,
          636
          /* BrtEndComment */
        );
        delete c.iauthor;
      });
    });
    write_record(
      ba,
      634
      /* BrtEndCommentList */
    );
    write_record(
      ba,
      629
      /* BrtEndComments */
    );
    return ba.end();
  }
  function fill_vba_xls(cfb, vba) {
    vba.FullPaths.forEach(function(p, i) {
      if (i == 0)
        return;
      var newpath = p.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
      if (newpath.slice(-1) !== "/")
        CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i].content);
    });
  }
  var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
  var rc_to_a1 = /* @__PURE__ */ (function() {
    var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
    var rcbase = { r: 0, c: 0 };
    function rcfunc($$, $1, $2, $3) {
      var cRel = false, rRel = false;
      if ($2.length == 0) rRel = true;
      else if ($2.charAt(0) == "[") {
        rRel = true;
        $2 = $2.slice(1, -1);
      }
      if ($3.length == 0) cRel = true;
      else if ($3.charAt(0) == "[") {
        cRel = true;
        $3 = $3.slice(1, -1);
      }
      var R = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
      if (cRel) C += rcbase.c;
      else --C;
      if (rRel) R += rcbase.r;
      else --R;
      return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);
    }
    return function rc_to_a12(fstr, base) {
      rcbase = base;
      return fstr.replace(rcregex, rcfunc);
    };
  })();
  var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
  var a1_to_rc = /* @__PURE__ */ (function() {
    return function a1_to_rc2(fstr, base) {
      return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
        var c = decode_col($3) - ($2 ? 0 : base.c);
        var r = decode_row($5) - ($4 ? 0 : base.r);
        var R = r == 0 ? "" : !$4 ? "[" + r + "]" : r + 1;
        var C = c == 0 ? "" : !$2 ? "[" + c + "]" : c + 1;
        return $1 + "R" + R + "C" + C;
      });
    };
  })();
  function shift_formula_str(f, delta) {
    return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
      return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
    });
  }
  function fuzzyfmla(f) {
    if (f.length == 1) return false;
    return true;
  }
  function parseread1(blob) {
    blob.l += 1;
    return;
  }
  function parse_ColRelU(blob, length) {
    var c = blob.read_shift(length == 1 ? 1 : 2);
    return [c & 16383, c >> 14 & 1, c >> 15 & 1];
  }
  function parse_RgceArea(blob, length, opts) {
    var w = 2;
    if (opts) {
      if (opts.biff >= 2 && opts.biff <= 5) return parse_RgceArea_BIFF2(blob, length, opts);
      else if (opts.biff == 12) w = 4;
    }
    var r = blob.read_shift(w), R = blob.read_shift(w);
    var c = parse_ColRelU(blob, 2);
    var C = parse_ColRelU(blob, 2);
    return { s: { r, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
  }
  function parse_RgceArea_BIFF2(blob) {
    var r = parse_ColRelU(blob, 2), R = parse_ColRelU(blob, 2);
    var c = blob.read_shift(1);
    var C = blob.read_shift(1);
    return { s: { r: r[0], c, cRel: r[1], rRel: r[2] }, e: { r: R[0], c: C, cRel: R[1], rRel: R[2] } };
  }
  function parse_RgceAreaRel(blob, length, opts) {
    if (opts.biff < 8) return parse_RgceArea_BIFF2(blob, length, opts);
    var r = blob.read_shift(opts.biff == 12 ? 4 : 2), R = blob.read_shift(opts.biff == 12 ? 4 : 2);
    var c = parse_ColRelU(blob, 2);
    var C = parse_ColRelU(blob, 2);
    return { s: { r, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
  }
  function parse_RgceLoc(blob, length, opts) {
    if (opts && opts.biff >= 2 && opts.biff <= 5) return parse_RgceLoc_BIFF2(blob, length, opts);
    var r = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
    var c = parse_ColRelU(blob, 2);
    return { r, c: c[0], cRel: c[1], rRel: c[2] };
  }
  function parse_RgceLoc_BIFF2(blob) {
    var r = parse_ColRelU(blob, 2);
    var c = blob.read_shift(1);
    return { r: r[0], c, cRel: r[1], rRel: r[2] };
  }
  function parse_RgceElfLoc(blob) {
    var r = blob.read_shift(2);
    var c = blob.read_shift(2);
    return { r, c: c & 255, fQuoted: !!(c & 16384), cRel: c >> 15, rRel: c >> 15 };
  }
  function parse_RgceLocRel(blob, length, opts) {
    var biff = opts && opts.biff ? opts.biff : 8;
    if (biff >= 2 && biff <= 5) return parse_RgceLocRel_BIFF2(blob, length, opts);
    var r = blob.read_shift(biff >= 12 ? 4 : 2);
    var cl = blob.read_shift(2);
    var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
    cl &= 16383;
    if (rRel == 1) while (r > 524287) r -= 1048576;
    if (cRel == 1) while (cl > 8191) cl = cl - 16384;
    return { r, c: cl, cRel, rRel };
  }
  function parse_RgceLocRel_BIFF2(blob) {
    var rl = blob.read_shift(2);
    var c = blob.read_shift(1);
    var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
    rl &= 16383;
    if (rRel == 1 && rl >= 8192) rl = rl - 16384;
    if (cRel == 1 && c >= 128) c = c - 256;
    return { r: rl, c, cRel, rRel };
  }
  function parse_PtgArea(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
    return [type, area];
  }
  function parse_PtgArea3d(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var ixti = blob.read_shift(2, "i");
    var w = 8;
    if (opts) switch (opts.biff) {
      case 5:
        blob.l += 12;
        w = 6;
        break;
      case 12:
        w = 12;
        break;
    }
    var area = parse_RgceArea(blob, w, opts);
    return [type, ixti, area];
  }
  function parse_PtgAreaErr(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
    return [type];
  }
  function parse_PtgAreaErr3d(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var ixti = blob.read_shift(2);
    var w = 8;
    if (opts) switch (opts.biff) {
      case 5:
        blob.l += 12;
        w = 6;
        break;
      case 12:
        w = 12;
        break;
    }
    blob.l += w;
    return [type, ixti];
  }
  function parse_PtgAreaN(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var area = parse_RgceAreaRel(blob, length - 1, opts);
    return [type, area];
  }
  function parse_PtgArray(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
    return [type];
  }
  function parse_PtgAttrBaxcel(blob) {
    var bitSemi = blob[blob.l + 1] & 1;
    var bitBaxcel = 1;
    blob.l += 4;
    return [bitSemi, bitBaxcel];
  }
  function parse_PtgAttrChoose(blob, length, opts) {
    blob.l += 2;
    var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    var o = [];
    for (var i = 0; i <= offset; ++i) o.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
    return o;
  }
  function parse_PtgAttrGoto(blob, length, opts) {
    var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
    blob.l += 2;
    return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
  }
  function parse_PtgAttrIf(blob, length, opts) {
    var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
    blob.l += 2;
    return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
  }
  function parse_PtgAttrIfError(blob) {
    var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
    blob.l += 2;
    return [bitIf, blob.read_shift(2)];
  }
  function parse_PtgAttrSemi(blob, length, opts) {
    var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
    blob.l += opts && opts.biff == 2 ? 3 : 4;
    return [bitSemi];
  }
  function parse_PtgAttrSpaceType(blob) {
    var type = blob.read_shift(1), cch = blob.read_shift(1);
    return [type, cch];
  }
  function parse_PtgAttrSpace(blob) {
    blob.read_shift(2);
    return parse_PtgAttrSpaceType(blob, 2);
  }
  function parse_PtgAttrSpaceSemi(blob) {
    blob.read_shift(2);
    return parse_PtgAttrSpaceType(blob, 2);
  }
  function parse_PtgRef(blob, length, opts) {
    var type = (blob[blob.l] & 96) >> 5;
    blob.l += 1;
    var loc = parse_RgceLoc(blob, 0, opts);
    return [type, loc];
  }
  function parse_PtgRefN(blob, length, opts) {
    var type = (blob[blob.l] & 96) >> 5;
    blob.l += 1;
    var loc = parse_RgceLocRel(blob, 0, opts);
    return [type, loc];
  }
  function parse_PtgRef3d(blob, length, opts) {
    var type = (blob[blob.l] & 96) >> 5;
    blob.l += 1;
    var ixti = blob.read_shift(2);
    if (opts && opts.biff == 5) blob.l += 12;
    var loc = parse_RgceLoc(blob, 0, opts);
    return [type, ixti, loc];
  }
  function parse_PtgFunc(blob, length, opts) {
    var type = (blob[blob.l] & 96) >> 5;
    blob.l += 1;
    var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
    return [FtabArgc[iftab], Ftab[iftab], type];
  }
  function parse_PtgFuncVar(blob, length, opts) {
    var type = blob[blob.l++];
    var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [type == 88 ? -1 : 0, blob.read_shift(1)] : parsetab(blob);
    return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
  }
  function parsetab(blob) {
    return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767];
  }
  function parse_PtgAttrSum(blob, length, opts) {
    blob.l += opts && opts.biff == 2 ? 3 : 4;
    return;
  }
  function parse_PtgExp(blob, length, opts) {
    blob.l++;
    if (opts && opts.biff == 12) return [blob.read_shift(4, "i"), 0];
    var row = blob.read_shift(2);
    var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    return [row, col];
  }
  function parse_PtgErr(blob) {
    blob.l++;
    return BErr[blob.read_shift(1)];
  }
  function parse_PtgInt(blob) {
    blob.l++;
    return blob.read_shift(2);
  }
  function parse_PtgBool(blob) {
    blob.l++;
    return blob.read_shift(1) !== 0;
  }
  function parse_PtgNum(blob) {
    blob.l++;
    return parse_Xnum(blob, 8);
  }
  function parse_PtgStr(blob, length, opts) {
    blob.l++;
    return parse_ShortXLUnicodeString(blob, length - 1, opts);
  }
  function parse_SerAr(blob, biff) {
    var val = [blob.read_shift(1)];
    if (biff == 12) switch (val[0]) {
      case 2:
        val[0] = 4;
        break;
      /* SerBool */
      case 4:
        val[0] = 16;
        break;
      /* SerErr */
      case 0:
        val[0] = 1;
        break;
      /* SerNum */
      case 1:
        val[0] = 2;
        break;
    }
    switch (val[0]) {
      case 4:
        val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
        if (biff != 12) blob.l += 7;
        break;
      case 37:
      /* appears to be an alias */
      case 16:
        val[1] = BErr[blob[blob.l]];
        blob.l += biff == 12 ? 4 : 8;
        break;
      case 0:
        blob.l += 8;
        break;
      case 1:
        val[1] = parse_Xnum(blob, 8);
        break;
      case 2:
        val[1] = parse_XLUnicodeString2(blob, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
        break;
      default:
        throw new Error("Bad SerAr: " + val[0]);
    }
    return val;
  }
  function parse_PtgExtraMem(blob, cce, opts) {
    var count = blob.read_shift(opts.biff == 12 ? 4 : 2);
    var out = [];
    for (var i = 0; i != count; ++i) out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob, 8));
    return out;
  }
  function parse_PtgExtraArray(blob, length, opts) {
    var rows = 0, cols = 0;
    if (opts.biff == 12) {
      rows = blob.read_shift(4);
      cols = blob.read_shift(4);
    } else {
      cols = 1 + blob.read_shift(1);
      rows = 1 + blob.read_shift(2);
    }
    if (opts.biff >= 2 && opts.biff < 8) {
      --rows;
      if (--cols == 0) cols = 256;
    }
    for (var i = 0, o = []; i != rows && (o[i] = []); ++i)
      for (var j = 0; j != cols; ++j) o[i][j] = parse_SerAr(blob, opts.biff);
    return o;
  }
  function parse_PtgName(blob, length, opts) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var w = !opts || opts.biff >= 8 ? 4 : 2;
    var nameindex = blob.read_shift(w);
    switch (opts.biff) {
      case 2:
        blob.l += 5;
        break;
      case 3:
      case 4:
        blob.l += 8;
        break;
      case 5:
        blob.l += 12;
        break;
    }
    return [type, 0, nameindex];
  }
  function parse_PtgNameX(blob, length, opts) {
    if (opts.biff == 5) return parse_PtgNameX_BIFF5(blob, length, opts);
    var type = blob.read_shift(1) >>> 5 & 3;
    var ixti = blob.read_shift(2);
    var nameindex = blob.read_shift(4);
    return [type, ixti, nameindex];
  }
  function parse_PtgNameX_BIFF5(blob) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var ixti = blob.read_shift(2, "i");
    blob.l += 8;
    var nameindex = blob.read_shift(2);
    blob.l += 12;
    return [type, ixti, nameindex];
  }
  function parse_PtgMemArea(blob, length, opts) {
    var type = blob.read_shift(1) >>> 5 & 3;
    blob.l += opts && opts.biff == 2 ? 3 : 4;
    var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    return [type, cce];
  }
  function parse_PtgMemFunc(blob, length, opts) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    return [type, cce];
  }
  function parse_PtgRefErr(blob, length, opts) {
    var type = blob.read_shift(1) >>> 5 & 3;
    blob.l += 4;
    if (opts.biff < 8) blob.l--;
    if (opts.biff == 12) blob.l += 2;
    return [type];
  }
  function parse_PtgRefErr3d(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var ixti = blob.read_shift(2);
    var w = 4;
    if (opts) switch (opts.biff) {
      case 5:
        w = 15;
        break;
      case 12:
        w = 6;
        break;
    }
    blob.l += w;
    return [type, ixti];
  }
  var parse_PtgMemErr = parsenoop;
  var parse_PtgMemNoMem = parsenoop;
  var parse_PtgTbl = parsenoop;
  function parse_PtgElfLoc(blob, length, opts) {
    blob.l += 2;
    return [parse_RgceElfLoc(blob, 4, opts)];
  }
  function parse_PtgElfNoop(blob) {
    blob.l += 6;
    return [];
  }
  var parse_PtgElfCol = parse_PtgElfLoc;
  var parse_PtgElfColS = parse_PtgElfNoop;
  var parse_PtgElfColSV = parse_PtgElfNoop;
  var parse_PtgElfColV = parse_PtgElfLoc;
  function parse_PtgElfLel(blob) {
    blob.l += 2;
    return [parseuint16(blob), blob.read_shift(2) & 1];
  }
  var parse_PtgElfRadical = parse_PtgElfLoc;
  var parse_PtgElfRadicalLel = parse_PtgElfLel;
  var parse_PtgElfRadicalS = parse_PtgElfNoop;
  var parse_PtgElfRw = parse_PtgElfLoc;
  var parse_PtgElfRwV = parse_PtgElfLoc;
  var PtgListRT = [
    "Data",
    "All",
    "Headers",
    "??",
    "?Data2",
    "??",
    "?DataHeaders",
    "??",
    "Totals",
    "??",
    "??",
    "??",
    "?DataTotals",
    "??",
    "??",
    "??",
    "?Current"
  ];
  function parse_PtgList(blob) {
    blob.l += 2;
    var ixti = blob.read_shift(2);
    var flags = blob.read_shift(2);
    var idx = blob.read_shift(4);
    var c = blob.read_shift(2);
    var C = blob.read_shift(2);
    var rt = PtgListRT[flags >> 2 & 31];
    return { ixti, coltype: flags & 3, rt, idx, c, C };
  }
  function parse_PtgSxName(blob) {
    blob.l += 2;
    return [blob.read_shift(4)];
  }
  function parse_PtgSheet(blob, length, opts) {
    blob.l += 5;
    blob.l += 2;
    blob.l += opts.biff == 2 ? 1 : 4;
    return ["PTGSHEET"];
  }
  function parse_PtgEndSheet(blob, length, opts) {
    blob.l += opts.biff == 2 ? 4 : 5;
    return ["PTGENDSHEET"];
  }
  function parse_PtgMemAreaN(blob) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var cce = blob.read_shift(2);
    return [type, cce];
  }
  function parse_PtgMemNoMemN(blob) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var cce = blob.read_shift(2);
    return [type, cce];
  }
  function parse_PtgAttrNoop(blob) {
    blob.l += 4;
    return [0, 0];
  }
  var PtgTypes = {
    /*::[*/
    1: { n: "PtgExp", f: parse_PtgExp },
    /*::[*/
    2: { n: "PtgTbl", f: parse_PtgTbl },
    /*::[*/
    3: { n: "PtgAdd", f: parseread1 },
    /*::[*/
    4: { n: "PtgSub", f: parseread1 },
    /*::[*/
    5: { n: "PtgMul", f: parseread1 },
    /*::[*/
    6: { n: "PtgDiv", f: parseread1 },
    /*::[*/
    7: { n: "PtgPower", f: parseread1 },
    /*::[*/
    8: { n: "PtgConcat", f: parseread1 },
    /*::[*/
    9: { n: "PtgLt", f: parseread1 },
    /*::[*/
    10: { n: "PtgLe", f: parseread1 },
    /*::[*/
    11: { n: "PtgEq", f: parseread1 },
    /*::[*/
    12: { n: "PtgGe", f: parseread1 },
    /*::[*/
    13: { n: "PtgGt", f: parseread1 },
    /*::[*/
    14: { n: "PtgNe", f: parseread1 },
    /*::[*/
    15: { n: "PtgIsect", f: parseread1 },
    /*::[*/
    16: { n: "PtgUnion", f: parseread1 },
    /*::[*/
    17: { n: "PtgRange", f: parseread1 },
    /*::[*/
    18: { n: "PtgUplus", f: parseread1 },
    /*::[*/
    19: { n: "PtgUminus", f: parseread1 },
    /*::[*/
    20: { n: "PtgPercent", f: parseread1 },
    /*::[*/
    21: { n: "PtgParen", f: parseread1 },
    /*::[*/
    22: { n: "PtgMissArg", f: parseread1 },
    /*::[*/
    23: { n: "PtgStr", f: parse_PtgStr },
    /*::[*/
    26: { n: "PtgSheet", f: parse_PtgSheet },
    /*::[*/
    27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
    /*::[*/
    28: { n: "PtgErr", f: parse_PtgErr },
    /*::[*/
    29: { n: "PtgBool", f: parse_PtgBool },
    /*::[*/
    30: { n: "PtgInt", f: parse_PtgInt },
    /*::[*/
    31: { n: "PtgNum", f: parse_PtgNum },
    /*::[*/
    32: { n: "PtgArray", f: parse_PtgArray },
    /*::[*/
    33: { n: "PtgFunc", f: parse_PtgFunc },
    /*::[*/
    34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
    /*::[*/
    35: { n: "PtgName", f: parse_PtgName },
    /*::[*/
    36: { n: "PtgRef", f: parse_PtgRef },
    /*::[*/
    37: { n: "PtgArea", f: parse_PtgArea },
    /*::[*/
    38: { n: "PtgMemArea", f: parse_PtgMemArea },
    /*::[*/
    39: { n: "PtgMemErr", f: parse_PtgMemErr },
    /*::[*/
    40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
    /*::[*/
    41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
    /*::[*/
    42: { n: "PtgRefErr", f: parse_PtgRefErr },
    /*::[*/
    43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
    /*::[*/
    44: { n: "PtgRefN", f: parse_PtgRefN },
    /*::[*/
    45: { n: "PtgAreaN", f: parse_PtgAreaN },
    /*::[*/
    46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
    /*::[*/
    47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
    /*::[*/
    57: { n: "PtgNameX", f: parse_PtgNameX },
    /*::[*/
    58: { n: "PtgRef3d", f: parse_PtgRef3d },
    /*::[*/
    59: { n: "PtgArea3d", f: parse_PtgArea3d },
    /*::[*/
    60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
    /*::[*/
    61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
    /*::[*/
    255: {}
  };
  var PtgDupes = {
    /*::[*/
    64: 32,
    /*::[*/
    96: 32,
    /*::[*/
    65: 33,
    /*::[*/
    97: 33,
    /*::[*/
    66: 34,
    /*::[*/
    98: 34,
    /*::[*/
    67: 35,
    /*::[*/
    99: 35,
    /*::[*/
    68: 36,
    /*::[*/
    100: 36,
    /*::[*/
    69: 37,
    /*::[*/
    101: 37,
    /*::[*/
    70: 38,
    /*::[*/
    102: 38,
    /*::[*/
    71: 39,
    /*::[*/
    103: 39,
    /*::[*/
    72: 40,
    /*::[*/
    104: 40,
    /*::[*/
    73: 41,
    /*::[*/
    105: 41,
    /*::[*/
    74: 42,
    /*::[*/
    106: 42,
    /*::[*/
    75: 43,
    /*::[*/
    107: 43,
    /*::[*/
    76: 44,
    /*::[*/
    108: 44,
    /*::[*/
    77: 45,
    /*::[*/
    109: 45,
    /*::[*/
    78: 46,
    /*::[*/
    110: 46,
    /*::[*/
    79: 47,
    /*::[*/
    111: 47,
    /*::[*/
    88: 34,
    /*::[*/
    120: 34,
    /*::[*/
    89: 57,
    /*::[*/
    121: 57,
    /*::[*/
    90: 58,
    /*::[*/
    122: 58,
    /*::[*/
    91: 59,
    /*::[*/
    123: 59,
    /*::[*/
    92: 60,
    /*::[*/
    124: 60,
    /*::[*/
    93: 61,
    /*::[*/
    125: 61
  };
  var Ptg18 = {
    /*::[*/
    1: { n: "PtgElfLel", f: parse_PtgElfLel },
    /*::[*/
    2: { n: "PtgElfRw", f: parse_PtgElfRw },
    /*::[*/
    3: { n: "PtgElfCol", f: parse_PtgElfCol },
    /*::[*/
    6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
    /*::[*/
    7: { n: "PtgElfColV", f: parse_PtgElfColV },
    /*::[*/
    10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
    /*::[*/
    11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
    /*::[*/
    13: { n: "PtgElfColS", f: parse_PtgElfColS },
    /*::[*/
    15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
    /*::[*/
    16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
    /*::[*/
    25: { n: "PtgList", f: parse_PtgList },
    /*::[*/
    29: { n: "PtgSxName", f: parse_PtgSxName },
    /*::[*/
    255: {}
  };
  var Ptg19 = {
    /*::[*/
    0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
    /*::[*/
    1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
    /*::[*/
    2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
    /*::[*/
    4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
    /*::[*/
    8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
    /*::[*/
    16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
    /*::[*/
    32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
    /*::[*/
    33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
    /*::[*/
    64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
    /*::[*/
    65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
    /*::[*/
    128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
    /*::[*/
    255: {}
  };
  function parse_RgbExtra(blob, length, rgce, opts) {
    if (opts.biff < 8) return parsenoop(blob, length);
    var target = blob.l + length;
    var o = [];
    for (var i = 0; i !== rgce.length; ++i) {
      switch (rgce[i][0]) {
        case "PtgArray":
          rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);
          o.push(rgce[i][1]);
          break;
        case "PtgMemArea":
          rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);
          o.push(rgce[i][2]);
          break;
        case "PtgExp":
          if (opts && opts.biff == 12) {
            rgce[i][1][1] = blob.read_shift(4);
            o.push(rgce[i][1]);
          }
          break;
        case "PtgList":
        /* TODO: PtgList -> PtgExtraList */
        case "PtgElfRadicalS":
        /* TODO: PtgElfRadicalS -> PtgExtraElf */
        case "PtgElfColS":
        /* TODO: PtgElfColS -> PtgExtraElf */
        case "PtgElfColSV":
          throw "Unsupported " + rgce[i][0];
        default:
          break;
      }
    }
    length = target - blob.l;
    if (length !== 0) o.push(parsenoop(blob, length));
    return o;
  }
  function parse_Rgce(blob, length, opts) {
    var target = blob.l + length;
    var R, id, ptgs = [];
    while (target != blob.l) {
      length = target - blob.l;
      id = blob[blob.l];
      R = PtgTypes[id] || PtgTypes[PtgDupes[id]];
      if (id === 24 || id === 25) R = (id === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
      if (!R || !R.f) {
        parsenoop(blob, length);
      } else {
        ptgs.push([R.n, R.f(blob, length, opts)]);
      }
    }
    return ptgs;
  }
  function stringify_array(f) {
    var o = [];
    for (var i = 0; i < f.length; ++i) {
      var x = f[i], r = [];
      for (var j = 0; j < x.length; ++j) {
        var y = x[j];
        if (y) switch (y[0]) {
          // TODO: handle embedded quotes
          case 2:
            r.push('"' + y[1].replace(/"/g, '""') + '"');
            break;
          default:
            r.push(y[1]);
        }
        else r.push("");
      }
      o.push(r.join(","));
    }
    return o.join(";");
  }
  var PtgBinOp = {
    PtgAdd: "+",
    PtgConcat: "&",
    PtgDiv: "/",
    PtgEq: "=",
    PtgGe: ">=",
    PtgGt: ">",
    PtgLe: "<=",
    PtgLt: "<",
    PtgMul: "*",
    PtgNe: "<>",
    PtgPower: "^",
    PtgSub: "-"
  };
  function formula_quote_sheet_name(sname, opts) {
    if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2)) throw new Error("empty sheet name");
    if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname)) return "'" + sname + "'";
    return sname;
  }
  function get_ixti_raw(supbooks, ixti, opts) {
    if (!supbooks) return "SH33TJSERR0";
    if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti])) return supbooks.SheetNames[ixti];
    if (!supbooks.XTI) return "SH33TJSERR6";
    var XTI = supbooks.XTI[ixti];
    if (opts.biff < 8) {
      if (ixti > 1e4) ixti -= 65536;
      if (ixti < 0) ixti = -ixti;
      return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
    }
    if (!XTI) return "SH33TJSERR1";
    var o = "";
    if (opts.biff > 8) switch (supbooks[XTI[0]][0]) {
      case 357:
        o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
        return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
      case 358:
        if (opts.SID != null) return supbooks.SheetNames[opts.SID];
        return "SH33TJSSAME" + supbooks[XTI[0]][0];
      case 355:
      /* 'BrtSupBookSrc' */
      /* falls through */
      default:
        return "SH33TJSSRC" + supbooks[XTI[0]][0];
    }
    switch (supbooks[XTI[0]][0][0]) {
      case 1025:
        o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
        return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
      case 14849:
        return supbooks[XTI[0]].slice(1).map(function(name) {
          return name.Name;
        }).join(";;");
      //return "SH33TJSERR8";
      default:
        if (!supbooks[XTI[0]][0][3]) return "SH33TJSERR2";
        o = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
        return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];
    }
  }
  function get_ixti(supbooks, ixti, opts) {
    var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
    return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
  }
  function stringify_formula(formula, range, cell, supbooks, opts) {
    var biff = opts && opts.biff || 8;
    var _range = (
      /*range != null ? range :*/
      { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }
    );
    var stack = [], e1, e2, c, ixti = 0, nameidx = 0, r, sname = "";
    if (!formula[0] || !formula[0][0]) return "";
    var last_sp = -1, sp = "";
    for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
      var f = formula[0][ff];
      switch (f[0]) {
        case "PtgUminus":
          stack.push("-" + stack.pop());
          break;
        case "PtgUplus":
          stack.push("+" + stack.pop());
          break;
        case "PtgPercent":
          stack.push(stack.pop() + "%");
          break;
        case "PtgAdd":
        /* [MS-XLS] 2.5.198.26 */
        case "PtgConcat":
        /* [MS-XLS] 2.5.198.43 */
        case "PtgDiv":
        /* [MS-XLS] 2.5.198.45 */
        case "PtgEq":
        /* [MS-XLS] 2.5.198.56 */
        case "PtgGe":
        /* [MS-XLS] 2.5.198.64 */
        case "PtgGt":
        /* [MS-XLS] 2.5.198.65 */
        case "PtgLe":
        /* [MS-XLS] 2.5.198.68 */
        case "PtgLt":
        /* [MS-XLS] 2.5.198.69 */
        case "PtgMul":
        /* [MS-XLS] 2.5.198.75 */
        case "PtgNe":
        /* [MS-XLS] 2.5.198.78 */
        case "PtgPower":
        /* [MS-XLS] 2.5.198.82 */
        case "PtgSub":
          e1 = stack.pop();
          e2 = stack.pop();
          if (last_sp >= 0) {
            switch (formula[0][last_sp][1][0]) {
              case 0:
                sp = fill(" ", formula[0][last_sp][1][1]);
                break;
              case 1:
                sp = fill("\r", formula[0][last_sp][1][1]);
                break;
              default:
                sp = "";
                if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
            }
            e2 = e2 + sp;
            last_sp = -1;
          }
          stack.push(e2 + PtgBinOp[f[0]] + e1);
          break;
        case "PtgIsect":
          e1 = stack.pop();
          e2 = stack.pop();
          stack.push(e2 + " " + e1);
          break;
        case "PtgUnion":
          e1 = stack.pop();
          e2 = stack.pop();
          stack.push(e2 + "," + e1);
          break;
        case "PtgRange":
          e1 = stack.pop();
          e2 = stack.pop();
          stack.push(e2 + ":" + e1);
          break;
        case "PtgAttrChoose":
          break;
        case "PtgAttrGoto":
          break;
        case "PtgAttrIf":
          break;
        case "PtgAttrIfError":
          break;
        case "PtgRef":
          c = shift_cell_xls(f[1][1], _range, opts);
          stack.push(encode_cell_xls(c, biff));
          break;
        case "PtgRefN":
          c = cell ? shift_cell_xls(f[1][1], cell, opts) : f[1][1];
          stack.push(encode_cell_xls(c, biff));
          break;
        case "PtgRef3d":
          ixti = /*::Number(*/
          f[1][1];
          c = shift_cell_xls(f[1][2], _range, opts);
          sname = get_ixti(supbooks, ixti, opts);
          var w = sname;
          stack.push(sname + "!" + encode_cell_xls(c, biff));
          break;
        case "PtgFunc":
        /* [MS-XLS] 2.5.198.62 */
        case "PtgFuncVar":
          var argc = f[1][0], func = f[1][1];
          if (!argc) argc = 0;
          argc &= 127;
          var args = argc == 0 ? [] : stack.slice(-argc);
          stack.length -= argc;
          if (func === "User") func = args.shift();
          stack.push(func + "(" + args.join(",") + ")");
          break;
        case "PtgBool":
          stack.push(f[1] ? "TRUE" : "FALSE");
          break;
        case "PtgInt":
          stack.push(
            /*::String(*/
            f[1]
            /*::)*/
          );
          break;
        case "PtgNum":
          stack.push(String(f[1]));
          break;
        case "PtgStr":
          stack.push('"' + f[1].replace(/"/g, '""') + '"');
          break;
        case "PtgErr":
          stack.push(
            /*::String(*/
            f[1]
            /*::)*/
          );
          break;
        case "PtgAreaN":
          r = shift_range_xls(f[1][1], cell ? { s: cell } : _range, opts);
          stack.push(encode_range_xls(r, opts));
          break;
        case "PtgArea":
          r = shift_range_xls(f[1][1], _range, opts);
          stack.push(encode_range_xls(r, opts));
          break;
        case "PtgArea3d":
          ixti = /*::Number(*/
          f[1][1];
          r = f[1][2];
          sname = get_ixti(supbooks, ixti, opts);
          stack.push(sname + "!" + encode_range_xls(r, opts));
          break;
        case "PtgAttrSum":
          stack.push("SUM(" + stack.pop() + ")");
          break;
        case "PtgAttrBaxcel":
        /* [MS-XLS] 2.5.198.33 */
        case "PtgAttrSemi":
          break;
        case "PtgName":
          nameidx = f[1][2];
          var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
          var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
          if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn) name = name.slice(6);
          stack.push(name);
          break;
        case "PtgNameX":
          var bookidx = f[1][1];
          nameidx = f[1][2];
          var externbook;
          if (opts.biff <= 5) {
            if (bookidx < 0) bookidx = -bookidx;
            if (supbooks[bookidx]) externbook = supbooks[bookidx][nameidx];
          } else {
            var o = "";
            if (((supbooks[bookidx] || [])[0] || [])[0] == 14849) {
            } else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
              if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
                o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
              }
            } else o = supbooks.SheetNames[nameidx - 1] + "!";
            if (supbooks[bookidx] && supbooks[bookidx][nameidx]) o += supbooks[bookidx][nameidx].Name;
            else if (supbooks[0] && supbooks[0][nameidx]) o += supbooks[0][nameidx].Name;
            else {
              var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
              if (ixtidata[nameidx - 1]) o = ixtidata[nameidx - 1];
              else o += "SH33TJSERRX";
            }
            stack.push(o);
            break;
          }
          if (!externbook) externbook = { Name: "SH33TJSERRY" };
          stack.push(externbook.Name);
          break;
        case "PtgParen":
          var lp = "(", rp = ")";
          if (last_sp >= 0) {
            sp = "";
            switch (formula[0][last_sp][1][0]) {
              // $FlowIgnore
              case 2:
                lp = fill(" ", formula[0][last_sp][1][1]) + lp;
                break;
              // $FlowIgnore
              case 3:
                lp = fill("\r", formula[0][last_sp][1][1]) + lp;
                break;
              // $FlowIgnore
              case 4:
                rp = fill(" ", formula[0][last_sp][1][1]) + rp;
                break;
              // $FlowIgnore
              case 5:
                rp = fill("\r", formula[0][last_sp][1][1]) + rp;
                break;
              default:
                if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
            }
            last_sp = -1;
          }
          stack.push(lp + stack.pop() + rp);
          break;
        case "PtgRefErr":
          stack.push("#REF!");
          break;
        case "PtgRefErr3d":
          stack.push("#REF!");
          break;
        case "PtgExp":
          c = { c: f[1][1], r: f[1][0] };
          var q = { c: cell.c, r: cell.r };
          if (supbooks.sharedf[encode_cell(c)]) {
            var parsedf = supbooks.sharedf[encode_cell(c)];
            stack.push(stringify_formula(parsedf, _range, q, supbooks, opts));
          } else {
            var fnd = false;
            for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
              e2 = supbooks.arrayf[e1];
              if (c.c < e2[0].s.c || c.c > e2[0].e.c) continue;
              if (c.r < e2[0].s.r || c.r > e2[0].e.r) continue;
              stack.push(stringify_formula(e2[1], _range, q, supbooks, opts));
              fnd = true;
              break;
            }
            if (!fnd) stack.push(
              /*::String(*/
              f[1]
              /*::)*/
            );
          }
          break;
        case "PtgArray":
          stack.push("{" + stringify_array(
            /*::(*/
            f[1]
            /*:: :any)*/
          ) + "}");
          break;
        case "PtgMemArea":
          break;
        case "PtgAttrSpace":
        /* [MS-XLS] 2.5.198.38 */
        case "PtgAttrSpaceSemi":
          last_sp = ff;
          break;
        case "PtgTbl":
          break;
        case "PtgMemErr":
          break;
        case "PtgMissArg":
          stack.push("");
          break;
        case "PtgAreaErr":
          stack.push("#REF!");
          break;
        case "PtgAreaErr3d":
          stack.push("#REF!");
          break;
        case "PtgList":
          stack.push("Table" + f[1].idx + "[#" + f[1].rt + "]");
          break;
        case "PtgMemAreaN":
        case "PtgMemNoMemN":
        case "PtgAttrNoop":
        case "PtgSheet":
        case "PtgEndSheet":
          break;
        case "PtgMemFunc":
          break;
        case "PtgMemNoMem":
          break;
        case "PtgElfCol":
        /* [MS-XLS] 2.5.198.46 */
        case "PtgElfColS":
        /* [MS-XLS] 2.5.198.47 */
        case "PtgElfColSV":
        /* [MS-XLS] 2.5.198.48 */
        case "PtgElfColV":
        /* [MS-XLS] 2.5.198.49 */
        case "PtgElfLel":
        /* [MS-XLS] 2.5.198.50 */
        case "PtgElfRadical":
        /* [MS-XLS] 2.5.198.51 */
        case "PtgElfRadicalLel":
        /* [MS-XLS] 2.5.198.52 */
        case "PtgElfRadicalS":
        /* [MS-XLS] 2.5.198.53 */
        case "PtgElfRw":
        /* [MS-XLS] 2.5.198.54 */
        case "PtgElfRwV":
          throw new Error("Unsupported ELFs");
        case "PtgSxName":
          throw new Error("Unrecognized Formula Token: " + String(f));
        default:
          throw new Error("Unrecognized Formula Token: " + String(f));
      }
      var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
      if (opts.biff != 3) {
        if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
          f = formula[0][last_sp];
          var _left = true;
          switch (f[1][0]) {
            /* note: some bad XLSB files omit the PtgParen */
            case 4:
              _left = false;
            /* falls through */
            case 0:
              sp = fill(" ", f[1][1]);
              break;
            case 5:
              _left = false;
            /* falls through */
            case 1:
              sp = fill("\r", f[1][1]);
              break;
            default:
              sp = "";
              if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);
          }
          stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));
          last_sp = -1;
        }
      }
    }
    if (stack.length > 1 && opts.WTF) throw new Error("bad formula stack");
    return stack[0];
  }
  function write_FormulaValue(value) {
    if (value == null) {
      var o = new_buf(8);
      o.write_shift(1, 3);
      o.write_shift(1, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 65535);
      return o;
    } else if (typeof value == "number") return write_Xnum(value);
    return write_Xnum(0);
  }
  function write_Formula(cell, R, C, opts, os) {
    var o1 = write_XLSCell(R, C, os);
    var o2 = write_FormulaValue(cell.v);
    var o3 = new_buf(6);
    var flags = 1 | 32;
    o3.write_shift(2, flags);
    o3.write_shift(4, 0);
    var bf = new_buf(cell.bf.length);
    for (var i = 0; i < cell.bf.length; ++i) bf[i] = cell.bf[i];
    var out = bconcat([o1, o2, o3, bf]);
    return out;
  }
  function parse_XLSBParsedFormula(data, length, opts) {
    var cce = data.read_shift(4);
    var rgce = parse_Rgce(data, cce, opts);
    var cb = data.read_shift(4);
    var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
    return [rgce, rgcb];
  }
  var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
  var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
  var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
  var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
  var Cetab = {
    0: "BEEP",
    1: "OPEN",
    2: "OPEN.LINKS",
    3: "CLOSE.ALL",
    4: "SAVE",
    5: "SAVE.AS",
    6: "FILE.DELETE",
    7: "PAGE.SETUP",
    8: "PRINT",
    9: "PRINTER.SETUP",
    10: "QUIT",
    11: "NEW.WINDOW",
    12: "ARRANGE.ALL",
    13: "WINDOW.SIZE",
    14: "WINDOW.MOVE",
    15: "FULL",
    16: "CLOSE",
    17: "RUN",
    22: "SET.PRINT.AREA",
    23: "SET.PRINT.TITLES",
    24: "SET.PAGE.BREAK",
    25: "REMOVE.PAGE.BREAK",
    26: "FONT",
    27: "DISPLAY",
    28: "PROTECT.DOCUMENT",
    29: "PRECISION",
    30: "A1.R1C1",
    31: "CALCULATE.NOW",
    32: "CALCULATION",
    34: "DATA.FIND",
    35: "EXTRACT",
    36: "DATA.DELETE",
    37: "SET.DATABASE",
    38: "SET.CRITERIA",
    39: "SORT",
    40: "DATA.SERIES",
    41: "TABLE",
    42: "FORMAT.NUMBER",
    43: "ALIGNMENT",
    44: "STYLE",
    45: "BORDER",
    46: "CELL.PROTECTION",
    47: "COLUMN.WIDTH",
    48: "UNDO",
    49: "CUT",
    50: "COPY",
    51: "PASTE",
    52: "CLEAR",
    53: "PASTE.SPECIAL",
    54: "EDIT.DELETE",
    55: "INSERT",
    56: "FILL.RIGHT",
    57: "FILL.DOWN",
    61: "DEFINE.NAME",
    62: "CREATE.NAMES",
    63: "FORMULA.GOTO",
    64: "FORMULA.FIND",
    65: "SELECT.LAST.CELL",
    66: "SHOW.ACTIVE.CELL",
    67: "GALLERY.AREA",
    68: "GALLERY.BAR",
    69: "GALLERY.COLUMN",
    70: "GALLERY.LINE",
    71: "GALLERY.PIE",
    72: "GALLERY.SCATTER",
    73: "COMBINATION",
    74: "PREFERRED",
    75: "ADD.OVERLAY",
    76: "GRIDLINES",
    77: "SET.PREFERRED",
    78: "AXES",
    79: "LEGEND",
    80: "ATTACH.TEXT",
    81: "ADD.ARROW",
    82: "SELECT.CHART",
    83: "SELECT.PLOT.AREA",
    84: "PATTERNS",
    85: "MAIN.CHART",
    86: "OVERLAY",
    87: "SCALE",
    88: "FORMAT.LEGEND",
    89: "FORMAT.TEXT",
    90: "EDIT.REPEAT",
    91: "PARSE",
    92: "JUSTIFY",
    93: "HIDE",
    94: "UNHIDE",
    95: "WORKSPACE",
    96: "FORMULA",
    97: "FORMULA.FILL",
    98: "FORMULA.ARRAY",
    99: "DATA.FIND.NEXT",
    100: "DATA.FIND.PREV",
    101: "FORMULA.FIND.NEXT",
    102: "FORMULA.FIND.PREV",
    103: "ACTIVATE",
    104: "ACTIVATE.NEXT",
    105: "ACTIVATE.PREV",
    106: "UNLOCKED.NEXT",
    107: "UNLOCKED.PREV",
    108: "COPY.PICTURE",
    109: "SELECT",
    110: "DELETE.NAME",
    111: "DELETE.FORMAT",
    112: "VLINE",
    113: "HLINE",
    114: "VPAGE",
    115: "HPAGE",
    116: "VSCROLL",
    117: "HSCROLL",
    118: "ALERT",
    119: "NEW",
    120: "CANCEL.COPY",
    121: "SHOW.CLIPBOARD",
    122: "MESSAGE",
    124: "PASTE.LINK",
    125: "APP.ACTIVATE",
    126: "DELETE.ARROW",
    127: "ROW.HEIGHT",
    128: "FORMAT.MOVE",
    129: "FORMAT.SIZE",
    130: "FORMULA.REPLACE",
    131: "SEND.KEYS",
    132: "SELECT.SPECIAL",
    133: "APPLY.NAMES",
    134: "REPLACE.FONT",
    135: "FREEZE.PANES",
    136: "SHOW.INFO",
    137: "SPLIT",
    138: "ON.WINDOW",
    139: "ON.DATA",
    140: "DISABLE.INPUT",
    142: "OUTLINE",
    143: "LIST.NAMES",
    144: "FILE.CLOSE",
    145: "SAVE.WORKBOOK",
    146: "DATA.FORM",
    147: "COPY.CHART",
    148: "ON.TIME",
    149: "WAIT",
    150: "FORMAT.FONT",
    151: "FILL.UP",
    152: "FILL.LEFT",
    153: "DELETE.OVERLAY",
    155: "SHORT.MENUS",
    159: "SET.UPDATE.STATUS",
    161: "COLOR.PALETTE",
    162: "DELETE.STYLE",
    163: "WINDOW.RESTORE",
    164: "WINDOW.MAXIMIZE",
    166: "CHANGE.LINK",
    167: "CALCULATE.DOCUMENT",
    168: "ON.KEY",
    169: "APP.RESTORE",
    170: "APP.MOVE",
    171: "APP.SIZE",
    172: "APP.MINIMIZE",
    173: "APP.MAXIMIZE",
    174: "BRING.TO.FRONT",
    175: "SEND.TO.BACK",
    185: "MAIN.CHART.TYPE",
    186: "OVERLAY.CHART.TYPE",
    187: "SELECT.END",
    188: "OPEN.MAIL",
    189: "SEND.MAIL",
    190: "STANDARD.FONT",
    191: "CONSOLIDATE",
    192: "SORT.SPECIAL",
    193: "GALLERY.3D.AREA",
    194: "GALLERY.3D.COLUMN",
    195: "GALLERY.3D.LINE",
    196: "GALLERY.3D.PIE",
    197: "VIEW.3D",
    198: "GOAL.SEEK",
    199: "WORKGROUP",
    200: "FILL.GROUP",
    201: "UPDATE.LINK",
    202: "PROMOTE",
    203: "DEMOTE",
    204: "SHOW.DETAIL",
    206: "UNGROUP",
    207: "OBJECT.PROPERTIES",
    208: "SAVE.NEW.OBJECT",
    209: "SHARE",
    210: "SHARE.NAME",
    211: "DUPLICATE",
    212: "APPLY.STYLE",
    213: "ASSIGN.TO.OBJECT",
    214: "OBJECT.PROTECTION",
    215: "HIDE.OBJECT",
    216: "SET.EXTRACT",
    217: "CREATE.PUBLISHER",
    218: "SUBSCRIBE.TO",
    219: "ATTRIBUTES",
    220: "SHOW.TOOLBAR",
    222: "PRINT.PREVIEW",
    223: "EDIT.COLOR",
    224: "SHOW.LEVELS",
    225: "FORMAT.MAIN",
    226: "FORMAT.OVERLAY",
    227: "ON.RECALC",
    228: "EDIT.SERIES",
    229: "DEFINE.STYLE",
    240: "LINE.PRINT",
    243: "ENTER.DATA",
    249: "GALLERY.RADAR",
    250: "MERGE.STYLES",
    251: "EDITION.OPTIONS",
    252: "PASTE.PICTURE",
    253: "PASTE.PICTURE.LINK",
    254: "SPELLING",
    256: "ZOOM",
    259: "INSERT.OBJECT",
    260: "WINDOW.MINIMIZE",
    265: "SOUND.NOTE",
    266: "SOUND.PLAY",
    267: "FORMAT.SHAPE",
    268: "EXTEND.POLYGON",
    269: "FORMAT.AUTO",
    272: "GALLERY.3D.BAR",
    273: "GALLERY.3D.SURFACE",
    274: "FILL.AUTO",
    276: "CUSTOMIZE.TOOLBAR",
    277: "ADD.TOOL",
    278: "EDIT.OBJECT",
    279: "ON.DOUBLECLICK",
    280: "ON.ENTRY",
    281: "WORKBOOK.ADD",
    282: "WORKBOOK.MOVE",
    283: "WORKBOOK.COPY",
    284: "WORKBOOK.OPTIONS",
    285: "SAVE.WORKSPACE",
    288: "CHART.WIZARD",
    289: "DELETE.TOOL",
    290: "MOVE.TOOL",
    291: "WORKBOOK.SELECT",
    292: "WORKBOOK.ACTIVATE",
    293: "ASSIGN.TO.TOOL",
    295: "COPY.TOOL",
    296: "RESET.TOOL",
    297: "CONSTRAIN.NUMERIC",
    298: "PASTE.TOOL",
    302: "WORKBOOK.NEW",
    305: "SCENARIO.CELLS",
    306: "SCENARIO.DELETE",
    307: "SCENARIO.ADD",
    308: "SCENARIO.EDIT",
    309: "SCENARIO.SHOW",
    310: "SCENARIO.SHOW.NEXT",
    311: "SCENARIO.SUMMARY",
    312: "PIVOT.TABLE.WIZARD",
    313: "PIVOT.FIELD.PROPERTIES",
    314: "PIVOT.FIELD",
    315: "PIVOT.ITEM",
    316: "PIVOT.ADD.FIELDS",
    318: "OPTIONS.CALCULATION",
    319: "OPTIONS.EDIT",
    320: "OPTIONS.VIEW",
    321: "ADDIN.MANAGER",
    322: "MENU.EDITOR",
    323: "ATTACH.TOOLBARS",
    324: "VBAActivate",
    325: "OPTIONS.CHART",
    328: "VBA.INSERT.FILE",
    330: "VBA.PROCEDURE.DEFINITION",
    336: "ROUTING.SLIP",
    338: "ROUTE.DOCUMENT",
    339: "MAIL.LOGON",
    342: "INSERT.PICTURE",
    343: "EDIT.TOOL",
    344: "GALLERY.DOUGHNUT",
    350: "CHART.TREND",
    352: "PIVOT.ITEM.PROPERTIES",
    354: "WORKBOOK.INSERT",
    355: "OPTIONS.TRANSITION",
    356: "OPTIONS.GENERAL",
    370: "FILTER.ADVANCED",
    373: "MAIL.ADD.MAILER",
    374: "MAIL.DELETE.MAILER",
    375: "MAIL.REPLY",
    376: "MAIL.REPLY.ALL",
    377: "MAIL.FORWARD",
    378: "MAIL.NEXT.LETTER",
    379: "DATA.LABEL",
    380: "INSERT.TITLE",
    381: "FONT.PROPERTIES",
    382: "MACRO.OPTIONS",
    383: "WORKBOOK.HIDE",
    384: "WORKBOOK.UNHIDE",
    385: "WORKBOOK.DELETE",
    386: "WORKBOOK.NAME",
    388: "GALLERY.CUSTOM",
    390: "ADD.CHART.AUTOFORMAT",
    391: "DELETE.CHART.AUTOFORMAT",
    392: "CHART.ADD.DATA",
    393: "AUTO.OUTLINE",
    394: "TAB.ORDER",
    395: "SHOW.DIALOG",
    396: "SELECT.ALL",
    397: "UNGROUP.SHEETS",
    398: "SUBTOTAL.CREATE",
    399: "SUBTOTAL.REMOVE",
    400: "RENAME.OBJECT",
    412: "WORKBOOK.SCROLL",
    413: "WORKBOOK.NEXT",
    414: "WORKBOOK.PREV",
    415: "WORKBOOK.TAB.SPLIT",
    416: "FULL.SCREEN",
    417: "WORKBOOK.PROTECT",
    420: "SCROLLBAR.PROPERTIES",
    421: "PIVOT.SHOW.PAGES",
    422: "TEXT.TO.COLUMNS",
    423: "FORMAT.CHARTTYPE",
    424: "LINK.FORMAT",
    425: "TRACER.DISPLAY",
    430: "TRACER.NAVIGATE",
    431: "TRACER.CLEAR",
    432: "TRACER.ERROR",
    433: "PIVOT.FIELD.GROUP",
    434: "PIVOT.FIELD.UNGROUP",
    435: "CHECKBOX.PROPERTIES",
    436: "LABEL.PROPERTIES",
    437: "LISTBOX.PROPERTIES",
    438: "EDITBOX.PROPERTIES",
    439: "PIVOT.REFRESH",
    440: "LINK.COMBO",
    441: "OPEN.TEXT",
    442: "HIDE.DIALOG",
    443: "SET.DIALOG.FOCUS",
    444: "ENABLE.OBJECT",
    445: "PUSHBUTTON.PROPERTIES",
    446: "SET.DIALOG.DEFAULT",
    447: "FILTER",
    448: "FILTER.SHOW.ALL",
    449: "CLEAR.OUTLINE",
    450: "FUNCTION.WIZARD",
    451: "ADD.LIST.ITEM",
    452: "SET.LIST.ITEM",
    453: "REMOVE.LIST.ITEM",
    454: "SELECT.LIST.ITEM",
    455: "SET.CONTROL.VALUE",
    456: "SAVE.COPY.AS",
    458: "OPTIONS.LISTS.ADD",
    459: "OPTIONS.LISTS.DELETE",
    460: "SERIES.AXES",
    461: "SERIES.X",
    462: "SERIES.Y",
    463: "ERRORBAR.X",
    464: "ERRORBAR.Y",
    465: "FORMAT.CHART",
    466: "SERIES.ORDER",
    467: "MAIL.LOGOFF",
    468: "CLEAR.ROUTING.SLIP",
    469: "APP.ACTIVATE.MICROSOFT",
    470: "MAIL.EDIT.MAILER",
    471: "ON.SHEET",
    472: "STANDARD.WIDTH",
    473: "SCENARIO.MERGE",
    474: "SUMMARY.INFO",
    475: "FIND.FILE",
    476: "ACTIVE.CELL.FONT",
    477: "ENABLE.TIPWIZARD",
    478: "VBA.MAKE.ADDIN",
    480: "INSERTDATATABLE",
    481: "WORKGROUP.OPTIONS",
    482: "MAIL.SEND.MAILER",
    485: "AUTOCORRECT",
    489: "POST.DOCUMENT",
    491: "PICKLIST",
    493: "VIEW.SHOW",
    494: "VIEW.DEFINE",
    495: "VIEW.DELETE",
    509: "SHEET.BACKGROUND",
    510: "INSERT.MAP.OBJECT",
    511: "OPTIONS.MENONO",
    517: "MSOCHECKS",
    518: "NORMAL",
    519: "LAYOUT",
    520: "RM.PRINT.AREA",
    521: "CLEAR.PRINT.AREA",
    522: "ADD.PRINT.AREA",
    523: "MOVE.BRK",
    545: "HIDECURR.NOTE",
    546: "HIDEALL.NOTES",
    547: "DELETE.NOTE",
    548: "TRAVERSE.NOTES",
    549: "ACTIVATE.NOTES",
    620: "PROTECT.REVISIONS",
    621: "UNPROTECT.REVISIONS",
    647: "OPTIONS.ME",
    653: "WEB.PUBLISH",
    667: "NEWWEBQUERY",
    673: "PIVOT.TABLE.CHART",
    753: "OPTIONS.SAVE",
    755: "OPTIONS.SPELL",
    808: "HIDEALL.INKANNOTS"
  };
  var Ftab = {
    0: "COUNT",
    1: "IF",
    2: "ISNA",
    3: "ISERROR",
    4: "SUM",
    5: "AVERAGE",
    6: "MIN",
    7: "MAX",
    8: "ROW",
    9: "COLUMN",
    10: "NA",
    11: "NPV",
    12: "STDEV",
    13: "DOLLAR",
    14: "FIXED",
    15: "SIN",
    16: "COS",
    17: "TAN",
    18: "ATAN",
    19: "PI",
    20: "SQRT",
    21: "EXP",
    22: "LN",
    23: "LOG10",
    24: "ABS",
    25: "INT",
    26: "SIGN",
    27: "ROUND",
    28: "LOOKUP",
    29: "INDEX",
    30: "REPT",
    31: "MID",
    32: "LEN",
    33: "VALUE",
    34: "TRUE",
    35: "FALSE",
    36: "AND",
    37: "OR",
    38: "NOT",
    39: "MOD",
    40: "DCOUNT",
    41: "DSUM",
    42: "DAVERAGE",
    43: "DMIN",
    44: "DMAX",
    45: "DSTDEV",
    46: "VAR",
    47: "DVAR",
    48: "TEXT",
    49: "LINEST",
    50: "TREND",
    51: "LOGEST",
    52: "GROWTH",
    53: "GOTO",
    54: "HALT",
    55: "RETURN",
    56: "PV",
    57: "FV",
    58: "NPER",
    59: "PMT",
    60: "RATE",
    61: "MIRR",
    62: "IRR",
    63: "RAND",
    64: "MATCH",
    65: "DATE",
    66: "TIME",
    67: "DAY",
    68: "MONTH",
    69: "YEAR",
    70: "WEEKDAY",
    71: "HOUR",
    72: "MINUTE",
    73: "SECOND",
    74: "NOW",
    75: "AREAS",
    76: "ROWS",
    77: "COLUMNS",
    78: "OFFSET",
    79: "ABSREF",
    80: "RELREF",
    81: "ARGUMENT",
    82: "SEARCH",
    83: "TRANSPOSE",
    84: "ERROR",
    85: "STEP",
    86: "TYPE",
    87: "ECHO",
    88: "SET.NAME",
    89: "CALLER",
    90: "DEREF",
    91: "WINDOWS",
    92: "SERIES",
    93: "DOCUMENTS",
    94: "ACTIVE.CELL",
    95: "SELECTION",
    96: "RESULT",
    97: "ATAN2",
    98: "ASIN",
    99: "ACOS",
    100: "CHOOSE",
    101: "HLOOKUP",
    102: "VLOOKUP",
    103: "LINKS",
    104: "INPUT",
    105: "ISREF",
    106: "GET.FORMULA",
    107: "GET.NAME",
    108: "SET.VALUE",
    109: "LOG",
    110: "EXEC",
    111: "CHAR",
    112: "LOWER",
    113: "UPPER",
    114: "PROPER",
    115: "LEFT",
    116: "RIGHT",
    117: "EXACT",
    118: "TRIM",
    119: "REPLACE",
    120: "SUBSTITUTE",
    121: "CODE",
    122: "NAMES",
    123: "DIRECTORY",
    124: "FIND",
    125: "CELL",
    126: "ISERR",
    127: "ISTEXT",
    128: "ISNUMBER",
    129: "ISBLANK",
    130: "T",
    131: "N",
    132: "FOPEN",
    133: "FCLOSE",
    134: "FSIZE",
    135: "FREADLN",
    136: "FREAD",
    137: "FWRITELN",
    138: "FWRITE",
    139: "FPOS",
    140: "DATEVALUE",
    141: "TIMEVALUE",
    142: "SLN",
    143: "SYD",
    144: "DDB",
    145: "GET.DEF",
    146: "REFTEXT",
    147: "TEXTREF",
    148: "INDIRECT",
    149: "REGISTER",
    150: "CALL",
    151: "ADD.BAR",
    152: "ADD.MENU",
    153: "ADD.COMMAND",
    154: "ENABLE.COMMAND",
    155: "CHECK.COMMAND",
    156: "RENAME.COMMAND",
    157: "SHOW.BAR",
    158: "DELETE.MENU",
    159: "DELETE.COMMAND",
    160: "GET.CHART.ITEM",
    161: "DIALOG.BOX",
    162: "CLEAN",
    163: "MDETERM",
    164: "MINVERSE",
    165: "MMULT",
    166: "FILES",
    167: "IPMT",
    168: "PPMT",
    169: "COUNTA",
    170: "CANCEL.KEY",
    171: "FOR",
    172: "WHILE",
    173: "BREAK",
    174: "NEXT",
    175: "INITIATE",
    176: "REQUEST",
    177: "POKE",
    178: "EXECUTE",
    179: "TERMINATE",
    180: "RESTART",
    181: "HELP",
    182: "GET.BAR",
    183: "PRODUCT",
    184: "FACT",
    185: "GET.CELL",
    186: "GET.WORKSPACE",
    187: "GET.WINDOW",
    188: "GET.DOCUMENT",
    189: "DPRODUCT",
    190: "ISNONTEXT",
    191: "GET.NOTE",
    192: "NOTE",
    193: "STDEVP",
    194: "VARP",
    195: "DSTDEVP",
    196: "DVARP",
    197: "TRUNC",
    198: "ISLOGICAL",
    199: "DCOUNTA",
    200: "DELETE.BAR",
    201: "UNREGISTER",
    204: "USDOLLAR",
    205: "FINDB",
    206: "SEARCHB",
    207: "REPLACEB",
    208: "LEFTB",
    209: "RIGHTB",
    210: "MIDB",
    211: "LENB",
    212: "ROUNDUP",
    213: "ROUNDDOWN",
    214: "ASC",
    215: "DBCS",
    216: "RANK",
    219: "ADDRESS",
    220: "DAYS360",
    221: "TODAY",
    222: "VDB",
    223: "ELSE",
    224: "ELSE.IF",
    225: "END.IF",
    226: "FOR.CELL",
    227: "MEDIAN",
    228: "SUMPRODUCT",
    229: "SINH",
    230: "COSH",
    231: "TANH",
    232: "ASINH",
    233: "ACOSH",
    234: "ATANH",
    235: "DGET",
    236: "CREATE.OBJECT",
    237: "VOLATILE",
    238: "LAST.ERROR",
    239: "CUSTOM.UNDO",
    240: "CUSTOM.REPEAT",
    241: "FORMULA.CONVERT",
    242: "GET.LINK.INFO",
    243: "TEXT.BOX",
    244: "INFO",
    245: "GROUP",
    246: "GET.OBJECT",
    247: "DB",
    248: "PAUSE",
    251: "RESUME",
    252: "FREQUENCY",
    253: "ADD.TOOLBAR",
    254: "DELETE.TOOLBAR",
    255: "User",
    256: "RESET.TOOLBAR",
    257: "EVALUATE",
    258: "GET.TOOLBAR",
    259: "GET.TOOL",
    260: "SPELLING.CHECK",
    261: "ERROR.TYPE",
    262: "APP.TITLE",
    263: "WINDOW.TITLE",
    264: "SAVE.TOOLBAR",
    265: "ENABLE.TOOL",
    266: "PRESS.TOOL",
    267: "REGISTER.ID",
    268: "GET.WORKBOOK",
    269: "AVEDEV",
    270: "BETADIST",
    271: "GAMMALN",
    272: "BETAINV",
    273: "BINOMDIST",
    274: "CHIDIST",
    275: "CHIINV",
    276: "COMBIN",
    277: "CONFIDENCE",
    278: "CRITBINOM",
    279: "EVEN",
    280: "EXPONDIST",
    281: "FDIST",
    282: "FINV",
    283: "FISHER",
    284: "FISHERINV",
    285: "FLOOR",
    286: "GAMMADIST",
    287: "GAMMAINV",
    288: "CEILING",
    289: "HYPGEOMDIST",
    290: "LOGNORMDIST",
    291: "LOGINV",
    292: "NEGBINOMDIST",
    293: "NORMDIST",
    294: "NORMSDIST",
    295: "NORMINV",
    296: "NORMSINV",
    297: "STANDARDIZE",
    298: "ODD",
    299: "PERMUT",
    300: "POISSON",
    301: "TDIST",
    302: "WEIBULL",
    303: "SUMXMY2",
    304: "SUMX2MY2",
    305: "SUMX2PY2",
    306: "CHITEST",
    307: "CORREL",
    308: "COVAR",
    309: "FORECAST",
    310: "FTEST",
    311: "INTERCEPT",
    312: "PEARSON",
    313: "RSQ",
    314: "STEYX",
    315: "SLOPE",
    316: "TTEST",
    317: "PROB",
    318: "DEVSQ",
    319: "GEOMEAN",
    320: "HARMEAN",
    321: "SUMSQ",
    322: "KURT",
    323: "SKEW",
    324: "ZTEST",
    325: "LARGE",
    326: "SMALL",
    327: "QUARTILE",
    328: "PERCENTILE",
    329: "PERCENTRANK",
    330: "MODE",
    331: "TRIMMEAN",
    332: "TINV",
    334: "MOVIE.COMMAND",
    335: "GET.MOVIE",
    336: "CONCATENATE",
    337: "POWER",
    338: "PIVOT.ADD.DATA",
    339: "GET.PIVOT.TABLE",
    340: "GET.PIVOT.FIELD",
    341: "GET.PIVOT.ITEM",
    342: "RADIANS",
    343: "DEGREES",
    344: "SUBTOTAL",
    345: "SUMIF",
    346: "COUNTIF",
    347: "COUNTBLANK",
    348: "SCENARIO.GET",
    349: "OPTIONS.LISTS.GET",
    350: "ISPMT",
    351: "DATEDIF",
    352: "DATESTRING",
    353: "NUMBERSTRING",
    354: "ROMAN",
    355: "OPEN.DIALOG",
    356: "SAVE.DIALOG",
    357: "VIEW.GET",
    358: "GETPIVOTDATA",
    359: "HYPERLINK",
    360: "PHONETIC",
    361: "AVERAGEA",
    362: "MAXA",
    363: "MINA",
    364: "STDEVPA",
    365: "VARPA",
    366: "STDEVA",
    367: "VARA",
    368: "BAHTTEXT",
    369: "THAIDAYOFWEEK",
    370: "THAIDIGIT",
    371: "THAIMONTHOFYEAR",
    372: "THAINUMSOUND",
    373: "THAINUMSTRING",
    374: "THAISTRINGLENGTH",
    375: "ISTHAIDIGIT",
    376: "ROUNDBAHTDOWN",
    377: "ROUNDBAHTUP",
    378: "THAIYEAR",
    379: "RTD",
    380: "CUBEVALUE",
    381: "CUBEMEMBER",
    382: "CUBEMEMBERPROPERTY",
    383: "CUBERANKEDMEMBER",
    384: "HEX2BIN",
    385: "HEX2DEC",
    386: "HEX2OCT",
    387: "DEC2BIN",
    388: "DEC2HEX",
    389: "DEC2OCT",
    390: "OCT2BIN",
    391: "OCT2HEX",
    392: "OCT2DEC",
    393: "BIN2DEC",
    394: "BIN2OCT",
    395: "BIN2HEX",
    396: "IMSUB",
    397: "IMDIV",
    398: "IMPOWER",
    399: "IMABS",
    400: "IMSQRT",
    401: "IMLN",
    402: "IMLOG2",
    403: "IMLOG10",
    404: "IMSIN",
    405: "IMCOS",
    406: "IMEXP",
    407: "IMARGUMENT",
    408: "IMCONJUGATE",
    409: "IMAGINARY",
    410: "IMREAL",
    411: "COMPLEX",
    412: "IMSUM",
    413: "IMPRODUCT",
    414: "SERIESSUM",
    415: "FACTDOUBLE",
    416: "SQRTPI",
    417: "QUOTIENT",
    418: "DELTA",
    419: "GESTEP",
    420: "ISEVEN",
    421: "ISODD",
    422: "MROUND",
    423: "ERF",
    424: "ERFC",
    425: "BESSELJ",
    426: "BESSELK",
    427: "BESSELY",
    428: "BESSELI",
    429: "XIRR",
    430: "XNPV",
    431: "PRICEMAT",
    432: "YIELDMAT",
    433: "INTRATE",
    434: "RECEIVED",
    435: "DISC",
    436: "PRICEDISC",
    437: "YIELDDISC",
    438: "TBILLEQ",
    439: "TBILLPRICE",
    440: "TBILLYIELD",
    441: "PRICE",
    442: "YIELD",
    443: "DOLLARDE",
    444: "DOLLARFR",
    445: "NOMINAL",
    446: "EFFECT",
    447: "CUMPRINC",
    448: "CUMIPMT",
    449: "EDATE",
    450: "EOMONTH",
    451: "YEARFRAC",
    452: "COUPDAYBS",
    453: "COUPDAYS",
    454: "COUPDAYSNC",
    455: "COUPNCD",
    456: "COUPNUM",
    457: "COUPPCD",
    458: "DURATION",
    459: "MDURATION",
    460: "ODDLPRICE",
    461: "ODDLYIELD",
    462: "ODDFPRICE",
    463: "ODDFYIELD",
    464: "RANDBETWEEN",
    465: "WEEKNUM",
    466: "AMORDEGRC",
    467: "AMORLINC",
    468: "CONVERT",
    724: "SHEETJS",
    469: "ACCRINT",
    470: "ACCRINTM",
    471: "WORKDAY",
    472: "NETWORKDAYS",
    473: "GCD",
    474: "MULTINOMIAL",
    475: "LCM",
    476: "FVSCHEDULE",
    477: "CUBEKPIMEMBER",
    478: "CUBESET",
    479: "CUBESETCOUNT",
    480: "IFERROR",
    481: "COUNTIFS",
    482: "SUMIFS",
    483: "AVERAGEIF",
    484: "AVERAGEIFS"
  };
  var FtabArgc = {
    2: 1,
    3: 1,
    10: 0,
    15: 1,
    16: 1,
    17: 1,
    18: 1,
    19: 0,
    20: 1,
    21: 1,
    22: 1,
    23: 1,
    24: 1,
    25: 1,
    26: 1,
    27: 2,
    30: 2,
    31: 3,
    32: 1,
    33: 1,
    34: 0,
    35: 0,
    38: 1,
    39: 2,
    40: 3,
    41: 3,
    42: 3,
    43: 3,
    44: 3,
    45: 3,
    47: 3,
    48: 2,
    53: 1,
    61: 3,
    63: 0,
    65: 3,
    66: 3,
    67: 1,
    68: 1,
    69: 1,
    70: 1,
    71: 1,
    72: 1,
    73: 1,
    74: 0,
    75: 1,
    76: 1,
    77: 1,
    79: 2,
    80: 2,
    83: 1,
    85: 0,
    86: 1,
    89: 0,
    90: 1,
    94: 0,
    95: 0,
    97: 2,
    98: 1,
    99: 1,
    101: 3,
    102: 3,
    105: 1,
    106: 1,
    108: 2,
    111: 1,
    112: 1,
    113: 1,
    114: 1,
    117: 2,
    118: 1,
    119: 4,
    121: 1,
    126: 1,
    127: 1,
    128: 1,
    129: 1,
    130: 1,
    131: 1,
    133: 1,
    134: 1,
    135: 1,
    136: 2,
    137: 2,
    138: 2,
    140: 1,
    141: 1,
    142: 3,
    143: 4,
    144: 4,
    161: 1,
    162: 1,
    163: 1,
    164: 1,
    165: 2,
    172: 1,
    175: 2,
    176: 2,
    177: 3,
    178: 2,
    179: 1,
    184: 1,
    186: 1,
    189: 3,
    190: 1,
    195: 3,
    196: 3,
    197: 1,
    198: 1,
    199: 3,
    201: 1,
    207: 4,
    210: 3,
    211: 1,
    212: 2,
    213: 2,
    214: 1,
    215: 1,
    225: 0,
    229: 1,
    230: 1,
    231: 1,
    232: 1,
    233: 1,
    234: 1,
    235: 3,
    244: 1,
    247: 4,
    252: 2,
    257: 1,
    261: 1,
    271: 1,
    273: 4,
    274: 2,
    275: 2,
    276: 2,
    277: 3,
    278: 3,
    279: 1,
    280: 3,
    281: 3,
    282: 3,
    283: 1,
    284: 1,
    285: 2,
    286: 4,
    287: 3,
    288: 2,
    289: 4,
    290: 3,
    291: 3,
    292: 3,
    293: 4,
    294: 1,
    295: 3,
    296: 1,
    297: 3,
    298: 1,
    299: 2,
    300: 3,
    301: 3,
    302: 4,
    303: 2,
    304: 2,
    305: 2,
    306: 2,
    307: 2,
    308: 2,
    309: 3,
    310: 2,
    311: 2,
    312: 2,
    313: 2,
    314: 2,
    315: 2,
    316: 4,
    325: 2,
    326: 2,
    327: 2,
    328: 2,
    331: 2,
    332: 2,
    337: 2,
    342: 1,
    343: 1,
    346: 2,
    347: 1,
    350: 4,
    351: 3,
    352: 1,
    353: 2,
    360: 1,
    368: 1,
    369: 1,
    370: 1,
    371: 1,
    372: 1,
    373: 1,
    374: 1,
    375: 1,
    376: 1,
    377: 1,
    378: 1,
    382: 3,
    385: 1,
    392: 1,
    393: 1,
    396: 2,
    397: 2,
    398: 2,
    399: 1,
    400: 1,
    401: 1,
    402: 1,
    403: 1,
    404: 1,
    405: 1,
    406: 1,
    407: 1,
    408: 1,
    409: 1,
    410: 1,
    414: 4,
    415: 1,
    416: 1,
    417: 2,
    420: 1,
    421: 1,
    422: 2,
    424: 1,
    425: 2,
    426: 2,
    427: 2,
    428: 2,
    430: 3,
    438: 3,
    439: 3,
    440: 3,
    443: 2,
    444: 2,
    445: 2,
    446: 2,
    447: 6,
    448: 6,
    449: 2,
    450: 2,
    464: 2,
    468: 3,
    476: 2,
    479: 1,
    480: 2,
    65535: 0
  };
  function csf_to_ods_formula(f) {
    var o = "of:=" + f.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
    return o.replace(/;/g, "|").replace(/,/g, ";");
  }
  function csf_to_ods_3D(r) {
    return r.replace(/\./, "!");
  }
  var browser_has_Map = typeof Map !== "undefined";
  function get_sst_id(sst, str, rev) {
    var i = 0, len = sst.length;
    if (rev) {
      if (browser_has_Map ? rev.has(str) : Object.prototype.hasOwnProperty.call(rev, str)) {
        var revarr = browser_has_Map ? rev.get(str) : rev[str];
        for (; i < revarr.length; ++i) {
          if (sst[revarr[i]].t === str) {
            sst.Count++;
            return revarr[i];
          }
        }
      }
    } else for (; i < len; ++i) {
      if (sst[i].t === str) {
        sst.Count++;
        return i;
      }
    }
    sst[len] = { t: str };
    sst.Count++;
    sst.Unique++;
    if (rev) {
      if (browser_has_Map) {
        if (!rev.has(str)) rev.set(str, []);
        rev.get(str).push(len);
      } else {
        if (!Object.prototype.hasOwnProperty.call(rev, str)) rev[str] = [];
        rev[str].push(len);
      }
    }
    return len;
  }
  function col_obj_w(C, col) {
    var p = { min: C + 1, max: C + 1 };
    var wch = -1;
    if (col.MDW) MDW = col.MDW;
    if (col.width != null) p.customWidth = 1;
    else if (col.wpx != null) wch = px2char(col.wpx);
    else if (col.wch != null) wch = col.wch;
    if (wch > -1) {
      p.width = char2width(wch);
      p.customWidth = 1;
    } else if (col.width != null) p.width = col.width;
    if (col.hidden) p.hidden = true;
    if (col.level != null) {
      p.outlineLevel = p.level = col.level;
    }
    return p;
  }
  function default_margins(margins, mode) {
    if (!margins) return;
    var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
    if (mode == "xlml") defs = [1, 1, 1, 1, 0.5, 0.5];
    if (margins.left == null) margins.left = defs[0];
    if (margins.right == null) margins.right = defs[1];
    if (margins.top == null) margins.top = defs[2];
    if (margins.bottom == null) margins.bottom = defs[3];
    if (margins.header == null) margins.header = defs[4];
    if (margins.footer == null) margins.footer = defs[5];
  }
  function get_cell_style(styles, cell, opts) {
    var z = opts.revssf[cell.z != null ? cell.z : "General"];
    var i = 60, len = styles.length;
    if (z == null && opts.ssf) {
      for (; i < 392; ++i) if (opts.ssf[i] == null) {
        SSF_load(cell.z, i);
        opts.ssf[i] = cell.z;
        opts.revssf[cell.z] = z = i;
        break;
      }
    }
    for (i = 0; i != len; ++i) if (styles[i].numFmtId === z) return i;
    styles[len] = {
      numFmtId: z,
      fontId: 0,
      fillId: 0,
      borderId: 0,
      xfId: 0,
      applyNumberFormat: 1
    };
    return len;
  }
  function check_ws(ws, sname, i) {
    if (ws && ws["!ref"]) {
      var range = safe_decode_range(ws["!ref"]);
      if (range.e.c < range.s.c || range.e.r < range.s.r) throw new Error("Bad range (" + i + "): " + ws["!ref"]);
    }
  }
  function write_ws_xml_merges(merges) {
    if (merges.length === 0) return "";
    var o = '<mergeCells count="' + merges.length + '">';
    for (var i = 0; i != merges.length; ++i) o += '<mergeCell ref="' + encode_range(merges[i]) + '"/>';
    return o + "</mergeCells>";
  }
  function write_ws_xml_sheetpr(ws, wb, idx, opts, o) {
    var needed = false;
    var props = {}, payload = null;
    if (opts.bookType !== "xlsx" && wb.vbaraw) {
      var cname = wb.SheetNames[idx];
      try {
        if (wb.Workbook) cname = wb.Workbook.Sheets[idx].CodeName || cname;
      } catch (e) {
      }
      needed = true;
      props.codeName = utf8write(escapexml(cname));
    }
    if (ws && ws["!outline"]) {
      var outlineprops = { summaryBelow: 1, summaryRight: 1 };
      if (ws["!outline"].above) outlineprops.summaryBelow = 0;
      if (ws["!outline"].left) outlineprops.summaryRight = 0;
      payload = (payload || "") + writextag("outlinePr", null, outlineprops);
    }
    if (!needed && !payload) return;
    o[o.length] = writextag("sheetPr", payload, props);
  }
  var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];
  var sheetprot_deftrue = [
    "formatColumns",
    "formatRows",
    "formatCells",
    "insertColumns",
    "insertRows",
    "insertHyperlinks",
    "deleteColumns",
    "deleteRows",
    "sort",
    "autoFilter",
    "pivotTables"
  ];
  function write_ws_xml_protection(sp) {
    var o = { sheet: 1 };
    sheetprot_deffalse.forEach(function(n) {
      if (sp[n] != null && sp[n]) o[n] = "1";
    });
    sheetprot_deftrue.forEach(function(n) {
      if (sp[n] != null && !sp[n]) o[n] = "0";
    });
    if (sp.password) o.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();
    return writextag("sheetProtection", null, o);
  }
  function write_ws_xml_margins(margin) {
    default_margins(margin);
    return writextag("pageMargins", null, margin);
  }
  function write_ws_xml_cols(ws, cols) {
    var o = ["<cols>"], col;
    for (var i = 0; i != cols.length; ++i) {
      if (!(col = cols[i])) continue;
      o[o.length] = writextag("col", null, col_obj_w(i, col));
    }
    o[o.length] = "</cols>";
    return o.join("");
  }
  function write_ws_xml_autofilter(data, ws, wb, idx) {
    var ref = typeof data.ref == "string" ? data.ref : encode_range(data.ref);
    if (!wb.Workbook) wb.Workbook = { Sheets: [] };
    if (!wb.Workbook.Names) wb.Workbook.Names = [];
    var names = wb.Workbook.Names;
    var range = decode_range(ref);
    if (range.s.r == range.e.r) {
      range.e.r = decode_range(ws["!ref"]).e.r;
      ref = encode_range(range);
    }
    for (var i = 0; i < names.length; ++i) {
      var name = names[i];
      if (name.Name != "_xlnm._FilterDatabase") continue;
      if (name.Sheet != idx) continue;
      name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref;
      break;
    }
    if (i == names.length) names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref });
    return writextag("autoFilter", null, { ref });
  }
  function write_ws_xml_sheetviews(ws, opts, idx, wb) {
    var sview = { workbookViewId: "0" };
    if ((((wb || {}).Workbook || {}).Views || [])[0]) sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";
    return writextag("sheetViews", writextag("sheetView", null, sview), {});
  }
  function write_ws_xml_cell(cell, ref, ws, opts) {
    if (cell.c) ws["!comments"].push([ref, cell.c]);
    if (cell.v === void 0 && typeof cell.f !== "string" || cell.t === "z" && !cell.f) return "";
    var vv = "";
    var oldt = cell.t, oldv = cell.v;
    if (cell.t !== "z") switch (cell.t) {
      case "b":
        vv = cell.v ? "1" : "0";
        break;
      case "n":
        vv = "" + cell.v;
        break;
      case "e":
        vv = BErr[cell.v];
        break;
      case "d":
        if (opts && opts.cellDates) vv = parseDate(cell.v, -1).toISOString();
        else {
          cell = dup(cell);
          cell.t = "n";
          vv = "" + (cell.v = datenum(parseDate(cell.v)));
        }
        if (typeof cell.z === "undefined") cell.z = table_fmt[14];
        break;
      default:
        vv = cell.v;
        break;
    }
    var v = writetag("v", escapexml(vv)), o = { r: ref };
    var os = get_cell_style(opts.cellXfs, cell, opts);
    if (os !== 0) o.s = os;
    switch (cell.t) {
      case "n":
        break;
      case "d":
        o.t = "d";
        break;
      case "b":
        o.t = "b";
        break;
      case "e":
        o.t = "e";
        break;
      case "z":
        break;
      default:
        if (cell.v == null) {
          delete cell.t;
          break;
        }
        if (cell.v.length > 32767) throw new Error("Text length must not exceed 32767 characters");
        if (opts && opts.bookSST) {
          v = writetag("v", "" + get_sst_id(opts.Strings, cell.v, opts.revStrings));
          o.t = "s";
          break;
        }
        o.t = "str";
        break;
    }
    if (cell.t != oldt) {
      cell.t = oldt;
      cell.v = oldv;
    }
    if (typeof cell.f == "string" && cell.f) {
      var ff = cell.F && cell.F.slice(0, ref.length) == ref ? { t: "array", ref: cell.F } : null;
      v = writextag("f", escapexml(cell.f), ff) + (cell.v != null ? v : "");
    }
    if (cell.l) ws["!links"].push([ref, cell.l]);
    if (cell.D) o.cm = 1;
    return writextag("c", v, o);
  }
  function write_ws_xml_data(ws, opts, idx, wb) {
    var o = [], r = [], range = safe_decode_range(ws["!ref"]), cell = "", ref, rr = "", cols = [], R = 0, C = 0, rows = ws["!rows"];
    var dense = Array.isArray(ws);
    var params = { r: rr }, row, height = -1;
    for (C = range.s.c; C <= range.e.c; ++C) cols[C] = encode_col(C);
    for (R = range.s.r; R <= range.e.r; ++R) {
      r = [];
      rr = encode_row(R);
      for (C = range.s.c; C <= range.e.c; ++C) {
        ref = cols[C] + rr;
        var _cell = dense ? (ws[R] || [])[C] : ws[ref];
        if (_cell === void 0) continue;
        if ((cell = write_ws_xml_cell(_cell, ref, ws, opts, idx, wb)) != null) r.push(cell);
      }
      if (r.length > 0 || rows && rows[R]) {
        params = { r: rr };
        if (rows && rows[R]) {
          row = rows[R];
          if (row.hidden) params.hidden = 1;
          height = -1;
          if (row.hpx) height = px2pt(row.hpx);
          else if (row.hpt) height = row.hpt;
          if (height > -1) {
            params.ht = height;
            params.customHeight = 1;
          }
          if (row.level) {
            params.outlineLevel = row.level;
          }
        }
        o[o.length] = writextag("row", r.join(""), params);
      }
    }
    if (rows) for (; R < rows.length; ++R) {
      if (rows && rows[R]) {
        params = { r: R + 1 };
        row = rows[R];
        if (row.hidden) params.hidden = 1;
        height = -1;
        if (row.hpx) height = px2pt(row.hpx);
        else if (row.hpt) height = row.hpt;
        if (height > -1) {
          params.ht = height;
          params.customHeight = 1;
        }
        if (row.level) {
          params.outlineLevel = row.level;
        }
        o[o.length] = writextag("row", "", params);
      }
    }
    return o.join("");
  }
  function write_ws_xml(idx, opts, wb, rels) {
    var o = [XML_HEADER, writextag("worksheet", null, {
      "xmlns": XMLNS_main[0],
      "xmlns:r": XMLNS.r
    })];
    var s = wb.SheetNames[idx], sidx = 0, rdata = "";
    var ws = wb.Sheets[s];
    if (ws == null) ws = {};
    var ref = ws["!ref"] || "A1";
    var range = safe_decode_range(ref);
    if (range.e.c > 16383 || range.e.r > 1048575) {
      if (opts.WTF) throw new Error("Range " + ref + " exceeds format limit A1:XFD1048576");
      range.e.c = Math.min(range.e.c, 16383);
      range.e.r = Math.min(range.e.c, 1048575);
      ref = encode_range(range);
    }
    if (!rels) rels = {};
    ws["!comments"] = [];
    var _drawing = [];
    write_ws_xml_sheetpr(ws, wb, idx, opts, o);
    o[o.length] = writextag("dimension", null, { "ref": ref });
    o[o.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);
    if (opts.sheetFormat) o[o.length] = writextag("sheetFormatPr", null, {
      defaultRowHeight: opts.sheetFormat.defaultRowHeight || "16",
      baseColWidth: opts.sheetFormat.baseColWidth || "10",
      outlineLevelRow: opts.sheetFormat.outlineLevelRow || "7"
    });
    if (ws["!cols"] != null && ws["!cols"].length > 0) o[o.length] = write_ws_xml_cols(ws, ws["!cols"]);
    o[sidx = o.length] = "<sheetData/>";
    ws["!links"] = [];
    if (ws["!ref"] != null) {
      rdata = write_ws_xml_data(ws, opts, idx, wb, rels);
      if (rdata.length > 0) o[o.length] = rdata;
    }
    if (o.length > sidx + 1) {
      o[o.length] = "</sheetData>";
      o[sidx] = o[sidx].replace("/>", ">");
    }
    if (ws["!protect"]) o[o.length] = write_ws_xml_protection(ws["!protect"]);
    if (ws["!autofilter"] != null) o[o.length] = write_ws_xml_autofilter(ws["!autofilter"], ws, wb, idx);
    if (ws["!merges"] != null && ws["!merges"].length > 0) o[o.length] = write_ws_xml_merges(ws["!merges"]);
    var relc = -1, rel, rId = -1;
    if (
      /*::(*/
      ws["!links"].length > 0
    ) {
      o[o.length] = "<hyperlinks>";
      ws["!links"].forEach(function(l) {
        if (!l[1].Target) return;
        rel = { "ref": l[0] };
        if (l[1].Target.charAt(0) != "#") {
          rId = add_rels(rels, -1, escapexml(l[1].Target).replace(/#.*$/, ""), RELS.HLINK);
          rel["r:id"] = "rId" + rId;
        }
        if ((relc = l[1].Target.indexOf("#")) > -1) rel.location = escapexml(l[1].Target.slice(relc + 1));
        if (l[1].Tooltip) rel.tooltip = escapexml(l[1].Tooltip);
        o[o.length] = writextag("hyperlink", null, rel);
      });
      o[o.length] = "</hyperlinks>";
    }
    delete ws["!links"];
    if (ws["!margins"] != null) o[o.length] = write_ws_xml_margins(ws["!margins"]);
    if (!opts || opts.ignoreEC || opts.ignoreEC == void 0) o[o.length] = writetag("ignoredErrors", writextag("ignoredError", null, { numberStoredAsText: 1, sqref: ref }));
    if (_drawing.length > 0) {
      rId = add_rels(rels, -1, "../drawings/drawing" + (idx + 1) + ".xml", RELS.DRAW);
      o[o.length] = writextag("drawing", null, { "r:id": "rId" + rId });
      ws["!drawing"] = _drawing;
    }
    if (ws["!comments"].length > 0) {
      rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
      o[o.length] = writextag("legacyDrawing", null, { "r:id": "rId" + rId });
      ws["!legacy"] = rId;
    }
    if (o.length > 1) {
      o[o.length] = "</worksheet>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function parse_BrtRowHdr(data, length) {
    var z = {};
    var tgt = data.l + length;
    z.r = data.read_shift(4);
    data.l += 4;
    var miyRw = data.read_shift(2);
    data.l += 1;
    var flags = data.read_shift(1);
    data.l = tgt;
    if (flags & 7) z.level = flags & 7;
    if (flags & 16) z.hidden = true;
    if (flags & 32) z.hpt = miyRw / 20;
    return z;
  }
  function write_BrtRowHdr(R, range, ws) {
    var o = new_buf(17 + 8 * 16);
    var row = (ws["!rows"] || [])[R] || {};
    o.write_shift(4, R);
    o.write_shift(4, 0);
    var miyRw = 320;
    if (row.hpx) miyRw = px2pt(row.hpx) * 20;
    else if (row.hpt) miyRw = row.hpt * 20;
    o.write_shift(2, miyRw);
    o.write_shift(1, 0);
    var flags = 0;
    if (row.level) flags |= row.level;
    if (row.hidden) flags |= 16;
    if (row.hpx || row.hpt) flags |= 32;
    o.write_shift(1, flags);
    o.write_shift(1, 0);
    var ncolspan = 0, lcs = o.l;
    o.l += 4;
    var caddr = { r: R, c: 0 };
    for (var i = 0; i < 16; ++i) {
      if (range.s.c > i + 1 << 10 || range.e.c < i << 10) continue;
      var first = -1, last = -1;
      for (var j = i << 10; j < i + 1 << 10; ++j) {
        caddr.c = j;
        var cell = Array.isArray(ws) ? (ws[caddr.r] || [])[caddr.c] : ws[encode_cell(caddr)];
        if (cell) {
          if (first < 0) first = j;
          last = j;
        }
      }
      if (first < 0) continue;
      ++ncolspan;
      o.write_shift(4, first);
      o.write_shift(4, last);
    }
    var l = o.l;
    o.l = lcs;
    o.write_shift(4, ncolspan);
    o.l = l;
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_row_header(ba, ws, range, R) {
    var o = write_BrtRowHdr(R, range, ws);
    if (o.length > 17 || (ws["!rows"] || [])[R]) write_record(ba, 0, o);
  }
  var parse_BrtWsDim = parse_UncheckedRfX;
  var write_BrtWsDim = write_UncheckedRfX;
  function parse_BrtWsFmtInfo() {
  }
  function parse_BrtWsProp(data, length) {
    var z = {};
    var f = data[data.l];
    ++data.l;
    z.above = !(f & 64);
    z.left = !(f & 128);
    data.l += 18;
    z.name = parse_XLSBCodeName(data, length - 19);
    return z;
  }
  function write_BrtWsProp(str, outl, o) {
    if (o == null) o = new_buf(84 + 4 * str.length);
    var f = 192;
    if (outl) {
      if (outl.above) f &= ~64;
      if (outl.left) f &= ~128;
    }
    o.write_shift(1, f);
    for (var i = 1; i < 3; ++i) o.write_shift(1, 0);
    write_BrtColor({ auto: 1 }, o);
    o.write_shift(-4, -1);
    o.write_shift(-4, -1);
    write_XLSBCodeName(str, o);
    return o.slice(0, o.l);
  }
  function parse_BrtCellBlank(data) {
    var cell = parse_XLSBCell(data);
    return [cell];
  }
  function write_BrtCellBlank(cell, ncell, o) {
    if (o == null) o = new_buf(8);
    return write_XLSBCell(ncell, o);
  }
  function parse_BrtShortBlank(data) {
    var cell = parse_XLSBShortCell(data);
    return [cell];
  }
  function write_BrtShortBlank(cell, ncell, o) {
    if (o == null) o = new_buf(4);
    return write_XLSBShortCell(ncell, o);
  }
  function parse_BrtCellBool(data) {
    var cell = parse_XLSBCell(data);
    var fBool = data.read_shift(1);
    return [cell, fBool, "b"];
  }
  function write_BrtCellBool(cell, ncell, o) {
    if (o == null) o = new_buf(9);
    write_XLSBCell(ncell, o);
    o.write_shift(1, cell.v ? 1 : 0);
    return o;
  }
  function parse_BrtShortBool(data) {
    var cell = parse_XLSBShortCell(data);
    var fBool = data.read_shift(1);
    return [cell, fBool, "b"];
  }
  function write_BrtShortBool(cell, ncell, o) {
    if (o == null) o = new_buf(5);
    write_XLSBShortCell(ncell, o);
    o.write_shift(1, cell.v ? 1 : 0);
    return o;
  }
  function parse_BrtCellError(data) {
    var cell = parse_XLSBCell(data);
    var bError = data.read_shift(1);
    return [cell, bError, "e"];
  }
  function write_BrtCellError(cell, ncell, o) {
    if (o == null) o = new_buf(9);
    write_XLSBCell(ncell, o);
    o.write_shift(1, cell.v);
    return o;
  }
  function parse_BrtShortError(data) {
    var cell = parse_XLSBShortCell(data);
    var bError = data.read_shift(1);
    return [cell, bError, "e"];
  }
  function write_BrtShortError(cell, ncell, o) {
    if (o == null) o = new_buf(8);
    write_XLSBShortCell(ncell, o);
    o.write_shift(1, cell.v);
    o.write_shift(2, 0);
    o.write_shift(1, 0);
    return o;
  }
  function parse_BrtCellIsst(data) {
    var cell = parse_XLSBCell(data);
    var isst = data.read_shift(4);
    return [cell, isst, "s"];
  }
  function write_BrtCellIsst(cell, ncell, o) {
    if (o == null) o = new_buf(12);
    write_XLSBCell(ncell, o);
    o.write_shift(4, ncell.v);
    return o;
  }
  function parse_BrtShortIsst(data) {
    var cell = parse_XLSBShortCell(data);
    var isst = data.read_shift(4);
    return [cell, isst, "s"];
  }
  function write_BrtShortIsst(cell, ncell, o) {
    if (o == null) o = new_buf(8);
    write_XLSBShortCell(ncell, o);
    o.write_shift(4, ncell.v);
    return o;
  }
  function parse_BrtCellReal(data) {
    var cell = parse_XLSBCell(data);
    var value = parse_Xnum(data);
    return [cell, value, "n"];
  }
  function write_BrtCellReal(cell, ncell, o) {
    if (o == null) o = new_buf(16);
    write_XLSBCell(ncell, o);
    write_Xnum(cell.v, o);
    return o;
  }
  function parse_BrtShortReal(data) {
    var cell = parse_XLSBShortCell(data);
    var value = parse_Xnum(data);
    return [cell, value, "n"];
  }
  function write_BrtShortReal(cell, ncell, o) {
    if (o == null) o = new_buf(12);
    write_XLSBShortCell(ncell, o);
    write_Xnum(cell.v, o);
    return o;
  }
  function parse_BrtCellRk(data) {
    var cell = parse_XLSBCell(data);
    var value = parse_RkNumber(data);
    return [cell, value, "n"];
  }
  function write_BrtCellRk(cell, ncell, o) {
    if (o == null) o = new_buf(12);
    write_XLSBCell(ncell, o);
    write_RkNumber(cell.v, o);
    return o;
  }
  function parse_BrtShortRk(data) {
    var cell = parse_XLSBShortCell(data);
    var value = parse_RkNumber(data);
    return [cell, value, "n"];
  }
  function write_BrtShortRk(cell, ncell, o) {
    if (o == null) o = new_buf(8);
    write_XLSBShortCell(ncell, o);
    write_RkNumber(cell.v, o);
    return o;
  }
  function parse_BrtCellRString(data) {
    var cell = parse_XLSBCell(data);
    var value = parse_RichStr(data);
    return [cell, value, "is"];
  }
  function parse_BrtCellSt(data) {
    var cell = parse_XLSBCell(data);
    var value = parse_XLWideString(data);
    return [cell, value, "str"];
  }
  function write_BrtCellSt(cell, ncell, o) {
    if (o == null) o = new_buf(12 + 4 * cell.v.length);
    write_XLSBCell(ncell, o);
    write_XLWideString(cell.v, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_BrtShortSt(data) {
    var cell = parse_XLSBShortCell(data);
    var value = parse_XLWideString(data);
    return [cell, value, "str"];
  }
  function write_BrtShortSt(cell, ncell, o) {
    if (o == null) o = new_buf(8 + 4 * cell.v.length);
    write_XLSBShortCell(ncell, o);
    write_XLWideString(cell.v, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_BrtFmlaBool(data, length, opts) {
    var end = data.l + length;
    var cell = parse_XLSBCell(data);
    cell.r = opts["!row"];
    var value = data.read_shift(1);
    var o = [cell, value, "b"];
    if (opts.cellFormula) {
      data.l += 2;
      var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
      o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
    } else data.l = end;
    return o;
  }
  function parse_BrtFmlaError(data, length, opts) {
    var end = data.l + length;
    var cell = parse_XLSBCell(data);
    cell.r = opts["!row"];
    var value = data.read_shift(1);
    var o = [cell, value, "e"];
    if (opts.cellFormula) {
      data.l += 2;
      var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
      o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
    } else data.l = end;
    return o;
  }
  function parse_BrtFmlaNum(data, length, opts) {
    var end = data.l + length;
    var cell = parse_XLSBCell(data);
    cell.r = opts["!row"];
    var value = parse_Xnum(data);
    var o = [cell, value, "n"];
    if (opts.cellFormula) {
      data.l += 2;
      var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
      o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
    } else data.l = end;
    return o;
  }
  function parse_BrtFmlaString(data, length, opts) {
    var end = data.l + length;
    var cell = parse_XLSBCell(data);
    cell.r = opts["!row"];
    var value = parse_XLWideString(data);
    var o = [cell, value, "str"];
    if (opts.cellFormula) {
      data.l += 2;
      var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
      o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
    } else data.l = end;
    return o;
  }
  var parse_BrtMergeCell = parse_UncheckedRfX;
  var write_BrtMergeCell = write_UncheckedRfX;
  function write_BrtBeginMergeCells(cnt, o) {
    if (o == null) o = new_buf(4);
    o.write_shift(4, cnt);
    return o;
  }
  function parse_BrtHLink(data, length) {
    var end = data.l + length;
    var rfx = parse_UncheckedRfX(data, 16);
    var relId = parse_XLNullableWideString(data);
    var loc = parse_XLWideString(data);
    var tooltip = parse_XLWideString(data);
    var display = parse_XLWideString(data);
    data.l = end;
    var o = { rfx, relId, loc, display };
    if (tooltip) o.Tooltip = tooltip;
    return o;
  }
  function write_BrtHLink(l, rId) {
    var o = new_buf(50 + 4 * (l[1].Target.length + (l[1].Tooltip || "").length));
    write_UncheckedRfX({ s: decode_cell(l[0]), e: decode_cell(l[0]) }, o);
    write_RelID("rId" + rId, o);
    var locidx = l[1].Target.indexOf("#");
    var loc = locidx == -1 ? "" : l[1].Target.slice(locidx + 1);
    write_XLWideString(loc || "", o);
    write_XLWideString(l[1].Tooltip || "", o);
    write_XLWideString("", o);
    return o.slice(0, o.l);
  }
  function parse_BrtPane() {
  }
  function parse_BrtArrFmla(data, length, opts) {
    var end = data.l + length;
    var rfx = parse_RfX(data, 16);
    var fAlwaysCalc = data.read_shift(1);
    var o = [rfx];
    o[2] = fAlwaysCalc;
    if (opts.cellFormula) {
      var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
      o[1] = formula;
    } else data.l = end;
    return o;
  }
  function parse_BrtShrFmla(data, length, opts) {
    var end = data.l + length;
    var rfx = parse_UncheckedRfX(data, 16);
    var o = [rfx];
    if (opts.cellFormula) {
      var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
      o[1] = formula;
      data.l = end;
    } else data.l = end;
    return o;
  }
  function write_BrtColInfo(C, col, o) {
    if (o == null) o = new_buf(18);
    var p = col_obj_w(C, col);
    o.write_shift(-4, C);
    o.write_shift(-4, C);
    o.write_shift(4, (p.width || 10) * 256);
    o.write_shift(
      4,
      0
      /*ixfe*/
    );
    var flags = 0;
    if (col.hidden) flags |= 1;
    if (typeof p.width == "number") flags |= 2;
    if (col.level) flags |= col.level << 8;
    o.write_shift(2, flags);
    return o;
  }
  var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
  function parse_BrtMargins(data) {
    var margins = {};
    BrtMarginKeys.forEach(function(k) {
      margins[k] = parse_Xnum(data, 8);
    });
    return margins;
  }
  function write_BrtMargins(margins, o) {
    if (o == null) o = new_buf(6 * 8);
    default_margins(margins);
    BrtMarginKeys.forEach(function(k) {
      write_Xnum(margins[k], o);
    });
    return o;
  }
  function parse_BrtBeginWsView(data) {
    var f = data.read_shift(2);
    data.l += 28;
    return { RTL: f & 32 };
  }
  function write_BrtBeginWsView(ws, Workbook, o) {
    if (o == null) o = new_buf(30);
    var f = 924;
    if ((((Workbook || {}).Views || [])[0] || {}).RTL) f |= 32;
    o.write_shift(2, f);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 100);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(4, 0);
    return o;
  }
  function write_BrtCellIgnoreEC(ref) {
    var o = new_buf(24);
    o.write_shift(4, 4);
    o.write_shift(4, 1);
    write_UncheckedRfX(ref, o);
    return o;
  }
  function write_BrtSheetProtection(sp, o) {
    if (o == null) o = new_buf(16 * 4 + 2);
    o.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);
    o.write_shift(4, 1);
    [
      ["objects", false],
      // fObjects
      ["scenarios", false],
      // fScenarios
      ["formatCells", true],
      // fFormatCells
      ["formatColumns", true],
      // fFormatColumns
      ["formatRows", true],
      // fFormatRows
      ["insertColumns", true],
      // fInsertColumns
      ["insertRows", true],
      // fInsertRows
      ["insertHyperlinks", true],
      // fInsertHyperlinks
      ["deleteColumns", true],
      // fDeleteColumns
      ["deleteRows", true],
      // fDeleteRows
      ["selectLockedCells", false],
      // fSelLockedCells
      ["sort", true],
      // fSort
      ["autoFilter", true],
      // fAutoFilter
      ["pivotTables", true],
      // fPivotTables
      ["selectUnlockedCells", false]
      // fSelUnlockedCells
    ].forEach(function(n) {
      if (n[1]) o.write_shift(4, sp[n[0]] != null && !sp[n[0]] ? 1 : 0);
      else o.write_shift(4, sp[n[0]] != null && sp[n[0]] ? 0 : 1);
    });
    return o;
  }
  function parse_BrtDVal() {
  }
  function parse_BrtDVal14() {
  }
  function write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen) {
    if (cell.v === void 0) return false;
    var vv = "";
    switch (cell.t) {
      case "b":
        vv = cell.v ? "1" : "0";
        break;
      case "d":
        cell = dup(cell);
        cell.z = cell.z || table_fmt[14];
        cell.v = datenum(parseDate(cell.v));
        cell.t = "n";
        break;
      /* falls through */
      case "n":
      case "e":
        vv = "" + cell.v;
        break;
      default:
        vv = cell.v;
        break;
    }
    var o = { r: R, c: C };
    o.s = get_cell_style(opts.cellXfs, cell, opts);
    if (cell.l) ws["!links"].push([encode_cell(o), cell.l]);
    if (cell.c) ws["!comments"].push([encode_cell(o), cell.c]);
    switch (cell.t) {
      case "s":
      case "str":
        if (opts.bookSST) {
          vv = get_sst_id(opts.Strings, cell.v, opts.revStrings);
          o.t = "s";
          o.v = vv;
          if (last_seen) write_record(ba, 18, write_BrtShortIsst(cell, o));
          else write_record(ba, 7, write_BrtCellIsst(cell, o));
        } else {
          o.t = "str";
          if (last_seen) write_record(ba, 17, write_BrtShortSt(cell, o));
          else write_record(ba, 6, write_BrtCellSt(cell, o));
        }
        return true;
      case "n":
        if (cell.v == (cell.v | 0) && cell.v > -1e3 && cell.v < 1e3) {
          if (last_seen) write_record(ba, 13, write_BrtShortRk(cell, o));
          else write_record(ba, 2, write_BrtCellRk(cell, o));
        } else {
          if (last_seen) write_record(ba, 16, write_BrtShortReal(cell, o));
          else write_record(ba, 5, write_BrtCellReal(cell, o));
        }
        return true;
      case "b":
        o.t = "b";
        if (last_seen) write_record(ba, 15, write_BrtShortBool(cell, o));
        else write_record(ba, 4, write_BrtCellBool(cell, o));
        return true;
      case "e":
        o.t = "e";
        if (last_seen) write_record(ba, 14, write_BrtShortError(cell, o));
        else write_record(ba, 3, write_BrtCellError(cell, o));
        return true;
    }
    if (last_seen) write_record(ba, 12, write_BrtShortBlank(cell, o));
    else write_record(ba, 1, write_BrtCellBlank(cell, o));
    return true;
  }
  function write_CELLTABLE(ba, ws, idx, opts) {
    var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
    write_record(
      ba,
      145
      /* BrtBeginSheetData */
    );
    var dense = Array.isArray(ws);
    var cap = range.e.r;
    if (ws["!rows"]) cap = Math.max(range.e.r, ws["!rows"].length - 1);
    for (var R = range.s.r; R <= cap; ++R) {
      rr = encode_row(R);
      write_row_header(ba, ws, range, R);
      var last_seen = false;
      if (R <= range.e.r) for (var C = range.s.c; C <= range.e.c; ++C) {
        if (R === range.s.r) cols[C] = encode_col(C);
        ref = cols[C] + rr;
        var cell = dense ? (ws[R] || [])[C] : ws[ref];
        if (!cell) {
          last_seen = false;
          continue;
        }
        last_seen = write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen);
      }
    }
    write_record(
      ba,
      146
      /* BrtEndSheetData */
    );
  }
  function write_MERGECELLS(ba, ws) {
    if (!ws || !ws["!merges"]) return;
    write_record(ba, 177, write_BrtBeginMergeCells(ws["!merges"].length));
    ws["!merges"].forEach(function(m) {
      write_record(ba, 176, write_BrtMergeCell(m));
    });
    write_record(
      ba,
      178
      /* BrtEndMergeCells */
    );
  }
  function write_COLINFOS(ba, ws) {
    if (!ws || !ws["!cols"]) return;
    write_record(
      ba,
      390
      /* BrtBeginColInfos */
    );
    ws["!cols"].forEach(function(m, i) {
      if (m) write_record(ba, 60, write_BrtColInfo(i, m));
    });
    write_record(
      ba,
      391
      /* BrtEndColInfos */
    );
  }
  function write_IGNOREECS(ba, ws) {
    if (!ws || !ws["!ref"]) return;
    write_record(
      ba,
      648
      /* BrtBeginCellIgnoreECs */
    );
    write_record(ba, 649, write_BrtCellIgnoreEC(safe_decode_range(ws["!ref"])));
    write_record(
      ba,
      650
      /* BrtEndCellIgnoreECs */
    );
  }
  function write_HLINKS(ba, ws, rels) {
    ws["!links"].forEach(function(l) {
      if (!l[1].Target) return;
      var rId = add_rels(rels, -1, l[1].Target.replace(/#.*$/, ""), RELS.HLINK);
      write_record(ba, 494, write_BrtHLink(l, rId));
    });
    delete ws["!links"];
  }
  function write_LEGACYDRAWING(ba, ws, idx, rels) {
    if (ws["!comments"].length > 0) {
      var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
      write_record(ba, 551, write_RelID("rId" + rId));
      ws["!legacy"] = rId;
    }
  }
  function write_AUTOFILTER(ba, ws, wb, idx) {
    if (!ws["!autofilter"]) return;
    var data = ws["!autofilter"];
    var ref = typeof data.ref === "string" ? data.ref : encode_range(data.ref);
    if (!wb.Workbook) wb.Workbook = { Sheets: [] };
    if (!wb.Workbook.Names) wb.Workbook.Names = [];
    var names = wb.Workbook.Names;
    var range = decode_range(ref);
    if (range.s.r == range.e.r) {
      range.e.r = decode_range(ws["!ref"]).e.r;
      ref = encode_range(range);
    }
    for (var i = 0; i < names.length; ++i) {
      var name = names[i];
      if (name.Name != "_xlnm._FilterDatabase") continue;
      if (name.Sheet != idx) continue;
      name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref;
      break;
    }
    if (i == names.length) names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref });
    write_record(ba, 161, write_UncheckedRfX(safe_decode_range(ref)));
    write_record(
      ba,
      162
      /* BrtEndAFilter */
    );
  }
  function write_WSVIEWS2(ba, ws, Workbook) {
    write_record(
      ba,
      133
      /* BrtBeginWsViews */
    );
    {
      write_record(ba, 137, write_BrtBeginWsView(ws, Workbook));
      write_record(
        ba,
        138
        /* BrtEndWsView */
      );
    }
    write_record(
      ba,
      134
      /* BrtEndWsViews */
    );
  }
  function write_WSFMTINFO() {
  }
  function write_SHEETPROTECT(ba, ws) {
    if (!ws["!protect"]) return;
    write_record(ba, 535, write_BrtSheetProtection(ws["!protect"]));
  }
  function write_ws_bin(idx, opts, wb, rels) {
    var ba = buf_array();
    var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
    var c = s;
    try {
      if (wb && wb.Workbook) c = wb.Workbook.Sheets[idx].CodeName || c;
    } catch (e) {
    }
    var r = safe_decode_range(ws["!ref"] || "A1");
    if (r.e.c > 16383 || r.e.r > 1048575) {
      if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
      r.e.c = Math.min(r.e.c, 16383);
      r.e.r = Math.min(r.e.c, 1048575);
    }
    ws["!links"] = [];
    ws["!comments"] = [];
    write_record(
      ba,
      129
      /* BrtBeginSheet */
    );
    if (wb.vbaraw || ws["!outline"]) write_record(ba, 147, write_BrtWsProp(c, ws["!outline"]));
    write_record(ba, 148, write_BrtWsDim(r));
    write_WSVIEWS2(ba, ws, wb.Workbook);
    write_WSFMTINFO(ba, ws);
    write_COLINFOS(ba, ws, idx, opts, wb);
    write_CELLTABLE(ba, ws, idx, opts, wb);
    write_SHEETPROTECT(ba, ws);
    write_AUTOFILTER(ba, ws, wb, idx);
    write_MERGECELLS(ba, ws);
    write_HLINKS(ba, ws, rels);
    if (ws["!margins"]) write_record(ba, 476, write_BrtMargins(ws["!margins"]));
    if (!opts || opts.ignoreEC || opts.ignoreEC == void 0) write_IGNOREECS(ba, ws);
    write_LEGACYDRAWING(ba, ws, idx, rels);
    write_record(
      ba,
      130
      /* BrtEndSheet */
    );
    return ba.end();
  }
  function parse_BrtCsProp(data, length) {
    data.l += 10;
    var name = parse_XLWideString(data, length - 10);
    return { name };
  }
  var WBPropsDef = [
    ["allowRefreshQuery", false, "bool"],
    ["autoCompressPictures", true, "bool"],
    ["backupFile", false, "bool"],
    ["checkCompatibility", false, "bool"],
    ["CodeName", ""],
    ["date1904", false, "bool"],
    ["defaultThemeVersion", 0, "int"],
    ["filterPrivacy", false, "bool"],
    ["hidePivotFieldList", false, "bool"],
    ["promptedSolutions", false, "bool"],
    ["publishItems", false, "bool"],
    ["refreshAllConnections", false, "bool"],
    ["saveExternalLinkValues", true, "bool"],
    ["showBorderUnselectedTables", true, "bool"],
    ["showInkAnnotation", true, "bool"],
    ["showObjects", "all"],
    ["showPivotChartFilter", false, "bool"],
    ["updateLinks", "userSet"]
  ];
  function safe1904(wb) {
    if (!wb.Workbook) return "false";
    if (!wb.Workbook.WBProps) return "false";
    return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";
  }
  var badchars = /* @__PURE__ */ "][*?/\\".split("");
  function check_ws_name(n, safe) {
    if (n.length > 31) {
      if (safe) return false;
      throw new Error("Sheet names cannot exceed 31 chars");
    }
    var _good = true;
    badchars.forEach(function(c) {
      if (n.indexOf(c) == -1) return;
      if (!safe) throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
      _good = false;
    });
    return _good;
  }
  function check_wb_names(N, S, codes) {
    N.forEach(function(n, i) {
      check_ws_name(n);
      for (var j = 0; j < i; ++j) if (n == N[j]) throw new Error("Duplicate Sheet Name: " + n);
      if (codes) {
        var cn = S && S[i] && S[i].CodeName || n;
        if (cn.charCodeAt(0) == 95 && cn.length > 22) throw new Error("Bad Code Name: Worksheet" + cn);
      }
    });
  }
  function check_wb(wb) {
    if (!wb || !wb.SheetNames || !wb.Sheets) throw new Error("Invalid Workbook");
    if (!wb.SheetNames.length) throw new Error("Workbook is empty");
    var Sheets = wb.Workbook && wb.Workbook.Sheets || [];
    check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);
    for (var i = 0; i < wb.SheetNames.length; ++i) check_ws(wb.Sheets[wb.SheetNames[i]], wb.SheetNames[i], i);
  }
  function write_wb_xml(wb) {
    var o = [XML_HEADER];
    o[o.length] = writextag("workbook", null, {
      "xmlns": XMLNS_main[0],
      //'xmlns:mx': XMLNS.mx,
      //'xmlns:s': XMLNS_main[0],
      "xmlns:r": XMLNS.r
    });
    var write_names = wb.Workbook && (wb.Workbook.Names || []).length > 0;
    var workbookPr = { codeName: "ThisWorkbook" };
    if (wb.Workbook && wb.Workbook.WBProps) {
      WBPropsDef.forEach(function(x) {
        if (wb.Workbook.WBProps[x[0]] == null) return;
        if (wb.Workbook.WBProps[x[0]] == x[1]) return;
        workbookPr[x[0]] = wb.Workbook.WBProps[x[0]];
      });
      if (wb.Workbook.WBProps.CodeName) {
        workbookPr.codeName = wb.Workbook.WBProps.CodeName;
        delete workbookPr.CodeName;
      }
    }
    o[o.length] = writextag("workbookPr", null, workbookPr);
    var sheets = wb.Workbook && wb.Workbook.Sheets || [];
    var i = 0;
    if (sheets && sheets[0] && !!sheets[0].Hidden) {
      o[o.length] = "<bookViews>";
      for (i = 0; i != wb.SheetNames.length; ++i) {
        if (!sheets[i]) break;
        if (!sheets[i].Hidden) break;
      }
      if (i == wb.SheetNames.length) i = 0;
      o[o.length] = '<workbookView firstSheet="' + i + '" activeTab="' + i + '"/>';
      o[o.length] = "</bookViews>";
    }
    o[o.length] = "<sheets>";
    for (i = 0; i != wb.SheetNames.length; ++i) {
      var sht = { name: escapexml(wb.SheetNames[i].slice(0, 31)) };
      sht.sheetId = "" + (i + 1);
      sht["r:id"] = "rId" + (i + 1);
      if (sheets[i]) switch (sheets[i].Hidden) {
        case 1:
          sht.state = "hidden";
          break;
        case 2:
          sht.state = "veryHidden";
          break;
      }
      o[o.length] = writextag("sheet", null, sht);
    }
    o[o.length] = "</sheets>";
    if (write_names) {
      o[o.length] = "<definedNames>";
      if (wb.Workbook && wb.Workbook.Names) wb.Workbook.Names.forEach(function(n) {
        var d = { name: n.Name };
        if (n.Comment) d.comment = n.Comment;
        if (n.Sheet != null) d.localSheetId = "" + n.Sheet;
        if (n.Hidden) d.hidden = "1";
        if (!n.Ref) return;
        o[o.length] = writextag("definedName", escapexml(n.Ref), d);
      });
      o[o.length] = "</definedNames>";
    }
    if (o.length > 2) {
      o[o.length] = "</workbook>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function parse_BrtBundleSh(data, length) {
    var z = {};
    z.Hidden = data.read_shift(4);
    z.iTabID = data.read_shift(4);
    z.strRelID = parse_RelID(data, length - 8);
    z.name = parse_XLWideString(data);
    return z;
  }
  function write_BrtBundleSh(data, o) {
    if (!o) o = new_buf(127);
    o.write_shift(4, data.Hidden);
    o.write_shift(4, data.iTabID);
    write_RelID(data.strRelID, o);
    write_XLWideString(data.name.slice(0, 31), o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_BrtWbProp(data, length) {
    var o = {};
    var flags = data.read_shift(4);
    o.defaultThemeVersion = data.read_shift(4);
    var strName = length > 8 ? parse_XLWideString(data) : "";
    if (strName.length > 0) o.CodeName = strName;
    o.autoCompressPictures = !!(flags & 65536);
    o.backupFile = !!(flags & 64);
    o.checkCompatibility = !!(flags & 4096);
    o.date1904 = !!(flags & 1);
    o.filterPrivacy = !!(flags & 8);
    o.hidePivotFieldList = !!(flags & 1024);
    o.promptedSolutions = !!(flags & 16);
    o.publishItems = !!(flags & 2048);
    o.refreshAllConnections = !!(flags & 262144);
    o.saveExternalLinkValues = !!(flags & 128);
    o.showBorderUnselectedTables = !!(flags & 4);
    o.showInkAnnotation = !!(flags & 32);
    o.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
    o.showPivotChartFilter = !!(flags & 32768);
    o.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
    return o;
  }
  function write_BrtWbProp(data, o) {
    if (!o) o = new_buf(72);
    var flags = 0;
    if (data) {
      if (data.filterPrivacy) flags |= 8;
    }
    o.write_shift(4, flags);
    o.write_shift(4, 0);
    write_XLSBCodeName(data && data.CodeName || "ThisWorkbook", o);
    return o.slice(0, o.l);
  }
  function parse_BrtName(data, length, opts) {
    var end = data.l + length;
    data.l += 4;
    data.l += 1;
    var itab = data.read_shift(4);
    var name = parse_XLNameWideString(data);
    var formula = parse_XLSBNameParsedFormula(data, 0, opts);
    var comment = parse_XLNullableWideString(data);
    data.l = end;
    var out = { Name: name, Ptg: formula };
    if (itab < 268435455) out.Sheet = itab;
    if (comment) out.Comment = comment;
    return out;
  }
  function write_BUNDLESHS(ba, wb) {
    write_record(
      ba,
      143
      /* BrtBeginBundleShs */
    );
    for (var idx = 0; idx != wb.SheetNames.length; ++idx) {
      var viz = wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx] && wb.Workbook.Sheets[idx].Hidden || 0;
      var d = { Hidden: viz, iTabID: idx + 1, strRelID: "rId" + (idx + 1), name: wb.SheetNames[idx] };
      write_record(ba, 156, write_BrtBundleSh(d));
    }
    write_record(
      ba,
      144
      /* BrtEndBundleShs */
    );
  }
  function write_BrtFileVersion(data, o) {
    if (!o) o = new_buf(127);
    for (var i = 0; i != 4; ++i) o.write_shift(4, 0);
    write_XLWideString("SheetJS", o);
    write_XLWideString(XLSX.version, o);
    write_XLWideString(XLSX.version, o);
    write_XLWideString("7262", o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_BrtBookView(idx, o) {
    if (!o) o = new_buf(29);
    o.write_shift(-4, 0);
    o.write_shift(-4, 460);
    o.write_shift(4, 28800);
    o.write_shift(4, 17600);
    o.write_shift(4, 500);
    o.write_shift(4, idx);
    o.write_shift(4, idx);
    var flags = 120;
    o.write_shift(1, flags);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_BOOKVIEWS(ba, wb) {
    if (!wb.Workbook || !wb.Workbook.Sheets) return;
    var sheets = wb.Workbook.Sheets;
    var i = 0, vistab = -1, hidden = -1;
    for (; i < sheets.length; ++i) {
      if (!sheets[i] || !sheets[i].Hidden && vistab == -1) vistab = i;
      else if (sheets[i].Hidden == 1 && hidden == -1) hidden = i;
    }
    if (hidden > vistab) return;
    write_record(
      ba,
      135
      /* BrtBeginBookViews */
    );
    write_record(ba, 158, write_BrtBookView(vistab));
    write_record(
      ba,
      136
      /* BrtEndBookViews */
    );
  }
  function write_wb_bin(wb, opts) {
    var ba = buf_array();
    write_record(
      ba,
      131
      /* BrtBeginBook */
    );
    write_record(ba, 128, write_BrtFileVersion());
    write_record(ba, 153, write_BrtWbProp(wb.Workbook && wb.Workbook.WBProps || null));
    write_BOOKVIEWS(ba, wb, opts);
    write_BUNDLESHS(ba, wb, opts);
    write_record(
      ba,
      132
      /* BrtEndBook */
    );
    return ba.end();
  }
  function write_wb(wb, name, opts) {
    return (name.slice(-4) === ".bin" ? write_wb_bin : write_wb_xml)(wb, opts);
  }
  function write_ws(data, name, opts, wb, rels) {
    return (name.slice(-4) === ".bin" ? write_ws_bin : write_ws_xml)(data, opts, wb, rels);
  }
  function write_sty(data, name, opts) {
    return (name.slice(-4) === ".bin" ? write_sty_bin : write_sty_xml)(data, opts);
  }
  function write_sst(data, name, opts) {
    return (name.slice(-4) === ".bin" ? write_sst_bin : write_sst_xml)(data, opts);
  }
  function write_cmnt(data, name, opts) {
    return (name.slice(-4) === ".bin" ? write_comments_bin : write_comments_xml)(data, opts);
  }
  function write_xlmeta(name) {
    return (name.slice(-4) === ".bin" ? write_xlmeta_bin : write_xlmeta_xml)();
  }
  function write_props_xlml(wb, opts) {
    var o = [];
    if (wb.Props) o.push(xlml_write_docprops(wb.Props, opts));
    if (wb.Custprops) o.push(xlml_write_custprops(wb.Props, wb.Custprops, opts));
    return o.join("");
  }
  function write_wb_xlml() {
    return "";
  }
  function write_sty_xlml(wb, opts) {
    var styles = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
    opts.cellXfs.forEach(function(xf, id) {
      var payload = [];
      payload.push(writextag("NumberFormat", null, { "ss:Format": escapexml(table_fmt[xf.numFmtId]) }));
      var o = (
        /*::(*/
        { "ss:ID": "s" + (21 + id) }
      );
      styles.push(writextag("Style", payload.join(""), o));
    });
    return writextag("Styles", styles.join(""));
  }
  function write_name_xlml(n) {
    return writextag("NamedRange", null, { "ss:Name": n.Name, "ss:RefersTo": "=" + a1_to_rc(n.Ref, { r: 0, c: 0 }) });
  }
  function write_names_xlml(wb) {
    if (!((wb || {}).Workbook || {}).Names) return "";
    var names = wb.Workbook.Names;
    var out = [];
    for (var i = 0; i < names.length; ++i) {
      var n = names[i];
      if (n.Sheet != null) continue;
      if (n.Name.match(/^_xlfn\./)) continue;
      out.push(write_name_xlml(n));
    }
    return writextag("Names", out.join(""));
  }
  function write_ws_xlml_names(ws, opts, idx, wb) {
    if (!ws) return "";
    if (!((wb || {}).Workbook || {}).Names) return "";
    var names = wb.Workbook.Names;
    var out = [];
    for (var i = 0; i < names.length; ++i) {
      var n = names[i];
      if (n.Sheet != idx) continue;
      if (n.Name.match(/^_xlfn\./)) continue;
      out.push(write_name_xlml(n));
    }
    return out.join("");
  }
  function write_ws_xlml_wsopts(ws, opts, idx, wb) {
    if (!ws) return "";
    var o = [];
    if (ws["!margins"]) {
      o.push("<PageSetup>");
      if (ws["!margins"].header) o.push(writextag("Header", null, { "x:Margin": ws["!margins"].header }));
      if (ws["!margins"].footer) o.push(writextag("Footer", null, { "x:Margin": ws["!margins"].footer }));
      o.push(writextag("PageMargins", null, {
        "x:Bottom": ws["!margins"].bottom || "0.75",
        "x:Left": ws["!margins"].left || "0.7",
        "x:Right": ws["!margins"].right || "0.7",
        "x:Top": ws["!margins"].top || "0.75"
      }));
      o.push("</PageSetup>");
    }
    if (wb && wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx]) {
      if (wb.Workbook.Sheets[idx].Hidden) o.push(writextag("Visible", wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
      else {
        for (var i = 0; i < idx; ++i) if (wb.Workbook.Sheets[i] && !wb.Workbook.Sheets[i].Hidden) break;
        if (i == idx) o.push("<Selected/>");
      }
    }
    if (((((wb || {}).Workbook || {}).Views || [])[0] || {}).RTL) o.push("<DisplayRightToLeft/>");
    if (ws["!protect"]) {
      o.push(writetag("ProtectContents", "True"));
      if (ws["!protect"].objects) o.push(writetag("ProtectObjects", "True"));
      if (ws["!protect"].scenarios) o.push(writetag("ProtectScenarios", "True"));
      if (ws["!protect"].selectLockedCells != null && !ws["!protect"].selectLockedCells) o.push(writetag("EnableSelection", "NoSelection"));
      else if (ws["!protect"].selectUnlockedCells != null && !ws["!protect"].selectUnlockedCells) o.push(writetag("EnableSelection", "UnlockedCells"));
      [
        ["formatCells", "AllowFormatCells"],
        ["formatColumns", "AllowSizeCols"],
        ["formatRows", "AllowSizeRows"],
        ["insertColumns", "AllowInsertCols"],
        ["insertRows", "AllowInsertRows"],
        ["insertHyperlinks", "AllowInsertHyperlinks"],
        ["deleteColumns", "AllowDeleteCols"],
        ["deleteRows", "AllowDeleteRows"],
        ["sort", "AllowSort"],
        ["autoFilter", "AllowFilter"],
        ["pivotTables", "AllowUsePivotTables"]
      ].forEach(function(x) {
        if (ws["!protect"][x[0]]) o.push("<" + x[1] + "/>");
      });
    }
    if (o.length == 0) return "";
    return writextag("WorksheetOptions", o.join(""), { xmlns: XLMLNS.x });
  }
  function write_ws_xlml_comment(comments) {
    return comments.map(function(c) {
      var t = xlml_unfixstr(c.t || "");
      var d = writextag("ss:Data", t, { "xmlns": "http://www.w3.org/TR/REC-html40" });
      return writextag("Comment", d, { "ss:Author": c.a });
    }).join("");
  }
  function write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr) {
    if (!cell || cell.v == void 0 && cell.f == void 0) return "";
    var attr = {};
    if (cell.f) attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));
    if (cell.F && cell.F.slice(0, ref.length) == ref) {
      var end = decode_cell(cell.F.slice(ref.length + 1));
      attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");
    }
    if (cell.l && cell.l.Target) {
      attr["ss:HRef"] = escapexml(cell.l.Target);
      if (cell.l.Tooltip) attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);
    }
    if (ws["!merges"]) {
      var marr = ws["!merges"];
      for (var mi = 0; mi != marr.length; ++mi) {
        if (marr[mi].s.c != addr.c || marr[mi].s.r != addr.r) continue;
        if (marr[mi].e.c > marr[mi].s.c) attr["ss:MergeAcross"] = marr[mi].e.c - marr[mi].s.c;
        if (marr[mi].e.r > marr[mi].s.r) attr["ss:MergeDown"] = marr[mi].e.r - marr[mi].s.r;
      }
    }
    var t = "", p = "";
    switch (cell.t) {
      case "z":
        if (!opts.sheetStubs) return "";
        break;
      case "n":
        t = "Number";
        p = String(cell.v);
        break;
      case "b":
        t = "Boolean";
        p = cell.v ? "1" : "0";
        break;
      case "e":
        t = "Error";
        p = BErr[cell.v];
        break;
      case "d":
        t = "DateTime";
        p = new Date(cell.v).toISOString();
        if (cell.z == null) cell.z = cell.z || table_fmt[14];
        break;
      case "s":
        t = "String";
        p = escapexlml(cell.v || "");
        break;
    }
    var os = get_cell_style(opts.cellXfs, cell, opts);
    attr["ss:StyleID"] = "s" + (21 + os);
    attr["ss:Index"] = addr.c + 1;
    var _v = cell.v != null ? p : "";
    var m = cell.t == "z" ? "" : '<Data ss:Type="' + t + '">' + _v + "</Data>";
    if ((cell.c || []).length > 0) m += write_ws_xlml_comment(cell.c);
    return writextag("Cell", m, attr);
  }
  function write_ws_xlml_row(R, row) {
    var o = '<Row ss:Index="' + (R + 1) + '"';
    if (row) {
      if (row.hpt && !row.hpx) row.hpx = pt2px(row.hpt);
      if (row.hpx) o += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';
      if (row.hidden) o += ' ss:Hidden="1"';
    }
    return o + ">";
  }
  function write_ws_xlml_table(ws, opts, idx, wb) {
    if (!ws["!ref"]) return "";
    var range = safe_decode_range(ws["!ref"]);
    var marr = ws["!merges"] || [], mi = 0;
    var o = [];
    if (ws["!cols"]) ws["!cols"].forEach(function(n, i) {
      process_col(n);
      var w = !!n.width;
      var p = col_obj_w(i, n);
      var k = { "ss:Index": i + 1 };
      if (w) k["ss:Width"] = width2px(p.width);
      if (n.hidden) k["ss:Hidden"] = "1";
      o.push(writextag("Column", null, k));
    });
    var dense = Array.isArray(ws);
    for (var R = range.s.r; R <= range.e.r; ++R) {
      var row = [write_ws_xlml_row(R, (ws["!rows"] || [])[R])];
      for (var C = range.s.c; C <= range.e.c; ++C) {
        var skip = false;
        for (mi = 0; mi != marr.length; ++mi) {
          if (marr[mi].s.c > C) continue;
          if (marr[mi].s.r > R) continue;
          if (marr[mi].e.c < C) continue;
          if (marr[mi].e.r < R) continue;
          if (marr[mi].s.c != C || marr[mi].s.r != R) skip = true;
          break;
        }
        if (skip) continue;
        var addr = { r: R, c: C };
        var ref = encode_cell(addr), cell = dense ? (ws[R] || [])[C] : ws[ref];
        row.push(write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr));
      }
      row.push("</Row>");
      if (row.length > 2) o.push(row.join(""));
    }
    return o.join("");
  }
  function write_ws_xlml(idx, opts, wb) {
    var o = [];
    var s = wb.SheetNames[idx];
    var ws = wb.Sheets[s];
    var t = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";
    if (t.length > 0) o.push("<Names>" + t + "</Names>");
    t = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";
    if (t.length > 0) o.push("<Table>" + t + "</Table>");
    o.push(write_ws_xlml_wsopts(ws, opts, idx, wb));
    return o.join("");
  }
  function write_xlml(wb, opts) {
    if (!opts) opts = {};
    if (!wb.SSF) wb.SSF = dup(table_fmt);
    if (wb.SSF) {
      make_ssf();
      SSF_load_table(wb.SSF);
      opts.revssf = evert_num(wb.SSF);
      opts.revssf[wb.SSF[65535]] = 0;
      opts.ssf = wb.SSF;
      opts.cellXfs = [];
      get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
    }
    var d = [];
    d.push(write_props_xlml(wb, opts));
    d.push(write_wb_xlml(wb, opts));
    d.push("");
    d.push("");
    for (var i = 0; i < wb.SheetNames.length; ++i)
      d.push(writextag("Worksheet", write_ws_xlml(i, opts, wb), { "ss:Name": escapexml(wb.SheetNames[i]) }));
    d[2] = write_sty_xlml(wb, opts);
    d[3] = write_names_xlml(wb, opts);
    return XML_HEADER + writextag("Workbook", d.join(""), {
      "xmlns": XLMLNS.ss,
      "xmlns:o": XLMLNS.o,
      "xmlns:x": XLMLNS.x,
      "xmlns:ss": XLMLNS.ss,
      "xmlns:dt": XLMLNS.dt,
      "xmlns:html": XLMLNS.html
    });
  }
  var PSCLSID = {
    SI: "e0859ff2f94f6810ab9108002b27b3d9",
    DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
    UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
  };
  function write_xls_props(wb, cfb) {
    var DSEntries = [], SEntries = [], CEntries = [];
    var i = 0, Keys;
    var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");
    var SummaryRE = evert_key(SummaryPIDSI, "n");
    if (wb.Props) {
      Keys = keys(wb.Props);
      for (i = 0; i < Keys.length; ++i) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Props[Keys[i]]]);
    }
    if (wb.Custprops) {
      Keys = keys(wb.Custprops);
      for (i = 0; i < Keys.length; ++i) if (!Object.prototype.hasOwnProperty.call(wb.Props || {}, Keys[i])) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Custprops[Keys[i]]]);
    }
    var CEntries2 = [];
    for (i = 0; i < CEntries.length; ++i) {
      if (XLSPSSkip.indexOf(CEntries[i][0]) > -1 || PseudoPropsPairs.indexOf(CEntries[i][0]) > -1) continue;
      if (CEntries[i][1] == null) continue;
      CEntries2.push(CEntries[i]);
    }
    if (SEntries.length) CFB.utils.cfb_add(cfb, "/SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));
    if (DSEntries.length || CEntries2.length) CFB.utils.cfb_add(cfb, "/DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));
  }
  function write_xlscfb(wb, opts) {
    var o = opts || {};
    var cfb = CFB.utils.cfb_new({ root: "R" });
    var wbpath = "/Workbook";
    switch (o.bookType || "xls") {
      case "xls":
        o.bookType = "biff8";
      /* falls through */
      case "xla":
        if (!o.bookType) o.bookType = "xla";
      /* falls through */
      case "biff8":
        wbpath = "/Workbook";
        o.biff = 8;
        break;
      case "biff5":
        wbpath = "/Book";
        o.biff = 5;
        break;
      default:
        throw new Error("invalid type " + o.bookType + " for XLS CFB");
    }
    CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o));
    if (o.biff == 8 && (wb.Props || wb.Custprops)) write_xls_props(wb, cfb);
    if (o.biff == 8 && wb.vbaraw) fill_vba_xls(cfb, CFB.read(wb.vbaraw, { type: typeof wb.vbaraw == "string" ? "binary" : "buffer" }));
    return cfb;
  }
  var XLSBRecordEnum = {
    /*::[*/
    0: {
      /* n:"BrtRowHdr", */
      f: parse_BrtRowHdr
    },
    /*::[*/
    1: {
      /* n:"BrtCellBlank", */
      f: parse_BrtCellBlank
    },
    /*::[*/
    2: {
      /* n:"BrtCellRk", */
      f: parse_BrtCellRk
    },
    /*::[*/
    3: {
      /* n:"BrtCellError", */
      f: parse_BrtCellError
    },
    /*::[*/
    4: {
      /* n:"BrtCellBool", */
      f: parse_BrtCellBool
    },
    /*::[*/
    5: {
      /* n:"BrtCellReal", */
      f: parse_BrtCellReal
    },
    /*::[*/
    6: {
      /* n:"BrtCellSt", */
      f: parse_BrtCellSt
    },
    /*::[*/
    7: {
      /* n:"BrtCellIsst", */
      f: parse_BrtCellIsst
    },
    /*::[*/
    8: {
      /* n:"BrtFmlaString", */
      f: parse_BrtFmlaString
    },
    /*::[*/
    9: {
      /* n:"BrtFmlaNum", */
      f: parse_BrtFmlaNum
    },
    /*::[*/
    10: {
      /* n:"BrtFmlaBool", */
      f: parse_BrtFmlaBool
    },
    /*::[*/
    11: {
      /* n:"BrtFmlaError", */
      f: parse_BrtFmlaError
    },
    /*::[*/
    12: {
      /* n:"BrtShortBlank", */
      f: parse_BrtShortBlank
    },
    /*::[*/
    13: {
      /* n:"BrtShortRk", */
      f: parse_BrtShortRk
    },
    /*::[*/
    14: {
      /* n:"BrtShortError", */
      f: parse_BrtShortError
    },
    /*::[*/
    15: {
      /* n:"BrtShortBool", */
      f: parse_BrtShortBool
    },
    /*::[*/
    16: {
      /* n:"BrtShortReal", */
      f: parse_BrtShortReal
    },
    /*::[*/
    17: {
      /* n:"BrtShortSt", */
      f: parse_BrtShortSt
    },
    /*::[*/
    18: {
      /* n:"BrtShortIsst", */
      f: parse_BrtShortIsst
    },
    /*::[*/
    19: {
      /* n:"BrtSSTItem", */
      f: parse_RichStr
    },
    /*::[*/
    20: {
      /* n:"BrtPCDIMissing" */
    },
    /*::[*/
    21: {
      /* n:"BrtPCDINumber" */
    },
    /*::[*/
    22: {
      /* n:"BrtPCDIBoolean" */
    },
    /*::[*/
    23: {
      /* n:"BrtPCDIError" */
    },
    /*::[*/
    24: {
      /* n:"BrtPCDIString" */
    },
    /*::[*/
    25: {
      /* n:"BrtPCDIDatetime" */
    },
    /*::[*/
    26: {
      /* n:"BrtPCDIIndex" */
    },
    /*::[*/
    27: {
      /* n:"BrtPCDIAMissing" */
    },
    /*::[*/
    28: {
      /* n:"BrtPCDIANumber" */
    },
    /*::[*/
    29: {
      /* n:"BrtPCDIABoolean" */
    },
    /*::[*/
    30: {
      /* n:"BrtPCDIAError" */
    },
    /*::[*/
    31: {
      /* n:"BrtPCDIAString" */
    },
    /*::[*/
    32: {
      /* n:"BrtPCDIADatetime" */
    },
    /*::[*/
    33: {
      /* n:"BrtPCRRecord" */
    },
    /*::[*/
    34: {
      /* n:"BrtPCRRecordDt" */
    },
    /*::[*/
    35: {
      /* n:"BrtFRTBegin", */
      T: 1
    },
    /*::[*/
    36: {
      /* n:"BrtFRTEnd", */
      T: -1
    },
    /*::[*/
    37: {
      /* n:"BrtACBegin", */
      T: 1
    },
    /*::[*/
    38: {
      /* n:"BrtACEnd", */
      T: -1
    },
    /*::[*/
    39: {
      /* n:"BrtName", */
      f: parse_BrtName
    },
    /*::[*/
    40: {
      /* n:"BrtIndexRowBlock" */
    },
    /*::[*/
    42: {
      /* n:"BrtIndexBlock" */
    },
    /*::[*/
    43: {
      /* n:"BrtFont", */
      f: parse_BrtFont
    },
    /*::[*/
    44: {
      /* n:"BrtFmt", */
      f: parse_BrtFmt
    },
    /*::[*/
    45: {
      /* n:"BrtFill", */
      f: parse_BrtFill
    },
    /*::[*/
    46: {
      /* n:"BrtBorder", */
      f: parse_BrtBorder
    },
    /*::[*/
    47: {
      /* n:"BrtXF", */
      f: parse_BrtXF
    },
    /*::[*/
    48: {
      /* n:"BrtStyle" */
    },
    /*::[*/
    49: {
      /* n:"BrtCellMeta", */
      f: parse_Int32LE
    },
    /*::[*/
    50: {
      /* n:"BrtValueMeta" */
    },
    /*::[*/
    51: {
      /* n:"BrtMdb" */
      f: parse_BrtMdb
    },
    /*::[*/
    52: {
      /* n:"BrtBeginFmd", */
      T: 1
    },
    /*::[*/
    53: {
      /* n:"BrtEndFmd", */
      T: -1
    },
    /*::[*/
    54: {
      /* n:"BrtBeginMdx", */
      T: 1
    },
    /*::[*/
    55: {
      /* n:"BrtEndMdx", */
      T: -1
    },
    /*::[*/
    56: {
      /* n:"BrtBeginMdxTuple", */
      T: 1
    },
    /*::[*/
    57: {
      /* n:"BrtEndMdxTuple", */
      T: -1
    },
    /*::[*/
    58: {
      /* n:"BrtMdxMbrIstr" */
    },
    /*::[*/
    59: {
      /* n:"BrtStr" */
    },
    /*::[*/
    60: {
      /* n:"BrtColInfo", */
      f: parse_ColInfo
    },
    /*::[*/
    62: {
      /* n:"BrtCellRString", */
      f: parse_BrtCellRString
    },
    /*::[*/
    63: {
      /* n:"BrtCalcChainItem$", */
      f: parse_BrtCalcChainItem$
    },
    /*::[*/
    64: {
      /* n:"BrtDVal", */
      f: parse_BrtDVal
    },
    /*::[*/
    65: {
      /* n:"BrtSxvcellNum" */
    },
    /*::[*/
    66: {
      /* n:"BrtSxvcellStr" */
    },
    /*::[*/
    67: {
      /* n:"BrtSxvcellBool" */
    },
    /*::[*/
    68: {
      /* n:"BrtSxvcellErr" */
    },
    /*::[*/
    69: {
      /* n:"BrtSxvcellDate" */
    },
    /*::[*/
    70: {
      /* n:"BrtSxvcellNil" */
    },
    /*::[*/
    128: {
      /* n:"BrtFileVersion" */
    },
    /*::[*/
    129: {
      /* n:"BrtBeginSheet", */
      T: 1
    },
    /*::[*/
    130: {
      /* n:"BrtEndSheet", */
      T: -1
    },
    /*::[*/
    131: {
      /* n:"BrtBeginBook", */
      T: 1,
      f: parsenoop,
      p: 0
    },
    /*::[*/
    132: {
      /* n:"BrtEndBook", */
      T: -1
    },
    /*::[*/
    133: {
      /* n:"BrtBeginWsViews", */
      T: 1
    },
    /*::[*/
    134: {
      /* n:"BrtEndWsViews", */
      T: -1
    },
    /*::[*/
    135: {
      /* n:"BrtBeginBookViews", */
      T: 1
    },
    /*::[*/
    136: {
      /* n:"BrtEndBookViews", */
      T: -1
    },
    /*::[*/
    137: {
      /* n:"BrtBeginWsView", */
      T: 1,
      f: parse_BrtBeginWsView
    },
    /*::[*/
    138: {
      /* n:"BrtEndWsView", */
      T: -1
    },
    /*::[*/
    139: {
      /* n:"BrtBeginCsViews", */
      T: 1
    },
    /*::[*/
    140: {
      /* n:"BrtEndCsViews", */
      T: -1
    },
    /*::[*/
    141: {
      /* n:"BrtBeginCsView", */
      T: 1
    },
    /*::[*/
    142: {
      /* n:"BrtEndCsView", */
      T: -1
    },
    /*::[*/
    143: {
      /* n:"BrtBeginBundleShs", */
      T: 1
    },
    /*::[*/
    144: {
      /* n:"BrtEndBundleShs", */
      T: -1
    },
    /*::[*/
    145: {
      /* n:"BrtBeginSheetData", */
      T: 1
    },
    /*::[*/
    146: {
      /* n:"BrtEndSheetData", */
      T: -1
    },
    /*::[*/
    147: {
      /* n:"BrtWsProp", */
      f: parse_BrtWsProp
    },
    /*::[*/
    148: {
      /* n:"BrtWsDim", */
      f: parse_BrtWsDim,
      p: 16
    },
    /*::[*/
    151: {
      /* n:"BrtPane", */
      f: parse_BrtPane
    },
    /*::[*/
    152: {
      /* n:"BrtSel" */
    },
    /*::[*/
    153: {
      /* n:"BrtWbProp", */
      f: parse_BrtWbProp
    },
    /*::[*/
    154: {
      /* n:"BrtWbFactoid" */
    },
    /*::[*/
    155: {
      /* n:"BrtFileRecover" */
    },
    /*::[*/
    156: {
      /* n:"BrtBundleSh", */
      f: parse_BrtBundleSh
    },
    /*::[*/
    157: {
      /* n:"BrtCalcProp" */
    },
    /*::[*/
    158: {
      /* n:"BrtBookView" */
    },
    /*::[*/
    159: {
      /* n:"BrtBeginSst", */
      T: 1,
      f: parse_BrtBeginSst
    },
    /*::[*/
    160: {
      /* n:"BrtEndSst", */
      T: -1
    },
    /*::[*/
    161: {
      /* n:"BrtBeginAFilter", */
      T: 1,
      f: parse_UncheckedRfX
    },
    /*::[*/
    162: {
      /* n:"BrtEndAFilter", */
      T: -1
    },
    /*::[*/
    163: {
      /* n:"BrtBeginFilterColumn", */
      T: 1
    },
    /*::[*/
    164: {
      /* n:"BrtEndFilterColumn", */
      T: -1
    },
    /*::[*/
    165: {
      /* n:"BrtBeginFilters", */
      T: 1
    },
    /*::[*/
    166: {
      /* n:"BrtEndFilters", */
      T: -1
    },
    /*::[*/
    167: {
      /* n:"BrtFilter" */
    },
    /*::[*/
    168: {
      /* n:"BrtColorFilter" */
    },
    /*::[*/
    169: {
      /* n:"BrtIconFilter" */
    },
    /*::[*/
    170: {
      /* n:"BrtTop10Filter" */
    },
    /*::[*/
    171: {
      /* n:"BrtDynamicFilter" */
    },
    /*::[*/
    172: {
      /* n:"BrtBeginCustomFilters", */
      T: 1
    },
    /*::[*/
    173: {
      /* n:"BrtEndCustomFilters", */
      T: -1
    },
    /*::[*/
    174: {
      /* n:"BrtCustomFilter" */
    },
    /*::[*/
    175: {
      /* n:"BrtAFilterDateGroupItem" */
    },
    /*::[*/
    176: {
      /* n:"BrtMergeCell", */
      f: parse_BrtMergeCell
    },
    /*::[*/
    177: {
      /* n:"BrtBeginMergeCells", */
      T: 1
    },
    /*::[*/
    178: {
      /* n:"BrtEndMergeCells", */
      T: -1
    },
    /*::[*/
    179: {
      /* n:"BrtBeginPivotCacheDef", */
      T: 1
    },
    /*::[*/
    180: {
      /* n:"BrtEndPivotCacheDef", */
      T: -1
    },
    /*::[*/
    181: {
      /* n:"BrtBeginPCDFields", */
      T: 1
    },
    /*::[*/
    182: {
      /* n:"BrtEndPCDFields", */
      T: -1
    },
    /*::[*/
    183: {
      /* n:"BrtBeginPCDField", */
      T: 1
    },
    /*::[*/
    184: {
      /* n:"BrtEndPCDField", */
      T: -1
    },
    /*::[*/
    185: {
      /* n:"BrtBeginPCDSource", */
      T: 1
    },
    /*::[*/
    186: {
      /* n:"BrtEndPCDSource", */
      T: -1
    },
    /*::[*/
    187: {
      /* n:"BrtBeginPCDSRange", */
      T: 1
    },
    /*::[*/
    188: {
      /* n:"BrtEndPCDSRange", */
      T: -1
    },
    /*::[*/
    189: {
      /* n:"BrtBeginPCDFAtbl", */
      T: 1
    },
    /*::[*/
    190: {
      /* n:"BrtEndPCDFAtbl", */
      T: -1
    },
    /*::[*/
    191: {
      /* n:"BrtBeginPCDIRun", */
      T: 1
    },
    /*::[*/
    192: {
      /* n:"BrtEndPCDIRun", */
      T: -1
    },
    /*::[*/
    193: {
      /* n:"BrtBeginPivotCacheRecords", */
      T: 1
    },
    /*::[*/
    194: {
      /* n:"BrtEndPivotCacheRecords", */
      T: -1
    },
    /*::[*/
    195: {
      /* n:"BrtBeginPCDHierarchies", */
      T: 1
    },
    /*::[*/
    196: {
      /* n:"BrtEndPCDHierarchies", */
      T: -1
    },
    /*::[*/
    197: {
      /* n:"BrtBeginPCDHierarchy", */
      T: 1
    },
    /*::[*/
    198: {
      /* n:"BrtEndPCDHierarchy", */
      T: -1
    },
    /*::[*/
    199: {
      /* n:"BrtBeginPCDHFieldsUsage", */
      T: 1
    },
    /*::[*/
    200: {
      /* n:"BrtEndPCDHFieldsUsage", */
      T: -1
    },
    /*::[*/
    201: {
      /* n:"BrtBeginExtConnection", */
      T: 1
    },
    /*::[*/
    202: {
      /* n:"BrtEndExtConnection", */
      T: -1
    },
    /*::[*/
    203: {
      /* n:"BrtBeginECDbProps", */
      T: 1
    },
    /*::[*/
    204: {
      /* n:"BrtEndECDbProps", */
      T: -1
    },
    /*::[*/
    205: {
      /* n:"BrtBeginECOlapProps", */
      T: 1
    },
    /*::[*/
    206: {
      /* n:"BrtEndECOlapProps", */
      T: -1
    },
    /*::[*/
    207: {
      /* n:"BrtBeginPCDSConsol", */
      T: 1
    },
    /*::[*/
    208: {
      /* n:"BrtEndPCDSConsol", */
      T: -1
    },
    /*::[*/
    209: {
      /* n:"BrtBeginPCDSCPages", */
      T: 1
    },
    /*::[*/
    210: {
      /* n:"BrtEndPCDSCPages", */
      T: -1
    },
    /*::[*/
    211: {
      /* n:"BrtBeginPCDSCPage", */
      T: 1
    },
    /*::[*/
    212: {
      /* n:"BrtEndPCDSCPage", */
      T: -1
    },
    /*::[*/
    213: {
      /* n:"BrtBeginPCDSCPItem", */
      T: 1
    },
    /*::[*/
    214: {
      /* n:"BrtEndPCDSCPItem", */
      T: -1
    },
    /*::[*/
    215: {
      /* n:"BrtBeginPCDSCSets", */
      T: 1
    },
    /*::[*/
    216: {
      /* n:"BrtEndPCDSCSets", */
      T: -1
    },
    /*::[*/
    217: {
      /* n:"BrtBeginPCDSCSet", */
      T: 1
    },
    /*::[*/
    218: {
      /* n:"BrtEndPCDSCSet", */
      T: -1
    },
    /*::[*/
    219: {
      /* n:"BrtBeginPCDFGroup", */
      T: 1
    },
    /*::[*/
    220: {
      /* n:"BrtEndPCDFGroup", */
      T: -1
    },
    /*::[*/
    221: {
      /* n:"BrtBeginPCDFGItems", */
      T: 1
    },
    /*::[*/
    222: {
      /* n:"BrtEndPCDFGItems", */
      T: -1
    },
    /*::[*/
    223: {
      /* n:"BrtBeginPCDFGRange", */
      T: 1
    },
    /*::[*/
    224: {
      /* n:"BrtEndPCDFGRange", */
      T: -1
    },
    /*::[*/
    225: {
      /* n:"BrtBeginPCDFGDiscrete", */
      T: 1
    },
    /*::[*/
    226: {
      /* n:"BrtEndPCDFGDiscrete", */
      T: -1
    },
    /*::[*/
    227: {
      /* n:"BrtBeginPCDSDTupleCache", */
      T: 1
    },
    /*::[*/
    228: {
      /* n:"BrtEndPCDSDTupleCache", */
      T: -1
    },
    /*::[*/
    229: {
      /* n:"BrtBeginPCDSDTCEntries", */
      T: 1
    },
    /*::[*/
    230: {
      /* n:"BrtEndPCDSDTCEntries", */
      T: -1
    },
    /*::[*/
    231: {
      /* n:"BrtBeginPCDSDTCEMembers", */
      T: 1
    },
    /*::[*/
    232: {
      /* n:"BrtEndPCDSDTCEMembers", */
      T: -1
    },
    /*::[*/
    233: {
      /* n:"BrtBeginPCDSDTCEMember", */
      T: 1
    },
    /*::[*/
    234: {
      /* n:"BrtEndPCDSDTCEMember", */
      T: -1
    },
    /*::[*/
    235: {
      /* n:"BrtBeginPCDSDTCQueries", */
      T: 1
    },
    /*::[*/
    236: {
      /* n:"BrtEndPCDSDTCQueries", */
      T: -1
    },
    /*::[*/
    237: {
      /* n:"BrtBeginPCDSDTCQuery", */
      T: 1
    },
    /*::[*/
    238: {
      /* n:"BrtEndPCDSDTCQuery", */
      T: -1
    },
    /*::[*/
    239: {
      /* n:"BrtBeginPCDSDTCSets", */
      T: 1
    },
    /*::[*/
    240: {
      /* n:"BrtEndPCDSDTCSets", */
      T: -1
    },
    /*::[*/
    241: {
      /* n:"BrtBeginPCDSDTCSet", */
      T: 1
    },
    /*::[*/
    242: {
      /* n:"BrtEndPCDSDTCSet", */
      T: -1
    },
    /*::[*/
    243: {
      /* n:"BrtBeginPCDCalcItems", */
      T: 1
    },
    /*::[*/
    244: {
      /* n:"BrtEndPCDCalcItems", */
      T: -1
    },
    /*::[*/
    245: {
      /* n:"BrtBeginPCDCalcItem", */
      T: 1
    },
    /*::[*/
    246: {
      /* n:"BrtEndPCDCalcItem", */
      T: -1
    },
    /*::[*/
    247: {
      /* n:"BrtBeginPRule", */
      T: 1
    },
    /*::[*/
    248: {
      /* n:"BrtEndPRule", */
      T: -1
    },
    /*::[*/
    249: {
      /* n:"BrtBeginPRFilters", */
      T: 1
    },
    /*::[*/
    250: {
      /* n:"BrtEndPRFilters", */
      T: -1
    },
    /*::[*/
    251: {
      /* n:"BrtBeginPRFilter", */
      T: 1
    },
    /*::[*/
    252: {
      /* n:"BrtEndPRFilter", */
      T: -1
    },
    /*::[*/
    253: {
      /* n:"BrtBeginPNames", */
      T: 1
    },
    /*::[*/
    254: {
      /* n:"BrtEndPNames", */
      T: -1
    },
    /*::[*/
    255: {
      /* n:"BrtBeginPName", */
      T: 1
    },
    /*::[*/
    256: {
      /* n:"BrtEndPName", */
      T: -1
    },
    /*::[*/
    257: {
      /* n:"BrtBeginPNPairs", */
      T: 1
    },
    /*::[*/
    258: {
      /* n:"BrtEndPNPairs", */
      T: -1
    },
    /*::[*/
    259: {
      /* n:"BrtBeginPNPair", */
      T: 1
    },
    /*::[*/
    260: {
      /* n:"BrtEndPNPair", */
      T: -1
    },
    /*::[*/
    261: {
      /* n:"BrtBeginECWebProps", */
      T: 1
    },
    /*::[*/
    262: {
      /* n:"BrtEndECWebProps", */
      T: -1
    },
    /*::[*/
    263: {
      /* n:"BrtBeginEcWpTables", */
      T: 1
    },
    /*::[*/
    264: {
      /* n:"BrtEndECWPTables", */
      T: -1
    },
    /*::[*/
    265: {
      /* n:"BrtBeginECParams", */
      T: 1
    },
    /*::[*/
    266: {
      /* n:"BrtEndECParams", */
      T: -1
    },
    /*::[*/
    267: {
      /* n:"BrtBeginECParam", */
      T: 1
    },
    /*::[*/
    268: {
      /* n:"BrtEndECParam", */
      T: -1
    },
    /*::[*/
    269: {
      /* n:"BrtBeginPCDKPIs", */
      T: 1
    },
    /*::[*/
    270: {
      /* n:"BrtEndPCDKPIs", */
      T: -1
    },
    /*::[*/
    271: {
      /* n:"BrtBeginPCDKPI", */
      T: 1
    },
    /*::[*/
    272: {
      /* n:"BrtEndPCDKPI", */
      T: -1
    },
    /*::[*/
    273: {
      /* n:"BrtBeginDims", */
      T: 1
    },
    /*::[*/
    274: {
      /* n:"BrtEndDims", */
      T: -1
    },
    /*::[*/
    275: {
      /* n:"BrtBeginDim", */
      T: 1
    },
    /*::[*/
    276: {
      /* n:"BrtEndDim", */
      T: -1
    },
    /*::[*/
    277: {
      /* n:"BrtIndexPartEnd" */
    },
    /*::[*/
    278: {
      /* n:"BrtBeginStyleSheet", */
      T: 1
    },
    /*::[*/
    279: {
      /* n:"BrtEndStyleSheet", */
      T: -1
    },
    /*::[*/
    280: {
      /* n:"BrtBeginSXView", */
      T: 1
    },
    /*::[*/
    281: {
      /* n:"BrtEndSXVI", */
      T: -1
    },
    /*::[*/
    282: {
      /* n:"BrtBeginSXVI", */
      T: 1
    },
    /*::[*/
    283: {
      /* n:"BrtBeginSXVIs", */
      T: 1
    },
    /*::[*/
    284: {
      /* n:"BrtEndSXVIs", */
      T: -1
    },
    /*::[*/
    285: {
      /* n:"BrtBeginSXVD", */
      T: 1
    },
    /*::[*/
    286: {
      /* n:"BrtEndSXVD", */
      T: -1
    },
    /*::[*/
    287: {
      /* n:"BrtBeginSXVDs", */
      T: 1
    },
    /*::[*/
    288: {
      /* n:"BrtEndSXVDs", */
      T: -1
    },
    /*::[*/
    289: {
      /* n:"BrtBeginSXPI", */
      T: 1
    },
    /*::[*/
    290: {
      /* n:"BrtEndSXPI", */
      T: -1
    },
    /*::[*/
    291: {
      /* n:"BrtBeginSXPIs", */
      T: 1
    },
    /*::[*/
    292: {
      /* n:"BrtEndSXPIs", */
      T: -1
    },
    /*::[*/
    293: {
      /* n:"BrtBeginSXDI", */
      T: 1
    },
    /*::[*/
    294: {
      /* n:"BrtEndSXDI", */
      T: -1
    },
    /*::[*/
    295: {
      /* n:"BrtBeginSXDIs", */
      T: 1
    },
    /*::[*/
    296: {
      /* n:"BrtEndSXDIs", */
      T: -1
    },
    /*::[*/
    297: {
      /* n:"BrtBeginSXLI", */
      T: 1
    },
    /*::[*/
    298: {
      /* n:"BrtEndSXLI", */
      T: -1
    },
    /*::[*/
    299: {
      /* n:"BrtBeginSXLIRws", */
      T: 1
    },
    /*::[*/
    300: {
      /* n:"BrtEndSXLIRws", */
      T: -1
    },
    /*::[*/
    301: {
      /* n:"BrtBeginSXLICols", */
      T: 1
    },
    /*::[*/
    302: {
      /* n:"BrtEndSXLICols", */
      T: -1
    },
    /*::[*/
    303: {
      /* n:"BrtBeginSXFormat", */
      T: 1
    },
    /*::[*/
    304: {
      /* n:"BrtEndSXFormat", */
      T: -1
    },
    /*::[*/
    305: {
      /* n:"BrtBeginSXFormats", */
      T: 1
    },
    /*::[*/
    306: {
      /* n:"BrtEndSxFormats", */
      T: -1
    },
    /*::[*/
    307: {
      /* n:"BrtBeginSxSelect", */
      T: 1
    },
    /*::[*/
    308: {
      /* n:"BrtEndSxSelect", */
      T: -1
    },
    /*::[*/
    309: {
      /* n:"BrtBeginISXVDRws", */
      T: 1
    },
    /*::[*/
    310: {
      /* n:"BrtEndISXVDRws", */
      T: -1
    },
    /*::[*/
    311: {
      /* n:"BrtBeginISXVDCols", */
      T: 1
    },
    /*::[*/
    312: {
      /* n:"BrtEndISXVDCols", */
      T: -1
    },
    /*::[*/
    313: {
      /* n:"BrtEndSXLocation", */
      T: -1
    },
    /*::[*/
    314: {
      /* n:"BrtBeginSXLocation", */
      T: 1
    },
    /*::[*/
    315: {
      /* n:"BrtEndSXView", */
      T: -1
    },
    /*::[*/
    316: {
      /* n:"BrtBeginSXTHs", */
      T: 1
    },
    /*::[*/
    317: {
      /* n:"BrtEndSXTHs", */
      T: -1
    },
    /*::[*/
    318: {
      /* n:"BrtBeginSXTH", */
      T: 1
    },
    /*::[*/
    319: {
      /* n:"BrtEndSXTH", */
      T: -1
    },
    /*::[*/
    320: {
      /* n:"BrtBeginISXTHRws", */
      T: 1
    },
    /*::[*/
    321: {
      /* n:"BrtEndISXTHRws", */
      T: -1
    },
    /*::[*/
    322: {
      /* n:"BrtBeginISXTHCols", */
      T: 1
    },
    /*::[*/
    323: {
      /* n:"BrtEndISXTHCols", */
      T: -1
    },
    /*::[*/
    324: {
      /* n:"BrtBeginSXTDMPS", */
      T: 1
    },
    /*::[*/
    325: {
      /* n:"BrtEndSXTDMPs", */
      T: -1
    },
    /*::[*/
    326: {
      /* n:"BrtBeginSXTDMP", */
      T: 1
    },
    /*::[*/
    327: {
      /* n:"BrtEndSXTDMP", */
      T: -1
    },
    /*::[*/
    328: {
      /* n:"BrtBeginSXTHItems", */
      T: 1
    },
    /*::[*/
    329: {
      /* n:"BrtEndSXTHItems", */
      T: -1
    },
    /*::[*/
    330: {
      /* n:"BrtBeginSXTHItem", */
      T: 1
    },
    /*::[*/
    331: {
      /* n:"BrtEndSXTHItem", */
      T: -1
    },
    /*::[*/
    332: {
      /* n:"BrtBeginMetadata", */
      T: 1
    },
    /*::[*/
    333: {
      /* n:"BrtEndMetadata", */
      T: -1
    },
    /*::[*/
    334: {
      /* n:"BrtBeginEsmdtinfo", */
      T: 1
    },
    /*::[*/
    335: {
      /* n:"BrtMdtinfo", */
      f: parse_BrtMdtinfo
    },
    /*::[*/
    336: {
      /* n:"BrtEndEsmdtinfo", */
      T: -1
    },
    /*::[*/
    337: {
      /* n:"BrtBeginEsmdb", */
      f: parse_BrtBeginEsmdb,
      T: 1
    },
    /*::[*/
    338: {
      /* n:"BrtEndEsmdb", */
      T: -1
    },
    /*::[*/
    339: {
      /* n:"BrtBeginEsfmd", */
      T: 1
    },
    /*::[*/
    340: {
      /* n:"BrtEndEsfmd", */
      T: -1
    },
    /*::[*/
    341: {
      /* n:"BrtBeginSingleCells", */
      T: 1
    },
    /*::[*/
    342: {
      /* n:"BrtEndSingleCells", */
      T: -1
    },
    /*::[*/
    343: {
      /* n:"BrtBeginList", */
      T: 1
    },
    /*::[*/
    344: {
      /* n:"BrtEndList", */
      T: -1
    },
    /*::[*/
    345: {
      /* n:"BrtBeginListCols", */
      T: 1
    },
    /*::[*/
    346: {
      /* n:"BrtEndListCols", */
      T: -1
    },
    /*::[*/
    347: {
      /* n:"BrtBeginListCol", */
      T: 1
    },
    /*::[*/
    348: {
      /* n:"BrtEndListCol", */
      T: -1
    },
    /*::[*/
    349: {
      /* n:"BrtBeginListXmlCPr", */
      T: 1
    },
    /*::[*/
    350: {
      /* n:"BrtEndListXmlCPr", */
      T: -1
    },
    /*::[*/
    351: {
      /* n:"BrtListCCFmla" */
    },
    /*::[*/
    352: {
      /* n:"BrtListTrFmla" */
    },
    /*::[*/
    353: {
      /* n:"BrtBeginExternals", */
      T: 1
    },
    /*::[*/
    354: {
      /* n:"BrtEndExternals", */
      T: -1
    },
    /*::[*/
    355: {
      /* n:"BrtSupBookSrc", */
      f: parse_RelID
    },
    /*::[*/
    357: {
      /* n:"BrtSupSelf" */
    },
    /*::[*/
    358: {
      /* n:"BrtSupSame" */
    },
    /*::[*/
    359: {
      /* n:"BrtSupTabs" */
    },
    /*::[*/
    360: {
      /* n:"BrtBeginSupBook", */
      T: 1
    },
    /*::[*/
    361: {
      /* n:"BrtPlaceholderName" */
    },
    /*::[*/
    362: {
      /* n:"BrtExternSheet", */
      f: parse_ExternSheet
    },
    /*::[*/
    363: {
      /* n:"BrtExternTableStart" */
    },
    /*::[*/
    364: {
      /* n:"BrtExternTableEnd" */
    },
    /*::[*/
    366: {
      /* n:"BrtExternRowHdr" */
    },
    /*::[*/
    367: {
      /* n:"BrtExternCellBlank" */
    },
    /*::[*/
    368: {
      /* n:"BrtExternCellReal" */
    },
    /*::[*/
    369: {
      /* n:"BrtExternCellBool" */
    },
    /*::[*/
    370: {
      /* n:"BrtExternCellError" */
    },
    /*::[*/
    371: {
      /* n:"BrtExternCellString" */
    },
    /*::[*/
    372: {
      /* n:"BrtBeginEsmdx", */
      T: 1
    },
    /*::[*/
    373: {
      /* n:"BrtEndEsmdx", */
      T: -1
    },
    /*::[*/
    374: {
      /* n:"BrtBeginMdxSet", */
      T: 1
    },
    /*::[*/
    375: {
      /* n:"BrtEndMdxSet", */
      T: -1
    },
    /*::[*/
    376: {
      /* n:"BrtBeginMdxMbrProp", */
      T: 1
    },
    /*::[*/
    377: {
      /* n:"BrtEndMdxMbrProp", */
      T: -1
    },
    /*::[*/
    378: {
      /* n:"BrtBeginMdxKPI", */
      T: 1
    },
    /*::[*/
    379: {
      /* n:"BrtEndMdxKPI", */
      T: -1
    },
    /*::[*/
    380: {
      /* n:"BrtBeginEsstr", */
      T: 1
    },
    /*::[*/
    381: {
      /* n:"BrtEndEsstr", */
      T: -1
    },
    /*::[*/
    382: {
      /* n:"BrtBeginPRFItem", */
      T: 1
    },
    /*::[*/
    383: {
      /* n:"BrtEndPRFItem", */
      T: -1
    },
    /*::[*/
    384: {
      /* n:"BrtBeginPivotCacheIDs", */
      T: 1
    },
    /*::[*/
    385: {
      /* n:"BrtEndPivotCacheIDs", */
      T: -1
    },
    /*::[*/
    386: {
      /* n:"BrtBeginPivotCacheID", */
      T: 1
    },
    /*::[*/
    387: {
      /* n:"BrtEndPivotCacheID", */
      T: -1
    },
    /*::[*/
    388: {
      /* n:"BrtBeginISXVIs", */
      T: 1
    },
    /*::[*/
    389: {
      /* n:"BrtEndISXVIs", */
      T: -1
    },
    /*::[*/
    390: {
      /* n:"BrtBeginColInfos", */
      T: 1
    },
    /*::[*/
    391: {
      /* n:"BrtEndColInfos", */
      T: -1
    },
    /*::[*/
    392: {
      /* n:"BrtBeginRwBrk", */
      T: 1
    },
    /*::[*/
    393: {
      /* n:"BrtEndRwBrk", */
      T: -1
    },
    /*::[*/
    394: {
      /* n:"BrtBeginColBrk", */
      T: 1
    },
    /*::[*/
    395: {
      /* n:"BrtEndColBrk", */
      T: -1
    },
    /*::[*/
    396: {
      /* n:"BrtBrk" */
    },
    /*::[*/
    397: {
      /* n:"BrtUserBookView" */
    },
    /*::[*/
    398: {
      /* n:"BrtInfo" */
    },
    /*::[*/
    399: {
      /* n:"BrtCUsr" */
    },
    /*::[*/
    400: {
      /* n:"BrtUsr" */
    },
    /*::[*/
    401: {
      /* n:"BrtBeginUsers", */
      T: 1
    },
    /*::[*/
    403: {
      /* n:"BrtEOF" */
    },
    /*::[*/
    404: {
      /* n:"BrtUCR" */
    },
    /*::[*/
    405: {
      /* n:"BrtRRInsDel" */
    },
    /*::[*/
    406: {
      /* n:"BrtRREndInsDel" */
    },
    /*::[*/
    407: {
      /* n:"BrtRRMove" */
    },
    /*::[*/
    408: {
      /* n:"BrtRREndMove" */
    },
    /*::[*/
    409: {
      /* n:"BrtRRChgCell" */
    },
    /*::[*/
    410: {
      /* n:"BrtRREndChgCell" */
    },
    /*::[*/
    411: {
      /* n:"BrtRRHeader" */
    },
    /*::[*/
    412: {
      /* n:"BrtRRUserView" */
    },
    /*::[*/
    413: {
      /* n:"BrtRRRenSheet" */
    },
    /*::[*/
    414: {
      /* n:"BrtRRInsertSh" */
    },
    /*::[*/
    415: {
      /* n:"BrtRRDefName" */
    },
    /*::[*/
    416: {
      /* n:"BrtRRNote" */
    },
    /*::[*/
    417: {
      /* n:"BrtRRConflict" */
    },
    /*::[*/
    418: {
      /* n:"BrtRRTQSIF" */
    },
    /*::[*/
    419: {
      /* n:"BrtRRFormat" */
    },
    /*::[*/
    420: {
      /* n:"BrtRREndFormat" */
    },
    /*::[*/
    421: {
      /* n:"BrtRRAutoFmt" */
    },
    /*::[*/
    422: {
      /* n:"BrtBeginUserShViews", */
      T: 1
    },
    /*::[*/
    423: {
      /* n:"BrtBeginUserShView", */
      T: 1
    },
    /*::[*/
    424: {
      /* n:"BrtEndUserShView", */
      T: -1
    },
    /*::[*/
    425: {
      /* n:"BrtEndUserShViews", */
      T: -1
    },
    /*::[*/
    426: {
      /* n:"BrtArrFmla", */
      f: parse_BrtArrFmla
    },
    /*::[*/
    427: {
      /* n:"BrtShrFmla", */
      f: parse_BrtShrFmla
    },
    /*::[*/
    428: {
      /* n:"BrtTable" */
    },
    /*::[*/
    429: {
      /* n:"BrtBeginExtConnections", */
      T: 1
    },
    /*::[*/
    430: {
      /* n:"BrtEndExtConnections", */
      T: -1
    },
    /*::[*/
    431: {
      /* n:"BrtBeginPCDCalcMems", */
      T: 1
    },
    /*::[*/
    432: {
      /* n:"BrtEndPCDCalcMems", */
      T: -1
    },
    /*::[*/
    433: {
      /* n:"BrtBeginPCDCalcMem", */
      T: 1
    },
    /*::[*/
    434: {
      /* n:"BrtEndPCDCalcMem", */
      T: -1
    },
    /*::[*/
    435: {
      /* n:"BrtBeginPCDHGLevels", */
      T: 1
    },
    /*::[*/
    436: {
      /* n:"BrtEndPCDHGLevels", */
      T: -1
    },
    /*::[*/
    437: {
      /* n:"BrtBeginPCDHGLevel", */
      T: 1
    },
    /*::[*/
    438: {
      /* n:"BrtEndPCDHGLevel", */
      T: -1
    },
    /*::[*/
    439: {
      /* n:"BrtBeginPCDHGLGroups", */
      T: 1
    },
    /*::[*/
    440: {
      /* n:"BrtEndPCDHGLGroups", */
      T: -1
    },
    /*::[*/
    441: {
      /* n:"BrtBeginPCDHGLGroup", */
      T: 1
    },
    /*::[*/
    442: {
      /* n:"BrtEndPCDHGLGroup", */
      T: -1
    },
    /*::[*/
    443: {
      /* n:"BrtBeginPCDHGLGMembers", */
      T: 1
    },
    /*::[*/
    444: {
      /* n:"BrtEndPCDHGLGMembers", */
      T: -1
    },
    /*::[*/
    445: {
      /* n:"BrtBeginPCDHGLGMember", */
      T: 1
    },
    /*::[*/
    446: {
      /* n:"BrtEndPCDHGLGMember", */
      T: -1
    },
    /*::[*/
    447: {
      /* n:"BrtBeginQSI", */
      T: 1
    },
    /*::[*/
    448: {
      /* n:"BrtEndQSI", */
      T: -1
    },
    /*::[*/
    449: {
      /* n:"BrtBeginQSIR", */
      T: 1
    },
    /*::[*/
    450: {
      /* n:"BrtEndQSIR", */
      T: -1
    },
    /*::[*/
    451: {
      /* n:"BrtBeginDeletedNames", */
      T: 1
    },
    /*::[*/
    452: {
      /* n:"BrtEndDeletedNames", */
      T: -1
    },
    /*::[*/
    453: {
      /* n:"BrtBeginDeletedName", */
      T: 1
    },
    /*::[*/
    454: {
      /* n:"BrtEndDeletedName", */
      T: -1
    },
    /*::[*/
    455: {
      /* n:"BrtBeginQSIFs", */
      T: 1
    },
    /*::[*/
    456: {
      /* n:"BrtEndQSIFs", */
      T: -1
    },
    /*::[*/
    457: {
      /* n:"BrtBeginQSIF", */
      T: 1
    },
    /*::[*/
    458: {
      /* n:"BrtEndQSIF", */
      T: -1
    },
    /*::[*/
    459: {
      /* n:"BrtBeginAutoSortScope", */
      T: 1
    },
    /*::[*/
    460: {
      /* n:"BrtEndAutoSortScope", */
      T: -1
    },
    /*::[*/
    461: {
      /* n:"BrtBeginConditionalFormatting", */
      T: 1
    },
    /*::[*/
    462: {
      /* n:"BrtEndConditionalFormatting", */
      T: -1
    },
    /*::[*/
    463: {
      /* n:"BrtBeginCFRule", */
      T: 1
    },
    /*::[*/
    464: {
      /* n:"BrtEndCFRule", */
      T: -1
    },
    /*::[*/
    465: {
      /* n:"BrtBeginIconSet", */
      T: 1
    },
    /*::[*/
    466: {
      /* n:"BrtEndIconSet", */
      T: -1
    },
    /*::[*/
    467: {
      /* n:"BrtBeginDatabar", */
      T: 1
    },
    /*::[*/
    468: {
      /* n:"BrtEndDatabar", */
      T: -1
    },
    /*::[*/
    469: {
      /* n:"BrtBeginColorScale", */
      T: 1
    },
    /*::[*/
    470: {
      /* n:"BrtEndColorScale", */
      T: -1
    },
    /*::[*/
    471: {
      /* n:"BrtCFVO" */
    },
    /*::[*/
    472: {
      /* n:"BrtExternValueMeta" */
    },
    /*::[*/
    473: {
      /* n:"BrtBeginColorPalette", */
      T: 1
    },
    /*::[*/
    474: {
      /* n:"BrtEndColorPalette", */
      T: -1
    },
    /*::[*/
    475: {
      /* n:"BrtIndexedColor" */
    },
    /*::[*/
    476: {
      /* n:"BrtMargins", */
      f: parse_BrtMargins
    },
    /*::[*/
    477: {
      /* n:"BrtPrintOptions" */
    },
    /*::[*/
    478: {
      /* n:"BrtPageSetup" */
    },
    /*::[*/
    479: {
      /* n:"BrtBeginHeaderFooter", */
      T: 1
    },
    /*::[*/
    480: {
      /* n:"BrtEndHeaderFooter", */
      T: -1
    },
    /*::[*/
    481: {
      /* n:"BrtBeginSXCrtFormat", */
      T: 1
    },
    /*::[*/
    482: {
      /* n:"BrtEndSXCrtFormat", */
      T: -1
    },
    /*::[*/
    483: {
      /* n:"BrtBeginSXCrtFormats", */
      T: 1
    },
    /*::[*/
    484: {
      /* n:"BrtEndSXCrtFormats", */
      T: -1
    },
    /*::[*/
    485: {
      /* n:"BrtWsFmtInfo", */
      f: parse_BrtWsFmtInfo
    },
    /*::[*/
    486: {
      /* n:"BrtBeginMgs", */
      T: 1
    },
    /*::[*/
    487: {
      /* n:"BrtEndMGs", */
      T: -1
    },
    /*::[*/
    488: {
      /* n:"BrtBeginMGMaps", */
      T: 1
    },
    /*::[*/
    489: {
      /* n:"BrtEndMGMaps", */
      T: -1
    },
    /*::[*/
    490: {
      /* n:"BrtBeginMG", */
      T: 1
    },
    /*::[*/
    491: {
      /* n:"BrtEndMG", */
      T: -1
    },
    /*::[*/
    492: {
      /* n:"BrtBeginMap", */
      T: 1
    },
    /*::[*/
    493: {
      /* n:"BrtEndMap", */
      T: -1
    },
    /*::[*/
    494: {
      /* n:"BrtHLink", */
      f: parse_BrtHLink
    },
    /*::[*/
    495: {
      /* n:"BrtBeginDCon", */
      T: 1
    },
    /*::[*/
    496: {
      /* n:"BrtEndDCon", */
      T: -1
    },
    /*::[*/
    497: {
      /* n:"BrtBeginDRefs", */
      T: 1
    },
    /*::[*/
    498: {
      /* n:"BrtEndDRefs", */
      T: -1
    },
    /*::[*/
    499: {
      /* n:"BrtDRef" */
    },
    /*::[*/
    500: {
      /* n:"BrtBeginScenMan", */
      T: 1
    },
    /*::[*/
    501: {
      /* n:"BrtEndScenMan", */
      T: -1
    },
    /*::[*/
    502: {
      /* n:"BrtBeginSct", */
      T: 1
    },
    /*::[*/
    503: {
      /* n:"BrtEndSct", */
      T: -1
    },
    /*::[*/
    504: {
      /* n:"BrtSlc" */
    },
    /*::[*/
    505: {
      /* n:"BrtBeginDXFs", */
      T: 1
    },
    /*::[*/
    506: {
      /* n:"BrtEndDXFs", */
      T: -1
    },
    /*::[*/
    507: {
      /* n:"BrtDXF" */
    },
    /*::[*/
    508: {
      /* n:"BrtBeginTableStyles", */
      T: 1
    },
    /*::[*/
    509: {
      /* n:"BrtEndTableStyles", */
      T: -1
    },
    /*::[*/
    510: {
      /* n:"BrtBeginTableStyle", */
      T: 1
    },
    /*::[*/
    511: {
      /* n:"BrtEndTableStyle", */
      T: -1
    },
    /*::[*/
    512: {
      /* n:"BrtTableStyleElement" */
    },
    /*::[*/
    513: {
      /* n:"BrtTableStyleClient" */
    },
    /*::[*/
    514: {
      /* n:"BrtBeginVolDeps", */
      T: 1
    },
    /*::[*/
    515: {
      /* n:"BrtEndVolDeps", */
      T: -1
    },
    /*::[*/
    516: {
      /* n:"BrtBeginVolType", */
      T: 1
    },
    /*::[*/
    517: {
      /* n:"BrtEndVolType", */
      T: -1
    },
    /*::[*/
    518: {
      /* n:"BrtBeginVolMain", */
      T: 1
    },
    /*::[*/
    519: {
      /* n:"BrtEndVolMain", */
      T: -1
    },
    /*::[*/
    520: {
      /* n:"BrtBeginVolTopic", */
      T: 1
    },
    /*::[*/
    521: {
      /* n:"BrtEndVolTopic", */
      T: -1
    },
    /*::[*/
    522: {
      /* n:"BrtVolSubtopic" */
    },
    /*::[*/
    523: {
      /* n:"BrtVolRef" */
    },
    /*::[*/
    524: {
      /* n:"BrtVolNum" */
    },
    /*::[*/
    525: {
      /* n:"BrtVolErr" */
    },
    /*::[*/
    526: {
      /* n:"BrtVolStr" */
    },
    /*::[*/
    527: {
      /* n:"BrtVolBool" */
    },
    /*::[*/
    528: {
      /* n:"BrtBeginCalcChain$", */
      T: 1
    },
    /*::[*/
    529: {
      /* n:"BrtEndCalcChain$", */
      T: -1
    },
    /*::[*/
    530: {
      /* n:"BrtBeginSortState", */
      T: 1
    },
    /*::[*/
    531: {
      /* n:"BrtEndSortState", */
      T: -1
    },
    /*::[*/
    532: {
      /* n:"BrtBeginSortCond", */
      T: 1
    },
    /*::[*/
    533: {
      /* n:"BrtEndSortCond", */
      T: -1
    },
    /*::[*/
    534: {
      /* n:"BrtBookProtection" */
    },
    /*::[*/
    535: {
      /* n:"BrtSheetProtection" */
    },
    /*::[*/
    536: {
      /* n:"BrtRangeProtection" */
    },
    /*::[*/
    537: {
      /* n:"BrtPhoneticInfo" */
    },
    /*::[*/
    538: {
      /* n:"BrtBeginECTxtWiz", */
      T: 1
    },
    /*::[*/
    539: {
      /* n:"BrtEndECTxtWiz", */
      T: -1
    },
    /*::[*/
    540: {
      /* n:"BrtBeginECTWFldInfoLst", */
      T: 1
    },
    /*::[*/
    541: {
      /* n:"BrtEndECTWFldInfoLst", */
      T: -1
    },
    /*::[*/
    542: {
      /* n:"BrtBeginECTwFldInfo", */
      T: 1
    },
    /*::[*/
    548: {
      /* n:"BrtFileSharing" */
    },
    /*::[*/
    549: {
      /* n:"BrtOleSize" */
    },
    /*::[*/
    550: {
      /* n:"BrtDrawing", */
      f: parse_RelID
    },
    /*::[*/
    551: {
      /* n:"BrtLegacyDrawing" */
    },
    /*::[*/
    552: {
      /* n:"BrtLegacyDrawingHF" */
    },
    /*::[*/
    553: {
      /* n:"BrtWebOpt" */
    },
    /*::[*/
    554: {
      /* n:"BrtBeginWebPubItems", */
      T: 1
    },
    /*::[*/
    555: {
      /* n:"BrtEndWebPubItems", */
      T: -1
    },
    /*::[*/
    556: {
      /* n:"BrtBeginWebPubItem", */
      T: 1
    },
    /*::[*/
    557: {
      /* n:"BrtEndWebPubItem", */
      T: -1
    },
    /*::[*/
    558: {
      /* n:"BrtBeginSXCondFmt", */
      T: 1
    },
    /*::[*/
    559: {
      /* n:"BrtEndSXCondFmt", */
      T: -1
    },
    /*::[*/
    560: {
      /* n:"BrtBeginSXCondFmts", */
      T: 1
    },
    /*::[*/
    561: {
      /* n:"BrtEndSXCondFmts", */
      T: -1
    },
    /*::[*/
    562: {
      /* n:"BrtBkHim" */
    },
    /*::[*/
    564: {
      /* n:"BrtColor" */
    },
    /*::[*/
    565: {
      /* n:"BrtBeginIndexedColors", */
      T: 1
    },
    /*::[*/
    566: {
      /* n:"BrtEndIndexedColors", */
      T: -1
    },
    /*::[*/
    569: {
      /* n:"BrtBeginMRUColors", */
      T: 1
    },
    /*::[*/
    570: {
      /* n:"BrtEndMRUColors", */
      T: -1
    },
    /*::[*/
    572: {
      /* n:"BrtMRUColor" */
    },
    /*::[*/
    573: {
      /* n:"BrtBeginDVals", */
      T: 1
    },
    /*::[*/
    574: {
      /* n:"BrtEndDVals", */
      T: -1
    },
    /*::[*/
    577: {
      /* n:"BrtSupNameStart" */
    },
    /*::[*/
    578: {
      /* n:"BrtSupNameValueStart" */
    },
    /*::[*/
    579: {
      /* n:"BrtSupNameValueEnd" */
    },
    /*::[*/
    580: {
      /* n:"BrtSupNameNum" */
    },
    /*::[*/
    581: {
      /* n:"BrtSupNameErr" */
    },
    /*::[*/
    582: {
      /* n:"BrtSupNameSt" */
    },
    /*::[*/
    583: {
      /* n:"BrtSupNameNil" */
    },
    /*::[*/
    584: {
      /* n:"BrtSupNameBool" */
    },
    /*::[*/
    585: {
      /* n:"BrtSupNameFmla" */
    },
    /*::[*/
    586: {
      /* n:"BrtSupNameBits" */
    },
    /*::[*/
    587: {
      /* n:"BrtSupNameEnd" */
    },
    /*::[*/
    588: {
      /* n:"BrtEndSupBook", */
      T: -1
    },
    /*::[*/
    589: {
      /* n:"BrtCellSmartTagProperty" */
    },
    /*::[*/
    590: {
      /* n:"BrtBeginCellSmartTag", */
      T: 1
    },
    /*::[*/
    591: {
      /* n:"BrtEndCellSmartTag", */
      T: -1
    },
    /*::[*/
    592: {
      /* n:"BrtBeginCellSmartTags", */
      T: 1
    },
    /*::[*/
    593: {
      /* n:"BrtEndCellSmartTags", */
      T: -1
    },
    /*::[*/
    594: {
      /* n:"BrtBeginSmartTags", */
      T: 1
    },
    /*::[*/
    595: {
      /* n:"BrtEndSmartTags", */
      T: -1
    },
    /*::[*/
    596: {
      /* n:"BrtSmartTagType" */
    },
    /*::[*/
    597: {
      /* n:"BrtBeginSmartTagTypes", */
      T: 1
    },
    /*::[*/
    598: {
      /* n:"BrtEndSmartTagTypes", */
      T: -1
    },
    /*::[*/
    599: {
      /* n:"BrtBeginSXFilters", */
      T: 1
    },
    /*::[*/
    600: {
      /* n:"BrtEndSXFilters", */
      T: -1
    },
    /*::[*/
    601: {
      /* n:"BrtBeginSXFILTER", */
      T: 1
    },
    /*::[*/
    602: {
      /* n:"BrtEndSXFilter", */
      T: -1
    },
    /*::[*/
    603: {
      /* n:"BrtBeginFills", */
      T: 1
    },
    /*::[*/
    604: {
      /* n:"BrtEndFills", */
      T: -1
    },
    /*::[*/
    605: {
      /* n:"BrtBeginCellWatches", */
      T: 1
    },
    /*::[*/
    606: {
      /* n:"BrtEndCellWatches", */
      T: -1
    },
    /*::[*/
    607: {
      /* n:"BrtCellWatch" */
    },
    /*::[*/
    608: {
      /* n:"BrtBeginCRErrs", */
      T: 1
    },
    /*::[*/
    609: {
      /* n:"BrtEndCRErrs", */
      T: -1
    },
    /*::[*/
    610: {
      /* n:"BrtCrashRecErr" */
    },
    /*::[*/
    611: {
      /* n:"BrtBeginFonts", */
      T: 1
    },
    /*::[*/
    612: {
      /* n:"BrtEndFonts", */
      T: -1
    },
    /*::[*/
    613: {
      /* n:"BrtBeginBorders", */
      T: 1
    },
    /*::[*/
    614: {
      /* n:"BrtEndBorders", */
      T: -1
    },
    /*::[*/
    615: {
      /* n:"BrtBeginFmts", */
      T: 1
    },
    /*::[*/
    616: {
      /* n:"BrtEndFmts", */
      T: -1
    },
    /*::[*/
    617: {
      /* n:"BrtBeginCellXFs", */
      T: 1
    },
    /*::[*/
    618: {
      /* n:"BrtEndCellXFs", */
      T: -1
    },
    /*::[*/
    619: {
      /* n:"BrtBeginStyles", */
      T: 1
    },
    /*::[*/
    620: {
      /* n:"BrtEndStyles", */
      T: -1
    },
    /*::[*/
    625: {
      /* n:"BrtBigName" */
    },
    /*::[*/
    626: {
      /* n:"BrtBeginCellStyleXFs", */
      T: 1
    },
    /*::[*/
    627: {
      /* n:"BrtEndCellStyleXFs", */
      T: -1
    },
    /*::[*/
    628: {
      /* n:"BrtBeginComments", */
      T: 1
    },
    /*::[*/
    629: {
      /* n:"BrtEndComments", */
      T: -1
    },
    /*::[*/
    630: {
      /* n:"BrtBeginCommentAuthors", */
      T: 1
    },
    /*::[*/
    631: {
      /* n:"BrtEndCommentAuthors", */
      T: -1
    },
    /*::[*/
    632: {
      /* n:"BrtCommentAuthor", */
      f: parse_BrtCommentAuthor
    },
    /*::[*/
    633: {
      /* n:"BrtBeginCommentList", */
      T: 1
    },
    /*::[*/
    634: {
      /* n:"BrtEndCommentList", */
      T: -1
    },
    /*::[*/
    635: {
      /* n:"BrtBeginComment", */
      T: 1,
      f: parse_BrtBeginComment
    },
    /*::[*/
    636: {
      /* n:"BrtEndComment", */
      T: -1
    },
    /*::[*/
    637: {
      /* n:"BrtCommentText", */
      f: parse_BrtCommentText
    },
    /*::[*/
    638: {
      /* n:"BrtBeginOleObjects", */
      T: 1
    },
    /*::[*/
    639: {
      /* n:"BrtOleObject" */
    },
    /*::[*/
    640: {
      /* n:"BrtEndOleObjects", */
      T: -1
    },
    /*::[*/
    641: {
      /* n:"BrtBeginSxrules", */
      T: 1
    },
    /*::[*/
    642: {
      /* n:"BrtEndSxRules", */
      T: -1
    },
    /*::[*/
    643: {
      /* n:"BrtBeginActiveXControls", */
      T: 1
    },
    /*::[*/
    644: {
      /* n:"BrtActiveX" */
    },
    /*::[*/
    645: {
      /* n:"BrtEndActiveXControls", */
      T: -1
    },
    /*::[*/
    646: {
      /* n:"BrtBeginPCDSDTCEMembersSortBy", */
      T: 1
    },
    /*::[*/
    648: {
      /* n:"BrtBeginCellIgnoreECs", */
      T: 1
    },
    /*::[*/
    649: {
      /* n:"BrtCellIgnoreEC" */
    },
    /*::[*/
    650: {
      /* n:"BrtEndCellIgnoreECs", */
      T: -1
    },
    /*::[*/
    651: {
      /* n:"BrtCsProp", */
      f: parse_BrtCsProp
    },
    /*::[*/
    652: {
      /* n:"BrtCsPageSetup" */
    },
    /*::[*/
    653: {
      /* n:"BrtBeginUserCsViews", */
      T: 1
    },
    /*::[*/
    654: {
      /* n:"BrtEndUserCsViews", */
      T: -1
    },
    /*::[*/
    655: {
      /* n:"BrtBeginUserCsView", */
      T: 1
    },
    /*::[*/
    656: {
      /* n:"BrtEndUserCsView", */
      T: -1
    },
    /*::[*/
    657: {
      /* n:"BrtBeginPcdSFCIEntries", */
      T: 1
    },
    /*::[*/
    658: {
      /* n:"BrtEndPCDSFCIEntries", */
      T: -1
    },
    /*::[*/
    659: {
      /* n:"BrtPCDSFCIEntry" */
    },
    /*::[*/
    660: {
      /* n:"BrtBeginListParts", */
      T: 1
    },
    /*::[*/
    661: {
      /* n:"BrtListPart" */
    },
    /*::[*/
    662: {
      /* n:"BrtEndListParts", */
      T: -1
    },
    /*::[*/
    663: {
      /* n:"BrtSheetCalcProp" */
    },
    /*::[*/
    664: {
      /* n:"BrtBeginFnGroup", */
      T: 1
    },
    /*::[*/
    665: {
      /* n:"BrtFnGroup" */
    },
    /*::[*/
    666: {
      /* n:"BrtEndFnGroup", */
      T: -1
    },
    /*::[*/
    667: {
      /* n:"BrtSupAddin" */
    },
    /*::[*/
    668: {
      /* n:"BrtSXTDMPOrder" */
    },
    /*::[*/
    669: {
      /* n:"BrtCsProtection" */
    },
    /*::[*/
    671: {
      /* n:"BrtBeginWsSortMap", */
      T: 1
    },
    /*::[*/
    672: {
      /* n:"BrtEndWsSortMap", */
      T: -1
    },
    /*::[*/
    673: {
      /* n:"BrtBeginRRSort", */
      T: 1
    },
    /*::[*/
    674: {
      /* n:"BrtEndRRSort", */
      T: -1
    },
    /*::[*/
    675: {
      /* n:"BrtRRSortItem" */
    },
    /*::[*/
    676: {
      /* n:"BrtFileSharingIso" */
    },
    /*::[*/
    677: {
      /* n:"BrtBookProtectionIso" */
    },
    /*::[*/
    678: {
      /* n:"BrtSheetProtectionIso" */
    },
    /*::[*/
    679: {
      /* n:"BrtCsProtectionIso" */
    },
    /*::[*/
    680: {
      /* n:"BrtRangeProtectionIso" */
    },
    /*::[*/
    681: {
      /* n:"BrtDValList" */
    },
    /*::[*/
    1024: {
      /* n:"BrtRwDescent" */
    },
    /*::[*/
    1025: {
      /* n:"BrtKnownFonts" */
    },
    /*::[*/
    1026: {
      /* n:"BrtBeginSXTupleSet", */
      T: 1
    },
    /*::[*/
    1027: {
      /* n:"BrtEndSXTupleSet", */
      T: -1
    },
    /*::[*/
    1028: {
      /* n:"BrtBeginSXTupleSetHeader", */
      T: 1
    },
    /*::[*/
    1029: {
      /* n:"BrtEndSXTupleSetHeader", */
      T: -1
    },
    /*::[*/
    1030: {
      /* n:"BrtSXTupleSetHeaderItem" */
    },
    /*::[*/
    1031: {
      /* n:"BrtBeginSXTupleSetData", */
      T: 1
    },
    /*::[*/
    1032: {
      /* n:"BrtEndSXTupleSetData", */
      T: -1
    },
    /*::[*/
    1033: {
      /* n:"BrtBeginSXTupleSetRow", */
      T: 1
    },
    /*::[*/
    1034: {
      /* n:"BrtEndSXTupleSetRow", */
      T: -1
    },
    /*::[*/
    1035: {
      /* n:"BrtSXTupleSetRowItem" */
    },
    /*::[*/
    1036: {
      /* n:"BrtNameExt" */
    },
    /*::[*/
    1037: {
      /* n:"BrtPCDH14" */
    },
    /*::[*/
    1038: {
      /* n:"BrtBeginPCDCalcMem14", */
      T: 1
    },
    /*::[*/
    1039: {
      /* n:"BrtEndPCDCalcMem14", */
      T: -1
    },
    /*::[*/
    1040: {
      /* n:"BrtSXTH14" */
    },
    /*::[*/
    1041: {
      /* n:"BrtBeginSparklineGroup", */
      T: 1
    },
    /*::[*/
    1042: {
      /* n:"BrtEndSparklineGroup", */
      T: -1
    },
    /*::[*/
    1043: {
      /* n:"BrtSparkline" */
    },
    /*::[*/
    1044: {
      /* n:"BrtSXDI14" */
    },
    /*::[*/
    1045: {
      /* n:"BrtWsFmtInfoEx14" */
    },
    /*::[*/
    1046: {
      /* n:"BrtBeginConditionalFormatting14", */
      T: 1
    },
    /*::[*/
    1047: {
      /* n:"BrtEndConditionalFormatting14", */
      T: -1
    },
    /*::[*/
    1048: {
      /* n:"BrtBeginCFRule14", */
      T: 1
    },
    /*::[*/
    1049: {
      /* n:"BrtEndCFRule14", */
      T: -1
    },
    /*::[*/
    1050: {
      /* n:"BrtCFVO14" */
    },
    /*::[*/
    1051: {
      /* n:"BrtBeginDatabar14", */
      T: 1
    },
    /*::[*/
    1052: {
      /* n:"BrtBeginIconSet14", */
      T: 1
    },
    /*::[*/
    1053: {
      /* n:"BrtDVal14", */
      f: parse_BrtDVal14
    },
    /*::[*/
    1054: {
      /* n:"BrtBeginDVals14", */
      T: 1
    },
    /*::[*/
    1055: {
      /* n:"BrtColor14" */
    },
    /*::[*/
    1056: {
      /* n:"BrtBeginSparklines", */
      T: 1
    },
    /*::[*/
    1057: {
      /* n:"BrtEndSparklines", */
      T: -1
    },
    /*::[*/
    1058: {
      /* n:"BrtBeginSparklineGroups", */
      T: 1
    },
    /*::[*/
    1059: {
      /* n:"BrtEndSparklineGroups", */
      T: -1
    },
    /*::[*/
    1061: {
      /* n:"BrtSXVD14" */
    },
    /*::[*/
    1062: {
      /* n:"BrtBeginSXView14", */
      T: 1
    },
    /*::[*/
    1063: {
      /* n:"BrtEndSXView14", */
      T: -1
    },
    /*::[*/
    1064: {
      /* n:"BrtBeginSXView16", */
      T: 1
    },
    /*::[*/
    1065: {
      /* n:"BrtEndSXView16", */
      T: -1
    },
    /*::[*/
    1066: {
      /* n:"BrtBeginPCD14", */
      T: 1
    },
    /*::[*/
    1067: {
      /* n:"BrtEndPCD14", */
      T: -1
    },
    /*::[*/
    1068: {
      /* n:"BrtBeginExtConn14", */
      T: 1
    },
    /*::[*/
    1069: {
      /* n:"BrtEndExtConn14", */
      T: -1
    },
    /*::[*/
    1070: {
      /* n:"BrtBeginSlicerCacheIDs", */
      T: 1
    },
    /*::[*/
    1071: {
      /* n:"BrtEndSlicerCacheIDs", */
      T: -1
    },
    /*::[*/
    1072: {
      /* n:"BrtBeginSlicerCacheID", */
      T: 1
    },
    /*::[*/
    1073: {
      /* n:"BrtEndSlicerCacheID", */
      T: -1
    },
    /*::[*/
    1075: {
      /* n:"BrtBeginSlicerCache", */
      T: 1
    },
    /*::[*/
    1076: {
      /* n:"BrtEndSlicerCache", */
      T: -1
    },
    /*::[*/
    1077: {
      /* n:"BrtBeginSlicerCacheDef", */
      T: 1
    },
    /*::[*/
    1078: {
      /* n:"BrtEndSlicerCacheDef", */
      T: -1
    },
    /*::[*/
    1079: {
      /* n:"BrtBeginSlicersEx", */
      T: 1
    },
    /*::[*/
    1080: {
      /* n:"BrtEndSlicersEx", */
      T: -1
    },
    /*::[*/
    1081: {
      /* n:"BrtBeginSlicerEx", */
      T: 1
    },
    /*::[*/
    1082: {
      /* n:"BrtEndSlicerEx", */
      T: -1
    },
    /*::[*/
    1083: {
      /* n:"BrtBeginSlicer", */
      T: 1
    },
    /*::[*/
    1084: {
      /* n:"BrtEndSlicer", */
      T: -1
    },
    /*::[*/
    1085: {
      /* n:"BrtSlicerCachePivotTables" */
    },
    /*::[*/
    1086: {
      /* n:"BrtBeginSlicerCacheOlapImpl", */
      T: 1
    },
    /*::[*/
    1087: {
      /* n:"BrtEndSlicerCacheOlapImpl", */
      T: -1
    },
    /*::[*/
    1088: {
      /* n:"BrtBeginSlicerCacheLevelsData", */
      T: 1
    },
    /*::[*/
    1089: {
      /* n:"BrtEndSlicerCacheLevelsData", */
      T: -1
    },
    /*::[*/
    1090: {
      /* n:"BrtBeginSlicerCacheLevelData", */
      T: 1
    },
    /*::[*/
    1091: {
      /* n:"BrtEndSlicerCacheLevelData", */
      T: -1
    },
    /*::[*/
    1092: {
      /* n:"BrtBeginSlicerCacheSiRanges", */
      T: 1
    },
    /*::[*/
    1093: {
      /* n:"BrtEndSlicerCacheSiRanges", */
      T: -1
    },
    /*::[*/
    1094: {
      /* n:"BrtBeginSlicerCacheSiRange", */
      T: 1
    },
    /*::[*/
    1095: {
      /* n:"BrtEndSlicerCacheSiRange", */
      T: -1
    },
    /*::[*/
    1096: {
      /* n:"BrtSlicerCacheOlapItem" */
    },
    /*::[*/
    1097: {
      /* n:"BrtBeginSlicerCacheSelections", */
      T: 1
    },
    /*::[*/
    1098: {
      /* n:"BrtSlicerCacheSelection" */
    },
    /*::[*/
    1099: {
      /* n:"BrtEndSlicerCacheSelections", */
      T: -1
    },
    /*::[*/
    1100: {
      /* n:"BrtBeginSlicerCacheNative", */
      T: 1
    },
    /*::[*/
    1101: {
      /* n:"BrtEndSlicerCacheNative", */
      T: -1
    },
    /*::[*/
    1102: {
      /* n:"BrtSlicerCacheNativeItem" */
    },
    /*::[*/
    1103: {
      /* n:"BrtRangeProtection14" */
    },
    /*::[*/
    1104: {
      /* n:"BrtRangeProtectionIso14" */
    },
    /*::[*/
    1105: {
      /* n:"BrtCellIgnoreEC14" */
    },
    /*::[*/
    1111: {
      /* n:"BrtList14" */
    },
    /*::[*/
    1112: {
      /* n:"BrtCFIcon" */
    },
    /*::[*/
    1113: {
      /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
      T: 1
    },
    /*::[*/
    1114: {
      /* n:"BrtEndSlicerCachesPivotCacheIDs", */
      T: -1
    },
    /*::[*/
    1115: {
      /* n:"BrtBeginSlicers", */
      T: 1
    },
    /*::[*/
    1116: {
      /* n:"BrtEndSlicers", */
      T: -1
    },
    /*::[*/
    1117: {
      /* n:"BrtWbProp14" */
    },
    /*::[*/
    1118: {
      /* n:"BrtBeginSXEdit", */
      T: 1
    },
    /*::[*/
    1119: {
      /* n:"BrtEndSXEdit", */
      T: -1
    },
    /*::[*/
    1120: {
      /* n:"BrtBeginSXEdits", */
      T: 1
    },
    /*::[*/
    1121: {
      /* n:"BrtEndSXEdits", */
      T: -1
    },
    /*::[*/
    1122: {
      /* n:"BrtBeginSXChange", */
      T: 1
    },
    /*::[*/
    1123: {
      /* n:"BrtEndSXChange", */
      T: -1
    },
    /*::[*/
    1124: {
      /* n:"BrtBeginSXChanges", */
      T: 1
    },
    /*::[*/
    1125: {
      /* n:"BrtEndSXChanges", */
      T: -1
    },
    /*::[*/
    1126: {
      /* n:"BrtSXTupleItems" */
    },
    /*::[*/
    1128: {
      /* n:"BrtBeginSlicerStyle", */
      T: 1
    },
    /*::[*/
    1129: {
      /* n:"BrtEndSlicerStyle", */
      T: -1
    },
    /*::[*/
    1130: {
      /* n:"BrtSlicerStyleElement" */
    },
    /*::[*/
    1131: {
      /* n:"BrtBeginStyleSheetExt14", */
      T: 1
    },
    /*::[*/
    1132: {
      /* n:"BrtEndStyleSheetExt14", */
      T: -1
    },
    /*::[*/
    1133: {
      /* n:"BrtBeginSlicerCachesPivotCacheID", */
      T: 1
    },
    /*::[*/
    1134: {
      /* n:"BrtEndSlicerCachesPivotCacheID", */
      T: -1
    },
    /*::[*/
    1135: {
      /* n:"BrtBeginConditionalFormattings", */
      T: 1
    },
    /*::[*/
    1136: {
      /* n:"BrtEndConditionalFormattings", */
      T: -1
    },
    /*::[*/
    1137: {
      /* n:"BrtBeginPCDCalcMemExt", */
      T: 1
    },
    /*::[*/
    1138: {
      /* n:"BrtEndPCDCalcMemExt", */
      T: -1
    },
    /*::[*/
    1139: {
      /* n:"BrtBeginPCDCalcMemsExt", */
      T: 1
    },
    /*::[*/
    1140: {
      /* n:"BrtEndPCDCalcMemsExt", */
      T: -1
    },
    /*::[*/
    1141: {
      /* n:"BrtPCDField14" */
    },
    /*::[*/
    1142: {
      /* n:"BrtBeginSlicerStyles", */
      T: 1
    },
    /*::[*/
    1143: {
      /* n:"BrtEndSlicerStyles", */
      T: -1
    },
    /*::[*/
    1144: {
      /* n:"BrtBeginSlicerStyleElements", */
      T: 1
    },
    /*::[*/
    1145: {
      /* n:"BrtEndSlicerStyleElements", */
      T: -1
    },
    /*::[*/
    1146: {
      /* n:"BrtCFRuleExt" */
    },
    /*::[*/
    1147: {
      /* n:"BrtBeginSXCondFmt14", */
      T: 1
    },
    /*::[*/
    1148: {
      /* n:"BrtEndSXCondFmt14", */
      T: -1
    },
    /*::[*/
    1149: {
      /* n:"BrtBeginSXCondFmts14", */
      T: 1
    },
    /*::[*/
    1150: {
      /* n:"BrtEndSXCondFmts14", */
      T: -1
    },
    /*::[*/
    1152: {
      /* n:"BrtBeginSortCond14", */
      T: 1
    },
    /*::[*/
    1153: {
      /* n:"BrtEndSortCond14", */
      T: -1
    },
    /*::[*/
    1154: {
      /* n:"BrtEndDVals14", */
      T: -1
    },
    /*::[*/
    1155: {
      /* n:"BrtEndIconSet14", */
      T: -1
    },
    /*::[*/
    1156: {
      /* n:"BrtEndDatabar14", */
      T: -1
    },
    /*::[*/
    1157: {
      /* n:"BrtBeginColorScale14", */
      T: 1
    },
    /*::[*/
    1158: {
      /* n:"BrtEndColorScale14", */
      T: -1
    },
    /*::[*/
    1159: {
      /* n:"BrtBeginSxrules14", */
      T: 1
    },
    /*::[*/
    1160: {
      /* n:"BrtEndSxrules14", */
      T: -1
    },
    /*::[*/
    1161: {
      /* n:"BrtBeginPRule14", */
      T: 1
    },
    /*::[*/
    1162: {
      /* n:"BrtEndPRule14", */
      T: -1
    },
    /*::[*/
    1163: {
      /* n:"BrtBeginPRFilters14", */
      T: 1
    },
    /*::[*/
    1164: {
      /* n:"BrtEndPRFilters14", */
      T: -1
    },
    /*::[*/
    1165: {
      /* n:"BrtBeginPRFilter14", */
      T: 1
    },
    /*::[*/
    1166: {
      /* n:"BrtEndPRFilter14", */
      T: -1
    },
    /*::[*/
    1167: {
      /* n:"BrtBeginPRFItem14", */
      T: 1
    },
    /*::[*/
    1168: {
      /* n:"BrtEndPRFItem14", */
      T: -1
    },
    /*::[*/
    1169: {
      /* n:"BrtBeginCellIgnoreECs14", */
      T: 1
    },
    /*::[*/
    1170: {
      /* n:"BrtEndCellIgnoreECs14", */
      T: -1
    },
    /*::[*/
    1171: {
      /* n:"BrtDxf14" */
    },
    /*::[*/
    1172: {
      /* n:"BrtBeginDxF14s", */
      T: 1
    },
    /*::[*/
    1173: {
      /* n:"BrtEndDxf14s", */
      T: -1
    },
    /*::[*/
    1177: {
      /* n:"BrtFilter14" */
    },
    /*::[*/
    1178: {
      /* n:"BrtBeginCustomFilters14", */
      T: 1
    },
    /*::[*/
    1180: {
      /* n:"BrtCustomFilter14" */
    },
    /*::[*/
    1181: {
      /* n:"BrtIconFilter14" */
    },
    /*::[*/
    1182: {
      /* n:"BrtPivotCacheConnectionName" */
    },
    /*::[*/
    2048: {
      /* n:"BrtBeginDecoupledPivotCacheIDs", */
      T: 1
    },
    /*::[*/
    2049: {
      /* n:"BrtEndDecoupledPivotCacheIDs", */
      T: -1
    },
    /*::[*/
    2050: {
      /* n:"BrtDecoupledPivotCacheID" */
    },
    /*::[*/
    2051: {
      /* n:"BrtBeginPivotTableRefs", */
      T: 1
    },
    /*::[*/
    2052: {
      /* n:"BrtEndPivotTableRefs", */
      T: -1
    },
    /*::[*/
    2053: {
      /* n:"BrtPivotTableRef" */
    },
    /*::[*/
    2054: {
      /* n:"BrtSlicerCacheBookPivotTables" */
    },
    /*::[*/
    2055: {
      /* n:"BrtBeginSxvcells", */
      T: 1
    },
    /*::[*/
    2056: {
      /* n:"BrtEndSxvcells", */
      T: -1
    },
    /*::[*/
    2057: {
      /* n:"BrtBeginSxRow", */
      T: 1
    },
    /*::[*/
    2058: {
      /* n:"BrtEndSxRow", */
      T: -1
    },
    /*::[*/
    2060: {
      /* n:"BrtPcdCalcMem15" */
    },
    /*::[*/
    2067: {
      /* n:"BrtQsi15" */
    },
    /*::[*/
    2068: {
      /* n:"BrtBeginWebExtensions", */
      T: 1
    },
    /*::[*/
    2069: {
      /* n:"BrtEndWebExtensions", */
      T: -1
    },
    /*::[*/
    2070: {
      /* n:"BrtWebExtension" */
    },
    /*::[*/
    2071: {
      /* n:"BrtAbsPath15" */
    },
    /*::[*/
    2072: {
      /* n:"BrtBeginPivotTableUISettings", */
      T: 1
    },
    /*::[*/
    2073: {
      /* n:"BrtEndPivotTableUISettings", */
      T: -1
    },
    /*::[*/
    2075: {
      /* n:"BrtTableSlicerCacheIDs" */
    },
    /*::[*/
    2076: {
      /* n:"BrtTableSlicerCacheID" */
    },
    /*::[*/
    2077: {
      /* n:"BrtBeginTableSlicerCache", */
      T: 1
    },
    /*::[*/
    2078: {
      /* n:"BrtEndTableSlicerCache", */
      T: -1
    },
    /*::[*/
    2079: {
      /* n:"BrtSxFilter15" */
    },
    /*::[*/
    2080: {
      /* n:"BrtBeginTimelineCachePivotCacheIDs", */
      T: 1
    },
    /*::[*/
    2081: {
      /* n:"BrtEndTimelineCachePivotCacheIDs", */
      T: -1
    },
    /*::[*/
    2082: {
      /* n:"BrtTimelineCachePivotCacheID" */
    },
    /*::[*/
    2083: {
      /* n:"BrtBeginTimelineCacheIDs", */
      T: 1
    },
    /*::[*/
    2084: {
      /* n:"BrtEndTimelineCacheIDs", */
      T: -1
    },
    /*::[*/
    2085: {
      /* n:"BrtBeginTimelineCacheID", */
      T: 1
    },
    /*::[*/
    2086: {
      /* n:"BrtEndTimelineCacheID", */
      T: -1
    },
    /*::[*/
    2087: {
      /* n:"BrtBeginTimelinesEx", */
      T: 1
    },
    /*::[*/
    2088: {
      /* n:"BrtEndTimelinesEx", */
      T: -1
    },
    /*::[*/
    2089: {
      /* n:"BrtBeginTimelineEx", */
      T: 1
    },
    /*::[*/
    2090: {
      /* n:"BrtEndTimelineEx", */
      T: -1
    },
    /*::[*/
    2091: {
      /* n:"BrtWorkBookPr15" */
    },
    /*::[*/
    2092: {
      /* n:"BrtPCDH15" */
    },
    /*::[*/
    2093: {
      /* n:"BrtBeginTimelineStyle", */
      T: 1
    },
    /*::[*/
    2094: {
      /* n:"BrtEndTimelineStyle", */
      T: -1
    },
    /*::[*/
    2095: {
      /* n:"BrtTimelineStyleElement" */
    },
    /*::[*/
    2096: {
      /* n:"BrtBeginTimelineStylesheetExt15", */
      T: 1
    },
    /*::[*/
    2097: {
      /* n:"BrtEndTimelineStylesheetExt15", */
      T: -1
    },
    /*::[*/
    2098: {
      /* n:"BrtBeginTimelineStyles", */
      T: 1
    },
    /*::[*/
    2099: {
      /* n:"BrtEndTimelineStyles", */
      T: -1
    },
    /*::[*/
    2100: {
      /* n:"BrtBeginTimelineStyleElements", */
      T: 1
    },
    /*::[*/
    2101: {
      /* n:"BrtEndTimelineStyleElements", */
      T: -1
    },
    /*::[*/
    2102: {
      /* n:"BrtDxf15" */
    },
    /*::[*/
    2103: {
      /* n:"BrtBeginDxfs15", */
      T: 1
    },
    /*::[*/
    2104: {
      /* n:"BrtEndDxfs15", */
      T: -1
    },
    /*::[*/
    2105: {
      /* n:"BrtSlicerCacheHideItemsWithNoData" */
    },
    /*::[*/
    2106: {
      /* n:"BrtBeginItemUniqueNames", */
      T: 1
    },
    /*::[*/
    2107: {
      /* n:"BrtEndItemUniqueNames", */
      T: -1
    },
    /*::[*/
    2108: {
      /* n:"BrtItemUniqueName" */
    },
    /*::[*/
    2109: {
      /* n:"BrtBeginExtConn15", */
      T: 1
    },
    /*::[*/
    2110: {
      /* n:"BrtEndExtConn15", */
      T: -1
    },
    /*::[*/
    2111: {
      /* n:"BrtBeginOledbPr15", */
      T: 1
    },
    /*::[*/
    2112: {
      /* n:"BrtEndOledbPr15", */
      T: -1
    },
    /*::[*/
    2113: {
      /* n:"BrtBeginDataFeedPr15", */
      T: 1
    },
    /*::[*/
    2114: {
      /* n:"BrtEndDataFeedPr15", */
      T: -1
    },
    /*::[*/
    2115: {
      /* n:"BrtTextPr15" */
    },
    /*::[*/
    2116: {
      /* n:"BrtRangePr15" */
    },
    /*::[*/
    2117: {
      /* n:"BrtDbCommand15" */
    },
    /*::[*/
    2118: {
      /* n:"BrtBeginDbTables15", */
      T: 1
    },
    /*::[*/
    2119: {
      /* n:"BrtEndDbTables15", */
      T: -1
    },
    /*::[*/
    2120: {
      /* n:"BrtDbTable15" */
    },
    /*::[*/
    2121: {
      /* n:"BrtBeginDataModel", */
      T: 1
    },
    /*::[*/
    2122: {
      /* n:"BrtEndDataModel", */
      T: -1
    },
    /*::[*/
    2123: {
      /* n:"BrtBeginModelTables", */
      T: 1
    },
    /*::[*/
    2124: {
      /* n:"BrtEndModelTables", */
      T: -1
    },
    /*::[*/
    2125: {
      /* n:"BrtModelTable" */
    },
    /*::[*/
    2126: {
      /* n:"BrtBeginModelRelationships", */
      T: 1
    },
    /*::[*/
    2127: {
      /* n:"BrtEndModelRelationships", */
      T: -1
    },
    /*::[*/
    2128: {
      /* n:"BrtModelRelationship" */
    },
    /*::[*/
    2129: {
      /* n:"BrtBeginECTxtWiz15", */
      T: 1
    },
    /*::[*/
    2130: {
      /* n:"BrtEndECTxtWiz15", */
      T: -1
    },
    /*::[*/
    2131: {
      /* n:"BrtBeginECTWFldInfoLst15", */
      T: 1
    },
    /*::[*/
    2132: {
      /* n:"BrtEndECTWFldInfoLst15", */
      T: -1
    },
    /*::[*/
    2133: {
      /* n:"BrtBeginECTWFldInfo15", */
      T: 1
    },
    /*::[*/
    2134: {
      /* n:"BrtFieldListActiveItem" */
    },
    /*::[*/
    2135: {
      /* n:"BrtPivotCacheIdVersion" */
    },
    /*::[*/
    2136: {
      /* n:"BrtSXDI15" */
    },
    /*::[*/
    2137: {
      /* n:"BrtBeginModelTimeGroupings", */
      T: 1
    },
    /*::[*/
    2138: {
      /* n:"BrtEndModelTimeGroupings", */
      T: -1
    },
    /*::[*/
    2139: {
      /* n:"BrtBeginModelTimeGrouping", */
      T: 1
    },
    /*::[*/
    2140: {
      /* n:"BrtEndModelTimeGrouping", */
      T: -1
    },
    /*::[*/
    2141: {
      /* n:"BrtModelTimeGroupingCalcCol" */
    },
    /*::[*/
    3072: {
      /* n:"BrtUid" */
    },
    /*::[*/
    3073: {
      /* n:"BrtRevisionPtr" */
    },
    /*::[*/
    4096: {
      /* n:"BrtBeginDynamicArrayPr", */
      T: 1
    },
    /*::[*/
    4097: {
      /* n:"BrtEndDynamicArrayPr", */
      T: -1
    },
    /*::[*/
    5002: {
      /* n:"BrtBeginRichValueBlock", */
      T: 1
    },
    /*::[*/
    5003: {
      /* n:"BrtEndRichValueBlock", */
      T: -1
    },
    /*::[*/
    5081: {
      /* n:"BrtBeginRichFilters", */
      T: 1
    },
    /*::[*/
    5082: {
      /* n:"BrtEndRichFilters", */
      T: -1
    },
    /*::[*/
    5083: {
      /* n:"BrtRichFilter" */
    },
    /*::[*/
    5084: {
      /* n:"BrtBeginRichFilterColumn", */
      T: 1
    },
    /*::[*/
    5085: {
      /* n:"BrtEndRichFilterColumn", */
      T: -1
    },
    /*::[*/
    5086: {
      /* n:"BrtBeginCustomRichFilters", */
      T: 1
    },
    /*::[*/
    5087: {
      /* n:"BrtEndCustomRichFilters", */
      T: -1
    },
    /*::[*/
    5088: {
      /* n:"BrtCustomRichFilter" */
    },
    /*::[*/
    5089: {
      /* n:"BrtTop10RichFilter" */
    },
    /*::[*/
    5090: {
      /* n:"BrtDynamicRichFilter" */
    },
    /*::[*/
    5092: {
      /* n:"BrtBeginRichSortCondition", */
      T: 1
    },
    /*::[*/
    5093: {
      /* n:"BrtEndRichSortCondition", */
      T: -1
    },
    /*::[*/
    5094: {
      /* n:"BrtRichFilterDateGroupItem" */
    },
    /*::[*/
    5095: {
      /* n:"BrtBeginCalcFeatures", */
      T: 1
    },
    /*::[*/
    5096: {
      /* n:"BrtEndCalcFeatures", */
      T: -1
    },
    /*::[*/
    5097: {
      /* n:"BrtCalcFeature" */
    },
    /*::[*/
    5099: {
      /* n:"BrtExternalLinksPr" */
    },
    /*::[*/
    65535: { n: "" }
  };
  function write_biff_rec(ba, type, payload, length) {
    var t = type;
    if (isNaN(t)) return;
    var len = length || (payload || []).length || 0;
    var o = ba.next(4);
    o.write_shift(2, t);
    o.write_shift(2, len);
    if (
      /*:: len != null &&*/
      len > 0 && is_buf(payload)
    ) ba.push(payload);
  }
  function write_biff_continue(ba, type, payload, length) {
    var len = length || (payload || []).length || 0;
    if (len <= 8224) return write_biff_rec(ba, type, payload, len);
    var t = type;
    if (isNaN(t)) return;
    var parts = payload.parts || [], sidx = 0;
    var i = 0, w = 0;
    while (w + (parts[sidx] || 8224) <= 8224) {
      w += parts[sidx] || 8224;
      sidx++;
    }
    var o = ba.next(4);
    o.write_shift(2, t);
    o.write_shift(2, w);
    ba.push(payload.slice(i, i + w));
    i += w;
    while (i < len) {
      o = ba.next(4);
      o.write_shift(2, 60);
      w = 0;
      while (w + (parts[sidx] || 8224) <= 8224) {
        w += parts[sidx] || 8224;
        sidx++;
      }
      o.write_shift(2, w);
      ba.push(payload.slice(i, i + w));
      i += w;
    }
  }
  function write_BIFF2Cell(out, r, c) {
    if (!out) out = new_buf(7);
    out.write_shift(2, r);
    out.write_shift(2, c);
    out.write_shift(2, 0);
    out.write_shift(1, 0);
    return out;
  }
  function write_BIFF2BERR(r, c, val, t) {
    var out = new_buf(9);
    write_BIFF2Cell(out, r, c);
    write_Bes(val, t || "b", out);
    return out;
  }
  function write_BIFF2LABEL(r, c, val) {
    var out = new_buf(8 + 2 * val.length);
    write_BIFF2Cell(out, r, c);
    out.write_shift(1, val.length);
    out.write_shift(val.length, val, "sbcs");
    return out.l < out.length ? out.slice(0, out.l) : out;
  }
  function write_ws_biff2_cell(ba, cell, R, C) {
    if (cell.v != null) switch (cell.t) {
      case "d":
      case "n":
        var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
        if (v == (v | 0) && v >= 0 && v < 65536)
          write_biff_rec(ba, 2, write_BIFF2INT(R, C, v));
        else
          write_biff_rec(ba, 3, write_BIFF2NUM(R, C, v));
        return;
      case "b":
      case "e":
        write_biff_rec(ba, 5, write_BIFF2BERR(R, C, cell.v, cell.t));
        return;
      /* TODO: codepage, sst */
      case "s":
      case "str":
        write_biff_rec(ba, 4, write_BIFF2LABEL(R, C, (cell.v || "").slice(0, 255)));
        return;
    }
    write_biff_rec(ba, 1, write_BIFF2Cell(null, R, C));
  }
  function write_ws_biff2(ba, ws, idx, opts) {
    var dense = Array.isArray(ws);
    var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
    if (range.e.c > 255 || range.e.r > 16383) {
      if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
      range.e.c = Math.min(range.e.c, 255);
      range.e.r = Math.min(range.e.c, 16383);
      ref = encode_range(range);
    }
    for (var R = range.s.r; R <= range.e.r; ++R) {
      rr = encode_row(R);
      for (var C = range.s.c; C <= range.e.c; ++C) {
        if (R === range.s.r) cols[C] = encode_col(C);
        ref = cols[C] + rr;
        var cell = dense ? (ws[R] || [])[C] : ws[ref];
        if (!cell) continue;
        write_ws_biff2_cell(ba, cell, R, C, opts);
      }
    }
  }
  function write_biff2_buf(wb, opts) {
    var o = opts || {};
    if (DENSE != null && o.dense == null) o.dense = DENSE;
    var ba = buf_array();
    var idx = 0;
    for (var i = 0; i < wb.SheetNames.length; ++i) if (wb.SheetNames[i] == o.sheet) idx = i;
    if (idx == 0 && !!o.sheet && wb.SheetNames[0] != o.sheet) throw new Error("Sheet not found: " + o.sheet);
    write_biff_rec(ba, o.biff == 4 ? 1033 : o.biff == 3 ? 521 : 9, write_BOF(wb, 16, o));
    write_ws_biff2(ba, wb.Sheets[wb.SheetNames[idx]], idx, o, wb);
    write_biff_rec(ba, 10);
    return ba.end();
  }
  function write_FONTS_biff8(ba, data, opts) {
    write_biff_rec(ba, 49, write_Font({
      sz: 12,
      color: { theme: 1 },
      name: "Arial",
      family: 2,
      scheme: "minor"
    }, opts));
  }
  function write_FMTS_biff8(ba, NF, opts) {
    if (!NF) return;
    [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(r) {
      for (var i = r[0]; i <= r[1]; ++i) if (NF[i] != null) write_biff_rec(ba, 1054, write_Format(i, NF[i], opts));
    });
  }
  function write_FEAT(ba, ws) {
    var o = new_buf(19);
    o.write_shift(4, 2151);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(2, 3);
    o.write_shift(1, 1);
    o.write_shift(4, 0);
    write_biff_rec(ba, 2151, o);
    o = new_buf(39);
    o.write_shift(4, 2152);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(2, 3);
    o.write_shift(1, 0);
    o.write_shift(4, 0);
    o.write_shift(2, 1);
    o.write_shift(4, 4);
    o.write_shift(2, 0);
    write_Ref8U(safe_decode_range(ws["!ref"] || "A1"), o);
    o.write_shift(4, 4);
    write_biff_rec(ba, 2152, o);
  }
  function write_CELLXFS_biff8(ba, opts) {
    for (var i = 0; i < 16; ++i) write_biff_rec(ba, 224, write_XF({ numFmtId: 0, style: true }, 0, opts));
    opts.cellXfs.forEach(function(c) {
      write_biff_rec(ba, 224, write_XF(c, 0, opts));
    });
  }
  function write_ws_biff8_hlinks(ba, ws) {
    for (var R = 0; R < ws["!links"].length; ++R) {
      var HL = ws["!links"][R];
      write_biff_rec(ba, 440, write_HLink(HL));
      if (HL[1].Tooltip) write_biff_rec(ba, 2048, write_HLinkTooltip(HL));
    }
    delete ws["!links"];
  }
  function write_ws_cols_biff8(ba, cols) {
    if (!cols) return;
    var cnt = 0;
    cols.forEach(function(col, idx) {
      if (++cnt <= 256 && col) {
        write_biff_rec(ba, 125, write_ColInfo(col_obj_w(idx, col), idx));
      }
    });
  }
  function write_ws_biff8_cell(ba, cell, R, C, opts) {
    var os = 16 + get_cell_style(opts.cellXfs, cell, opts);
    if (cell.v == null && !cell.bf) {
      write_biff_rec(ba, 513, write_XLSCell(R, C, os));
      return;
    }
    if (cell.bf) write_biff_rec(ba, 6, write_Formula(cell, R, C, opts, os));
    else switch (cell.t) {
      case "d":
      case "n":
        var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
        write_biff_rec(ba, 515, write_Number(R, C, v, os, opts));
        break;
      case "b":
      case "e":
        write_biff_rec(ba, 517, write_BoolErr(R, C, cell.v, os, opts, cell.t));
        break;
      /* TODO: codepage, sst */
      case "s":
      case "str":
        if (opts.bookSST) {
          var isst = get_sst_id(opts.Strings, cell.v, opts.revStrings);
          write_biff_rec(ba, 253, write_LabelSst(R, C, isst, os, opts));
        } else write_biff_rec(ba, 516, write_Label(R, C, (cell.v || "").slice(0, 255), os, opts));
        break;
      default:
        write_biff_rec(ba, 513, write_XLSCell(R, C, os));
    }
  }
  function write_ws_biff8(idx, opts, wb) {
    var ba = buf_array();
    var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
    var _WB = (wb || {}).Workbook || {};
    var _sheet = (_WB.Sheets || [])[idx] || {};
    var dense = Array.isArray(ws);
    var b8 = opts.biff == 8;
    var ref, rr = "", cols = [];
    var range = safe_decode_range(ws["!ref"] || "A1");
    var MAX_ROWS = b8 ? 65536 : 16384;
    if (range.e.c > 255 || range.e.r >= MAX_ROWS) {
      if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
      range.e.c = Math.min(range.e.c, 255);
      range.e.r = Math.min(range.e.c, MAX_ROWS - 1);
    }
    write_biff_rec(ba, 2057, write_BOF(wb, 16, opts));
    write_biff_rec(ba, 13, writeuint16(1));
    write_biff_rec(ba, 12, writeuint16(100));
    write_biff_rec(ba, 15, writebool(true));
    write_biff_rec(ba, 17, writebool(false));
    write_biff_rec(ba, 16, write_Xnum(1e-3));
    write_biff_rec(ba, 95, writebool(true));
    write_biff_rec(ba, 42, writebool(false));
    write_biff_rec(ba, 43, writebool(false));
    write_biff_rec(ba, 130, writeuint16(1));
    write_biff_rec(ba, 128, write_Guts([0, 0]));
    write_biff_rec(ba, 131, writebool(false));
    write_biff_rec(ba, 132, writebool(false));
    if (b8) write_ws_cols_biff8(ba, ws["!cols"]);
    write_biff_rec(ba, 512, write_Dimensions(range, opts));
    if (b8) ws["!links"] = [];
    for (var R = range.s.r; R <= range.e.r; ++R) {
      rr = encode_row(R);
      for (var C = range.s.c; C <= range.e.c; ++C) {
        if (R === range.s.r) cols[C] = encode_col(C);
        ref = cols[C] + rr;
        var cell = dense ? (ws[R] || [])[C] : ws[ref];
        if (!cell) continue;
        write_ws_biff8_cell(ba, cell, R, C, opts);
        if (b8 && cell.l) ws["!links"].push([ref, cell.l]);
      }
    }
    var cname = _sheet.CodeName || _sheet.name || s;
    if (b8) write_biff_rec(ba, 574, write_Window2((_WB.Views || [])[0]));
    if (b8 && (ws["!merges"] || []).length) write_biff_rec(ba, 229, write_MergeCells(ws["!merges"]));
    if (b8) write_ws_biff8_hlinks(ba, ws);
    write_biff_rec(ba, 442, write_XLUnicodeString(cname, opts));
    if (b8) write_FEAT(ba, ws);
    write_biff_rec(
      ba,
      10
      /* EOF */
    );
    return ba.end();
  }
  function write_biff8_global(wb, bufs, opts) {
    var A = buf_array();
    var _WB = (wb || {}).Workbook || {};
    var _sheets = _WB.Sheets || [];
    var _wb = (
      /*::((*/
      _WB.WBProps || {
        /*::CodeName:"ThisWorkbook"*/
      }
    );
    var b8 = opts.biff == 8, b5 = opts.biff == 5;
    write_biff_rec(A, 2057, write_BOF(wb, 5, opts));
    if (opts.bookType == "xla") write_biff_rec(
      A,
      135
      /* Addin */
    );
    write_biff_rec(A, 225, b8 ? writeuint16(1200) : null);
    write_biff_rec(A, 193, writezeroes(2));
    if (b5) write_biff_rec(
      A,
      191
      /* ToolbarHdr */
    );
    if (b5) write_biff_rec(
      A,
      192
      /* ToolbarEnd */
    );
    write_biff_rec(
      A,
      226
      /* InterfaceEnd */
    );
    write_biff_rec(A, 92, write_WriteAccess("SheetJS", opts));
    write_biff_rec(A, 66, writeuint16(b8 ? 1200 : 1252));
    if (b8) write_biff_rec(A, 353, writeuint16(0));
    if (b8) write_biff_rec(
      A,
      448
      /* Excel9File */
    );
    write_biff_rec(A, 317, write_RRTabId(wb.SheetNames.length));
    if (b8 && wb.vbaraw) write_biff_rec(
      A,
      211
      /* ObProj */
    );
    if (b8 && wb.vbaraw) {
      var cname = _wb.CodeName || "ThisWorkbook";
      write_biff_rec(A, 442, write_XLUnicodeString(cname, opts));
    }
    write_biff_rec(A, 156, writeuint16(17));
    write_biff_rec(A, 25, writebool(false));
    write_biff_rec(A, 18, writebool(false));
    write_biff_rec(A, 19, writeuint16(0));
    if (b8) write_biff_rec(A, 431, writebool(false));
    if (b8) write_biff_rec(A, 444, writeuint16(0));
    write_biff_rec(A, 61, write_Window1(opts));
    write_biff_rec(A, 64, writebool(false));
    write_biff_rec(A, 141, writeuint16(0));
    write_biff_rec(A, 34, writebool(safe1904(wb) == "true"));
    write_biff_rec(A, 14, writebool(true));
    if (b8) write_biff_rec(A, 439, writebool(false));
    write_biff_rec(A, 218, writeuint16(0));
    write_FONTS_biff8(A, wb, opts);
    write_FMTS_biff8(A, wb.SSF, opts);
    write_CELLXFS_biff8(A, opts);
    if (b8) write_biff_rec(A, 352, writebool(false));
    var a = A.end();
    var C = buf_array();
    if (b8) write_biff_rec(C, 140, write_Country());
    if (b8 && opts.Strings) write_biff_continue(C, 252, write_SST(opts.Strings, opts));
    write_biff_rec(
      C,
      10
      /* EOF */
    );
    var c = C.end();
    var B = buf_array();
    var blen = 0, j = 0;
    for (j = 0; j < wb.SheetNames.length; ++j) blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j].length;
    var start = a.length + blen + c.length;
    for (j = 0; j < wb.SheetNames.length; ++j) {
      var _sheet = _sheets[j] || {};
      write_biff_rec(B, 133, write_BoundSheet8({ pos: start, hs: _sheet.Hidden || 0, dt: 0, name: wb.SheetNames[j] }, opts));
      start += bufs[j].length;
    }
    var b = B.end();
    if (blen != b.length) throw new Error("BS8 " + blen + " != " + b.length);
    var out = [];
    if (a.length) out.push(a);
    if (b.length) out.push(b);
    if (c.length) out.push(c);
    return bconcat(out);
  }
  function write_biff8_buf(wb, opts) {
    var o = opts || {};
    var bufs = [];
    if (wb && !wb.SSF) {
      wb.SSF = dup(table_fmt);
    }
    if (wb && wb.SSF) {
      make_ssf();
      SSF_load_table(wb.SSF);
      o.revssf = evert_num(wb.SSF);
      o.revssf[wb.SSF[65535]] = 0;
      o.ssf = wb.SSF;
    }
    o.Strings = /*::((*/
    [];
    o.Strings.Count = 0;
    o.Strings.Unique = 0;
    fix_write_opts(o);
    o.cellXfs = [];
    get_cell_style(o.cellXfs, {}, { revssf: { "General": 0 } });
    if (!wb.Props) wb.Props = {};
    for (var i = 0; i < wb.SheetNames.length; ++i) bufs[bufs.length] = write_ws_biff8(i, o, wb);
    bufs.unshift(write_biff8_global(wb, bufs, o));
    return bconcat(bufs);
  }
  function write_biff_buf(wb, opts) {
    for (var i = 0; i <= wb.SheetNames.length; ++i) {
      var ws = wb.Sheets[wb.SheetNames[i]];
      if (!ws || !ws["!ref"]) continue;
      var range = decode_range(ws["!ref"]);
      if (range.e.c > 255) {
        if (typeof console != "undefined" && console.error) console.error("Worksheet '" + wb.SheetNames[i] + "' extends beyond column IV (255).  Data may be lost.");
      }
    }
    var o = opts || {};
    switch (o.biff || 2) {
      case 8:
      case 5:
        return write_biff8_buf(wb, opts);
      case 4:
      case 3:
      case 2:
        return write_biff2_buf(wb, opts);
    }
    throw new Error("invalid type " + o.bookType + " for BIFF");
  }
  function make_html_row(ws, r, R, o) {
    var M = ws["!merges"] || [];
    var oo = [];
    for (var C = r.s.c; C <= r.e.c; ++C) {
      var RS = 0, CS = 0;
      for (var j = 0; j < M.length; ++j) {
        if (M[j].s.r > R || M[j].s.c > C) continue;
        if (M[j].e.r < R || M[j].e.c < C) continue;
        if (M[j].s.r < R || M[j].s.c < C) {
          RS = -1;
          break;
        }
        RS = M[j].e.r - M[j].s.r + 1;
        CS = M[j].e.c - M[j].s.c + 1;
        break;
      }
      if (RS < 0) continue;
      var coord = encode_cell({ r: R, c: C });
      var cell = o.dense ? (ws[R] || [])[C] : ws[coord];
      var w = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
      var sp = {};
      if (RS > 1) sp.rowspan = RS;
      if (CS > 1) sp.colspan = CS;
      if (o.editable) w = '<span contenteditable="true">' + w + "</span>";
      else if (cell) {
        sp["data-t"] = cell && cell.t || "z";
        if (cell.v != null) sp["data-v"] = cell.v;
        if (cell.z != null) sp["data-z"] = cell.z;
        if (cell.l && (cell.l.Target || "#").charAt(0) != "#") w = '<a href="' + cell.l.Target + '">' + w + "</a>";
      }
      sp.id = (o.id || "sjs") + "-" + coord;
      oo.push(writextag("td", w, sp));
    }
    var preamble = "<tr>";
    return preamble + oo.join("") + "</tr>";
  }
  var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
  var HTML_END = "</body></html>";
  function make_html_preamble(ws, R, o) {
    var out = [];
    return out.join("") + "<table" + (o && o.id ? ' id="' + o.id + '"' : "") + ">";
  }
  function sheet_to_html(ws, opts) {
    var o = opts || {};
    var header = o.header != null ? o.header : HTML_BEGIN;
    var footer = o.footer != null ? o.footer : HTML_END;
    var out = [header];
    var r = decode_range(ws["!ref"]);
    o.dense = Array.isArray(ws);
    out.push(make_html_preamble(ws, r, o));
    for (var R = r.s.r; R <= r.e.r; ++R) out.push(make_html_row(ws, r, R, o));
    out.push("</table>" + footer);
    return out.join("");
  }
  function sheet_add_dom(ws, table, _opts) {
    var opts = _opts || {};
    if (DENSE != null) opts.dense = DENSE;
    var or_R = 0, or_C = 0;
    if (opts.origin != null) {
      if (typeof opts.origin == "number") or_R = opts.origin;
      else {
        var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;
        or_R = _origin.r;
        or_C = _origin.c;
      }
    }
    var rows = table.getElementsByTagName("tr");
    var sheetRows = Math.min(opts.sheetRows || 1e7, rows.length);
    var range = { s: { r: 0, c: 0 }, e: { r: or_R, c: or_C } };
    if (ws["!ref"]) {
      var _range = decode_range(ws["!ref"]);
      range.s.r = Math.min(range.s.r, _range.s.r);
      range.s.c = Math.min(range.s.c, _range.s.c);
      range.e.r = Math.max(range.e.r, _range.e.r);
      range.e.c = Math.max(range.e.c, _range.e.c);
      if (or_R == -1) range.e.r = or_R = _range.e.r + 1;
    }
    var merges = [], midx = 0;
    var rowinfo = ws["!rows"] || (ws["!rows"] = []);
    var _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;
    if (!ws["!cols"]) ws["!cols"] = [];
    for (; _R < rows.length && R < sheetRows; ++_R) {
      var row = rows[_R];
      if (is_dom_element_hidden(row)) {
        if (opts.display) continue;
        rowinfo[R] = { hidden: true };
      }
      var elts = row.children;
      for (_C = C = 0; _C < elts.length; ++_C) {
        var elt = elts[_C];
        if (opts.display && is_dom_element_hidden(elt)) continue;
        var v = elt.hasAttribute("data-v") ? elt.getAttribute("data-v") : elt.hasAttribute("v") ? elt.getAttribute("v") : htmldecode(elt.innerHTML);
        var z = elt.getAttribute("data-z") || elt.getAttribute("z");
        for (midx = 0; midx < merges.length; ++midx) {
          var m = merges[midx];
          if (m.s.c == C + or_C && m.s.r < R + or_R && R + or_R <= m.e.r) {
            C = m.e.c + 1 - or_C;
            midx = -1;
          }
        }
        CS = +elt.getAttribute("colspan") || 1;
        if ((RS = +elt.getAttribute("rowspan") || 1) > 1 || CS > 1) merges.push({ s: { r: R + or_R, c: C + or_C }, e: { r: R + or_R + (RS || 1) - 1, c: C + or_C + (CS || 1) - 1 } });
        var o = { t: "s", v };
        var _t = elt.getAttribute("data-t") || elt.getAttribute("t") || "";
        if (v != null) {
          if (v.length == 0) o.t = _t || "z";
          else if (opts.raw || v.trim().length == 0 || _t == "s") {
          } else if (v === "TRUE") o = { t: "b", v: true };
          else if (v === "FALSE") o = { t: "b", v: false };
          else if (!isNaN(fuzzynum(v))) o = { t: "n", v: fuzzynum(v) };
          else if (!isNaN(fuzzydate(v).getDate())) {
            o = { t: "d", v: parseDate(v) };
            if (!opts.cellDates) o = { t: "n", v: datenum(o.v) };
            o.z = opts.dateNF || table_fmt[14];
          }
        }
        if (o.z === void 0 && z != null) o.z = z;
        var l = "", Aelts = elt.getElementsByTagName("A");
        if (Aelts && Aelts.length) {
          for (var Aelti = 0; Aelti < Aelts.length; ++Aelti) if (Aelts[Aelti].hasAttribute("href")) {
            l = Aelts[Aelti].getAttribute("href");
            if (l.charAt(0) != "#") break;
          }
        }
        if (l && l.charAt(0) != "#") o.l = { Target: l };
        if (opts.dense) {
          if (!ws[R + or_R]) ws[R + or_R] = [];
          ws[R + or_R][C + or_C] = o;
        } else ws[encode_cell({ c: C + or_C, r: R + or_R })] = o;
        if (range.e.c < C + or_C) range.e.c = C + or_C;
        C += CS;
      }
      ++R;
    }
    if (merges.length) ws["!merges"] = (ws["!merges"] || []).concat(merges);
    range.e.r = Math.max(range.e.r, R - 1 + or_R);
    ws["!ref"] = encode_range(range);
    if (R >= sheetRows) ws["!fullref"] = encode_range((range.e.r = rows.length - _R + R - 1 + or_R, range));
    return ws;
  }
  function parse_dom_table(table, _opts) {
    var opts = _opts || {};
    var ws = opts.dense ? [] : {};
    return sheet_add_dom(ws, table, _opts);
  }
  function table_to_book(table, opts) {
    return sheet_to_workbook(parse_dom_table(table, opts), opts);
  }
  function is_dom_element_hidden(element) {
    var display = "";
    var get_computed_style = get_get_computed_style_function(element);
    if (get_computed_style) display = get_computed_style(element).getPropertyValue("display");
    if (!display) display = element.style && element.style.display;
    return display === "none";
  }
  function get_get_computed_style_function(element) {
    if (element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === "function") return element.ownerDocument.defaultView.getComputedStyle;
    if (typeof getComputedStyle === "function") return getComputedStyle;
    return null;
  }
  var write_styles_ods = /* @__PURE__ */ (function() {
    var master_styles = [
      "<office:master-styles>",
      '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
      "<style:header/>",
      '<style:header-left style:display="false"/>',
      "<style:footer/>",
      '<style:footer-left style:display="false"/>',
      "</style:master-page>",
      "</office:master-styles>"
    ].join("");
    var payload = "<office:document-styles " + wxt_helper({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "office:version": "1.2"
    }) + ">" + master_styles + "</office:document-styles>";
    return function wso() {
      return XML_HEADER + payload;
    };
  })();
  var write_content_ods = /* @__PURE__ */ (function() {
    var write_text_p = function(text) {
      return escapexml(text).replace(/  +/g, function($$) {
        return '<text:s text:c="' + $$.length + '"/>';
      }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
    };
    var null_cell_xml = "          <table:table-cell />\n";
    var covered_cell_xml = "          <table:covered-table-cell/>\n";
    var write_ws2 = function(ws, wb, i) {
      var o = [];
      o.push('      <table:table table:name="' + escapexml(wb.SheetNames[i]) + '" table:style-name="ta1">\n');
      var R = 0, C = 0, range = decode_range(ws["!ref"] || "A1");
      var marr = ws["!merges"] || [], mi = 0;
      var dense = Array.isArray(ws);
      if (ws["!cols"]) {
        for (C = 0; C <= range.e.c; ++C) o.push("        <table:table-column" + (ws["!cols"][C] ? ' table:style-name="co' + ws["!cols"][C].ods + '"' : "") + "></table:table-column>\n");
      }
      var H = "", ROWS = ws["!rows"] || [];
      for (R = 0; R < range.s.r; ++R) {
        H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
        o.push("        <table:table-row" + H + "></table:table-row>\n");
      }
      for (; R <= range.e.r; ++R) {
        H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
        o.push("        <table:table-row" + H + ">\n");
        for (C = 0; C < range.s.c; ++C) o.push(null_cell_xml);
        for (; C <= range.e.c; ++C) {
          var skip = false, ct = {}, textp = "";
          for (mi = 0; mi != marr.length; ++mi) {
            if (marr[mi].s.c > C) continue;
            if (marr[mi].s.r > R) continue;
            if (marr[mi].e.c < C) continue;
            if (marr[mi].e.r < R) continue;
            if (marr[mi].s.c != C || marr[mi].s.r != R) skip = true;
            ct["table:number-columns-spanned"] = marr[mi].e.c - marr[mi].s.c + 1;
            ct["table:number-rows-spanned"] = marr[mi].e.r - marr[mi].s.r + 1;
            break;
          }
          if (skip) {
            o.push(covered_cell_xml);
            continue;
          }
          var ref = encode_cell({ r: R, c: C }), cell = dense ? (ws[R] || [])[C] : ws[ref];
          if (cell && cell.f) {
            ct["table:formula"] = escapexml(csf_to_ods_formula(cell.f));
            if (cell.F) {
              if (cell.F.slice(0, ref.length) == ref) {
                var _Fref = decode_range(cell.F);
                ct["table:number-matrix-columns-spanned"] = _Fref.e.c - _Fref.s.c + 1;
                ct["table:number-matrix-rows-spanned"] = _Fref.e.r - _Fref.s.r + 1;
              }
            }
          }
          if (!cell) {
            o.push(null_cell_xml);
            continue;
          }
          switch (cell.t) {
            case "b":
              textp = cell.v ? "TRUE" : "FALSE";
              ct["office:value-type"] = "boolean";
              ct["office:boolean-value"] = cell.v ? "true" : "false";
              break;
            case "n":
              textp = cell.w || String(cell.v || 0);
              ct["office:value-type"] = "float";
              ct["office:value"] = cell.v || 0;
              break;
            case "s":
            case "str":
              textp = cell.v == null ? "" : cell.v;
              ct["office:value-type"] = "string";
              break;
            case "d":
              textp = cell.w || parseDate(cell.v).toISOString();
              ct["office:value-type"] = "date";
              ct["office:date-value"] = parseDate(cell.v).toISOString();
              ct["table:style-name"] = "ce1";
              break;
            //case 'e':
            default:
              o.push(null_cell_xml);
              continue;
          }
          var text_p = write_text_p(textp);
          if (cell.l && cell.l.Target) {
            var _tgt = cell.l.Target;
            _tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;
            if (_tgt.charAt(0) != "#" && !_tgt.match(/^\w+:/)) _tgt = "../" + _tgt;
            text_p = writextag("text:a", text_p, { "xlink:href": _tgt.replace(/&/g, "&amp;") });
          }
          o.push("          " + writextag("table:table-cell", writextag("text:p", text_p, {}), ct) + "\n");
        }
        o.push("        </table:table-row>\n");
      }
      o.push("      </table:table>\n");
      return o.join("");
    };
    var write_automatic_styles_ods = function(o, wb) {
      o.push(" <office:automatic-styles>\n");
      o.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');
      o.push('   <number:month number:style="long"/>\n');
      o.push("   <number:text>/</number:text>\n");
      o.push('   <number:day number:style="long"/>\n');
      o.push("   <number:text>/</number:text>\n");
      o.push("   <number:year/>\n");
      o.push("  </number:date-style>\n");
      var cidx = 0;
      wb.SheetNames.map(function(n) {
        return wb.Sheets[n];
      }).forEach(function(ws) {
        if (!ws) return;
        if (ws["!cols"]) {
          for (var C = 0; C < ws["!cols"].length; ++C) if (ws["!cols"][C]) {
            var colobj = ws["!cols"][C];
            if (colobj.width == null && colobj.wpx == null && colobj.wch == null) continue;
            process_col(colobj);
            colobj.ods = cidx;
            var w = ws["!cols"][C].wpx + "px";
            o.push('  <style:style style:name="co' + cidx + '" style:family="table-column">\n');
            o.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + w + '"/>\n');
            o.push("  </style:style>\n");
            ++cidx;
          }
        }
      });
      var ridx = 0;
      wb.SheetNames.map(function(n) {
        return wb.Sheets[n];
      }).forEach(function(ws) {
        if (!ws) return;
        if (ws["!rows"]) {
          for (var R = 0; R < ws["!rows"].length; ++R) if (ws["!rows"][R]) {
            ws["!rows"][R].ods = ridx;
            var h = ws["!rows"][R].hpx + "px";
            o.push('  <style:style style:name="ro' + ridx + '" style:family="table-row">\n');
            o.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + h + '"/>\n');
            o.push("  </style:style>\n");
            ++ridx;
          }
        }
      });
      o.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n');
      o.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n');
      o.push("  </style:style>\n");
      o.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');
      o.push(" </office:automatic-styles>\n");
    };
    return function wcx(wb, opts) {
      var o = [XML_HEADER];
      var attr = wxt_helper({
        "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
        "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
        "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
        "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
        "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
        "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        "xmlns:dc": "http://purl.org/dc/elements/1.1/",
        "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
        "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
        "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
        "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
        "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
        "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
        "xmlns:math": "http://www.w3.org/1998/Math/MathML",
        "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
        "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
        "xmlns:ooo": "http://openoffice.org/2004/office",
        "xmlns:ooow": "http://openoffice.org/2004/writer",
        "xmlns:oooc": "http://openoffice.org/2004/calc",
        "xmlns:dom": "http://www.w3.org/2001/xml-events",
        "xmlns:xforms": "http://www.w3.org/2002/xforms",
        "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
        "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
        "xmlns:rpt": "http://openoffice.org/2005/report",
        "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
        "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
        "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
        "xmlns:tableooo": "http://openoffice.org/2009/table",
        "xmlns:drawooo": "http://openoffice.org/2010/draw",
        "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
        "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
        "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
        "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
        "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
        "office:version": "1.2"
      });
      var fods = wxt_helper({
        "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
        "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
      });
      if (opts.bookType == "fods") {
        o.push("<office:document" + attr + fods + ">\n");
        o.push(write_meta_ods().replace(/office:document-meta/g, "office:meta"));
      } else o.push("<office:document-content" + attr + ">\n");
      write_automatic_styles_ods(o, wb);
      o.push("  <office:body>\n");
      o.push("    <office:spreadsheet>\n");
      for (var i = 0; i != wb.SheetNames.length; ++i) o.push(write_ws2(wb.Sheets[wb.SheetNames[i]], wb, i, opts));
      o.push("    </office:spreadsheet>\n");
      o.push("  </office:body>\n");
      if (opts.bookType == "fods") o.push("</office:document>");
      else o.push("</office:document-content>");
      return o.join("");
    };
  })();
  function write_ods(wb, opts) {
    if (opts.bookType == "fods") return write_content_ods(wb, opts);
    var zip = zip_new();
    var f = "";
    var manifest = [];
    var rdf = [];
    f = "mimetype";
    zip_add_file(zip, f, "application/vnd.oasis.opendocument.spreadsheet");
    f = "content.xml";
    zip_add_file(zip, f, write_content_ods(wb, opts));
    manifest.push([f, "text/xml"]);
    rdf.push([f, "ContentFile"]);
    f = "styles.xml";
    zip_add_file(zip, f, write_styles_ods(wb, opts));
    manifest.push([f, "text/xml"]);
    rdf.push([f, "StylesFile"]);
    f = "meta.xml";
    zip_add_file(zip, f, XML_HEADER + write_meta_ods(
      /*::wb, opts*/
    ));
    manifest.push([f, "text/xml"]);
    rdf.push([f, "MetadataFile"]);
    f = "manifest.rdf";
    zip_add_file(zip, f, write_rdf(
      rdf
      /*, opts*/
    ));
    manifest.push([f, "application/rdf+xml"]);
    f = "META-INF/manifest.xml";
    zip_add_file(zip, f, write_manifest(
      manifest
      /*, opts*/
    ));
    return zip;
  }
  function u8_to_dataview(array) {
    return new DataView(array.buffer, array.byteOffset, array.byteLength);
  }
  function stru8(str) {
    return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));
  }
  function u8contains(body, search) {
    outer:
      for (var L = 0; L <= body.length - search.length; ++L) {
        for (var j = 0; j < search.length; ++j)
          if (body[L + j] != search[j])
            continue outer;
        return true;
      }
    return false;
  }
  function u8concat(u8a) {
    var len = u8a.reduce(function(acc, x) {
      return acc + x.length;
    }, 0);
    var out = new Uint8Array(len);
    var off = 0;
    u8a.forEach(function(u8) {
      out.set(u8, off);
      off += u8.length;
    });
    return out;
  }
  function writeDecimal128LE(buf, offset, value) {
    var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 20;
    var mantissa = value / Math.pow(10, exp - 6176);
    buf[offset + 15] |= exp >> 7;
    buf[offset + 14] |= (exp & 127) << 1;
    for (var i = 0; mantissa >= 1; ++i, mantissa /= 256)
      buf[offset + i] = mantissa & 255;
    buf[offset + 15] |= value >= 0 ? 0 : 128;
  }
  function parse_varint49(buf, ptr) {
    var l = ptr ? ptr[0] : 0;
    var usz = buf[l] & 127;
    varint:
      if (buf[l++] >= 128) {
        usz |= (buf[l] & 127) << 7;
        if (buf[l++] < 128)
          break varint;
        usz |= (buf[l] & 127) << 14;
        if (buf[l++] < 128)
          break varint;
        usz |= (buf[l] & 127) << 21;
        if (buf[l++] < 128)
          break varint;
        usz += (buf[l] & 127) * Math.pow(2, 28);
        ++l;
        if (buf[l++] < 128)
          break varint;
        usz += (buf[l] & 127) * Math.pow(2, 35);
        ++l;
        if (buf[l++] < 128)
          break varint;
        usz += (buf[l] & 127) * Math.pow(2, 42);
        ++l;
        if (buf[l++] < 128)
          break varint;
      }
    if (ptr)
      ptr[0] = l;
    return usz;
  }
  function write_varint49(v) {
    var usz = new Uint8Array(7);
    usz[0] = v & 127;
    var L = 1;
    sz:
      if (v > 127) {
        usz[L - 1] |= 128;
        usz[L] = v >> 7 & 127;
        ++L;
        if (v <= 16383)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v >> 14 & 127;
        ++L;
        if (v <= 2097151)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v >> 21 & 127;
        ++L;
        if (v <= 268435455)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v / 256 >>> 21 & 127;
        ++L;
        if (v <= 34359738367)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v / 65536 >>> 21 & 127;
        ++L;
        if (v <= 4398046511103)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v / 16777216 >>> 21 & 127;
        ++L;
      }
    return usz.slice(0, L);
  }
  function varint_to_i32(buf) {
    var l = 0, i32 = buf[l] & 127;
    varint:
      if (buf[l++] >= 128) {
        i32 |= (buf[l] & 127) << 7;
        if (buf[l++] < 128)
          break varint;
        i32 |= (buf[l] & 127) << 14;
        if (buf[l++] < 128)
          break varint;
        i32 |= (buf[l] & 127) << 21;
        if (buf[l++] < 128)
          break varint;
        i32 |= (buf[l] & 127) << 28;
      }
    return i32;
  }
  function parse_shallow(buf) {
    var out = [], ptr = [0];
    while (ptr[0] < buf.length) {
      var off = ptr[0];
      var num = parse_varint49(buf, ptr);
      var type = num & 7;
      num = Math.floor(num / 8);
      var len = 0;
      var res;
      if (num == 0)
        break;
      switch (type) {
        case 0:
          {
            var l = ptr[0];
            while (buf[ptr[0]++] >= 128)
              ;
            res = buf.slice(l, ptr[0]);
          }
          break;
        case 5:
          len = 4;
          res = buf.slice(ptr[0], ptr[0] + len);
          ptr[0] += len;
          break;
        case 1:
          len = 8;
          res = buf.slice(ptr[0], ptr[0] + len);
          ptr[0] += len;
          break;
        case 2:
          len = parse_varint49(buf, ptr);
          res = buf.slice(ptr[0], ptr[0] + len);
          ptr[0] += len;
          break;
        case 3:
        case 4:
        default:
          throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
      }
      var v = { data: res, type };
      if (out[num] == null)
        out[num] = [v];
      else
        out[num].push(v);
    }
    return out;
  }
  function write_shallow(proto) {
    var out = [];
    proto.forEach(function(field, idx) {
      field.forEach(function(item) {
        if (!item.data)
          return;
        out.push(write_varint49(idx * 8 + item.type));
        if (item.type == 2)
          out.push(write_varint49(item.data.length));
        out.push(item.data);
      });
    });
    return u8concat(out);
  }
  function parse_iwa_file(buf) {
    var _a;
    var out = [], ptr = [0];
    while (ptr[0] < buf.length) {
      var len = parse_varint49(buf, ptr);
      var ai = parse_shallow(buf.slice(ptr[0], ptr[0] + len));
      ptr[0] += len;
      var res = {
        id: varint_to_i32(ai[1][0].data),
        messages: []
      };
      ai[2].forEach(function(b) {
        var mi = parse_shallow(b.data);
        var fl = varint_to_i32(mi[3][0].data);
        res.messages.push({
          meta: mi,
          data: buf.slice(ptr[0], ptr[0] + fl)
        });
        ptr[0] += fl;
      });
      if ((_a = ai[3]) == null ? void 0 : _a[0])
        res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
      out.push(res);
    }
    return out;
  }
  function write_iwa_file(ias) {
    var bufs = [];
    ias.forEach(function(ia) {
      var ai = [];
      ai[1] = [{ data: write_varint49(ia.id), type: 0 }];
      ai[2] = [];
      if (ia.merge != null)
        ai[3] = [{ data: write_varint49(+!!ia.merge), type: 0 }];
      var midata = [];
      ia.messages.forEach(function(mi) {
        midata.push(mi.data);
        mi.meta[3] = [{ type: 0, data: write_varint49(mi.data.length) }];
        ai[2].push({ data: write_shallow(mi.meta), type: 2 });
      });
      var aipayload = write_shallow(ai);
      bufs.push(write_varint49(aipayload.length));
      bufs.push(aipayload);
      midata.forEach(function(mid) {
        return bufs.push(mid);
      });
    });
    return u8concat(bufs);
  }
  function parse_snappy_chunk(type, buf) {
    if (type != 0)
      throw new Error("Unexpected Snappy chunk type ".concat(type));
    var ptr = [0];
    var usz = parse_varint49(buf, ptr);
    var chunks = [];
    while (ptr[0] < buf.length) {
      var tag = buf[ptr[0]] & 3;
      if (tag == 0) {
        var len = buf[ptr[0]++] >> 2;
        if (len < 60)
          ++len;
        else {
          var c = len - 59;
          len = buf[ptr[0]];
          if (c > 1)
            len |= buf[ptr[0] + 1] << 8;
          if (c > 2)
            len |= buf[ptr[0] + 2] << 16;
          if (c > 3)
            len |= buf[ptr[0] + 3] << 24;
          len >>>= 0;
          len++;
          ptr[0] += c;
        }
        chunks.push(buf.slice(ptr[0], ptr[0] + len));
        ptr[0] += len;
        continue;
      } else {
        var offset = 0, length = 0;
        if (tag == 1) {
          length = (buf[ptr[0]] >> 2 & 7) + 4;
          offset = (buf[ptr[0]++] & 224) << 3;
          offset |= buf[ptr[0]++];
        } else {
          length = (buf[ptr[0]++] >> 2) + 1;
          if (tag == 2) {
            offset = buf[ptr[0]] | buf[ptr[0] + 1] << 8;
            ptr[0] += 2;
          } else {
            offset = (buf[ptr[0]] | buf[ptr[0] + 1] << 8 | buf[ptr[0] + 2] << 16 | buf[ptr[0] + 3] << 24) >>> 0;
            ptr[0] += 4;
          }
        }
        chunks = [u8concat(chunks)];
        if (offset == 0)
          throw new Error("Invalid offset 0");
        if (offset > chunks[0].length)
          throw new Error("Invalid offset beyond length");
        if (length >= offset) {
          chunks.push(chunks[0].slice(-offset));
          length -= offset;
          while (length >= chunks[chunks.length - 1].length) {
            chunks.push(chunks[chunks.length - 1]);
            length -= chunks[chunks.length - 1].length;
          }
        }
        chunks.push(chunks[0].slice(-offset, -offset + length));
      }
    }
    var o = u8concat(chunks);
    if (o.length != usz)
      throw new Error("Unexpected length: ".concat(o.length, " != ").concat(usz));
    return o;
  }
  function decompress_iwa_file(buf) {
    var out = [];
    var l = 0;
    while (l < buf.length) {
      var t = buf[l++];
      var len = buf[l] | buf[l + 1] << 8 | buf[l + 2] << 16;
      l += 3;
      out.push(parse_snappy_chunk(t, buf.slice(l, l + len)));
      l += len;
    }
    if (l !== buf.length)
      throw new Error("data is not a valid framed stream!");
    return u8concat(out);
  }
  function compress_iwa_file(buf) {
    var out = [];
    var l = 0;
    while (l < buf.length) {
      var c = Math.min(buf.length - l, 268435455);
      var frame = new Uint8Array(4);
      out.push(frame);
      var usz = write_varint49(c);
      var L = usz.length;
      out.push(usz);
      if (c <= 60) {
        L++;
        out.push(new Uint8Array([c - 1 << 2]));
      } else if (c <= 256) {
        L += 2;
        out.push(new Uint8Array([240, c - 1 & 255]));
      } else if (c <= 65536) {
        L += 3;
        out.push(new Uint8Array([244, c - 1 & 255, c - 1 >> 8 & 255]));
      } else if (c <= 16777216) {
        L += 4;
        out.push(new Uint8Array([248, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255]));
      } else if (c <= 4294967296) {
        L += 5;
        out.push(new Uint8Array([252, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255, c - 1 >>> 24 & 255]));
      }
      out.push(buf.slice(l, l + c));
      L += c;
      frame[0] = 0;
      frame[1] = L & 255;
      frame[2] = L >> 8 & 255;
      frame[3] = L >> 16 & 255;
      l += c;
    }
    return u8concat(out);
  }
  function write_new_storage(cell, sst) {
    var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;
    out[0] = 5;
    switch (cell.t) {
      case "n":
        out[1] = 2;
        writeDecimal128LE(out, l, cell.v);
        flags |= 1;
        l += 16;
        break;
      case "b":
        out[1] = 6;
        dv.setFloat64(l, cell.v ? 1 : 0, true);
        flags |= 2;
        l += 8;
        break;
      case "s":
        if (sst.indexOf(cell.v) == -1)
          throw new Error("Value ".concat(cell.v, " missing from SST!"));
        out[1] = 3;
        dv.setUint32(l, sst.indexOf(cell.v), true);
        flags |= 8;
        l += 4;
        break;
      default:
        throw "unsupported cell type " + cell.t;
    }
    dv.setUint32(8, flags, true);
    return out.slice(0, l);
  }
  function write_old_storage(cell, sst) {
    var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;
    out[0] = 3;
    switch (cell.t) {
      case "n":
        out[2] = 2;
        dv.setFloat64(l, cell.v, true);
        flags |= 32;
        l += 8;
        break;
      case "b":
        out[2] = 6;
        dv.setFloat64(l, cell.v ? 1 : 0, true);
        flags |= 32;
        l += 8;
        break;
      case "s":
        if (sst.indexOf(cell.v) == -1)
          throw new Error("Value ".concat(cell.v, " missing from SST!"));
        out[2] = 3;
        dv.setUint32(l, sst.indexOf(cell.v), true);
        flags |= 16;
        l += 4;
        break;
      default:
        throw "unsupported cell type " + cell.t;
    }
    dv.setUint32(4, flags, true);
    return out.slice(0, l);
  }
  function parse_TSP_Reference(buf) {
    var pb = parse_shallow(buf);
    return parse_varint49(pb[1][0].data);
  }
  function write_tile_row(tri, data, SST) {
    var _a, _b, _c, _d;
    if (!((_a = tri[6]) == null ? void 0 : _a[0]) || !((_b = tri[7]) == null ? void 0 : _b[0]))
      throw "Mutation only works on post-BNC storages!";
    var wide_offsets = ((_d = (_c = tri[8]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && varint_to_i32(tri[8][0].data) > 0 || false;
    if (wide_offsets)
      throw "Math only works with normal offsets";
    var cnt = 0;
    var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];
    var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];
    for (var C = 0; C < data.length; ++C) {
      if (data[C] == null) {
        dv.setUint16(C * 2, 65535, true);
        _dv.setUint16(C * 2, 65535);
        continue;
      }
      dv.setUint16(C * 2, last_offset, true);
      _dv.setUint16(C * 2, _last_offset, true);
      var celload, _celload;
      switch (typeof data[C]) {
        case "string":
          celload = write_new_storage({ t: "s", v: data[C] }, SST);
          _celload = write_old_storage({ t: "s", v: data[C] }, SST);
          break;
        case "number":
          celload = write_new_storage({ t: "n", v: data[C] }, SST);
          _celload = write_old_storage({ t: "n", v: data[C] }, SST);
          break;
        case "boolean":
          celload = write_new_storage({ t: "b", v: data[C] }, SST);
          _celload = write_old_storage({ t: "b", v: data[C] }, SST);
          break;
        default:
          throw new Error("Unsupported value " + data[C]);
      }
      cell_storage.push(celload);
      last_offset += celload.length;
      _cell_storage.push(_celload);
      _last_offset += _celload.length;
      ++cnt;
    }
    tri[2][0].data = write_varint49(cnt);
    for (; C < tri[7][0].data.length / 2; ++C) {
      dv.setUint16(C * 2, 65535, true);
      _dv.setUint16(C * 2, 65535, true);
    }
    tri[6][0].data = u8concat(cell_storage);
    tri[3][0].data = u8concat(_cell_storage);
    return cnt;
  }
  function write_numbers_iwa(wb, opts) {
    if (!opts || !opts.numbers)
      throw new Error("Must pass a `numbers` option -- check the README");
    var ws = wb.Sheets[wb.SheetNames[0]];
    if (wb.SheetNames.length > 1)
      console.error("The Numbers writer currently writes only the first table");
    var range = decode_range(ws["!ref"]);
    range.s.r = range.s.c = 0;
    var trunc = false;
    if (range.e.c > 9) {
      trunc = true;
      range.e.c = 9;
    }
    if (range.e.r > 49) {
      trunc = true;
      range.e.r = 49;
    }
    if (trunc)
      console.error("The Numbers writer is currently limited to ".concat(encode_range(range)));
    var data = sheet_to_json(ws, { range, header: 1 });
    var SST = ["~Sh33tJ5~"];
    data.forEach(function(row) {
      return row.forEach(function(cell) {
        if (typeof cell == "string")
          SST.push(cell);
      });
    });
    var dependents = {};
    var indices = [];
    var cfb = CFB.read(opts.numbers, { type: "base64" });
    cfb.FileIndex.map(function(fi, idx) {
      return [fi, cfb.FullPaths[idx]];
    }).forEach(function(row) {
      var fi = row[0], fp = row[1];
      if (fi.type != 2)
        return;
      if (!fi.name.match(/\.iwa/))
        return;
      var old_content = fi.content;
      var raw1 = decompress_iwa_file(old_content);
      var x2 = parse_iwa_file(raw1);
      x2.forEach(function(packet2) {
        indices.push(packet2.id);
        dependents[packet2.id] = { deps: [], location: fp, type: varint_to_i32(packet2.messages[0].meta[1][0].data) };
      });
    });
    indices.sort(function(x2, y2) {
      return x2 - y2;
    });
    var indices_varint = indices.filter(function(x2) {
      return x2 > 1;
    }).map(function(x2) {
      return [x2, write_varint49(x2)];
    });
    cfb.FileIndex.map(function(fi, idx) {
      return [fi, cfb.FullPaths[idx]];
    }).forEach(function(row) {
      var fi = row[0], fp = row[1];
      if (!fi.name.match(/\.iwa/))
        return;
      var x2 = parse_iwa_file(decompress_iwa_file(fi.content));
      x2.forEach(function(ia) {
        ia.messages.forEach(function(m) {
          indices_varint.forEach(function(ivi) {
            if (ia.messages.some(function(mess) {
              return varint_to_i32(mess.meta[1][0].data) != 11006 && u8contains(mess.data, ivi[1]);
            })) {
              dependents[ivi[0]].deps.push(ia.id);
            }
          });
        });
      });
    });
    function get_unique_msgid() {
      for (var i = 927262; i < 2e6; ++i)
        if (!dependents[i])
          return i;
      throw new Error("Too many messages");
    }
    var entry = CFB.find(cfb, dependents[1].location);
    var x = parse_iwa_file(decompress_iwa_file(entry.content));
    var docroot;
    for (var xi = 0; xi < x.length; ++xi) {
      var packet = x[xi];
      if (packet.id == 1)
        docroot = packet;
    }
    var sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);
    entry = CFB.find(cfb, dependents[sheetrootref].location);
    x = parse_iwa_file(decompress_iwa_file(entry.content));
    for (xi = 0; xi < x.length; ++xi) {
      packet = x[xi];
      if (packet.id == sheetrootref)
        docroot = packet;
    }
    sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
    entry = CFB.find(cfb, dependents[sheetrootref].location);
    x = parse_iwa_file(decompress_iwa_file(entry.content));
    for (xi = 0; xi < x.length; ++xi) {
      packet = x[xi];
      if (packet.id == sheetrootref)
        docroot = packet;
    }
    sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
    entry = CFB.find(cfb, dependents[sheetrootref].location);
    x = parse_iwa_file(decompress_iwa_file(entry.content));
    for (xi = 0; xi < x.length; ++xi) {
      packet = x[xi];
      if (packet.id == sheetrootref)
        docroot = packet;
    }
    var pb = parse_shallow(docroot.messages[0].data);
    {
      pb[6][0].data = write_varint49(range.e.r + 1);
      pb[7][0].data = write_varint49(range.e.c + 1);
      var cruidsref = parse_TSP_Reference(pb[46][0].data);
      var oldbucket = CFB.find(cfb, dependents[cruidsref].location);
      var _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
      {
        for (var j = 0; j < _x.length; ++j) {
          if (_x[j].id == cruidsref)
            break;
        }
        if (_x[j].id != cruidsref)
          throw "Bad ColumnRowUIDMapArchive";
        var cruids = parse_shallow(_x[j].messages[0].data);
        cruids[1] = [];
        cruids[2] = [], cruids[3] = [];
        for (var C = 0; C <= range.e.c; ++C) {
          var uuid = [];
          uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(C + 420690) }];
          cruids[1].push({ type: 2, data: write_shallow(uuid) });
          cruids[2].push({ type: 0, data: write_varint49(C) });
          cruids[3].push({ type: 0, data: write_varint49(C) });
        }
        cruids[4] = [];
        cruids[5] = [], cruids[6] = [];
        for (var R = 0; R <= range.e.r; ++R) {
          uuid = [];
          uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(R + 726270) }];
          cruids[4].push({ type: 2, data: write_shallow(uuid) });
          cruids[5].push({ type: 0, data: write_varint49(R) });
          cruids[6].push({ type: 0, data: write_varint49(R) });
        }
        _x[j].messages[0].data = write_shallow(cruids);
      }
      oldbucket.content = compress_iwa_file(write_iwa_file(_x));
      oldbucket.size = oldbucket.content.length;
      delete pb[46];
      var store = parse_shallow(pb[4][0].data);
      {
        store[7][0].data = write_varint49(range.e.r + 1);
        var row_headers = parse_shallow(store[1][0].data);
        var row_header_ref = parse_TSP_Reference(row_headers[2][0].data);
        oldbucket = CFB.find(cfb, dependents[row_header_ref].location);
        _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
        {
          if (_x[0].id != row_header_ref)
            throw "Bad HeaderStorageBucket";
          var base_bucket = parse_shallow(_x[0].messages[0].data);
          for (R = 0; R < data.length; ++R) {
            var _bucket = parse_shallow(base_bucket[2][0].data);
            _bucket[1][0].data = write_varint49(R);
            _bucket[4][0].data = write_varint49(data[R].length);
            base_bucket[2][R] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
          }
          _x[0].messages[0].data = write_shallow(base_bucket);
        }
        oldbucket.content = compress_iwa_file(write_iwa_file(_x));
        oldbucket.size = oldbucket.content.length;
        var col_header_ref = parse_TSP_Reference(store[2][0].data);
        oldbucket = CFB.find(cfb, dependents[col_header_ref].location);
        _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
        {
          if (_x[0].id != col_header_ref)
            throw "Bad HeaderStorageBucket";
          base_bucket = parse_shallow(_x[0].messages[0].data);
          for (C = 0; C <= range.e.c; ++C) {
            _bucket = parse_shallow(base_bucket[2][0].data);
            _bucket[1][0].data = write_varint49(C);
            _bucket[4][0].data = write_varint49(range.e.r + 1);
            base_bucket[2][C] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
          }
          _x[0].messages[0].data = write_shallow(base_bucket);
        }
        oldbucket.content = compress_iwa_file(write_iwa_file(_x));
        oldbucket.size = oldbucket.content.length;
        var sstref = parse_TSP_Reference(store[4][0].data);
        (function() {
          var sentry = CFB.find(cfb, dependents[sstref].location);
          var sx = parse_iwa_file(decompress_iwa_file(sentry.content));
          var sstroot;
          for (var sxi = 0; sxi < sx.length; ++sxi) {
            var packet2 = sx[sxi];
            if (packet2.id == sstref)
              sstroot = packet2;
          }
          var sstdata = parse_shallow(sstroot.messages[0].data);
          {
            sstdata[3] = [];
            var newsst = [];
            SST.forEach(function(str, i) {
              newsst[1] = [{ type: 0, data: write_varint49(i) }];
              newsst[2] = [{ type: 0, data: write_varint49(1) }];
              newsst[3] = [{ type: 2, data: stru8(str) }];
              sstdata[3].push({ type: 2, data: write_shallow(newsst) });
            });
          }
          sstroot.messages[0].data = write_shallow(sstdata);
          var sy = write_iwa_file(sx);
          var raw32 = compress_iwa_file(sy);
          sentry.content = raw32;
          sentry.size = sentry.content.length;
        })();
        var tile = parse_shallow(store[3][0].data);
        {
          var t = tile[1][0];
          delete tile[2];
          var tl = parse_shallow(t.data);
          {
            var tileref = parse_TSP_Reference(tl[2][0].data);
            (function() {
              var tentry = CFB.find(cfb, dependents[tileref].location);
              var tx = parse_iwa_file(decompress_iwa_file(tentry.content));
              var tileroot;
              for (var sxi = 0; sxi < tx.length; ++sxi) {
                var packet2 = tx[sxi];
                if (packet2.id == tileref)
                  tileroot = packet2;
              }
              var tiledata = parse_shallow(tileroot.messages[0].data);
              {
                delete tiledata[6];
                delete tile[7];
                var rowload = new Uint8Array(tiledata[5][0].data);
                tiledata[5] = [];
                var cnt = 0;
                for (var R2 = 0; R2 <= range.e.r; ++R2) {
                  var tilerow = parse_shallow(rowload);
                  cnt += write_tile_row(tilerow, data[R2], SST);
                  tilerow[1][0].data = write_varint49(R2);
                  tiledata[5].push({ data: write_shallow(tilerow), type: 2 });
                }
                tiledata[1] = [{ type: 0, data: write_varint49(range.e.c + 1) }];
                tiledata[2] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
                tiledata[3] = [{ type: 0, data: write_varint49(cnt) }];
                tiledata[4] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
              }
              tileroot.messages[0].data = write_shallow(tiledata);
              var ty = write_iwa_file(tx);
              var raw32 = compress_iwa_file(ty);
              tentry.content = raw32;
              tentry.size = tentry.content.length;
            })();
          }
          t.data = write_shallow(tl);
        }
        store[3][0].data = write_shallow(tile);
      }
      pb[4][0].data = write_shallow(store);
    }
    docroot.messages[0].data = write_shallow(pb);
    var y = write_iwa_file(x);
    var raw3 = compress_iwa_file(y);
    entry.content = raw3;
    entry.size = entry.content.length;
    return cfb;
  }
  function fix_opts_func(defaults) {
    return function fix_opts(opts) {
      for (var i = 0; i != defaults.length; ++i) {
        var d = defaults[i];
        if (opts[d[0]] === void 0) opts[d[0]] = d[1];
        if (d[2] === "n") opts[d[0]] = Number(opts[d[0]]);
      }
    };
  }
  function fix_write_opts(opts) {
    fix_opts_func([
      ["cellDates", false],
      /* write date cells with type `d` */
      ["bookSST", false],
      /* Generate Shared String Table */
      ["bookType", "xlsx"],
      /* Type of workbook (xlsx/m/b) */
      ["compression", false],
      /* Use file compression */
      ["WTF", false]
      /* WTF mode (throws errors) */
    ])(opts);
  }
  function write_zip(wb, opts) {
    if (opts.bookType == "ods") return write_ods(wb, opts);
    if (opts.bookType == "numbers") return write_numbers_iwa(wb, opts);
    if (opts.bookType == "xlsb") return write_zip_xlsxb(wb, opts);
    return write_zip_xlsx(wb, opts);
  }
  function write_zip_xlsxb(wb, opts) {
    _shapeid = 1024;
    if (wb && !wb.SSF) {
      wb.SSF = dup(table_fmt);
    }
    if (wb && wb.SSF) {
      make_ssf();
      SSF_load_table(wb.SSF);
      opts.revssf = evert_num(wb.SSF);
      opts.revssf[wb.SSF[65535]] = 0;
      opts.ssf = wb.SSF;
    }
    opts.rels = {};
    opts.wbrels = {};
    opts.Strings = /*::((*/
    [];
    opts.Strings.Count = 0;
    opts.Strings.Unique = 0;
    if (browser_has_Map) opts.revStrings = /* @__PURE__ */ new Map();
    else {
      opts.revStrings = {};
      opts.revStrings.foo = [];
      delete opts.revStrings.foo;
    }
    var wbext = opts.bookType == "xlsb" ? "bin" : "xml";
    var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
    var ct = new_ct();
    fix_write_opts(opts = opts || {});
    var zip = zip_new();
    var f = "", rId = 0;
    opts.cellXfs = [];
    get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
    if (!wb.Props) wb.Props = {};
    f = "docProps/core.xml";
    zip_add_file(zip, f, write_core_props(wb.Props, opts));
    ct.coreprops.push(f);
    add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
    f = "docProps/app.xml";
    if (wb.Props && wb.Props.SheetNames) {
    } else if (!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;
    else {
      var _sn = [];
      for (var _i = 0; _i < wb.SheetNames.length; ++_i)
        if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2) _sn.push(wb.SheetNames[_i]);
      wb.Props.SheetNames = _sn;
    }
    wb.Props.Worksheets = wb.Props.SheetNames.length;
    zip_add_file(zip, f, write_ext_props(wb.Props, opts));
    ct.extprops.push(f);
    add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
    if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
      f = "docProps/custom.xml";
      zip_add_file(zip, f, write_cust_props(wb.Custprops, opts));
      ct.custprops.push(f);
      add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
    }
    for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
      var wsrels = { "!id": {} };
      var ws = wb.Sheets[wb.SheetNames[rId - 1]];
      var _type = (ws || {})["!type"] || "sheet";
      switch (_type) {
        case "chart":
        /* falls through */
        default:
          f = "xl/worksheets/sheet" + rId + "." + wbext;
          zip_add_file(zip, f, write_ws(rId - 1, f, opts, wb, wsrels));
          ct.sheets.push(f);
          add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
      }
      if (ws) {
        var comments = ws["!comments"];
        var need_vml = false;
        var cf = "";
        if (comments && comments.length > 0) {
          cf = "xl/comments" + rId + "." + wbext;
          zip_add_file(zip, cf, write_cmnt(comments, cf, opts));
          ct.comments.push(cf);
          add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
          need_vml = true;
        }
        if (ws["!legacy"]) {
          if (need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
        }
        delete ws["!comments"];
        delete ws["!legacy"];
      }
      if (wsrels["!id"].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
    }
    if (opts.Strings != null && opts.Strings.length > 0) {
      f = "xl/sharedStrings." + wbext;
      zip_add_file(zip, f, write_sst(opts.Strings, f, opts));
      ct.strs.push(f);
      add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
    }
    f = "xl/workbook." + wbext;
    zip_add_file(zip, f, write_wb(wb, f, opts));
    ct.workbooks.push(f);
    add_rels(opts.rels, 1, f, RELS.WB);
    f = "xl/theme/theme1.xml";
    zip_add_file(zip, f, write_theme(wb.Themes, opts));
    ct.themes.push(f);
    add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
    f = "xl/styles." + wbext;
    zip_add_file(zip, f, write_sty(wb, f, opts));
    ct.styles.push(f);
    add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
    if (wb.vbaraw && vbafmt) {
      f = "xl/vbaProject.bin";
      zip_add_file(zip, f, wb.vbaraw);
      ct.vba.push(f);
      add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
    }
    f = "xl/metadata." + wbext;
    zip_add_file(zip, f, write_xlmeta(f));
    ct.metadata.push(f);
    add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
    zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
    zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
    zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
    delete opts.revssf;
    delete opts.ssf;
    return zip;
  }
  function write_zip_xlsx(wb, opts) {
    _shapeid = 1024;
    if (wb && !wb.SSF) {
      wb.SSF = dup(table_fmt);
    }
    if (wb && wb.SSF) {
      make_ssf();
      SSF_load_table(wb.SSF);
      opts.revssf = evert_num(wb.SSF);
      opts.revssf[wb.SSF[65535]] = 0;
      opts.ssf = wb.SSF;
    }
    opts.rels = {};
    opts.wbrels = {};
    opts.Strings = /*::((*/
    [];
    opts.Strings.Count = 0;
    opts.Strings.Unique = 0;
    if (browser_has_Map) opts.revStrings = /* @__PURE__ */ new Map();
    else {
      opts.revStrings = {};
      opts.revStrings.foo = [];
      delete opts.revStrings.foo;
    }
    var wbext = "xml";
    var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
    var ct = new_ct();
    fix_write_opts(opts = opts || {});
    var zip = zip_new();
    var f = "", rId = 0;
    opts.cellXfs = [];
    get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
    if (!wb.Props) wb.Props = {};
    f = "docProps/core.xml";
    zip_add_file(zip, f, write_core_props(wb.Props, opts));
    ct.coreprops.push(f);
    add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
    f = "docProps/app.xml";
    if (wb.Props && wb.Props.SheetNames) {
    } else if (!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;
    else {
      var _sn = [];
      for (var _i = 0; _i < wb.SheetNames.length; ++_i)
        if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2) _sn.push(wb.SheetNames[_i]);
      wb.Props.SheetNames = _sn;
    }
    wb.Props.Worksheets = wb.Props.SheetNames.length;
    zip_add_file(zip, f, write_ext_props(wb.Props, opts));
    ct.extprops.push(f);
    add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
    if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
      f = "docProps/custom.xml";
      zip_add_file(zip, f, write_cust_props(wb.Custprops, opts));
      ct.custprops.push(f);
      add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
    }
    var people = ["SheetJ5"];
    opts.tcid = 0;
    for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
      var wsrels = { "!id": {} };
      var ws = wb.Sheets[wb.SheetNames[rId - 1]];
      var _type = (ws || {})["!type"] || "sheet";
      switch (_type) {
        case "chart":
        /* falls through */
        default:
          f = "xl/worksheets/sheet" + rId + "." + wbext;
          zip_add_file(zip, f, write_ws_xml(rId - 1, opts, wb, wsrels));
          ct.sheets.push(f);
          add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
      }
      if (ws) {
        var comments = ws["!comments"];
        var need_vml = false;
        var cf = "";
        if (comments && comments.length > 0) {
          var needtc = false;
          comments.forEach(function(carr) {
            carr[1].forEach(function(c) {
              if (c.T == true) needtc = true;
            });
          });
          if (needtc) {
            cf = "xl/threadedComments/threadedComment" + rId + "." + wbext;
            zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));
            ct.threadedcomments.push(cf);
            add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + "." + wbext, RELS.TCMNT);
          }
          cf = "xl/comments" + rId + "." + wbext;
          zip_add_file(zip, cf, write_comments_xml(comments, opts));
          ct.comments.push(cf);
          add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
          need_vml = true;
        }
        if (ws["!legacy"]) {
          if (need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
        }
        delete ws["!comments"];
        delete ws["!legacy"];
      }
      if (wsrels["!id"].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
    }
    if (opts.Strings != null && opts.Strings.length > 0) {
      f = "xl/sharedStrings." + wbext;
      zip_add_file(zip, f, write_sst_xml(opts.Strings, opts));
      ct.strs.push(f);
      add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
    }
    f = "xl/workbook." + wbext;
    zip_add_file(zip, f, write_wb_xml(wb, opts));
    ct.workbooks.push(f);
    add_rels(opts.rels, 1, f, RELS.WB);
    f = "xl/theme/theme1.xml";
    zip_add_file(zip, f, write_theme(wb.Themes, opts));
    ct.themes.push(f);
    add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
    f = "xl/styles." + wbext;
    zip_add_file(zip, f, write_sty_xml(wb, opts));
    ct.styles.push(f);
    add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
    if (wb.vbaraw && vbafmt) {
      f = "xl/vbaProject.bin";
      zip_add_file(zip, f, wb.vbaraw);
      ct.vba.push(f);
      add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
    }
    f = "xl/metadata." + wbext;
    zip_add_file(zip, f, write_xlmeta_xml());
    ct.metadata.push(f);
    add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
    if (people.length > 1) {
      f = "xl/persons/person.xml";
      zip_add_file(zip, f, write_people_xml(people, opts));
      ct.people.push(f);
      add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);
    }
    zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
    zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
    zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
    delete opts.revssf;
    delete opts.ssf;
    return zip;
  }
  function firstbyte(f, o) {
    var x = "";
    switch ((o || {}).type || "base64") {
      case "buffer":
        return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
      case "base64":
        x = Base64_decode(f.slice(0, 12));
        break;
      case "binary":
        x = f;
        break;
      case "array":
        return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
      default:
        throw new Error("Unrecognized type " + (o && o.type || "undefined"));
    }
    return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];
  }
  function write_cfb_ctr(cfb, o) {
    switch (o.type) {
      case "base64":
      case "binary":
        break;
      case "buffer":
      case "array":
        o.type = "";
        break;
      case "file":
        return write_dl(o.file, CFB.write(cfb, { type: has_buf ? "buffer" : "" }));
      case "string":
        throw new Error("'string' output type invalid for '" + o.bookType + "' files");
      default:
        throw new Error("Unrecognized type " + o.type);
    }
    return CFB.write(cfb, o);
  }
  function write_zip_type(wb, opts) {
    var o = dup(opts || {});
    var z = write_zip(wb, o);
    return write_zip_denouement(z, o);
  }
  function write_zip_denouement(z, o) {
    var oopts = {};
    var ftype = has_buf ? "nodebuffer" : typeof Uint8Array !== "undefined" ? "array" : "string";
    if (o.compression) oopts.compression = "DEFLATE";
    if (o.password) oopts.type = ftype;
    else switch (o.type) {
      case "base64":
        oopts.type = "base64";
        break;
      case "binary":
        oopts.type = "string";
        break;
      case "string":
        throw new Error("'string' output type invalid for '" + o.bookType + "' files");
      case "buffer":
      case "file":
        oopts.type = ftype;
        break;
      default:
        throw new Error("Unrecognized type " + o.type);
    }
    var out = z.FullPaths ? CFB.write(z, { fileType: "zip", type: (
      /*::(*/
      { "nodebuffer": "buffer", "string": "binary" }[oopts.type] || oopts.type
    ), compression: !!o.compression }) : z.generate(oopts);
    if (typeof Deno !== "undefined") {
      if (typeof out == "string") {
        if (o.type == "binary" || o.type == "base64") return out;
        out = new Uint8Array(s2ab(out));
      }
    }
    if (o.password && typeof encrypt_agile !== "undefined") return write_cfb_ctr(encrypt_agile(out, o.password), o);
    if (o.type === "file") return write_dl(o.file, out);
    return o.type == "string" ? utf8read(
      /*::(*/
      out
      /*:: :any)*/
    ) : out;
  }
  function write_cfb_type(wb, opts) {
    var o = opts || {};
    var cfb = write_xlscfb(wb, o);
    return write_cfb_ctr(cfb, o);
  }
  function write_string_type(out, opts, bom) {
    if (!bom) bom = "";
    var o = bom + out;
    switch (opts.type) {
      case "base64":
        return Base64_encode(utf8write(o));
      case "binary":
        return utf8write(o);
      case "string":
        return out;
      case "file":
        return write_dl(opts.file, o, "utf8");
      case "buffer": {
        if (has_buf) return Buffer_from(o, "utf8");
        else if (typeof TextEncoder !== "undefined") return new TextEncoder().encode(o);
        else return write_string_type(o, { type: "binary" }).split("").map(function(c) {
          return c.charCodeAt(0);
        });
      }
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function write_stxt_type(out, opts) {
    switch (opts.type) {
      case "base64":
        return Base64_encode(out);
      case "binary":
        return out;
      case "string":
        return out;
      /* override in sheet_to_txt */
      case "file":
        return write_dl(opts.file, out, "binary");
      case "buffer": {
        if (has_buf) return Buffer_from(out, "binary");
        else return out.split("").map(function(c) {
          return c.charCodeAt(0);
        });
      }
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function write_binary_type(out, opts) {
    switch (opts.type) {
      case "string":
      case "base64":
      case "binary":
        var bstr = "";
        for (var i = 0; i < out.length; ++i) bstr += String.fromCharCode(out[i]);
        return opts.type == "base64" ? Base64_encode(bstr) : opts.type == "string" ? utf8read(bstr) : bstr;
      case "file":
        return write_dl(opts.file, out);
      case "buffer":
        return out;
      default:
        throw new Error("Unrecognized type " + opts.type);
    }
  }
  function writeSync(wb, opts) {
    reset_cp();
    check_wb(wb);
    var o = dup(opts || {});
    if (o.cellStyles) {
      o.cellNF = true;
      o.sheetStubs = true;
    }
    if (o.type == "array") {
      o.type = "binary";
      var out = writeSync(wb, o);
      o.type = "array";
      return s2ab(out);
    }
    var idx = 0;
    if (o.sheet) {
      if (typeof o.sheet == "number") idx = o.sheet;
      else idx = wb.SheetNames.indexOf(o.sheet);
      if (!wb.SheetNames[idx]) throw new Error("Sheet not found: " + o.sheet + " : " + typeof o.sheet);
    }
    switch (o.bookType || "xlsb") {
      case "xml":
      case "xlml":
        return write_string_type(write_xlml(wb, o), o);
      case "slk":
      case "sylk":
        return write_string_type(SYLK.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "htm":
      case "html":
        return write_string_type(sheet_to_html(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "txt":
        return write_stxt_type(sheet_to_txt(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "csv":
        return write_string_type(sheet_to_csv(wb.Sheets[wb.SheetNames[idx]], o), o, "\uFEFF");
      case "dif":
        return write_string_type(DIF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "dbf":
        return write_binary_type(DBF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "prn":
        return write_string_type(PRN.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "rtf":
        return write_string_type(RTF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "eth":
        return write_string_type(ETH.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "fods":
        return write_string_type(write_ods(wb, o), o);
      case "wk1":
        return write_binary_type(WK_.sheet_to_wk1(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "wk3":
        return write_binary_type(WK_.book_to_wk3(wb, o), o);
      case "biff2":
        if (!o.biff) o.biff = 2;
      /* falls through */
      case "biff3":
        if (!o.biff) o.biff = 3;
      /* falls through */
      case "biff4":
        if (!o.biff) o.biff = 4;
        return write_binary_type(write_biff_buf(wb, o), o);
      case "biff5":
        if (!o.biff) o.biff = 5;
      /* falls through */
      case "biff8":
      case "xla":
      case "xls":
        if (!o.biff) o.biff = 8;
        return write_cfb_type(wb, o);
      case "xlsx":
      case "xlsm":
      case "xlam":
      case "xlsb":
      case "numbers":
      case "ods":
        return write_zip_type(wb, o);
      default:
        throw new Error("Unrecognized bookType |" + o.bookType + "|");
    }
  }
  function make_json_row(sheet, r, R, cols, header, hdr, dense, o) {
    var rr = encode_row(R);
    var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");
    var isempty = true;
    var row = header === 1 ? [] : {};
    if (header !== 1) {
      if (Object.defineProperty) try {
        Object.defineProperty(row, "__rowNum__", { value: R, enumerable: false });
      } catch (e) {
        row.__rowNum__ = R;
      }
      else row.__rowNum__ = R;
    }
    if (!dense || sheet[R]) for (var C = r.s.c; C <= r.e.c; ++C) {
      var val = dense ? sheet[R][C] : sheet[cols[C] + rr];
      if (val === void 0 || val.t === void 0) {
        if (defval === void 0) continue;
        if (hdr[C] != null) {
          row[hdr[C]] = defval;
        }
        continue;
      }
      var v = val.v;
      switch (val.t) {
        case "z":
          if (v == null) break;
          continue;
        case "e":
          v = v == 0 ? null : void 0;
          break;
        case "s":
        case "d":
        case "b":
        case "n":
          break;
        default:
          throw new Error("unrecognized type " + val.t);
      }
      if (hdr[C] != null) {
        if (v == null) {
          if (val.t == "e" && v === null) row[hdr[C]] = null;
          else if (defval !== void 0) row[hdr[C]] = defval;
          else if (raw && v === null) row[hdr[C]] = null;
          else continue;
        } else {
          row[hdr[C]] = raw && (val.t !== "n" || val.t === "n" && o.rawNumbers !== false) ? v : format_cell(val, v, o);
        }
        if (v != null) isempty = false;
      }
    }
    return { row, isempty };
  }
  function sheet_to_json(sheet, opts) {
    if (sheet == null || sheet["!ref"] == null) return [];
    var val = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v = 0, vv = "";
    var r = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    var o = opts || {};
    var range = o.range != null ? o.range : sheet["!ref"];
    if (o.header === 1) header = 1;
    else if (o.header === "A") header = 2;
    else if (Array.isArray(o.header)) header = 3;
    else if (o.header == null) header = 0;
    switch (typeof range) {
      case "string":
        r = safe_decode_range(range);
        break;
      case "number":
        r = safe_decode_range(sheet["!ref"]);
        r.s.r = range;
        break;
      default:
        r = range;
    }
    if (header > 0) offset = 0;
    var rr = encode_row(r.s.r);
    var cols = [];
    var out = [];
    var outi = 0, counter = 0;
    var dense = Array.isArray(sheet);
    var R = r.s.r, C = 0;
    var header_cnt = {};
    if (dense && !sheet[R]) sheet[R] = [];
    var colinfo = o.skipHidden && sheet["!cols"] || [];
    var rowinfo = o.skipHidden && sheet["!rows"] || [];
    for (C = r.s.c; C <= r.e.c; ++C) {
      if ((colinfo[C] || {}).hidden) continue;
      cols[C] = encode_col(C);
      val = dense ? sheet[R][C] : sheet[cols[C] + rr];
      switch (header) {
        case 1:
          hdr[C] = C - r.s.c;
          break;
        case 2:
          hdr[C] = cols[C];
          break;
        case 3:
          hdr[C] = o.header[C - r.s.c];
          break;
        default:
          if (val == null) val = { w: "__EMPTY", t: "s" };
          vv = v = format_cell(val, null, o);
          counter = header_cnt[v] || 0;
          if (!counter) header_cnt[v] = 1;
          else {
            do {
              vv = v + "_" + counter++;
            } while (header_cnt[vv]);
            header_cnt[v] = counter;
            header_cnt[vv] = 1;
          }
          hdr[C] = vv;
      }
    }
    for (R = r.s.r + offset; R <= r.e.r; ++R) {
      if ((rowinfo[R] || {}).hidden) continue;
      var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);
      if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows)) out[outi++] = row.row;
    }
    out.length = outi;
    return out;
  }
  var qreg = /"/g;
  function make_csv_row(sheet, r, R, cols, fs, rs, FS, o) {
    var isempty = true;
    var row = [], txt = "", rr = encode_row(R);
    for (var C = r.s.c; C <= r.e.c; ++C) {
      if (!cols[C]) continue;
      var val = o.dense ? (sheet[R] || [])[C] : sheet[cols[C] + rr];
      if (val == null) txt = "";
      else if (val.v != null) {
        isempty = false;
        txt = "" + (o.rawNumbers && val.t == "n" ? val.v : format_cell(val, null, o));
        for (var i = 0, cc = 0; i !== txt.length; ++i) if ((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {
          txt = '"' + txt.replace(qreg, '""') + '"';
          break;
        }
        if (txt == "ID") txt = '"ID"';
      } else if (val.f != null && !val.F) {
        isempty = false;
        txt = "=" + val.f;
        if (txt.indexOf(",") >= 0) txt = '"' + txt.replace(qreg, '""') + '"';
      } else txt = "";
      row.push(txt);
    }
    if (o.blankrows === false && isempty) return null;
    return row.join(FS);
  }
  function sheet_to_csv(sheet, opts) {
    var out = [];
    var o = opts == null ? {} : opts;
    if (sheet == null || sheet["!ref"] == null) return "";
    var r = safe_decode_range(sheet["!ref"]);
    var FS = o.FS !== void 0 ? o.FS : ",", fs = FS.charCodeAt(0);
    var RS = o.RS !== void 0 ? o.RS : "\n", rs = RS.charCodeAt(0);
    var endregex = new RegExp((FS == "|" ? "\\|" : FS) + "+$");
    var row = "", cols = [];
    o.dense = Array.isArray(sheet);
    var colinfo = o.skipHidden && sheet["!cols"] || [];
    var rowinfo = o.skipHidden && sheet["!rows"] || [];
    for (var C = r.s.c; C <= r.e.c; ++C) if (!(colinfo[C] || {}).hidden) cols[C] = encode_col(C);
    var w = 0;
    for (var R = r.s.r; R <= r.e.r; ++R) {
      if ((rowinfo[R] || {}).hidden) continue;
      row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);
      if (row == null) {
        continue;
      }
      if (o.strip) row = row.replace(endregex, "");
      if (row || o.blankrows !== false) out.push((w++ ? RS : "") + row);
    }
    delete o.dense;
    return out.join("");
  }
  function sheet_to_txt(sheet, opts) {
    if (!opts) opts = {};
    opts.FS = "	";
    opts.RS = "\n";
    var s = sheet_to_csv(sheet, opts);
    if (typeof $cptable == "undefined" || opts.type == "string") return s;
    var o = $cptable.utils.encode(1200, s, "str");
    return String.fromCharCode(255) + String.fromCharCode(254) + o;
  }
  function sheet_to_formulae(sheet) {
    var y = "", x, val = "";
    if (sheet == null || sheet["!ref"] == null) return [];
    var r = safe_decode_range(sheet["!ref"]), rr = "", cols = [], C;
    var cmds = [];
    var dense = Array.isArray(sheet);
    for (C = r.s.c; C <= r.e.c; ++C) cols[C] = encode_col(C);
    for (var R = r.s.r; R <= r.e.r; ++R) {
      rr = encode_row(R);
      for (C = r.s.c; C <= r.e.c; ++C) {
        y = cols[C] + rr;
        x = dense ? (sheet[R] || [])[C] : sheet[y];
        val = "";
        if (x === void 0) continue;
        else if (x.F != null) {
          y = x.F;
          if (!x.f) continue;
          val = x.f;
          if (y.indexOf(":") == -1) y = y + ":" + y;
        }
        if (x.f != null) val = x.f;
        else if (x.t == "z") continue;
        else if (x.t == "n" && x.v != null) val = "" + x.v;
        else if (x.t == "b") val = x.v ? "TRUE" : "FALSE";
        else if (x.w !== void 0) val = "'" + x.w;
        else if (x.v === void 0) continue;
        else if (x.t == "s") val = "'" + x.v;
        else val = "" + x.v;
        cmds[cmds.length] = y + "=" + val;
      }
    }
    return cmds;
  }
  function sheet_add_json(_ws, js, opts) {
    var o = opts || {};
    var offset = +!o.skipHeader;
    var ws = _ws || {};
    var _R = 0, _C = 0;
    if (ws && o.origin != null) {
      if (typeof o.origin == "number") _R = o.origin;
      else {
        var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
        _R = _origin.r;
        _C = _origin.c;
      }
    }
    var cell;
    var range = { s: { c: 0, r: 0 }, e: { c: _C, r: _R + js.length - 1 + offset } };
    if (ws["!ref"]) {
      var _range = safe_decode_range(ws["!ref"]);
      range.e.c = Math.max(range.e.c, _range.e.c);
      range.e.r = Math.max(range.e.r, _range.e.r);
      if (_R == -1) {
        _R = _range.e.r + 1;
        range.e.r = _R + js.length - 1 + offset;
      }
    } else {
      if (_R == -1) {
        _R = 0;
        range.e.r = js.length - 1 + offset;
      }
    }
    var hdr = o.header || [], C = 0;
    js.forEach(function(JS, R) {
      keys(JS).forEach(function(k) {
        if ((C = hdr.indexOf(k)) == -1) hdr[C = hdr.length] = k;
        var v = JS[k];
        var t = "z";
        var z = "";
        var ref = encode_cell({ c: _C + C, r: _R + R + offset });
        cell = ws_get_cell_stub(ws, ref);
        if (v && typeof v === "object" && !(v instanceof Date)) {
          ws[ref] = v;
        } else {
          if (typeof v == "number") t = "n";
          else if (typeof v == "boolean") t = "b";
          else if (typeof v == "string") t = "s";
          else if (v instanceof Date) {
            t = "d";
            if (!o.cellDates) {
              t = "n";
              v = datenum(v);
            }
            z = o.dateNF || table_fmt[14];
          } else if (v === null && o.nullError) {
            t = "e";
            v = 0;
          }
          if (!cell) ws[ref] = cell = { t, v };
          else {
            cell.t = t;
            cell.v = v;
            delete cell.w;
            delete cell.R;
            if (z) cell.z = z;
          }
          if (z) cell.z = z;
        }
      });
    });
    range.e.c = Math.max(range.e.c, _C + hdr.length - 1);
    var __R = encode_row(_R);
    if (offset) for (C = 0; C < hdr.length; ++C) ws[encode_col(C + _C) + __R] = { t: "s", v: hdr[C] };
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function json_to_sheet(js, opts) {
    return sheet_add_json(null, js, opts);
  }
  function ws_get_cell_stub(ws, R, C) {
    if (typeof R == "string") {
      if (Array.isArray(ws)) {
        var RC = decode_cell(R);
        if (!ws[RC.r]) ws[RC.r] = [];
        return ws[RC.r][RC.c] || (ws[RC.r][RC.c] = { t: "z" });
      }
      return ws[R] || (ws[R] = { t: "z" });
    }
    if (typeof R != "number") return ws_get_cell_stub(ws, encode_cell(R));
    return ws_get_cell_stub(ws, encode_cell({ r: R, c: C || 0 }));
  }
  function wb_sheet_idx(wb, sh) {
    if (typeof sh == "number") {
      if (sh >= 0 && wb.SheetNames.length > sh) return sh;
      throw new Error("Cannot find sheet # " + sh);
    } else if (typeof sh == "string") {
      var idx = wb.SheetNames.indexOf(sh);
      if (idx > -1) return idx;
      throw new Error("Cannot find sheet name |" + sh + "|");
    } else throw new Error("Cannot find sheet |" + sh + "|");
  }
  function book_new() {
    return { SheetNames: [], Sheets: {} };
  }
  function book_append_sheet(wb, ws, name, roll) {
    var i = 1;
    if (!name) {
      for (; i <= 65535; ++i, name = void 0) if (wb.SheetNames.indexOf(name = "Sheet" + i) == -1) break;
    }
    if (!name || wb.SheetNames.length >= 65535) throw new Error("Too many worksheets");
    if (roll && wb.SheetNames.indexOf(name) >= 0) {
      var m = name.match(/(^.*?)(\d+)$/);
      i = m && +m[2] || 0;
      var root = m && m[1] || name;
      for (++i; i <= 65535; ++i) if (wb.SheetNames.indexOf(name = root + i) == -1) break;
    }
    check_ws_name(name);
    if (wb.SheetNames.indexOf(name) >= 0) throw new Error("Worksheet with name |" + name + "| already exists!");
    wb.SheetNames.push(name);
    wb.Sheets[name] = ws;
    return name;
  }
  function book_set_sheet_visibility(wb, sh, vis) {
    if (!wb.Workbook) wb.Workbook = {};
    if (!wb.Workbook.Sheets) wb.Workbook.Sheets = [];
    var idx = wb_sheet_idx(wb, sh);
    if (!wb.Workbook.Sheets[idx]) wb.Workbook.Sheets[idx] = {};
    switch (vis) {
      case 0:
      case 1:
      case 2:
        break;
      default:
        throw new Error("Bad sheet visibility setting " + vis);
    }
    wb.Workbook.Sheets[idx].Hidden = vis;
  }
  function cell_set_number_format(cell, fmt) {
    cell.z = fmt;
    return cell;
  }
  function cell_set_hyperlink(cell, target, tooltip) {
    if (!target) {
      delete cell.l;
    } else {
      cell.l = { Target: target };
      if (tooltip) cell.l.Tooltip = tooltip;
    }
    return cell;
  }
  function cell_set_internal_link(cell, range, tooltip) {
    return cell_set_hyperlink(cell, "#" + range, tooltip);
  }
  function cell_add_comment(cell, text, author) {
    if (!cell.c) cell.c = [];
    cell.c.push({ t: text, a: author || "SheetJS" });
  }
  function sheet_set_array_formula(ws, range, formula, dynamic) {
    var rng = typeof range != "string" ? range : safe_decode_range(range);
    var rngstr = typeof range == "string" ? range : encode_range(range);
    for (var R = rng.s.r; R <= rng.e.r; ++R) for (var C = rng.s.c; C <= rng.e.c; ++C) {
      var cell = ws_get_cell_stub(ws, R, C);
      cell.t = "n";
      cell.F = rngstr;
      delete cell.v;
      if (R == rng.s.r && C == rng.s.c) {
        cell.f = formula;
        if (dynamic) cell.D = true;
      }
    }
    return ws;
  }
  var utils = {
    encode_col,
    encode_row,
    encode_cell,
    encode_range,
    decode_col,
    decode_row,
    split_cell,
    decode_cell,
    decode_range,
    format_cell,
    sheet_add_aoa,
    sheet_add_json,
    sheet_add_dom,
    aoa_to_sheet,
    json_to_sheet,
    table_to_sheet: parse_dom_table,
    table_to_book,
    sheet_to_csv,
    sheet_to_txt,
    sheet_to_json,
    sheet_to_html,
    sheet_to_formulae,
    sheet_to_row_object_array: sheet_to_json,
    sheet_get_cell: ws_get_cell_stub,
    book_new,
    book_append_sheet,
    book_set_sheet_visibility,
    cell_set_number_format,
    cell_set_hyperlink,
    cell_set_internal_link,
    cell_add_comment,
    sheet_set_array_formula,
    consts: {
      SHEET_VISIBLE: 0,
      SHEET_HIDDEN: 1,
      SHEET_VERY_HIDDEN: 2
    }
  };
  var version = XLSX.version;

  // src/export.ts
  var LEGACY_KEY_ALIASES = {
    player_self_id: ["playerOneId", "p1_id"],
    player_self_name: ["playerOneName", "p1_name"],
    player_self_country: ["playerOneCountry", "p1_country"],
    player_self_victory: ["playerOneVictory", "p1_victory"],
    player_self_finalHealth: ["playerOneFinalHealth", "p1_finalHealth"],
    player_self_startRating: ["playerOneStartRating", "p1_startRating"],
    player_self_endRating: ["playerOneEndRating", "p1_endRating"],
    player_mate_id: ["teamOnePlayerTwoId", "p2_id"],
    player_mate_name: ["teamOnePlayerTwoName", "p2_name"],
    player_mate_country: ["teamOnePlayerTwoCountry", "p2_country"],
    player_mate_startRating: ["p2_startRating"],
    player_mate_endRating: ["p2_endRating"],
    player_opponent_id: ["playerTwoId", "teamTwoPlayerOneId", "p3_id", "p2_id"],
    player_opponent_name: ["playerTwoName", "teamTwoPlayerOneName", "p3_name", "p2_name"],
    player_opponent_country: ["playerTwoCountry", "teamTwoPlayerOneCountry", "p3_country", "p2_country"],
    player_opponent_victory: ["playerTwoVictory", "p2_victory"],
    player_opponent_finalHealth: ["playerTwoFinalHealth", "p2_finalHealth"],
    player_opponent_startRating: ["playerTwoStartRating", "p3_startRating", "p2_startRating"],
    player_opponent_endRating: ["playerTwoEndRating", "p3_endRating", "p2_endRating"],
    player_opponent_mate_id: ["teamTwoPlayerTwoId", "p4_id"],
    player_opponent_mate_name: ["teamTwoPlayerTwoName", "p4_name"],
    player_opponent_mate_country: ["teamTwoPlayerTwoCountry", "p4_country"],
    player_opponent_mate_startRating: ["p4_startRating"],
    player_opponent_mate_endRating: ["p4_endRating"],
    player_self_playerId: ["p1_playerId"],
    player_self_teamId: ["p1_teamId"],
    player_self_guessLat: ["p1_guessLat"],
    player_self_guessLng: ["p1_guessLng"],
    player_self_guessCountry: ["p1_guessCountry", "guessCountry"],
    player_self_distanceKm: ["p1_distanceKm"],
    player_self_score: ["p1_score", "score"],
    player_self_healthAfter: ["p1_healthAfter"],
    player_self_isBestGuess: ["p1_isBestGuess"],
    player_mate_playerId: ["p2_playerId"],
    player_mate_teamId: ["p2_teamId"],
    player_mate_guessLat: ["p2_guessLat"],
    player_mate_guessLng: ["p2_guessLng"],
    player_mate_guessCountry: ["p2_guessCountry"],
    player_mate_distanceKm: ["p2_distanceKm"],
    player_mate_score: ["p2_score"],
    player_mate_healthAfter: ["p2_healthAfter"],
    player_mate_isBestGuess: ["p2_isBestGuess"],
    player_opponent_playerId: ["p3_playerId", "p2_playerId"],
    player_opponent_teamId: ["p3_teamId", "p2_teamId"],
    player_opponent_guessLat: ["p3_guessLat", "p2_guessLat"],
    player_opponent_guessLng: ["p3_guessLng", "p2_guessLng"],
    player_opponent_guessCountry: ["p3_guessCountry", "p2_guessCountry"],
    player_opponent_distanceKm: ["p3_distanceKm", "p2_distanceKm"],
    player_opponent_score: ["p3_score", "p2_score"],
    player_opponent_healthAfter: ["p3_healthAfter", "p2_healthAfter"],
    player_opponent_isBestGuess: ["p3_isBestGuess", "p2_isBestGuess"],
    player_opponent_mate_playerId: ["p4_playerId"],
    player_opponent_mate_teamId: ["p4_teamId"],
    player_opponent_mate_guessLat: ["p4_guessLat"],
    player_opponent_mate_guessLng: ["p4_guessLng"],
    player_opponent_mate_guessCountry: ["p4_guessCountry"],
    player_opponent_mate_distanceKm: ["p4_distanceKm"],
    player_opponent_mate_score: ["p4_score"],
    player_opponent_mate_healthAfter: ["p4_healthAfter"],
    player_opponent_mate_isBestGuess: ["p4_isBestGuess"]
  };
  function pickWithAliases2(obj, key) {
    if (obj && obj[key] !== void 0 && obj[key] !== null) return obj[key];
    for (const alias of LEGACY_KEY_ALIASES[key] || []) {
      if (obj && obj[alias] !== void 0 && obj[alias] !== null) return obj[alias];
    }
    return void 0;
  }
  function getByPath3(obj, path) {
    const parts = path.split(".");
    let cur = obj;
    for (const p of parts) {
      if (!cur || typeof cur !== "object" || !(p in cur)) return void 0;
      cur = cur[p];
    }
    return cur;
  }
  function pickFirst4(obj, paths) {
    for (const p of paths) {
      const v = getByPath3(obj, p);
      if (v !== void 0 && v !== null) return v;
    }
    return void 0;
  }
  function iso(ts) {
    if (!ts || !Number.isFinite(ts)) return "";
    return new Date(ts).toISOString();
  }
  function sanitizeSheetName(name) {
    const n = (name || "unknown").replace(/[\\/*?:[\]]/g, "_");
    return n.length > 31 ? n.slice(0, 31) : n;
  }
  function counterObjectToRows(category, counterLike) {
    if (!counterLike || typeof counterLike !== "object") return [];
    return Object.entries(counterLike).map(([key, value]) => ({ category, key, count: Number(value) || 0 })).sort((a, b) => b.count - a.count);
  }
  function normalizeIso22(v) {
    if (typeof v !== "string") return void 0;
    const x = v.trim().toLowerCase();
    return /^[a-z]{2}$/.test(x) ? x : void 0;
  }
  function isLatLngInRange(lat, lng) {
    return typeof lat === "number" && Number.isFinite(lat) && Math.abs(lat) <= 90 && typeof lng === "number" && Number.isFinite(lng) && Math.abs(lng) <= 180;
  }
  function toTsMaybe(isoMaybe) {
    if (typeof isoMaybe !== "string" || !isoMaybe) return void 0;
    const t = Date.parse(isoMaybe);
    return Number.isFinite(t) ? t : void 0;
  }
  function asFiniteNumber(v) {
    if (typeof v === "number" && Number.isFinite(v)) return v;
    if (typeof v === "string") {
      const n = Number(v);
      if (Number.isFinite(n)) return n;
    }
    return void 0;
  }
  function buildGoogleMapsUrl(lat, lng) {
    if (!isLatLngInRange(lat, lng)) return "";
    return `https://www.google.com/maps?q=${lat},${lng}`;
  }
  function buildStreetViewUrl(lat, lng, heading) {
    if (!isLatLngInRange(lat, lng)) return "";
    const base = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${lat},${lng}`;
    if (typeof heading === "number" && Number.isFinite(heading)) {
      return `${base}&heading=${heading}`;
    }
    return base;
  }
  function exportModeSheetKey(gameMode, modeFamily) {
    const family = String(modeFamily || "").toLowerCase();
    if (family === "standard") return "standard";
    if (family === "streak") return "streak";
    return gameMode || "unknown";
  }
  function isDetailsExpected(modeFamily, gameMode) {
    const family = String(modeFamily || "").toLowerCase();
    if (family === "duels" || family === "teamduels") return true;
    const m = String(gameMode || "").toLowerCase();
    return m.includes("duel");
  }
  function resolveGuessCountryForExport(existing) {
    return normalizeIso22(existing) ?? "";
  }
  async function downloadWorkbook(wb, filename) {
    const arrayBuffer = writeSync(wb, { type: "array", bookType: "xlsx" });
    const blob = new Blob([arrayBuffer], {
      type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    await new Promise((r) => setTimeout(r, 150));
    URL.revokeObjectURL(url);
  }
  async function exportExcel(onStatus) {
    onStatus("Preparing export...");
    const [games, rounds, details, metaRows] = await Promise.all([
      db.games.orderBy("playedAt").reverse().toArray(),
      db.rounds.toArray(),
      db.details.toArray(),
      db.meta.toArray()
    ]);
    if (games.length === 0) {
      onStatus("No games to export.");
      return;
    }
    const detailsByGame = new Map(details.map((d) => [d.gameId, d]));
    const gameById = new Map(games.map((g) => [g.gameId, g]));
    const metaByKey = new Map(metaRows.map((m) => [m.key, m.value]));
    const roundsByGameCount = /* @__PURE__ */ new Map();
    for (const r of rounds) roundsByGameCount.set(r.gameId, (roundsByGameCount.get(r.gameId) || 0) + 1);
    const gamesByMode = /* @__PURE__ */ new Map();
    for (const g of games) {
      const d = detailsByGame.get(g.gameId);
      const modeFamily = g.modeFamily || "";
      const mode = exportModeSheetKey(g.gameMode || g.mode, modeFamily);
      if (!gamesByMode.has(mode)) gamesByMode.set(mode, []);
      const played = new Date(g.playedAt);
      const date = played.toISOString().slice(0, 10);
      const time = played.toISOString().slice(11, 23);
      const isTeam = (mode || "").toLowerCase().includes("team");
      const isStandard = modeFamily === "standard";
      const isStreak = modeFamily === "streak" && !(mode || "").toLowerCase().includes("team");
      const raw = g.raw;
      if (isStandard || isStreak) {
        if (isStandard) {
          gamesByMode.get(mode).push({
            gameNumber: "",
            date,
            clock: time,
            mapSlug: pickFirst4(raw, ["payload.mapSlug", "payload.map.slug", "mapSlug", "map.slug"]) || "",
            mapName: pickFirst4(raw, ["payload.mapName", "payload.map.name", "mapName", "map.name"]) || "",
            points: pickFirst4(raw, ["payload.points", "payload.score", "points", "score"]) || "",
            gameToken: pickFirst4(raw, ["payload.gameToken", "payload.token", "payload.gameId", "gameToken", "token", "id"]) || g.gameId,
            gameMode: mode || "",
            __playedAt: g.playedAt
          });
        } else {
          gamesByMode.get(mode).push({
            gameNumber: "",
            date,
            clock: time,
            mapSlug: pickFirst4(raw, ["payload.mapSlug", "payload.map.slug", "mapSlug", "map.slug"]) || "",
            points: pickFirst4(raw, ["payload.points", "payload.score", "points", "score"]) || "",
            gameToken: pickFirst4(raw, ["payload.gameToken", "payload.token", "payload.gameId", "gameToken", "token", "id"]) || g.gameId,
            gameMode: mode || "",
            __playedAt: g.playedAt
          });
        }
        continue;
      }
      const base = {
        gameId: g.gameId,
        date,
        time,
        gameMode: d?.gameModeSimple || mode || "",
        mapName: d?.mapName || "",
        mapSlug: d?.mapSlug || "",
        isRated: typeof d?.isRated === "boolean" ? d.isRated : "",
        detailsStatus: d?.status || "missing",
        detailsFetchedAt: iso(d?.fetchedAt),
        detailsError: d?.status === "error" ? d?.error || "" : ""
      };
      if (!isTeam) {
        base.player_self_id = pickWithAliases2(d, "player_self_id") ?? "";
        base.player_self_name = pickWithAliases2(d, "player_self_name") ?? "";
        base.player_self_country = pickWithAliases2(d, "player_self_country") ?? "";
        base.player_self_victory = pickWithAliases2(d, "player_self_victory") ?? (d?.playerOneVictory === void 0 ? "" : d?.playerOneVictory);
        base.player_self_finalHealth = pickWithAliases2(d, "player_self_finalHealth") ?? "";
        base.player_self_startRating = pickWithAliases2(d, "player_self_startRating") ?? "";
        base.player_self_endRating = pickWithAliases2(d, "player_self_endRating") ?? "";
        base.player_opponent_id = pickWithAliases2(d, "player_opponent_id") ?? "";
        base.player_opponent_name = pickWithAliases2(d, "player_opponent_name") ?? "";
        base.player_opponent_country = pickWithAliases2(d, "player_opponent_country") ?? "";
        base.player_opponent_victory = pickWithAliases2(d, "player_opponent_victory") ?? (d?.playerTwoVictory === void 0 ? "" : d?.playerTwoVictory);
        base.player_opponent_finalHealth = pickWithAliases2(d, "player_opponent_finalHealth") ?? "";
        base.player_opponent_startRating = pickWithAliases2(d, "player_opponent_startRating") ?? "";
        base.player_opponent_endRating = pickWithAliases2(d, "player_opponent_endRating") ?? "";
        base.totalRounds = d?.totalRounds ?? "";
        base.damageMultiplierRounds = Array.isArray(d?.damageMultiplierRounds) ? `[${d?.damageMultiplierRounds.join(", ")}]` : "[]";
        base.healingRounds = Array.isArray(d?.healingRounds) ? `[${d?.healingRounds.join(", ")}]` : "[]";
      } else {
        base.teamOneId = d?.teamOneId ?? "";
        base.teamOneVictory = d?.teamOneVictory ?? "";
        base.teamOneFinalHealth = d?.teamOneFinalHealth ?? "";
        base.teamOneStartRating = d?.teamOneStartRating ?? "";
        base.teamOneEndRating = d?.teamOneEndRating ?? "";
        base.teamOnePlayerOneId = d?.teamOnePlayerOneId ?? "";
        base.teamOnePlayerOneName = d?.teamOnePlayerOneName ?? "";
        base.teamOnePlayerOneCountry = d?.teamOnePlayerOneCountry ?? "";
        base.teamOnePlayerTwoId = d?.teamOnePlayerTwoId ?? "";
        base.teamOnePlayerTwoName = d?.teamOnePlayerTwoName ?? "";
        base.teamOnePlayerTwoCountry = d?.teamOnePlayerTwoCountry ?? "";
        base.teamTwoId = d?.teamTwoId ?? "";
        base.teamTwoVictory = d?.teamTwoVictory ?? "";
        base.teamTwoFinalHealth = d?.teamTwoFinalHealth ?? "";
        base.teamTwoStartRating = d?.teamTwoStartRating ?? "";
        base.teamTwoEndRating = d?.teamTwoEndRating ?? "";
        base.teamTwoPlayerOneId = d?.teamTwoPlayerOneId ?? "";
        base.teamTwoPlayerOneName = d?.teamTwoPlayerOneName ?? "";
        base.teamTwoPlayerOneCountry = d?.teamTwoPlayerOneCountry ?? "";
        base.teamTwoPlayerTwoId = d?.teamTwoPlayerTwoId ?? "";
        base.teamTwoPlayerTwoName = d?.teamTwoPlayerTwoName ?? "";
        base.teamTwoPlayerTwoCountry = d?.teamTwoPlayerTwoCountry ?? "";
        base.player_self_id = pickWithAliases2(d, "player_self_id") ?? "";
        base.player_self_name = pickWithAliases2(d, "player_self_name") ?? "";
        base.player_self_country = pickWithAliases2(d, "player_self_country") ?? "";
        base.player_self_startRating = pickWithAliases2(d, "player_self_startRating") ?? "";
        base.player_self_endRating = pickWithAliases2(d, "player_self_endRating") ?? "";
        base.player_mate_id = pickWithAliases2(d, "player_mate_id") ?? "";
        base.player_mate_name = pickWithAliases2(d, "player_mate_name") ?? "";
        base.player_mate_country = pickWithAliases2(d, "player_mate_country") ?? "";
        base.player_mate_startRating = pickWithAliases2(d, "player_mate_startRating") ?? "";
        base.player_mate_endRating = pickWithAliases2(d, "player_mate_endRating") ?? "";
        base.player_opponent_id = pickWithAliases2(d, "player_opponent_id") ?? "";
        base.player_opponent_name = pickWithAliases2(d, "player_opponent_name") ?? "";
        base.player_opponent_country = pickWithAliases2(d, "player_opponent_country") ?? "";
        base.player_opponent_startRating = pickWithAliases2(d, "player_opponent_startRating") ?? "";
        base.player_opponent_endRating = pickWithAliases2(d, "player_opponent_endRating") ?? "";
        base.player_opponent_mate_id = pickWithAliases2(d, "player_opponent_mate_id") ?? "";
        base.player_opponent_mate_name = pickWithAliases2(d, "player_opponent_mate_name") ?? "";
        base.player_opponent_mate_country = pickWithAliases2(d, "player_opponent_mate_country") ?? "";
        base.player_opponent_mate_startRating = pickWithAliases2(d, "player_opponent_mate_startRating") ?? "";
        base.player_opponent_mate_endRating = pickWithAliases2(d, "player_opponent_mate_endRating") ?? "";
        base.totalRounds = d?.totalRounds ?? "";
        base.damageMultiplierRounds = Array.isArray(d?.damageMultiplierRounds) ? `[${d?.damageMultiplierRounds.join(", ")}]` : "[]";
        base.healingRounds = Array.isArray(d?.healingRounds) ? `[${d?.healingRounds.join(", ")}]` : "[]";
      }
      gamesByMode.get(mode).push(base);
    }
    const roundsByMode = /* @__PURE__ */ new Map();
    for (const r of rounds) {
      const g = gameById.get(r.gameId);
      const mode = exportModeSheetKey(g?.gameMode || g?.mode, g?.modeFamily);
      if (!roundsByMode.has(mode)) roundsByMode.set(mode, []);
      const selfLat = pickWithAliases2(r, "player_self_guessLat");
      const selfLng = pickWithAliases2(r, "player_self_guessLng");
      const selfCountry = resolveGuessCountryForExport(pickWithAliases2(r, "player_self_guessCountry"));
      const mateCountry = resolveGuessCountryForExport(pickWithAliases2(r, "player_mate_guessCountry"));
      const oppCountry = resolveGuessCountryForExport(pickWithAliases2(r, "player_opponent_guessCountry"));
      const oppMateCountry = resolveGuessCountryForExport(pickWithAliases2(r, "player_opponent_mate_guessCountry"));
      const trueHeading = asFiniteNumber(
        pickFirst4(r.raw, [
          "panorama.heading",
          "panorama.bearing",
          "panorama.rotation",
          "heading",
          "bearing",
          "rotation"
        ])
      );
      const rowBase = {
        gameId: r.gameId,
        roundNumber: r.roundNumber,
        startTime: iso(r.startTime),
        endTime: iso(r.endTime),
        durationSeconds: r.durationSeconds ?? "",
        true_country: r.trueCountry ?? "",
        true_lat: r.trueLat ?? "",
        true_lng: r.trueLng ?? "",
        true_heading_deg: trueHeading ?? "",
        true_googleMaps_url: buildGoogleMapsUrl(r.trueLat, r.trueLng),
        true_streetView_url: buildStreetViewUrl(r.trueLat, r.trueLng, trueHeading),
        damage_multiplier: r.damageMultiplier ?? "",
        is_healing_round: r.isHealingRound ? 1 : 0,
        player_self_playerId: pickWithAliases2(r, "player_self_playerId") ?? "",
        player_self_guessLat: selfLat ?? "",
        player_self_guessLng: selfLng ?? "",
        player_self_googleMaps_url: buildGoogleMapsUrl(selfLat, selfLng),
        player_self_guessCountry: selfCountry,
        player_self_distance_km: pickWithAliases2(r, "player_self_distanceKm") ?? "",
        player_self_score: pickWithAliases2(r, "player_self_score") ?? "",
        player_self_healthAfter: pickWithAliases2(r, "player_self_healthAfter") ?? "",
        player_self_isBestGuess: pickWithAliases2(r, "player_self_isBestGuess") ? 1 : 0,
        player_opponent_playerId: pickWithAliases2(r, "player_opponent_playerId") ?? "",
        player_opponent_guessLat: pickWithAliases2(r, "player_opponent_guessLat") ?? "",
        player_opponent_guessLng: pickWithAliases2(r, "player_opponent_guessLng") ?? "",
        player_opponent_googleMaps_url: buildGoogleMapsUrl(pickWithAliases2(r, "player_opponent_guessLat"), pickWithAliases2(r, "player_opponent_guessLng")),
        player_opponent_guessCountry: resolveGuessCountryForExport(pickWithAliases2(r, "player_opponent_guessCountry")),
        player_opponent_distance_km: pickWithAliases2(r, "player_opponent_distanceKm") ?? "",
        player_opponent_score: pickWithAliases2(r, "player_opponent_score") ?? "",
        player_opponent_healthAfter: pickWithAliases2(r, "player_opponent_healthAfter") ?? "",
        player_opponent_isBestGuess: pickWithAliases2(r, "player_opponent_isBestGuess") ? 1 : 0,
        healthDiffAfter: r.healthDiffAfter ?? "",
        __sortTs: r.startTime ?? g?.playedAt ?? 0
      };
      const isTeamMode = (mode || "").toLowerCase().includes("team");
      if (isTeamMode) {
        rowBase.player_self_teamId = pickWithAliases2(r, "player_self_teamId") ?? "";
        rowBase.player_mate_playerId = pickWithAliases2(r, "player_mate_playerId") ?? "";
        rowBase.player_mate_teamId = pickWithAliases2(r, "player_mate_teamId") ?? "";
        rowBase.player_mate_guessLat = pickWithAliases2(r, "player_mate_guessLat") ?? "";
        rowBase.player_mate_guessLng = pickWithAliases2(r, "player_mate_guessLng") ?? "";
        rowBase.player_mate_googleMaps_url = buildGoogleMapsUrl(pickWithAliases2(r, "player_mate_guessLat"), pickWithAliases2(r, "player_mate_guessLng"));
        rowBase.player_mate_guessCountry = mateCountry;
        rowBase.player_mate_distance_km = pickWithAliases2(r, "player_mate_distanceKm") ?? "";
        rowBase.player_mate_score = pickWithAliases2(r, "player_mate_score") ?? "";
        rowBase.player_mate_healthAfter = pickWithAliases2(r, "player_mate_healthAfter") ?? "";
        rowBase.player_mate_isBestGuess = pickWithAliases2(r, "player_mate_isBestGuess") ? 1 : 0;
        rowBase.player_opponent_playerId = pickWithAliases2(r, "player_opponent_playerId") ?? "";
        rowBase.player_opponent_teamId = pickWithAliases2(r, "player_opponent_teamId") ?? "";
        rowBase.player_opponent_guessLat = pickWithAliases2(r, "player_opponent_guessLat") ?? "";
        rowBase.player_opponent_guessLng = pickWithAliases2(r, "player_opponent_guessLng") ?? "";
        rowBase.player_opponent_googleMaps_url = buildGoogleMapsUrl(pickWithAliases2(r, "player_opponent_guessLat"), pickWithAliases2(r, "player_opponent_guessLng"));
        rowBase.player_opponent_guessCountry = oppCountry;
        rowBase.player_opponent_distance_km = pickWithAliases2(r, "player_opponent_distanceKm") ?? "";
        rowBase.player_opponent_score = pickWithAliases2(r, "player_opponent_score") ?? "";
        rowBase.player_opponent_healthAfter = pickWithAliases2(r, "player_opponent_healthAfter") ?? "";
        rowBase.player_opponent_isBestGuess = pickWithAliases2(r, "player_opponent_isBestGuess") ? 1 : 0;
        rowBase.player_opponent_mate_playerId = pickWithAliases2(r, "player_opponent_mate_playerId") ?? "";
        rowBase.player_opponent_mate_teamId = pickWithAliases2(r, "player_opponent_mate_teamId") ?? "";
        rowBase.player_opponent_mate_guessLat = pickWithAliases2(r, "player_opponent_mate_guessLat") ?? "";
        rowBase.player_opponent_mate_guessLng = pickWithAliases2(r, "player_opponent_mate_guessLng") ?? "";
        rowBase.player_opponent_mate_googleMaps_url = buildGoogleMapsUrl(
          pickWithAliases2(r, "player_opponent_mate_guessLat"),
          pickWithAliases2(r, "player_opponent_mate_guessLng")
        );
        rowBase.player_opponent_mate_guessCountry = oppMateCountry;
        rowBase.player_opponent_mate_distance_km = pickWithAliases2(r, "player_opponent_mate_distanceKm") ?? "";
        rowBase.player_opponent_mate_score = pickWithAliases2(r, "player_opponent_mate_score") ?? "";
        rowBase.player_opponent_mate_healthAfter = pickWithAliases2(r, "player_opponent_mate_healthAfter") ?? "";
        rowBase.player_opponent_mate_isBestGuess = pickWithAliases2(r, "player_opponent_mate_isBestGuess") ? 1 : 0;
      }
      roundsByMode.get(mode).push(rowBase);
    }
    const gamesWb = utils.book_new();
    for (const [mode, rows] of [...gamesByMode.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
      const modeRows = [...rows];
      if (modeRows.length > 0 && "__playedAt" in modeRows[0]) {
        modeRows.sort((a, b) => (a.__playedAt || 0) - (b.__playedAt || 0));
        for (let i = 0; i < modeRows.length; i++) modeRows[i].gameNumber = i + 1;
        modeRows.sort((a, b) => (b.__playedAt || 0) - (a.__playedAt || 0));
        for (const r of modeRows) delete r.__playedAt;
      }
      utils.book_append_sheet(gamesWb, utils.json_to_sheet(modeRows), sanitizeSheetName(mode));
    }
    const modeFamilyCounts = /* @__PURE__ */ new Map();
    const exportModeCounts = /* @__PURE__ */ new Map();
    for (const g of games) {
      const family = String(g.modeFamily || "unknown");
      modeFamilyCounts.set(family, (modeFamilyCounts.get(family) || 0) + 1);
      const modeKey = exportModeSheetKey(g.gameMode || g.mode, g.modeFamily);
      exportModeCounts.set(modeKey, (exportModeCounts.get(modeKey) || 0) + 1);
    }
    const roundsByModeCounts = /* @__PURE__ */ new Map();
    for (const r of rounds) {
      const g = gameById.get(r.gameId);
      const mode = exportModeSheetKey(g?.gameMode || g?.mode, g?.modeFamily);
      roundsByModeCounts.set(mode, (roundsByModeCounts.get(mode) || 0) + 1);
    }
    const gamesWithoutDetails = games.filter((g) => !detailsByGame.has(g.gameId)).length;
    const expectedDetailGames = games.filter((g) => isDetailsExpected(g.modeFamily, g.gameMode || g.mode));
    const expectedWithDetails = expectedDetailGames.filter((g) => detailsByGame.has(g.gameId));
    const expectedWithoutDetails = expectedDetailGames.filter((g) => !detailsByGame.has(g.gameId));
    const expectedStatusCounts = { ok: 0, missing: 0, error: 0, no_row: 0 };
    for (const g of expectedDetailGames) {
      const d = detailsByGame.get(g.gameId);
      if (!d) {
        expectedStatusCounts.no_row++;
        continue;
      }
      if (d.status === "ok") expectedStatusCounts.ok++;
      else if (d.status === "missing") expectedStatusCounts.missing++;
      else if (d.status === "error") expectedStatusCounts.error++;
      else expectedStatusCounts.no_row++;
    }
    const roundsWithoutGame = rounds.filter((r) => !gameById.has(r.gameId)).length;
    const syncDebug = metaByKey.get("syncDebugLast") || {};
    const syncPageDiagnosticsRaw = Array.isArray(syncDebug.pageDiagnostics) ? syncDebug.pageDiagnostics : [];
    const syncDroppedSamplesRaw = Array.isArray(syncDebug.droppedEventSamples) ? syncDebug.droppedEventSamples : [];
    const syncPageDiagnostics = syncPageDiagnosticsRaw.map((p) => ({
      ...p,
      newestPlayedAtIso: iso(p?.newestPlayedAt),
      oldestPlayedAtIso: iso(p?.oldestPlayedAt)
    }));
    const syncDroppedSamples = syncDroppedSamplesRaw.map((r) => ({
      ...r,
      timeCandidateParsedIso: iso(toTsMaybe(r?.timeCandidate))
    }));
    const diagnosticsSyncCounters = [
      ...counterObjectToRows("sync_id_source", syncDebug.idSourceCounts),
      ...counterObjectToRows("sync_drop_reason", syncDebug.dropReasonCounts),
      ...counterObjectToRows("sync_drop_type", syncDebug.dropTypeCounts)
    ];
    const diagnosticsSummary = [
      { metric: "export_generated_at", value: (/* @__PURE__ */ new Date()).toISOString() },
      { metric: "db_games_total", value: games.length },
      { metric: "db_rounds_total", value: rounds.length },
      { metric: "db_details_total", value: details.length },
      { metric: "games_without_details", value: gamesWithoutDetails },
      { metric: "details_expected_games", value: expectedDetailGames.length },
      { metric: "details_expected_with_row", value: expectedWithDetails.length },
      { metric: "details_expected_without_row", value: expectedWithoutDetails.length },
      { metric: "details_expected_status_ok", value: expectedStatusCounts.ok },
      { metric: "details_expected_status_missing", value: expectedStatusCounts.missing },
      { metric: "details_expected_status_error", value: expectedStatusCounts.error },
      { metric: "details_expected_status_no_row", value: expectedStatusCounts.no_row },
      { metric: "rounds_without_game_row", value: roundsWithoutGame },
      { metric: "export_mode_sheet_count", value: gamesByMode.size },
      { metric: "sync_break_reason", value: syncDebug.breakReason ?? "" },
      { metric: "sync_pages_fetched", value: syncDebug.pagesFetched ?? "" },
      { metric: "sync_max_pages", value: syncDebug.maxPages ?? "" },
      { metric: "sync_entries_seen", value: syncDebug.entriesSeen ?? "" },
      { metric: "sync_events_seen", value: syncDebug.eventsSeen ?? "" },
      { metric: "sync_rows_with_gameId", value: syncDebug.rowsWithGameId ?? "" },
      { metric: "sync_deduped_rows", value: syncDebug.dedupedRows ?? "" },
      { metric: "sync_inserted_rows", value: syncDebug.insertedRows ?? "" },
      { metric: "sync_total_games_after_sync", value: syncDebug.totalGamesAfterSync ?? "" },
      { metric: "sync_lastSeen_before_sync", value: syncDebug.lastSeenBeforeSync ?? "" },
      { metric: "sync_elapsed_ms", value: syncDebug.elapsedMs ?? "" },
      { metric: "sync_dropped_samples_exported", value: syncDroppedSamples.length },
      { metric: "sync_pages_diagnostics_exported", value: syncPageDiagnostics.length },
      {
        metric: "hint",
        value: "For missing games, inspect Diagnostics_SyncPages, Diagnostics_SyncCounters and Diagnostics_DroppedEvents."
      },
      {
        metric: "hint",
        value: "If duel/teamduel details are missing, inspect Diagnostics_DetailCoverage for per-game reason/error/endpoint."
      }
    ];
    const diagnosticsModeRows = [
      ...[...modeFamilyCounts.entries()].sort((a, b) => b[1] - a[1]).map(([modeFamily, count]) => ({ category: "mode_family", key: modeFamily, count })),
      ...[...exportModeCounts.entries()].sort((a, b) => b[1] - a[1]).map(([mode, count]) => ({ category: "export_mode", key: mode, count })),
      ...[...roundsByModeCounts.entries()].sort((a, b) => b[1] - a[1]).map(([mode, count]) => ({ category: "rounds_mode", key: mode, count }))
    ];
    utils.book_append_sheet(gamesWb, utils.json_to_sheet(diagnosticsSummary), sanitizeSheetName("Diagnostics"));
    utils.book_append_sheet(gamesWb, utils.json_to_sheet(diagnosticsModeRows), sanitizeSheetName("Diagnostics_Modes"));
    utils.book_append_sheet(
      gamesWb,
      utils.json_to_sheet(diagnosticsSyncCounters),
      sanitizeSheetName("Diagnostics_SyncCounters")
    );
    utils.book_append_sheet(
      gamesWb,
      utils.json_to_sheet(syncPageDiagnostics),
      sanitizeSheetName("Diagnostics_SyncPages")
    );
    utils.book_append_sheet(
      gamesWb,
      utils.json_to_sheet(syncDroppedSamples),
      sanitizeSheetName("Diagnostics_DroppedEvents")
    );
    const diagnosticsDetailCoverage = games.map((g) => {
      const d = detailsByGame.get(g.gameId);
      const expected = isDetailsExpected(g.modeFamily, g.gameMode || g.mode);
      const status = d?.status || "no_row";
      const reason = !expected ? "details_not_applicable_for_mode" : status === "ok" ? "ok" : status === "missing" ? "marked_missing_by_fetcher" : status === "error" ? "fetch_or_parse_error" : "details_row_not_created";
      return {
        gameId: g.gameId,
        playedAt: iso(g.playedAt),
        modeFamily: g.modeFamily || "",
        gameMode: g.gameMode || g.mode || "",
        detailsExpected: expected ? 1 : 0,
        detailsStatus: status,
        reason,
        detailsFetchedAt: iso(d?.fetchedAt),
        detailsEndpoint: d?.endpoint || "",
        detailsError: d?.error || "",
        roundsStored: roundsByGameCount.get(g.gameId) || 0
      };
    }).sort((a, b) => {
      if (a.detailsExpected !== b.detailsExpected) return b.detailsExpected - a.detailsExpected;
      if (a.detailsStatus !== b.detailsStatus) return a.detailsStatus.localeCompare(b.detailsStatus);
      return String(b.playedAt).localeCompare(String(a.playedAt));
    });
    utils.book_append_sheet(
      gamesWb,
      utils.json_to_sheet(diagnosticsDetailCoverage),
      sanitizeSheetName("Diagnostics_DetailCoverage")
    );
    const statsWb = utils.book_new();
    for (const [mode, rows] of [...roundsByMode.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
      const sortedRows = [...rows].sort((a, b) => {
        const ta = typeof a.__sortTs === "number" && Number.isFinite(a.__sortTs) ? a.__sortTs : toTsMaybe(a.startTime) ?? 0;
        const tb = typeof b.__sortTs === "number" && Number.isFinite(b.__sortTs) ? b.__sortTs : toTsMaybe(b.startTime) ?? 0;
        if (tb !== ta) return tb - ta;
        const ga = String(a.gameId || "");
        const gb = String(b.gameId || "");
        if (gb !== ga) return gb.localeCompare(ga);
        return Number(b.roundNumber || 0) - Number(a.roundNumber || 0);
      });
      for (const r of sortedRows) delete r.__sortTs;
      utils.book_append_sheet(statsWb, utils.json_to_sheet(sortedRows), sanitizeSheetName(mode));
    }
    utils.book_append_sheet(statsWb, utils.json_to_sheet(diagnosticsSummary), sanitizeSheetName("Diagnostics"));
    utils.book_append_sheet(statsWb, utils.json_to_sheet(diagnosticsModeRows), sanitizeSheetName("Diagnostics_Modes"));
    utils.book_append_sheet(
      statsWb,
      utils.json_to_sheet(diagnosticsSyncCounters),
      sanitizeSheetName("Diagnostics_SyncCounters")
    );
    utils.book_append_sheet(
      statsWb,
      utils.json_to_sheet(syncPageDiagnostics),
      sanitizeSheetName("Diagnostics_SyncPages")
    );
    utils.book_append_sheet(
      statsWb,
      utils.json_to_sheet(syncDroppedSamples),
      sanitizeSheetName("Diagnostics_DroppedEvents")
    );
    utils.book_append_sheet(
      statsWb,
      utils.json_to_sheet(diagnosticsDetailCoverage),
      sanitizeSheetName("Diagnostics_DetailCoverage")
    );
    const now = /* @__PURE__ */ new Date();
    const stamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, "0")}${String(now.getDate()).padStart(2, "0")}_${String(now.getHours()).padStart(2, "0")}${String(now.getMinutes()).padStart(2, "0")}`;
    await downloadWorkbook(gamesWb, `geoguessr_games_${stamp}.xlsx`);
    await downloadWorkbook(statsWb, `geoguessr_stats_${stamp}.xlsx`);
    onStatus(`Export done: ${games.length} games, ${rounds.length} rounds (${gamesByMode.size} mode sheets).`);
  }

  // src/engine/validate.ts
  var ValidationError = class extends Error {
    code;
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  };
  function assert(condition, code, msg) {
    if (!condition) throw new ValidationError(code, msg);
  }
  function validateDashboardAgainstSemantic(semantic, dash) {
    if (dash.dashboard.globalFilters) validateGlobalFiltersSpec(semantic, dash);
    for (const section of dash.dashboard.sections) {
      if (section.localFilters) validateLocalFiltersSpec(semantic, section);
      for (const placedCard of section.layout.cards) {
        for (const widget of placedCard.card.children) {
          validateWidget(semantic, widget);
        }
      }
    }
  }
  function validateGlobalFiltersSpec(semantic, dash) {
    const gf = dash.dashboard.globalFilters;
    assert(!!gf && typeof gf === "object", "E_BAD_SPEC", "dashboard.globalFilters must be an object");
    assert(typeof gf.enabled === "boolean", "E_BAD_SPEC", "dashboard.globalFilters.enabled must be boolean");
    assert(Array.isArray(gf.controls), "E_BAD_SPEC", "dashboard.globalFilters.controls must be an array");
    const ids = /* @__PURE__ */ new Set();
    for (const c of gf.controls) {
      assert(!!c && typeof c === "object", "E_BAD_SPEC", "Global filter control must be an object");
      assert(typeof c.id === "string" && c.id.trim().length > 0, "E_BAD_SPEC", "Global filter control id must be a string");
      assert(!ids.has(c.id), "E_BAD_SPEC", `Duplicate global filter control id '${c.id}'`);
      ids.add(c.id);
      assert(typeof c.type === "string", "E_BAD_SPEC", `Global filter control '${c.id}' missing type`);
      assert(typeof c.label === "string" && c.label.trim().length > 0, "E_BAD_SPEC", `Global filter control '${c.id}' missing label`);
      assert(Array.isArray(c.appliesTo) && c.appliesTo.length > 0, "E_BAD_SPEC", `Global filter control '${c.id}' appliesTo must be a non-empty array`);
      if (c.type === "date_range") {
        assert(!!c.default && typeof c.default === "object", "E_BAD_SPEC", `date_range '${c.id}' default must be an object`);
        const fromTs = c.default.fromTs;
        const toTs2 = c.default.toTs;
        assert(fromTs === null || typeof fromTs === "number", "E_BAD_SPEC", `date_range '${c.id}' default.fromTs must be number|null`);
        assert(toTs2 === null || typeof toTs2 === "number", "E_BAD_SPEC", `date_range '${c.id}' default.toTs must be number|null`);
        continue;
      }
      if (c.type === "select") {
        assert(typeof c.dimension === "string" && c.dimension.trim().length > 0, "E_BAD_SPEC", `select '${c.id}' missing dimension`);
        assert(typeof c.options === "string", "E_BAD_SPEC", `select '${c.id}' missing options`);
        assert(
          c.options === "auto_distinct" || c.options === "auto_teammates",
          "E_BAD_SPEC",
          `select '${c.id}' options must be 'auto_distinct' | 'auto_teammates'`
        );
        assert(typeof c.default === "string" && c.default.trim().length > 0, "E_BAD_SPEC", `select '${c.id}' default must be a string`);
        const dimId = String(c.dimension);
        const dim = semantic.dimensions[dimId];
        assert(!!dim, "E_UNKNOWN_DIMENSION", `Unknown dimension '${dimId}' in global filter '${c.id}'`);
        const dimGrains = Array.isArray(dim.grain) ? dim.grain : [dim.grain];
        for (const g of c.appliesTo) {
          assert(dimGrains.includes(g), "E_GRAIN_MISMATCH", `Global filter '${c.id}' appliesTo includes unsupported grain '${g}' for dimension '${dimId}'`);
        }
        continue;
      }
      throw new ValidationError("E_BAD_SPEC", `Unknown global filter control type '${c.type}'`);
    }
  }
  function validateLocalFiltersSpec(semantic, section) {
    const lf = section.localFilters;
    assert(!!lf && typeof lf === "object", "E_BAD_SPEC", `section '${section.id}' localFilters must be an object`);
    assert(Array.isArray(lf.controls) && lf.controls.length > 0, "E_BAD_SPEC", `section '${section.id}' localFilters.controls must be a non-empty array`);
    const ids = /* @__PURE__ */ new Set();
    for (const c of lf.controls) {
      assert(!!c && typeof c === "object", "E_BAD_SPEC", `Local filter control in section '${section.id}' must be an object`);
      assert(typeof c.id === "string" && c.id.trim().length > 0, "E_BAD_SPEC", `Local filter control id must be a string`);
      assert(!ids.has(c.id), "E_BAD_SPEC", `Duplicate local filter control id '${c.id}' in section '${section.id}'`);
      ids.add(c.id);
      assert(c.type === "select", "E_BAD_SPEC", `Local filter '${c.id}' in section '${section.id}' must have type 'select'`);
      assert(typeof c.label === "string" && c.label.trim().length > 0, "E_BAD_SPEC", `Local filter '${c.id}' missing label`);
      assert(typeof c.dimension === "string" && c.dimension.trim().length > 0, "E_BAD_SPEC", `Local filter '${c.id}' missing dimension`);
      assert(typeof c.options === "string", "E_BAD_SPEC", `Local filter '${c.id}' missing options`);
      assert(
        c.options === "auto_distinct" || c.options === "auto_teammates",
        "E_BAD_SPEC",
        `Local filter '${c.id}' options must be 'auto_distinct' | 'auto_teammates'`
      );
      assert(typeof c.default === "string" && c.default.trim().length > 0, "E_BAD_SPEC", `Local filter '${c.id}' default must be a string`);
      assert(Array.isArray(c.appliesTo) && c.appliesTo.length > 0, "E_BAD_SPEC", `Local filter '${c.id}' appliesTo must be a non-empty array`);
      const dimId = String(c.dimension);
      const dim = semantic.dimensions[dimId];
      assert(!!dim, "E_UNKNOWN_DIMENSION", `Unknown dimension '${dimId}' in local filter '${c.id}' (section '${section.id}')`);
      const dimGrains = Array.isArray(dim.grain) ? dim.grain : [dim.grain];
      for (const g of c.appliesTo) {
        assert(dimGrains.includes(g), "E_GRAIN_MISMATCH", `Local filter '${c.id}' appliesTo includes unsupported grain '${g}' for dimension '${dimId}'`);
      }
    }
  }
  function validateWidget(semantic, widget) {
    assert(semantic.datasets[widget.grain] !== void 0, "E_UNKNOWN_GRAIN", `Unknown grain: ${widget.grain}`);
    if (widget.type === "chart") {
      const spec = widget.spec;
      const xDimId = spec.x?.dimension;
      assert(typeof xDimId === "string", "E_BAD_SPEC", `Chart widget ${widget.widgetId} missing x.dimension`);
      const yMeasureIds = getChartMeasureIds(spec);
      assert(yMeasureIds.length > 0, "E_BAD_SPEC", `Chart widget ${widget.widgetId} missing y.measure or y.measures`);
      const xDim = semantic.dimensions[xDimId];
      assert(!!xDim, "E_UNKNOWN_DIMENSION", `Unknown dimension '${xDimId}' in widget ${widget.widgetId}`);
      const xGrains = Array.isArray(xDim.grain) ? xDim.grain : [xDim.grain];
      assert(xGrains.includes(widget.grain), "E_GRAIN_MISMATCH", `x '${xDimId}' grain mismatch for widget grain=${widget.grain}`);
      assert(xDim.allowedCharts.includes(spec.type), "E_NOT_ALLOWED", `Dimension '${xDimId}' not allowed for ${spec.type}`);
      if (spec.sort?.mode) {
        assert(xDim.sortModes.includes(spec.sort.mode), "E_NOT_ALLOWED", `Sort mode '${spec.sort.mode}' not allowed for dimension '${xDimId}'`);
      }
      if (Array.isArray(spec.sorts)) {
        for (const s of spec.sorts) {
          const mode = s?.mode;
          if (!mode) continue;
          assert(xDim.sortModes.includes(mode), "E_NOT_ALLOWED", `Sort mode '${mode}' not allowed for dimension '${xDimId}'`);
        }
      }
      if (spec.activeSort?.mode) {
        assert(xDim.sortModes.includes(spec.activeSort.mode), "E_NOT_ALLOWED", `Sort mode '${spec.activeSort.mode}' not allowed for dimension '${xDimId}'`);
      }
      for (const yMeasId of yMeasureIds) {
        const yMeas = semantic.measures[yMeasId];
        assert(!!yMeas, "E_UNKNOWN_MEASURE", `Unknown measure '${yMeasId}' in widget ${widget.widgetId}`);
        assert(
          xGrains.includes(yMeas.grain),
          "E_GRAIN_MISMATCH",
          `y '${yMeasId}' grain=${yMeas.grain} not supported by x '${xDimId}' grains=${xGrains.join(",")}`
        );
        assert(yMeas.allowedCharts.includes(spec.type), "E_NOT_ALLOWED", `Measure '${yMeasId}' not allowed for ${spec.type}`);
      }
      const activeMeasure = typeof spec.y?.activeMeasure === "string" ? spec.y.activeMeasure : void 0;
      if (activeMeasure) {
        assert(yMeasureIds.includes(activeMeasure), "E_BAD_SPEC", `activeMeasure '${activeMeasure}' is not listed in y.measures`);
      }
      if (spec.type === "line") {
        assert(xDim.ordered === true, "E_CHART_X_NOT_ORDERED", `Line chart requires ordered x dimension '${xDimId}'`);
      }
      if (xDim.cardinality?.selectorRequired) {
        const hasTopN = typeof spec.limit === "number" && spec.limit > 0;
        const selectorMode = spec.x?.selector?.mode;
        const hasSelector = selectorMode === "top_n" || selectorMode === "selected";
        assert(
          hasTopN || hasSelector,
          "E_SELECTOR_REQUIRED",
          `Dimension '${xDimId}' requires selector; set chart.limit or x.selector`
        );
      }
      if (spec.series) {
        const sDimId = spec.series.dimension;
        const sDim = semantic.dimensions[sDimId];
        assert(!!sDim, "E_UNKNOWN_DIMENSION", `Unknown series dimension '${sDimId}'`);
        const sGrains = Array.isArray(sDim.grain) ? sDim.grain : [sDim.grain];
        assert(sGrains.includes(widget.grain), "E_GRAIN_MISMATCH", `series '${sDimId}' grain mismatch for widget grain=${widget.grain}`);
        assert(!!spec.series.selector, "E_BAD_SPEC", `series.selector missing for '${sDimId}'`);
        const maxSeries = sDim.cardinality?.maxSeries ?? 50;
        const requested = spec.series.selector.mode === "selected" ? spec.series.selector.values?.length ?? 0 : spec.series.selector.mode === "top_n" ? spec.series.selector.n ?? 0 : spec.series.selector.maxSeries ?? maxSeries;
        assert(requested <= maxSeries, "E_TOO_MANY_SERIES", `Too many series for '${sDimId}' requested=${requested} max=${maxSeries}`);
      }
      validateClickAction(semantic, widget.widgetId, spec.actions?.click);
    }
    if (widget.type === "stat_list") {
      const spec = widget.spec;
      assert(Array.isArray(spec.rows) && spec.rows.length > 0, "E_BAD_SPEC", `stat_list ${widget.widgetId} has no rows`);
      for (const row of spec.rows) {
        const meas = semantic.measures[row.measure];
        assert(!!meas, "E_UNKNOWN_MEASURE", `Unknown measure '${row.measure}' in stat_list ${widget.widgetId}`);
        const rowGrain = row.grain ?? widget.grain;
        assert(
          meas.grain === rowGrain,
          "E_GRAIN_MISMATCH",
          `Measure '${row.measure}' grain=${meas.grain} but stat row grain=${rowGrain} (widget grain=${widget.grain})`
        );
        validateClickAction(semantic, widget.widgetId, row.actions?.click);
      }
    }
    if (widget.type === "stat_value") {
      const spec = widget.spec;
      const meas = semantic.measures[spec.measure];
      assert(!!meas, "E_UNKNOWN_MEASURE", `Unknown measure '${spec.measure}' in stat_value ${widget.widgetId}`);
      assert(meas.grain === widget.grain, "E_GRAIN_MISMATCH", `Measure '${spec.measure}' grain=${meas.grain} but widget grain=${widget.grain}`);
      validateClickAction(semantic, widget.widgetId, spec.actions?.click);
    }
    if (widget.type === "breakdown") {
      const spec = widget.spec;
      const dim = semantic.dimensions[spec.dimension];
      const measIds = getBreakdownMeasureIds(spec);
      assert(!!dim, "E_UNKNOWN_DIMENSION", `Unknown dimension '${spec.dimension}' in breakdown ${widget.widgetId}`);
      const dGrains = Array.isArray(dim.grain) ? dim.grain : [dim.grain];
      assert(dGrains.includes(widget.grain), "E_GRAIN_MISMATCH", `Breakdown dim grain mismatch in ${widget.widgetId}`);
      assert(measIds.length > 0, "E_BAD_SPEC", `Breakdown ${widget.widgetId} missing measure or measures[]`);
      for (const measId of measIds) {
        const meas = semantic.measures[measId];
        assert(!!meas, "E_UNKNOWN_MEASURE", `Unknown measure '${measId}' in breakdown ${widget.widgetId}`);
        assert(meas.grain === widget.grain, "E_GRAIN_MISMATCH", `Breakdown measure '${measId}' grain mismatch in ${widget.widgetId}`);
      }
      if (typeof spec.activeMeasure === "string" && spec.activeMeasure.trim()) {
        assert(measIds.includes(spec.activeMeasure.trim()), "E_BAD_SPEC", `breakdown ${widget.widgetId} activeMeasure must be in measures[]`);
      }
      if (spec.sort?.mode) {
        assert(dim.sortModes.includes(spec.sort.mode), "E_NOT_ALLOWED", `Sort mode '${spec.sort.mode}' not allowed for dimension '${spec.dimension}'`);
      }
      if (Array.isArray(spec.sorts)) {
        for (const s of spec.sorts) {
          const mode = s?.mode;
          if (!mode) continue;
          assert(dim.sortModes.includes(mode), "E_NOT_ALLOWED", `Sort mode '${mode}' not allowed for dimension '${spec.dimension}'`);
        }
      }
      if (spec.activeSort?.mode) {
        assert(dim.sortModes.includes(spec.activeSort.mode), "E_NOT_ALLOWED", `Sort mode '${spec.activeSort.mode}' not allowed for dimension '${spec.dimension}'`);
      }
      if (dim.cardinality?.selectorRequired) {
        assert(
          typeof spec.limit === "number" && spec.limit > 0,
          "E_SELECTOR_REQUIRED",
          `Breakdown '${spec.dimension}' requires a positive limit`
        );
      }
      validateClickAction(semantic, widget.widgetId, spec.actions?.click);
    }
    if (widget.type === "record_list") {
      const spec = widget.spec;
      assert(Array.isArray(spec.records) && spec.records.length > 0, "E_BAD_SPEC", `record_list ${widget.widgetId} has no records`);
      for (const r of spec.records) {
        const kind = r?.kind === "same_value_streak" ? "same_value_streak" : r?.kind === "streak" ? "streak" : r?.kind === "overall" ? "overall" : "group_extreme";
        if (kind === "streak") {
          assert(Array.isArray(r.streakFilters) && r.streakFilters.length > 0, "E_BAD_SPEC", `record ${r.id} missing streakFilters`);
          validateClickAction(semantic, widget.widgetId, r.actions?.click);
          continue;
        }
        if (kind === "same_value_streak") {
          assert(typeof r.dimension === "string" && r.dimension.trim().length > 0, "E_BAD_SPEC", `record ${r.id} missing dimension`);
          const d2 = semantic.dimensions[r.dimension];
          assert(!!d2, "E_UNKNOWN_DIMENSION", `Unknown record dimension '${r.dimension}' in ${widget.widgetId}`);
          const grains2 = Array.isArray(d2.grain) ? d2.grain : [d2.grain];
          assert(grains2.includes(widget.grain), "E_GRAIN_MISMATCH", `Record dimension '${r.dimension}' grain mismatch in ${widget.widgetId}`);
          validateClickAction(semantic, widget.widgetId, r.actions?.click);
          continue;
        }
        if (kind === "overall") {
          assert(typeof r.metric === "string" && r.metric.trim().length > 0, "E_BAD_SPEC", `record ${r.id} missing metric`);
          const m2 = semantic.measures[r.metric];
          assert(!!m2, "E_UNKNOWN_MEASURE", `Unknown record metric '${r.metric}' in ${widget.widgetId}`);
          assert(m2.grain === widget.grain, "E_GRAIN_MISMATCH", `Record metric '${r.metric}' grain mismatch in ${widget.widgetId}`);
          validateClickAction(semantic, widget.widgetId, r.actions?.click);
          continue;
        }
        const m = semantic.measures[r.metric];
        assert(!!m, "E_UNKNOWN_MEASURE", `Unknown record metric '${r.metric}' in ${widget.widgetId}`);
        assert(m.grain === widget.grain, "E_GRAIN_MISMATCH", `Record metric '${r.metric}' grain mismatch in ${widget.widgetId}`);
        const d = semantic.dimensions[r.groupBy];
        assert(!!d, "E_UNKNOWN_DIMENSION", `Unknown record groupBy '${r.groupBy}' in ${widget.widgetId}`);
        const grains = Array.isArray(d.grain) ? d.grain : [d.grain];
        assert(grains.includes(widget.grain), "E_GRAIN_MISMATCH", `Record groupBy '${r.groupBy}' grain mismatch in ${widget.widgetId}`);
        assert(r.extreme === "max" || r.extreme === "min", "E_BAD_SPEC", `Record extreme must be max|min in ${widget.widgetId}`);
        validateClickAction(semantic, widget.widgetId, r.actions?.click);
      }
    }
    if (widget.type === "leader_list") {
      const spec = widget.spec;
      assert(Array.isArray(spec.rows) && spec.rows.length > 0, "E_BAD_SPEC", `leader_list ${widget.widgetId} has no rows`);
      for (const r of spec.rows) {
        assert(typeof r.label === "string" && r.label.trim().length > 0, "E_BAD_SPEC", `leader_list row missing label in ${widget.widgetId}`);
        assert(typeof r.dimension === "string" && r.dimension.trim().length > 0, "E_BAD_SPEC", `leader_list row missing dimension in ${widget.widgetId}`);
        const d = semantic.dimensions[r.dimension];
        assert(!!d, "E_UNKNOWN_DIMENSION", `Unknown leader_list dimension '${r.dimension}' in ${widget.widgetId}`);
        const grains = Array.isArray(d.grain) ? d.grain : [d.grain];
        assert(grains.includes(widget.grain), "E_GRAIN_MISMATCH", `leader_list dimension '${r.dimension}' grain mismatch in ${widget.widgetId}`);
        validateClickAction(semantic, widget.widgetId, r.actions?.click);
      }
    }
  }
  function validateClickAction(semantic, widgetId, click) {
    if (!click || click.type !== "drilldown") return;
    const target = click.target;
    const targetPreset = semantic.drilldownPresets[target];
    assert(!!targetPreset, "E_BAD_SPEC", `Unknown drilldown target '${target}' in widget ${widgetId}`);
    const columns = targetPreset?.columnsPresets?.[click.columnsPreset];
    assert(!!columns && columns.length > 0, "E_BAD_SPEC", `Unknown columnsPreset '${click.columnsPreset}' in widget ${widgetId}`);
  }
  function getChartMeasureIds(spec) {
    const result = [];
    const single = typeof spec?.y?.measure === "string" ? spec.y.measure.trim() : "";
    if (single) result.push(single);
    if (Array.isArray(spec?.y?.measures)) {
      for (const m of spec.y.measures) {
        if (typeof m !== "string") continue;
        const clean = m.trim();
        if (!clean || result.includes(clean)) continue;
        result.push(clean);
      }
    }
    return result;
  }
  function getBreakdownMeasureIds(spec) {
    const result = [];
    const single = typeof spec?.measure === "string" ? spec.measure.trim() : "";
    if (single) result.push(single);
    if (Array.isArray(spec?.measures)) {
      for (const m of spec.measures) {
        if (typeof m !== "string") continue;
        const clean = m.trim();
        if (!clean || result.includes(clean)) continue;
        result.push(clean);
      }
    }
    return result;
  }

  // src/config/semantic.json
  var semantic_default = {
    $schema: "./semantic.schema.json",
    schemaVersion: "0.1.0",
    grains: ["session", "game", "round"],
    datasets: {
      session: {
        primaryKey: ["sessionId"],
        timeField: "sessionStartTs"
      },
      game: {
        primaryKey: ["gameId"],
        timeField: "ts"
      },
      round: {
        primaryKey: ["gameId", "roundNumber"],
        timeField: "ts"
      }
    },
    settings: {
      sessionGapMinutesDefault: 45
    },
    dimensions: {
      time_day: {
        label: "Date",
        kind: "time",
        grain: ["round", "game", "session"],
        ordered: true,
        allowedCharts: ["line", "bar"],
        sortModes: ["chronological"]
      },
      weekday: {
        label: "Weekday",
        kind: "category",
        grain: ["round", "game"],
        ordered: true,
        allowedCharts: ["bar"],
        sortModes: ["chronological", "asc", "desc"]
      },
      hour: {
        label: "Hour of day",
        kind: "category",
        grain: ["round", "game"],
        ordered: true,
        allowedCharts: ["bar"],
        sortModes: ["chronological", "asc", "desc"]
      },
      session_index: {
        label: "Session #",
        kind: "category",
        grain: "session",
        ordered: true,
        allowedCharts: ["bar", "line"],
        sortModes: ["chronological", "asc", "desc"]
      },
      session_start: {
        label: "Session start",
        kind: "category",
        grain: "session",
        ordered: true,
        allowedCharts: ["bar", "line"],
        sortModes: ["chronological", "asc", "desc"]
      },
      game_mode: {
        label: "Game mode",
        kind: "category",
        grain: "game",
        allowedCharts: ["bar", "line"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 10 }
      },
      mode_family: {
        label: "Mode",
        kind: "category",
        grain: ["game", "round"],
        allowedCharts: ["bar", "line"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 10 }
      },
      is_rated: {
        label: "Rated",
        kind: "category",
        grain: ["game", "round"],
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 3 }
      },
      map_name: {
        label: "Map",
        kind: "category",
        grain: ["game", "round"],
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 30 }
      },
      map_slug: {
        label: "Map (slug)",
        kind: "category",
        grain: ["game", "round"],
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 30 }
      },
      result: {
        label: "Result",
        kind: "category",
        grain: "game",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 5 }
      },
      is_flawless_win: {
        label: "Flawless win?",
        kind: "category",
        grain: "game",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 2 }
      },
      game_length: {
        label: "Game length (rounds)",
        kind: "category",
        grain: "game",
        ordered: true,
        allowedCharts: ["bar"],
        sortModes: ["chronological", "asc", "desc"],
        cardinality: { policy: "small", maxSeries: 30 }
      },
      opponent_country: {
        label: "Opponent country",
        kind: "category",
        grain: "game",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 30 }
      },
      opponent_name: {
        label: "Opponent",
        kind: "category",
        grain: "game",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 30, selectorRequired: true }
      },
      round_number: {
        label: "Round #",
        kind: "category",
        grain: "round",
        ordered: true,
        allowedCharts: ["bar"],
        sortModes: ["chronological", "asc", "desc"]
      },
      round_id: {
        label: "Round",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 200, selectorRequired: true }
      },
      true_country: {
        label: "True country",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar", "line"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 12, selectorRequired: true }
      },
      teammate_name: {
        label: "Teammate",
        kind: "category",
        grain: ["round", "game"],
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 15, selectorRequired: true }
      },
      movement_type: {
        label: "Movement",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar", "line"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 8 }
      },
      game_id: {
        label: "Game",
        kind: "category",
        grain: ["round", "game"],
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 50, selectorRequired: true }
      },
      is_hit: {
        label: "Hit?",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 2 }
      },
      is_throw: {
        label: "Throw?",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 2 }
      },
      is_damage_dealt: {
        label: "Damage dealt?",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 2 }
      },
      is_damage_taken: {
        label: "Damage taken?",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 2 }
      },
      is_near_perfect: {
        label: "Near-perfect? (>=4500)",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 2 }
      },
      is_low_score: {
        label: "Low score? (<500)",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 2 }
      },
      duration_bucket: {
        label: "Guess duration bucket",
        kind: "category",
        grain: "round",
        ordered: true,
        allowedCharts: ["bar"],
        sortModes: ["chronological", "asc", "desc"]
      },
      confused_countries: {
        label: "Confused countries",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 80, selectorRequired: true }
      },
      guess_country: {
        label: "Guessed country",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "large", maxSeries: 20, selectorRequired: true }
      },
      score_bucket: {
        label: "Score bucket",
        kind: "category",
        grain: "round",
        ordered: true,
        allowedCharts: ["bar"],
        sortModes: ["chronological"]
      },
      team_closer_winner: {
        label: "Closer guesses",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 3 }
      },
      team_higher_score_winner: {
        label: "Higher score rounds",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 3 }
      },
      team_fewer_throw_winner: {
        label: "Fewer throws (<50)",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 3 }
      },
      team_more_5k_winner: {
        label: "More 5k rounds",
        kind: "category",
        grain: "round",
        allowedCharts: ["bar"],
        sortModes: ["asc", "desc"],
        cardinality: { policy: "small", maxSeries: 3 }
      }
    },
    measures: {
      games_count: {
        label: "Games",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "count_games"
      },
      matchups_count: {
        label: "Match-ups",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "count_games"
      },
      strongest_opponent_rating: {
        label: "Strongest opponent (rating)",
        unit: "rating",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "max_opponent_start_rating"
      },
      strongest_defeated_opponent_rating: {
        label: "Strongest defeated opponent (rating)",
        unit: "rating",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "max_defeated_opponent_start_rating"
      },
      unique_opponents_count: {
        label: "Unique opponents",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "count_distinct_opponent_name"
      },
      unique_opponent_countries_count: {
        label: "Unique countries",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "count_distinct_opponent_country"
      },
      avg_game_length: {
        label: "Avg game length",
        unit: "float",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "mean_game_length_rounds"
      },
      rounds_count: {
        label: "Rounds",
        unit: "count",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "count_rounds"
      },
      games_distinct_count: {
        label: "Games",
        unit: "count",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "count_distinct_game_id"
      },
      first_played_at: {
        label: "First game together",
        unit: "datetime",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "min_played_at_ts"
      },
      last_played_at: {
        label: "Most recent game together",
        unit: "datetime",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "max_played_at_ts"
      },
      score_spread: {
        label: "Score spread",
        unit: "points",
        grain: "round",
        allowedCharts: ["bar"],
        formulaId: "spread_player_self_score",
        range: { min: 0, max: 5e3 }
      },
      avg_score: {
        label: "Avg score",
        unit: "points",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "mean_player_self_score",
        range: { min: 0, max: 5e3 }
      },
      round_score: {
        label: "Round score",
        unit: "points",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "round_score_value",
        range: { min: 0, max: 5e3 }
      },
      round_damage_dealt: {
        label: "Damage dealt",
        unit: "int",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "round_damage_dealt_value",
        range: { min: 0 }
      },
      round_damage_taken: {
        label: "Damage taken",
        unit: "int",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "round_damage_taken_value",
        range: { min: 0 }
      },
      round_guess_duration: {
        label: "Guess duration",
        unit: "seconds",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "round_guess_duration_value",
        range: { min: 0 }
      },
      round_score_per_second: {
        label: "Score per second",
        unit: "float",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "round_score_per_second",
        range: { min: 0 }
      },
      avg_score_hit_only: {
        label: "Avg score (hit only)",
        unit: "points",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "mean_player_self_score_hit_only",
        range: { min: 0, max: 5e3 }
      },
      avg_distance_km: {
        label: "Avg distance",
        unit: "km",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "mean_player_self_distance_km",
        range: { min: 0 }
      },
      avg_guess_duration: {
        label: "Avg guess duration",
        unit: "seconds",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "mean_duration_seconds",
        range: { min: 0 }
      },
      fivek_rate: {
        label: "5k rate",
        unit: "percent",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "rate_player_self_score_eq_5000",
        range: { min: 0, max: 100 },
        drilldown: {
          filterFromPoint: true,
          extraFilters: [{ dimension: "score_bucket", op: "eq", value: "5000" }]
        }
      },
      fivek_count: {
        label: "5k count",
        unit: "count",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "count_5k_round",
        range: { min: 0 },
        drilldown: {
          filterFromPoint: true,
          extraFilters: [{ dimension: "score_bucket", op: "eq", value: "5000" }]
        }
      },
      near_perfect_rate: {
        label: "Near-perfect rate (>=4500)",
        unit: "percent",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "rate_near_perfect_round",
        range: { min: 0, max: 100 }
      },
      near_perfect_count: {
        label: "Near-perfect count (>=4500)",
        unit: "count",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "count_near_perfect_round",
        range: { min: 0 }
      },
      low_score_rate: {
        label: "Low score rate (<500)",
        unit: "percent",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "rate_low_score_round",
        range: { min: 0, max: 100 }
      },
      low_score_count: {
        label: "Low score count (<500)",
        unit: "count",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "count_low_score_round",
        range: { min: 0 }
      },
      win_rate: {
        label: "Win rate",
        unit: "percent",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "rate_player_self_win",
        range: { min: 0, max: 100 }
      },
      win_count: {
        label: "Win count",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "count_win_game",
        range: { min: 0 }
      },
      games_with_result_count: {
        label: "Games with result data",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "count_games_with_result",
        range: { min: 0 }
      },
      loss_count: {
        label: "Loss count",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "count_loss_game",
        range: { min: 0 }
      },
      tie_count: {
        label: "Tie count",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "count_tie_game",
        range: { min: 0 }
      },
      end_rating: {
        label: "End rating",
        unit: "rating",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "last_player_self_end_rating",
        timeDayFill: "carry_forward",
        range: { min: 0 }
      },
      rating_trend: {
        label: "Trend",
        unit: "rating_delta",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "trend_player_self_rating"
      },
      best_end_rating: {
        label: "Best rating",
        unit: "rating",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "max_player_self_end_rating"
      },
      rating_delta_avg: {
        label: "Avg rating delta",
        unit: "rating_delta",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "mean_player_self_rating_delta"
      },
      rating_delta_highest: {
        label: "Highest rating delta",
        unit: "rating_delta",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "max_player_self_rating_delta"
      },
      rating_delta_lowest: {
        label: "Lowest rating delta",
        unit: "rating_delta",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "min_player_self_rating_delta"
      },
      game_avg_score: {
        label: "Avg score (game)",
        unit: "points",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "game_avg_score_over_rounds",
        range: { min: 0, max: 5e3 }
      },
      game_5k_count: {
        label: "5k count (game)",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "game_5k_count",
        range: { min: 0 }
      },
      game_throw_count: {
        label: "Throw count (game)",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "game_throw_count",
        range: { min: 0 }
      },
      game_hit_rate: {
        label: "Hit rate (game)",
        unit: "percent",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "game_hit_rate",
        range: { min: 0, max: 1 }
      },
      game_rating_delta: {
        label: "Rating delta (game)",
        unit: "rating_delta",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "game_rating_delta_value"
      },
      game_duration: {
        label: "Game duration",
        unit: "duration",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "game_duration_seconds",
        range: { min: 0 }
      },
      game_final_health: {
        label: "Final health",
        unit: "int",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "game_final_health",
        range: { min: 0 }
      },
      flawless_wins_count: {
        label: "Flawless wins",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "count_flawless_wins",
        range: { min: 0 }
      },
      longest_win_streak: {
        label: "Longest win streak",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "max_win_streak"
      },
      longest_loss_streak: {
        label: "Longest loss streak",
        unit: "count",
        grain: "game",
        allowedCharts: ["bar", "line"],
        formulaId: "max_loss_streak"
      },
      hit_rate: {
        label: "Hit rate",
        unit: "percent",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "rate_true_country_hit",
        range: { min: 0, max: 100 },
        drilldown: {
          filterFromPoint: true,
          extraFilters: [{ dimension: "is_hit", op: "eq", value: "true" }]
        }
      },
      hit_count: {
        label: "Hit count",
        unit: "count",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "count_hit_round",
        range: { min: 0 },
        drilldown: {
          filterFromPoint: true,
          extraFilters: [{ dimension: "is_hit", op: "eq", value: "true" }]
        }
      },
      throw_rate: {
        label: "Throw rate",
        unit: "percent",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "rate_throw_round",
        range: { min: 0, max: 100 },
        drilldown: {
          filterFromPoint: true,
          extraFilters: [{ dimension: "is_throw", op: "eq", value: "true" }]
        }
      },
      throw_count: {
        label: "Throw count",
        unit: "count",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "count_throw_round",
        range: { min: 0 },
        drilldown: {
          filterFromPoint: true,
          extraFilters: [{ dimension: "is_throw", op: "eq", value: "true" }]
        }
      },
      score_median: {
        label: "Median score",
        unit: "points",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "median_player_self_score",
        range: { min: 0, max: 5e3 }
      },
      score_stddev: {
        label: "Score Std Dev",
        unit: "points",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "stddev_player_self_score",
        range: { min: 0, max: 5e3 }
      },
      distance_median_km: {
        label: "Median distance",
        unit: "km",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "median_player_self_distance_km",
        range: { min: 0 }
      },
      guess_duration_median: {
        label: "Median guess duration",
        unit: "seconds",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "median_duration_seconds",
        range: { min: 0 }
      },
      rounds_with_time_count: {
        label: "Rounds with time data",
        unit: "count",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "count_rounds_with_duration",
        range: { min: 0 }
      },
      time_played_seconds: {
        label: "Time played",
        unit: "duration",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "sum_duration_seconds"
      },
      damage_dealt_avg: {
        label: "Avg damage dealt",
        unit: "points",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "mean_damage_dealt",
        range: { min: 0, max: 5e3 }
      },
      damage_taken_avg: {
        label: "Avg damage taken",
        unit: "points",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "mean_damage_taken",
        range: { min: 0, max: 5e3 }
      },
      damage_dealt_share: {
        label: "Damage dealt share",
        unit: "percent",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "share_damage_dealt",
        range: { min: 0, max: 100 },
        drilldown: {
          filterFromPoint: true,
          extraFilters: [{ dimension: "is_damage_dealt", op: "eq", value: "true" }]
        }
      },
      damage_taken_share: {
        label: "Damage taken share",
        unit: "percent",
        grain: "round",
        allowedCharts: ["bar", "line"],
        formulaId: "share_damage_taken",
        range: { min: 0, max: 100 },
        drilldown: {
          filterFromPoint: true,
          extraFilters: [{ dimension: "is_damage_taken", op: "eq", value: "true" }]
        }
      },
      sessions_count: {
        label: "Sessions",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "count_sessions",
        range: { min: 0 }
      },
      sessions_longest_break_seconds: {
        label: "Longest break between sessions",
        unit: "duration",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "max_break_between_sessions_seconds"
      },
      sessions_avg_games: {
        label: "Avg games per session",
        unit: "float",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "mean_games_per_session"
      },
      session_avg_score_hit: {
        label: "Avg score (hits only)",
        unit: "points",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_avg_score_hit",
        range: { min: 0, max: 5e3 }
      },
      session_5k_count: {
        label: "5k count",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_5k_count",
        range: { min: 0 }
      },
      session_hit_count: {
        label: "Hit count",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_hit_count",
        range: { min: 0 }
      },
      session_throw_count: {
        label: "Throw count",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_throw_count",
        range: { min: 0 }
      },
      session_win_rate: {
        label: "Win rate",
        unit: "percent",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_win_rate",
        range: { min: 0, max: 1 }
      },
      session_win_count: {
        label: "Wins",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_win_count",
        range: { min: 0 }
      },
      session_start_rating: {
        label: "Start rating",
        unit: "rating",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_start_rating"
      },
      session_end_rating: {
        label: "End rating",
        unit: "rating",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_end_rating"
      },
      session_duration_minutes: {
        label: "Session duration",
        unit: "duration",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_duration_seconds",
        range: { min: 0 }
      },
      session_games_count: {
        label: "Games",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_games_count"
      },
      session_rounds_count: {
        label: "Rounds",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_rounds_count"
      },
      session_avg_score: {
        label: "Avg score",
        unit: "points",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_avg_score",
        range: { min: 0, max: 5e3 }
      },
      session_avg_guess_duration: {
        label: "Avg guess duration",
        unit: "seconds",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_avg_guess_duration"
      },
      session_avg_distance_km: {
        label: "Avg distance",
        unit: "km",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_avg_distance_km"
      },
      session_fivek_rate: {
        label: "5k rate",
        unit: "percent",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_fivek_rate"
      },
      session_hit_rate: {
        label: "Hit rate",
        unit: "percent",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_hit_rate"
      },
      session_throw_rate: {
        label: "Throw rate",
        unit: "percent",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_throw_rate"
      },
      session_delta_rating: {
        label: "Session rating delta",
        unit: "rating_delta",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_delta_rating"
      },
      session_rating_delta: {
        label: "Rating delta",
        unit: "rating_delta",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "session_delta_rating"
      },
      day_win_rate_min5: {
        label: "Win rate (day, min 5 games)",
        unit: "percent",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "day_win_rate_min5",
        range: { min: 0, max: 1 }
      },
      max_consecutive_days_without_games: {
        label: "Most consecutive days without games",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "max_consecutive_days_without_games",
        range: { min: 0 }
      },
      longest_active_streak_days: {
        label: "Longest active streak (days)",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "longest_active_streak_days",
        range: { min: 0 }
      },
      longest_5k_day_streak_days: {
        label: "Longest 5k day streak (days)",
        unit: "count",
        grain: "session",
        allowedCharts: ["bar", "line"],
        formulaId: "longest_5k_day_streak_days",
        range: { min: 0 }
      }
    },
    units: {
      count: { format: "int" },
      int: { format: "int" },
      points: { format: "float", decimals: 1 },
      percent: { format: "percent", decimals: 1 },
      seconds: { format: "float", decimals: 1 },
      duration: { format: "duration" },
      datetime: { format: "datetime" },
      rating: { format: "float", decimals: 0 },
      rating_delta: { format: "float", decimals: 0, showSign: true },
      km: { format: "float", decimals: 1 },
      float: { format: "float", decimals: 2 }
    },
    columnAliases: {
      ts: ["playedAt", "startTime"],
      game_mode: ["gameMode", "gameModeSimple", "game_mode", "mode", "gameType"],
      true_country: ["trueCountry", "true_country"],
      player_self_country: ["player_self_guessCountry", "p1_guessCountry", "guessCountry"],
      player_self_score: ["player_self_score", "p1_score", "score"],
      player_opponent_name: ["player_opponent_name", "playerTwoName", "playerOpponentName"],
      player_opponent_id: ["player_opponent_id", "playerTwoId", "playerOpponentId"],
      player_opponent_mate_name: ["player_opponent_mate_name", "teamTwoPlayerTwoName", "playerOpponentMateName"],
      player_opponent_mate_id: ["player_opponent_mate_id", "teamTwoPlayerTwoId", "playerOpponentMateId"],
      player_mate_name: ["player_mate_name", "teamOnePlayerTwoName", "playerMateName"],
      player_mate_id: ["player_mate_id", "teamOnePlayerTwoId", "playerMateId"],
      player_self_guessLat: ["p1_guessLat", "player_self_guessLat"],
      player_self_guessLng: ["p1_guessLng", "player_self_guessLng"],
      player_self_isBestGuess: ["p1_isBestGuess", "player_self_isBestGuess"],
      player_mate_guessLat: ["p2_guessLat", "player_mate_guessLat"],
      player_mate_guessLng: ["p2_guessLng", "player_mate_guessLng"],
      player_mate_score: ["p2_score", "player_mate_score"],
      player_mate_isBestGuess: ["p2_isBestGuess", "player_mate_isBestGuess"],
      player_opponent_guessLat: ["p3_guessLat", "player_opponent_guessLat", "p2_guessLat"],
      player_opponent_guessLng: ["p3_guessLng", "player_opponent_guessLng", "p2_guessLng"],
      player_opponent_score: ["p3_score", "player_opponent_score", "p2_score"],
      player_opponent_isBestGuess: ["p3_isBestGuess", "player_opponent_isBestGuess", "p2_isBestGuess"],
      player_opponent_mate_guessLat: ["p4_guessLat", "player_opponent_mate_guessLat"],
      player_opponent_mate_guessLng: ["p4_guessLng", "player_opponent_mate_guessLng"],
      player_opponent_mate_score: ["p4_score", "player_opponent_mate_score"],
      player_opponent_mate_isBestGuess: ["p4_isBestGuess", "player_opponent_mate_isBestGuess"],
      distanceKm: ["player_self_distanceKm", "p1_distanceKm", "distanceKm"],
      durationSeconds: ["durationSeconds", "guessDurationSec", "timeSec"]
    },
    drilldownPresets: {
      rounds: {
        entity: "round",
        columnsPresets: {
          roundMode: [
            { key: "ts", label: "Date", sortable: true },
            { key: "result", label: "Result", sortable: true, colored: true },
            { key: "roundNumber", label: "Round", sortable: true },
            { key: "movementType", label: "Movement", sortable: true },
            { key: "player_self_score", label: "Score", sortable: true },
            { key: "true_country", label: "Country", sortable: true },
            { key: "durationSeconds", label: "Guess Duration", sortable: true },
            { key: "damage", label: "Damage", sortable: true, colored: true },
            { key: "teammateName", label: "Mate", sortable: true },
            { key: "gameId", label: "Game", sortable: true, display: { truncate: true, truncateHead: 8 } },
            { key: "guess_maps", label: "Guess Maps", type: "link", link: { kind: "guess_maps", label: "Open" } },
            { key: "street_view", label: "True Street View", type: "link", link: { kind: "street_view", label: "Open" } }
          ]
        },
        defaultPreset: "roundMode"
      },
      sessions: {
        entity: "session",
        columnsPresets: {
          sessionMode: [
            { key: "sessionStartTs", label: "Start", sortable: true },
            { key: "sessionEndTs", label: "End", sortable: true },
            { key: "gamesCount", label: "Games", sortable: true },
            { key: "roundsCount", label: "Rounds", sortable: true },
            { key: "ratingDelta", label: "Rating Delta", sortable: true, colored: true },
            { key: "sessionId", label: "Session", sortable: true, display: { truncate: true, truncateHead: 2 } }
          ]
        },
        defaultPreset: "sessionMode"
      },
      games: {
        entity: "game",
        columnsPresets: {
          gameMode: [
            { key: "ts", label: "Date", sortable: true },
            { key: "modeFamily", label: "Game Mode", sortable: true },
            { key: "movementType", label: "Movement", sortable: true },
            { key: "roundsCount", label: "Rounds", sortable: true },
            { key: "result", label: "Result", sortable: true, colored: true },
            { key: "endRating", label: "End Rating", sortable: true },
            { key: "ratingDelta", label: "Rating Delta", sortable: true, colored: true },
            { key: "sessionId", label: "Session", sortable: true, display: { truncate: true, truncateHead: 2 } },
            { key: "gameId", label: "Game", sortable: true, display: { truncate: true, truncateHead: 8 } }
          ]
        },
        defaultPreset: "gameMode"
      },
      players: {
        entity: "game",
        columnsPresets: {
          opponentMode: [
            { key: "ts", label: "Date", sortable: true },
            { key: "modeFamily", label: "Game Mode", sortable: true },
            { key: "movementType", label: "Movement", sortable: true },
            { key: "roundsCount", label: "Rounds", sortable: true },
            { key: "teammateName", label: "Mate", sortable: true },
            { key: "result", label: "Result", sortable: true, colored: true },
            { key: "player_opponent_name", label: "Opponent", sortable: true },
            { key: "player_opponent_mate_name", label: "Opponent Mate", sortable: true },
            { key: "endRating", label: "End Rating", sortable: true },
            { key: "ratingDelta", label: "Rating Delta", sortable: true, colored: true },
            { key: "sessionId", label: "Session", sortable: true, display: { truncate: true, truncateHead: 2 } },
            { key: "gameId", label: "Game", sortable: true, display: { truncate: true, truncateHead: 8 } }
          ]
        },
        defaultPreset: "opponentMode"
      }
    },
    errors: {
      E_GRAIN_MISMATCH: "Selected fields have incompatible grains.",
      E_CHART_X_NOT_ORDERED: "Line charts require an ordered x-dimension.",
      E_SELECTOR_REQUIRED: "This dimension requires a selector (Top-N or Selected).",
      E_TOO_MANY_SERIES: "Too many series requested; reduce categories or use selector."
    }
  };

  // src/config/dashboard.json
  var dashboard_default = {
    $schema: "./dashboard.schema.json",
    schemaVersion: "0.1.0",
    dashboard: {
      id: "default",
      title: "GeoAnalyzr",
      ui: {
        topbarTitle: "{{playerName}}",
        windowTitle: "{{playerName}} - GeoAnalyzr"
      },
      globalFilters: {
        enabled: true,
        layout: { variant: "compact" },
        controls: [
          {
            id: "dateRange",
            type: "date_range",
            label: "From / To",
            default: { fromTs: null, toTs: null },
            appliesTo: ["round", "game", "session"]
          },
          {
            id: "modeFamily",
            type: "select",
            label: "Game mode",
            dimension: "mode_family",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round", "game"]
          },
          {
            id: "rated",
            type: "select",
            label: "Rated",
            dimension: "is_rated",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round", "game"]
          },
          {
            id: "map",
            type: "select",
            label: "Map",
            dimension: "map_slug",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round", "game"]
          },
          {
            id: "teammate",
            type: "select",
            label: "Teammate",
            dimension: "teammate_name",
            default: "all",
            options: "auto_teammates",
            appliesTo: ["round", "game"]
          },
          {
            id: "movement",
            type: "select",
            label: "Movement",
            dimension: "movement_type",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round"]
          },
          {
            id: "guessTimeBucket",
            type: "select",
            label: "Guess time",
            dimension: "duration_bucket",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round"]
          },
          {
            id: "country",
            type: "select",
            label: "Country",
            dimension: "true_country",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round"]
          }
        ],
        buttons: { apply: false, reset: true }
      },
      sections: [
        {
          id: "overview",
          title: "Overview",
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_overview_main",
                title: "Overview",
                x: 0,
                y: 0,
                w: 12,
                h: 22,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_overview_facts",
                      type: "stat_list",
                      title: "Results, Win Rate & Streaks",
                      grain: "game",
                      placement: { x: 0, y: 0, w: 12, h: 7 },
                      spec: {
                        rows: [
                          {
                            label: "Games with result data",
                            measure: "games_with_result_count",
                            actions: { click: { type: "drilldown", target: "players", columnsPreset: "opponentMode", filterFromPoint: false } }
                          },
                          {
                            label: "Wins",
                            measure: "win_count",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "players",
                                columnsPreset: "opponentMode",
                                filterFromPoint: false,
                                extraFilters: [{ dimension: "result", op: "eq", value: "Win" }]
                              }
                            }
                          },
                          {
                            label: "Losses",
                            measure: "loss_count",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "players",
                                columnsPreset: "opponentMode",
                                filterFromPoint: false,
                                extraFilters: [{ dimension: "result", op: "eq", value: "Loss" }]
                              }
                            }
                          },
                          {
                            label: "Win rate",
                            measure: "win_rate",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "players",
                                columnsPreset: "opponentMode",
                                filterFromPoint: false,
                                extraFilters: [{ dimension: "result", op: "eq", value: "Win" }]
                              }
                            }
                          },
                          {
                            label: "Best rating",
                            measure: "best_end_rating",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "players",
                                columnsPreset: "opponentMode",
                                filterFromPoint: false,
                                initialSort: { key: "endRating", dir: "desc" }
                              }
                            }
                          },
                          {
                            label: "Longest win streak",
                            measure: "longest_win_streak",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "players",
                                columnsPreset: "opponentMode",
                                filterFromPoint: false
                              }
                            }
                          },
                          {
                            label: "Longest loss streak",
                            measure: "longest_loss_streak",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "players",
                                columnsPreset: "opponentMode",
                                filterFromPoint: false
                              }
                            }
                          },
                          {
                            label: "Avg score (pts)",
                            measure: "avg_score",
                            grain: "round",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: false } }
                          },
                          {
                            label: "Avg distance (km)",
                            measure: "avg_distance_km",
                            grain: "round",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: false } }
                          },
                          {
                            label: "Avg time (s)",
                            measure: "avg_guess_duration",
                            grain: "round",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: false } }
                          },
                          {
                            label: "Time played",
                            measure: "time_played_seconds",
                            grain: "round",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: false } }
                          },
                          {
                            label: "Perfect 5k rounds",
                            measure: "fivek_count",
                            grain: "round",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: false } }
                          },
                          {
                            label: "Throws (<50)",
                            measure: "throw_count",
                            grain: "round",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: false } }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_overview_mode_breakdown",
                      type: "breakdown",
                      title: "Mode Breakdown",
                      grain: "game",
                      placement: { x: 0, y: 7, w: 12, h: 4 },
                      spec: {
                        dimension: "mode_family",
                        excludeKeys: ["other", "Streak"],
                        measure: "games_count",
                        sort: { mode: "desc" },
                        limit: 12,
                        actions: {
                          click: {
                            type: "drilldown",
                            target: "players",
                            columnsPreset: "opponentMode",
                            filterFromPoint: true
                          }
                        }
                      }
                    },
                    {
                      widgetId: "w_overview_movement_breakdown",
                      type: "breakdown",
                      title: "Movement Breakdown",
                      grain: "round",
                      placement: { x: 0, y: 11, w: 12, h: 4 },
                      spec: {
                        dimension: "movement_type",
                        measure: "rounds_count",
                        sort: { mode: "desc" },
                        limit: 12,
                        actions: {
                          click: {
                            type: "drilldown",
                            target: "rounds",
                            columnsPreset: "roundMode",
                            filterFromPoint: true
                          }
                        }
                      }
                    },
                    {
                      widgetId: "w_overview_time_progression",
                      type: "chart",
                      title: "Time progression metrics",
                      grain: "round",
                      placement: { x: 0, y: 15, w: 12, h: 7 },
                      spec: {
                        type: "line",
                        maxPoints: 100,
                        x: { dimension: "time_day" },
                        y: {
                          measures: [
                            "games_count",
                            "rounds_count",
                            "time_played_seconds",
                            "avg_score",
                            "avg_score_hit_only",
                            "avg_distance_km",
                            "avg_guess_duration",
                            "throw_rate",
                            "throw_count",
                            "fivek_rate",
                            "fivek_count",
                            "hit_rate",
                            "hit_count",
                            "win_rate",
                            "win_count",
                            "end_rating",
                            "damage_dealt_avg",
                            "damage_taken_avg"
                          ],
                          activeMeasure: "games_count",
                          accumulations: ["period", "to_date"],
                          activeAccumulation: "to_date"
                        },
                        sort: { mode: "chronological" },
                        actions: {
                          hover: true,
                          click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true }
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "rating",
          title: "Rating",
          filterScope: { exclude: ["movement", "guessTimeBucket", "country"] },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_rating",
                title: "Rating",
                x: 0,
                y: 0,
                w: 12,
                h: 16,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_rating_kpis",
                      type: "stat_list",
                      title: "Rating",
                      grain: "game",
                      placement: { x: 0, y: 0, w: 12, h: 4 },
                      spec: {
                        rows: [
                          { label: "Current rating", measure: "end_rating" },
                          { label: "Trend", measure: "rating_trend" },
                          { label: "Avg rating delta", measure: "rating_delta_avg" },
                          {
                            label: "Highest rating delta",
                            measure: "rating_delta_highest",
                            actions: { click: { type: "drilldown", target: "games", columnsPreset: "gameMode", filterFromPoint: true } }
                          },
                          {
                            label: "Lowest rating delta",
                            measure: "rating_delta_lowest",
                            actions: { click: { type: "drilldown", target: "games", columnsPreset: "gameMode", filterFromPoint: true } }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_rating_session_records",
                      type: "record_list",
                      title: "Sessions",
                      grain: "session",
                      placement: { x: 0, y: 4, w: 12, h: 4 },
                      spec: {
                        records: [
                          {
                            id: "biggest_session_rating_gain",
                            label: "Biggest session rating gain",
                            metric: "session_delta_rating",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "biggest_session_rating_loss",
                            label: "Biggest session rating loss",
                            metric: "session_delta_rating",
                            groupBy: "session_start",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_rating_over_time",
                      type: "chart",
                      title: "Rating over time",
                      grain: "game",
                      placement: { x: 0, y: 8, w: 12, h: 8 },
                      spec: {
                        type: "line",
                        maxPoints: 220,
                        x: { dimension: "time_day" },
                        y: { measures: ["end_rating"], activeMeasure: "end_rating" },
                        sort: { mode: "chronological" },
                        actions: {
                          hover: true,
                          click: {
                            type: "drilldown",
                            target: "players",
                            columnsPreset: "opponentMode",
                            filterFromPoint: true
                          }
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "personal_records",
          title: "Personal Records",
          filterScope: { exclude: ["movement", "guessTimeBucket"] },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_personal_records",
                title: "Personal Records",
                x: 0,
                y: 0,
                w: 12,
                h: 30,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_round_records",
                      type: "record_list",
                      title: "Round Records",
                      grain: "round",
                      placement: { x: 0, y: 0, w: 12, h: 6 },
                      spec: {
                        records: [
                          {
                            id: "highest_score_round",
                            label: "Highest score round",
                            metric: "round_score",
                            groupBy: "round_id",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "lowest_score_round",
                            label: "Lowest score round",
                            metric: "round_score",
                            groupBy: "round_id",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "biggest_damage_dealt_round",
                            label: "Biggest damage dealt round",
                            metric: "round_damage_dealt",
                            groupBy: "round_id",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "biggest_damage_taken_round",
                            label: "Biggest damage taken round",
                            metric: "round_damage_taken",
                            groupBy: "round_id",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "fastest_round",
                            label: "Fastest round (min duration)",
                            metric: "round_guess_duration",
                            groupBy: "round_id",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "slowest_round",
                            label: "Slowest round (max duration)",
                            metric: "round_guess_duration",
                            groupBy: "round_id",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "fastest_5k",
                            label: "Fastest 5k",
                            metric: "round_guess_duration",
                            groupBy: "round_id",
                            extreme: "min",
                            filters: [{ dimension: "score_bucket", op: "eq", value: "5000" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "score_bucket", op: "eq", value: "5000" }]
                              }
                            }
                          },
                          {
                            id: "slowest_throw",
                            label: "Slowest throw",
                            metric: "round_guess_duration",
                            groupBy: "round_id",
                            extreme: "max",
                            filters: [{ dimension: "is_throw", op: "eq", value: "true" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "is_throw", op: "eq", value: "true" }]
                              }
                            }
                          },
                          {
                            id: "best_score_per_second",
                            label: "Best score-per-second",
                            metric: "round_score_per_second",
                            groupBy: "round_id",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "worst_region_guess",
                            label: "Worst region-guess (hit but low score)",
                            metric: "round_score",
                            groupBy: "round_id",
                            extreme: "min",
                            filters: [{ dimension: "is_hit", op: "eq", value: "true" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "is_hit", op: "eq", value: "true" }]
                              }
                            }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_game_records",
                      type: "record_list",
                      title: "Game Records",
                      grain: "game",
                      placement: { x: 0, y: 6, w: 12, h: 7 },
                      spec: {
                        records: [
                          {
                            id: "flawless_wins",
                            label: "Flawless wins (no damage taken)",
                            kind: "overall",
                            metric: "flawless_wins_count",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "games",
                                columnsPreset: "gameMode",
                                filterFromPoint: false,
                                extraFilters: [{ dimension: "is_flawless_win", op: "eq", value: "true" }]
                              }
                            }
                          },
                          {
                            id: "highest_avg_score_game",
                            label: "Highest avg score game",
                            metric: "game_avg_score",
                            groupBy: "game_id",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "games", columnsPreset: "gameMode", filterFromPoint: true } }
                          },
                          {
                            id: "lowest_avg_score_game",
                            label: "Lowest avg score game",
                            metric: "game_avg_score",
                            groupBy: "game_id",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "games", columnsPreset: "gameMode", filterFromPoint: true } }
                          },
                          {
                            id: "most_5ks_in_game",
                            label: "Most 5ks in a game",
                            metric: "game_5k_count",
                            groupBy: "game_id",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "games", columnsPreset: "gameMode", filterFromPoint: true } }
                          },
                          {
                            id: "most_throws_in_game",
                            label: "Most throws in a game",
                            metric: "game_throw_count",
                            groupBy: "game_id",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "games", columnsPreset: "gameMode", filterFromPoint: true } }
                          },
                          {
                            id: "worst_hit_rate_game",
                            label: "Worst hit rate game",
                            metric: "game_hit_rate",
                            groupBy: "game_id",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "games", columnsPreset: "gameMode", filterFromPoint: true } }
                          },
                          {
                            id: "highest_rating_gain_game",
                            label: "Highest rating gain",
                            metric: "game_rating_delta",
                            groupBy: "game_id",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "games", columnsPreset: "gameMode", filterFromPoint: true } }
                          },
                          {
                            id: "fastest_win_game",
                            label: "Fastest win game",
                            metric: "game_duration",
                            groupBy: "game_id",
                            extreme: "min",
                            filters: [{ dimension: "result", op: "eq", value: "Win" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "games",
                                columnsPreset: "gameMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "result", op: "eq", value: "Win" }]
                              }
                            }
                          },
                          {
                            id: "slowest_win_game",
                            label: "Slowest win game",
                            metric: "game_duration",
                            groupBy: "game_id",
                            extreme: "max",
                            filters: [{ dimension: "result", op: "eq", value: "Win" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "games",
                                columnsPreset: "gameMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "result", op: "eq", value: "Win" }]
                              }
                            }
                          },
                          {
                            id: "best_clutch_game",
                            label: "Best clutch (win with lowest health)",
                            metric: "game_final_health",
                            groupBy: "game_id",
                            extreme: "min",
                            filters: [{ dimension: "result", op: "eq", value: "Win" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "games",
                                columnsPreset: "gameMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "result", op: "eq", value: "Win" }]
                              }
                            }
                          },
                          {
                            id: "worst_throw_game",
                            label: "Worst throw (loss with highest health in last round)",
                            metric: "game_final_health",
                            groupBy: "game_id",
                            extreme: "max",
                            filters: [{ dimension: "result", op: "eq", value: "Loss" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "games",
                                columnsPreset: "gameMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "result", op: "eq", value: "Loss" }]
                              }
                            }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_session_records",
                      type: "record_list",
                      title: "Session Records",
                      grain: "session",
                      placement: { x: 0, y: 13, w: 12, h: 6 },
                      spec: {
                        records: [
                          {
                            id: "highest_win_rate_session",
                            label: "Highest win rate session",
                            metric: "session_win_rate",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "highest_avg_score_session",
                            label: "Highest avg score session",
                            metric: "session_avg_score",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "lowest_avg_score_session",
                            label: "Lowest avg score session",
                            metric: "session_avg_score",
                            groupBy: "session_start",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "most_games_session",
                            label: "Most games session",
                            metric: "session_games_count",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "longest_session_total_duration",
                            label: "Longest session (total duration)",
                            metric: "session_duration_minutes",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "most_5ks_session",
                            label: "Most 5ks session",
                            metric: "session_5k_count",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "best_hit_rate_session",
                            label: "Best hit rate session",
                            metric: "session_hit_rate",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "highest_throw_rate_session",
                            label: "Highest throw rate session",
                            metric: "session_throw_rate",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "biggest_rating_gain_in_session",
                            label: "Biggest rating gain in a session",
                            metric: "session_delta_rating",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "biggest_rating_loss_in_session",
                            label: "Biggest rating loss in a session",
                            metric: "session_delta_rating",
                            groupBy: "session_start",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_day_records",
                      type: "record_list",
                      title: "Day Records",
                      grain: "session",
                      placement: { x: 0, y: 19, w: 12, h: 7 },
                      spec: {
                        records: [
                          {
                            id: "best_day_by_avg_score",
                            label: "Best day by avg score",
                            metric: "session_avg_score",
                            groupBy: "time_day",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "worst_day_by_avg_score",
                            label: "Worst day by avg score",
                            metric: "session_avg_score",
                            groupBy: "time_day",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "most_sessions_in_a_day",
                            label: "Most sessions in a day",
                            metric: "sessions_count",
                            groupBy: "time_day",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "most_games_in_a_day",
                            label: "Most games in a day",
                            metric: "session_games_count",
                            groupBy: "time_day",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "most_time_played_in_a_day",
                            label: "Most time played in a day",
                            metric: "session_duration_minutes",
                            groupBy: "time_day",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "most_5ks_in_a_day",
                            label: "Most 5ks in a day",
                            metric: "session_5k_count",
                            groupBy: "time_day",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "best_win_rate_day",
                            label: "Best win rate day (min 5 games)",
                            metric: "day_win_rate_min5",
                            groupBy: "time_day",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "worst_win_rate_day",
                            label: "Worst win rate day (min 5 games)",
                            metric: "day_win_rate_min5",
                            groupBy: "time_day",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_day_streaks",
                      type: "stat_list",
                      title: "Day Streaks",
                      grain: "session",
                      placement: { x: 0, y: 26, w: 12, h: 3 },
                      spec: {
                        rows: [
                          { label: "Most consecutive days without games", measure: "max_consecutive_days_without_games" },
                          { label: "Longest active streak (min 1 game/day)", measure: "longest_active_streak_days" },
                          { label: "Longest 5k day streak (min 1 5k/day)", measure: "longest_5k_day_streak_days" }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "sessions",
          title: "Sessions",
          filterScope: { exclude: ["movement", "guessTimeBucket"] },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_sessions",
                title: "Sessions",
                x: 0,
                y: 0,
                w: 12,
                h: 20,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_sessions_kpis",
                      type: "stat_list",
                      title: "Sessions",
                      grain: "session",
                      placement: { x: 0, y: 0, w: 12, h: 4 },
                      spec: {
                        rows: [
                          {
                            label: "Sessions detected (gap >45m)",
                            measure: "sessions_count",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: false } }
                          },
                          { label: "Longest break between sessions", measure: "sessions_longest_break_seconds" },
                          { label: "Avg games per session", measure: "sessions_avg_games" }
                        ]
                      }
                    },
                    {
                      widgetId: "w_sessions_records",
                      type: "record_list",
                      title: "Session Records",
                      grain: "session",
                      placement: { x: 0, y: 4, w: 12, h: 5 },
                      spec: {
                        records: [
                          {
                            id: "longest_session",
                            label: "Longest session",
                            metric: "session_games_count",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "best_session",
                            label: "Best session",
                            metric: "session_avg_score",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          },
                          {
                            id: "worst_session",
                            label: "Worst session",
                            metric: "session_avg_score",
                            groupBy: "session_start",
                            extreme: "min",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_sessions_line",
                      type: "chart",
                      title: "Sessions over time (line)",
                      grain: "session",
                      placement: { x: 0, y: 9, w: 12, h: 5 },
                      spec: {
                        type: "line",
                        maxPoints: 120,
                        x: { dimension: "session_index" },
                        y: {
                          measures: [
                            "session_avg_score",
                            "session_avg_score_hit",
                            "session_fivek_rate",
                            "session_5k_count",
                            "session_throw_rate",
                            "session_throw_count",
                            "session_hit_rate",
                            "session_hit_count",
                            "session_win_rate",
                            "session_win_count",
                            "session_start_rating",
                            "session_end_rating",
                            "session_rating_delta",
                            "session_duration_minutes",
                            "session_games_count",
                            "session_rounds_count",
                            "session_avg_guess_duration",
                            "session_avg_distance_km"
                          ],
                          activeMeasure: "session_avg_score"
                        },
                        sort: { mode: "chronological" },
                        actions: { hover: true, click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                      }
                    },
                    {
                      widgetId: "w_sessions_breakdown",
                      type: "breakdown",
                      title: "Sessions (bar)",
                      grain: "session",
                      placement: { x: 0, y: 14, w: 12, h: 6 },
                      spec: {
                        dimension: "session_start",
                        measures: [
                          "session_avg_score",
                          "session_avg_score_hit",
                          "session_fivek_rate",
                          "session_5k_count",
                          "session_throw_rate",
                          "session_throw_count",
                          "session_hit_rate",
                          "session_hit_count",
                          "session_win_rate",
                          "session_win_count",
                          "session_start_rating",
                          "session_end_rating",
                          "session_rating_delta",
                          "session_duration_minutes",
                          "session_games_count",
                          "session_rounds_count"
                        ],
                        activeMeasure: "session_avg_score",
                        sorts: [{ mode: "chronological" }, { mode: "desc" }, { mode: "asc" }],
                        activeSort: { mode: "chronological" },
                        limit: 12,
                        extendable: true,
                        actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "tempo",
          title: "Tempo",
          filterScope: { exclude: ["movement", "guessTimeBucket"] },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_tempo",
                title: "Tempo",
                x: 0,
                y: 0,
                w: 12,
                h: 14,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_tempo_records",
                      type: "record_list",
                      title: "Tempo",
                      grain: "round",
                      placement: { x: 0, y: 0, w: 12, h: 6 },
                      spec: {
                        records: [
                          {
                            id: "fastest_guess",
                            label: "Fastest guess",
                            metric: "avg_guess_duration",
                            groupBy: "round_id",
                            extreme: "min",
                            displayKey: "first_ts_score",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "slowest_guess",
                            label: "Slowest guess",
                            metric: "avg_guess_duration",
                            groupBy: "round_id",
                            extreme: "max",
                            displayKey: "first_ts_score",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "fastest_5k",
                            label: "Fastest 5k",
                            metric: "avg_guess_duration",
                            groupBy: "round_id",
                            extreme: "min",
                            filters: [{ dimension: "score_bucket", op: "eq", value: "5000" }],
                            displayKey: "first_ts",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "score_bucket", op: "eq", value: "5000" }]
                              }
                            }
                          },
                          {
                            id: "slowest_throw",
                            label: "Slowest throw (<50)",
                            metric: "avg_guess_duration",
                            groupBy: "round_id",
                            extreme: "max",
                            filters: [{ dimension: "is_throw", op: "eq", value: "true" }],
                            displayKey: "first_ts_score",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "is_throw", op: "eq", value: "true" }]
                              }
                            }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_tempo_bucket_breakdown",
                      type: "breakdown",
                      title: "Tempo - Time bucket metrics",
                      grain: "round",
                      placement: { x: 0, y: 6, w: 12, h: 8 },
                      spec: {
                        dimension: "duration_bucket",
                        measures: ["avg_score", "fivek_rate", "throw_rate", "hit_rate", "avg_guess_duration"],
                        activeMeasure: "avg_score",
                        sorts: [{ mode: "chronological" }, { mode: "desc" }, { mode: "asc" }],
                        activeSort: { mode: "chronological" },
                        limit: 12,
                        actions: {
                          click: {
                            type: "drilldown",
                            target: "rounds",
                            columnsPreset: "roundMode",
                            filterFromPoint: true
                          }
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "scores",
          title: "Scores",
          filterScope: { exclude: ["movement", "guessTimeBucket"] },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_scores_kpis",
                title: "Scores",
                x: 0,
                y: 0,
                w: 12,
                h: 14,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_scores_kpis",
                      type: "stat_list",
                      title: "Scores",
                      grain: "round",
                      placement: { x: 0, y: 0, w: 12, h: 4 },
                      spec: {
                        rows: [
                          {
                            label: "Perfect 5k",
                            measure: "fivek_count",
                            secondaryMeasure: "fivek_rate",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: false,
                                extraFilters: [{ dimension: "score_bucket", op: "eq", value: "5000" }]
                              }
                            }
                          },
                          {
                            label: "Near-perfect (>=4500)",
                            measure: "near_perfect_count",
                            secondaryMeasure: "near_perfect_rate",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: false,
                                extraFilters: [{ dimension: "is_near_perfect", op: "eq", value: "true" }]
                              }
                            }
                          },
                          {
                            label: "Low scores (<500)",
                            measure: "low_score_count",
                            secondaryMeasure: "low_score_rate",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: false,
                                extraFilters: [{ dimension: "is_low_score", op: "eq", value: "true" }]
                              }
                            }
                          },
                          {
                            label: "Throws (<50)",
                            measure: "throw_count",
                            secondaryMeasure: "throw_rate",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: false,
                                extraFilters: [{ dimension: "is_throw", op: "eq", value: "true" }]
                              }
                            }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_score_distribution",
                      type: "chart",
                      title: "Scores - Score distribution (smoothed)",
                      grain: "round",
                      placement: { x: 0, y: 4, w: 12, h: 10 },
                      spec: {
                        type: "bar",
                        limit: 200,
                        x: { dimension: "score_bucket" },
                        y: { measure: "rounds_count" },
                        sort: { mode: "chronological" },
                        actions: {
                          hover: true,
                          click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true }
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "rounds",
          title: "Rounds",
          filterScope: { exclude: ["movement", "guessTimeBucket", "country"] },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_rounds",
                title: "Rounds",
                x: 0,
                y: 0,
                w: 12,
                h: 24,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_rounds_records",
                      type: "record_list",
                      title: "Rounds",
                      grain: "round",
                      placement: { x: 0, y: 0, w: 12, h: 7 },
                      spec: {
                        records: [
                          {
                            id: "game_most_rounds",
                            label: "Game with most rounds",
                            metric: "rounds_count",
                            groupBy: "game_id",
                            extreme: "max",
                            displayKey: "first_ts",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "game_fewest_rounds",
                            label: "Games with fewest rounds",
                            metric: "rounds_count",
                            groupBy: "game_id",
                            extreme: "min",
                            displayKey: "first_ts",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "largest_score_spread_game",
                            label: "Largest score spread (max-min in one game)",
                            metric: "score_spread",
                            groupBy: "game_id",
                            extreme: "max",
                            displayKey: "first_ts",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "fast_round_streak",
                            label: "Fastest round streak (<20s)",
                            kind: "streak",
                            streakFilters: [{ dimension: "duration_bucket", op: "eq", value: "<20 sec" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "duration_bucket", op: "eq", value: "<20 sec" }]
                              }
                            }
                          },
                          {
                            id: "damage_dealt_streak",
                            label: "Damage dealt streak",
                            kind: "streak",
                            streakFilters: [{ dimension: "is_damage_dealt", op: "eq", value: "true" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "is_damage_dealt", op: "eq", value: "true" }]
                              }
                            }
                          },
                          {
                            id: "damage_taken_streak",
                            label: "Damage taken streak",
                            kind: "streak",
                            streakFilters: [{ dimension: "is_damage_taken", op: "eq", value: "true" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "is_damage_taken", op: "eq", value: "true" }]
                              }
                            }
                          },
                          {
                            id: "same_country_streak",
                            label: "Longest same-country streak",
                            kind: "same_value_streak",
                            dimension: "true_country",
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true } }
                          },
                          {
                            id: "correct_country_streak",
                            label: "Correct-country streak",
                            kind: "streak",
                            streakFilters: [{ dimension: "is_hit", op: "eq", value: "true" }],
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                filterFromPoint: true,
                                extraFilters: [{ dimension: "is_hit", op: "eq", value: "true" }]
                              }
                            }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_rounds_progression",
                      type: "chart",
                      title: "Rounds - Round progression metrics",
                      grain: "round",
                      placement: { x: 0, y: 7, w: 12, h: 8 },
                      spec: {
                        type: "bar",
                        x: { dimension: "round_number" },
                        y: {
                          measures: [
                            "avg_score",
                            "avg_score_hit_only",
                            "avg_distance_km",
                            "avg_guess_duration",
                            "fivek_rate",
                            "throw_rate",
                            "hit_rate",
                            "damage_dealt_avg",
                            "damage_taken_avg"
                          ],
                          activeMeasure: "avg_score"
                        },
                        sorts: [{ mode: "chronological" }, { mode: "desc" }, { mode: "asc" }],
                        activeSort: { mode: "chronological" },
                        limit: 20,
                        actions: {
                          hover: true,
                          click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true }
                        }
                      }
                    },
                    {
                      widgetId: "w_game_length_perf",
                      type: "chart",
                      title: "Rounds - Performance by game length (rounds per game, 2+)",
                      grain: "game",
                      placement: { x: 0, y: 15, w: 12, h: 9 },
                      spec: {
                        type: "bar",
                        x: { dimension: "game_length" },
                        y: {
                          measures: ["games_count", "win_rate", "win_count", "loss_count", "tie_count", "best_end_rating"],
                          activeMeasure: "games_count"
                        },
                        sorts: [{ mode: "chronological" }, { mode: "desc" }, { mode: "asc" }],
                        activeSort: { mode: "chronological" },
                        limit: 20,
                        actions: {
                          hover: true,
                          click: { type: "drilldown", target: "players", columnsPreset: "opponentMode", filterFromPoint: true }
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "time_patterns",
          title: "Time Patterns",
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_by_weekday",
                title: "By weekday",
                x: 0,
                y: 0,
                w: 12,
                h: 10,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "by_weekday_chart",
                      type: "chart",
                      title: "Weekday Analysis",
                      grain: "round",
                      placement: { x: 0, y: 0, w: 12, h: 10 },
                      spec: {
                        type: "bar",
                        x: { dimension: "weekday" },
                        y: {
                          measures: [
                            "games_count",
                            "rounds_count",
                            "avg_score",
                            "avg_score_hit_only",
                            "avg_distance_km",
                            "avg_guess_duration",
                            "throw_rate",
                            "throw_count",
                            "fivek_rate",
                            "fivek_count",
                            "hit_rate",
                            "hit_count",
                            "win_rate",
                            "win_count",
                            "damage_dealt_avg",
                            "damage_taken_avg"
                          ],
                          activeMeasure: "games_count"
                        },
                        sorts: [{ mode: "desc" }, { mode: "asc" }, { mode: "chronological" }],
                        activeSort: { mode: "chronological" },
                        actions: {
                          hover: true,
                          click: {
                            type: "drilldown",
                            target: "rounds",
                            columnsPreset: "roundMode",
                            filterFromPoint: true
                          }
                        }
                      }
                    }
                  ]
                }
              },
              {
                cardId: "card_by_hour",
                title: "By hour",
                x: 0,
                y: 10,
                w: 12,
                h: 10,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "by_hour_chart",
                      type: "chart",
                      title: "Hour Analysis",
                      grain: "round",
                      placement: { x: 0, y: 0, w: 12, h: 10 },
                      spec: {
                        type: "bar",
                        color: "#ff8a3d",
                        x: { dimension: "hour" },
                        y: {
                          measures: [
                            "games_count",
                            "rounds_count",
                            "avg_score",
                            "avg_score_hit_only",
                            "avg_distance_km",
                            "avg_guess_duration",
                            "throw_rate",
                            "throw_count",
                            "fivek_rate",
                            "fivek_count",
                            "hit_rate",
                            "hit_count",
                            "win_rate",
                            "win_count",
                            "damage_dealt_avg",
                            "damage_taken_avg"
                          ],
                          activeMeasure: "games_count"
                        },
                        sorts: [{ mode: "desc" }, { mode: "asc" }, { mode: "chronological" }],
                        activeSort: { mode: "chronological" },
                        actions: {
                          hover: true,
                          click: {
                            type: "drilldown",
                            target: "rounds",
                            columnsPreset: "roundMode",
                            filterFromPoint: true
                          }
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "countries",
          title: "Countries",
          filterScope: { exclude: ["movement", "guessTimeBucket", "country"] },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_countries",
                title: "Countries",
                x: 0,
                y: 0,
                w: 12,
                h: 18,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_country_metrics",
                      type: "breakdown",
                      title: "Countries - Country metrics",
                      grain: "round",
                      placement: { x: 0, y: 0, w: 12, h: 10 },
                      spec: {
                        dimension: "true_country",
                        measures: [
                          "avg_score",
                          "avg_score_hit_only",
                          "avg_distance_km",
                          "avg_guess_duration",
                          "rounds_count",
                          "fivek_rate",
                          "fivek_count",
                          "throw_rate",
                          "throw_count",
                          "hit_rate",
                          "hit_count",
                          "damage_dealt_avg",
                          "damage_taken_avg",
                          "damage_dealt_share",
                          "damage_taken_share"
                        ],
                        activeMeasure: "avg_score",
                        sorts: [{ mode: "desc" }, { mode: "asc" }],
                        activeSort: { mode: "desc" },
                        limit: 15,
                        extendable: true,
                        actions: {
                          click: {
                            type: "drilldown",
                            target: "rounds",
                            columnsPreset: "roundMode",
                            filterFromPoint: true
                          }
                        }
                      }
                    },
                    {
                      widgetId: "w_country_confusion",
                      type: "chart",
                      title: "Countries - Confusion matrix (top pairs)",
                      grain: "round",
                      placement: { x: 0, y: 10, w: 12, h: 8 },
                      spec: {
                        type: "bar",
                        limit: 20,
                        x: { dimension: "confused_countries" },
                        y: { measure: "rounds_count" },
                        sort: { mode: "desc" },
                        actions: {
                          hover: true,
                          click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true }
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "opponents",
          title: "Opponents",
          filterScope: { exclude: ["movement", "guessTimeBucket", "country"] },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_opponents",
                title: "Opponents",
                x: 0,
                y: 0,
                w: 12,
                h: 18,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_opponents_scope",
                      type: "stat_list",
                      title: "Scope",
                      grain: "game",
                      placement: { x: 0, y: 0, w: 12, h: 3 },
                      spec: {
                        rows: [
                          { label: "Unique opponents", measure: "unique_opponents_count" },
                          { label: "Unique countries", measure: "unique_opponent_countries_count" },
                          {
                            label: "Strongest opponent (rating)",
                            measure: "strongest_opponent_rating",
                            actions: { click: { type: "drilldown", target: "players", columnsPreset: "opponentMode", filterFromPoint: false } }
                          },
                          {
                            label: "Strongest defeated opponent (rating)",
                            measure: "strongest_defeated_opponent_rating",
                            actions: { click: { type: "drilldown", target: "players", columnsPreset: "opponentMode", filterFromPoint: false } }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_opponents_by_country",
                      type: "chart",
                      title: "Opponents - Match-ups by opponent country",
                      grain: "game",
                      placement: { x: 0, y: 3, w: 12, h: 8 },
                      spec: {
                        type: "bar",
                        limit: 20,
                        x: { dimension: "opponent_country" },
                        y: { measure: "matchups_count" },
                        sort: { mode: "desc" },
                        actions: {
                          hover: true,
                          click: { type: "drilldown", target: "players", columnsPreset: "opponentMode", filterFromPoint: true }
                        }
                      }
                    },
                    {
                      widgetId: "w_opponents_top",
                      type: "breakdown",
                      title: "Opponents - Top opponents",
                      grain: "game",
                      placement: { x: 0, y: 11, w: 12, h: 7 },
                      spec: {
                        dimension: "opponent_name",
                        measure: "matchups_count",
                        sort: { mode: "desc" },
                        limit: 15,
                        extendable: true,
                        actions: {
                          click: { type: "drilldown", target: "players", columnsPreset: "opponentMode", filterFromPoint: true }
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "team",
          title: "Team",
          localFilters: {
            enabled: true,
            controls: [
              {
                id: "mate",
                type: "select",
                label: "Mate",
                dimension: "teammate_name",
                default: "auto_top",
                options: "auto_teammates",
                required: true,
                appliesTo: ["round"]
              }
            ],
            buttons: { reset: true }
          },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_team",
                title: "Team: You + {{local.mate}}",
                x: 0,
                y: 0,
                w: 12,
                h: 18,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_team_h2h",
                      type: "leader_list",
                      title: "Head-to-head questions",
                      grain: "round",
                      placement: { x: 0, y: 0, w: 12, h: 5 },
                      spec: {
                        rows: [
                          {
                            label: "Closer guesses",
                            dimension: "team_closer_winner",
                            excludeKeys: ["Tie"],
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } }
                          },
                          {
                            label: "Higher score rounds",
                            dimension: "team_higher_score_winner",
                            excludeKeys: ["Tie"],
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } }
                          },
                          {
                            label: "Fewer throws (<50)",
                            dimension: "team_fewer_throw_winner",
                            excludeKeys: ["Tie"],
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } }
                          },
                          {
                            label: "More 5k rounds",
                            dimension: "team_more_5k_winner",
                            excludeKeys: ["Tie"],
                            actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_team_facts_round",
                      type: "stat_list",
                      title: "Team facts",
                      grain: "round",
                      placement: { x: 0, y: 5, w: 12, h: 5 },
                      spec: {
                        rows: [
                          { label: "Games together", measure: "games_distinct_count", actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } } },
                          { label: "Rounds together", measure: "rounds_count", actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } } },
                          { label: "Time played together", measure: "time_played_seconds", secondaryMeasure: "rounds_with_time_count", actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } } },
                          { label: "First game together", measure: "first_played_at", actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } } },
                          { label: "Most recent game together", measure: "last_played_at", actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } } }
                        ]
                      }
                    },
                    {
                      widgetId: "w_team_session_records",
                      type: "record_list",
                      title: "Session records together",
                      grain: "session",
                      placement: { x: 0, y: 10, w: 12, h: 4 },
                      spec: {
                        records: [
                          {
                            id: "longest_session_together",
                            label: "Longest session together",
                            metric: "session_games_count",
                            groupBy: "session_start",
                            extreme: "max",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: true } }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_team_facts_sessions",
                      type: "stat_list",
                      title: "Session stats together",
                      grain: "session",
                      placement: { x: 0, y: 14, w: 12, h: 4 },
                      spec: {
                        rows: [
                          {
                            label: "Sessions detected (gap > session standard)",
                            measure: "sessions_count",
                            actions: { click: { type: "drilldown", target: "sessions", columnsPreset: "sessionMode", filterFromPoint: false } }
                          },
                          { label: "Longest break between sessions", measure: "sessions_longest_break_seconds" },
                          { label: "Avg games per session", measure: "sessions_avg_games" }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          id: "country_insight",
          title: "Country Insight",
          filterScope: { exclude: ["country"] },
          localFilters: {
            enabled: true,
            controls: [
              {
                id: "spotlightCountry",
                type: "select",
                label: "Country",
                dimension: "true_country",
                presentation: "map",
                map: {
                  variant: "wide",
                  height: 720,
                  restrictToOptions: true,
                  tintSelectable: true
                },
                default: "auto_top",
                options: "auto_distinct",
                required: true,
                appliesTo: ["round"]
              }
            ],
            buttons: { reset: false }
          },
          layout: {
            mode: "grid",
            columns: 12,
            cards: [
              {
                cardId: "card_country_insight",
                title: "Country Spotlight: {{local.spotlightCountry}}",
                x: 0,
                y: 0,
                w: 12,
                h: 18,
                card: {
                  type: "composite",
                  children: [
                    {
                      widgetId: "w_country_insight_stats",
                      type: "stat_list",
                      title: "Country spotlight",
                      grain: "round",
                      placement: { x: 0, y: 0, w: 12, h: 6 },
                      spec: {
                        rows: [
                          { label: "Rounds", measure: "rounds_count", actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } } },
                          { label: "Hit rate", measure: "hit_rate", actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } } },
                          { label: "Avg score", measure: "avg_score", secondaryMeasure: "score_median", actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } } },
                          { label: "Avg distance", measure: "avg_distance_km", actions: { click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode" } } },
                          {
                            label: "Perfect 5k in this country",
                            measure: "fivek_count",
                            secondaryMeasure: "fivek_rate",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                extraFilters: [{ dimension: "score_bucket", op: "eq", value: "5000" }]
                              }
                            }
                          },
                          {
                            label: "Throws (<50) in this country",
                            measure: "throw_count",
                            secondaryMeasure: "throw_rate",
                            actions: {
                              click: {
                                type: "drilldown",
                                target: "rounds",
                                columnsPreset: "roundMode",
                                extraFilters: [{ dimension: "is_throw", op: "eq", value: "true" }]
                              }
                            }
                          }
                        ]
                      }
                    },
                    {
                      widgetId: "w_country_insight_confusions",
                      type: "breakdown",
                      title: "Top confusions (guessed country on misses)",
                      grain: "round",
                      placement: { x: 0, y: 6, w: 12, h: 4 },
                      spec: {
                        dimension: "guess_country",
                        measure: "rounds_count",
                        filters: [{ dimension: "is_hit", op: "eq", value: "false" }],
                        sort: { mode: "desc" },
                        limit: 3,
                        actions: {
                          click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true }
                        }
                      }
                    },
                    {
                      widgetId: "w_country_insight_distribution",
                      type: "chart",
                      title: "Score distribution (smoothed)",
                      grain: "round",
                      placement: { x: 0, y: 10, w: 12, h: 8 },
                      spec: {
                        type: "bar",
                        limit: 200,
                        x: { dimension: "score_bucket" },
                        y: { measure: "rounds_count" },
                        sort: { mode: "chronological" },
                        actions: {
                          hover: true,
                          click: { type: "drilldown", target: "rounds", columnsPreset: "roundMode", filterFromPoint: true }
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      ]
    }
  };

  // src/ui/semanticDashboardCss.ts
  function injectSemanticDashboardCssOnce(doc) {
    const id = "geoanalyzr-semantic-dashboard-css";
    if (doc.getElementById(id)) return;
    const style = doc.createElement("style");
    style.id = id;
    style.textContent = `
    html.ga-semantic-page, body.ga-semantic-page {
      margin: 0;
      padding: 0;
      min-height: 100%;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
      background: var(--ga-bg);
      color: var(--ga-text);
    }
    .ga-root {
      --ga-font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
      --ga-topbar-h: 0px;
      --ga-filters-h: 0px;
      --ga-bg: #0f1115;
      --ga-surface: #15181e;
      --ga-surface-2: #171b22;
      --ga-card: #12161d;
      --ga-card-2: #10141b;
      --ga-text: #d7deea;
      --ga-text-muted: #9aa5b6;
      --ga-border: #2b3340;
      --ga-control-bg: #161b23;
      --ga-control-text: #d7deea;
      --ga-control-border: #3a4352;
      --ga-axis-color: #7f8ca2;
      --ga-axis-grid: #3c4555;
      --ga-axis-text: #c7d2e4;
      --ga-graph-color: #7eb6ff;
      --ga-accent: #7950E5;
      --ga-accent2: #00A2FE;
      --ga-good: #97E851;
      --ga-warn: #FECD19;
      --ga-danger: #ff6b6b;
      --ga-link: var(--ga-accent2);
      --ga-overlay-bg: rgba(0,0,0,0.62);
      --ga-focus-ring: color-mix(in srgb, var(--ga-accent2) 55%, transparent);
      --ga-map-border: rgba(255,255,255,0.10);
      --ga-map-toolbar-bg: rgba(20,20,32,0.78);
      --ga-map-toolbar-border: rgba(255,255,255,0.16);
      --ga-map-hint: rgba(243,244,255,0.66);
      --ga-map-fill: rgba(255,255,255,0.03);
      --ga-map-stroke: rgba(255,255,255,0.16);
      --ga-map-selectable-fill: rgba(0, 162, 254, 0.11);
      --ga-map-selectable-hover: rgba(0, 162, 254, 0.20);
      --ga-map-disabled-fill: rgba(255,255,255,0.02);
      --ga-map-disabled-stroke: rgba(255,255,255,0.08);
      --ga-map-active-fill: rgba(254,205,25,0.40);
      --ga-map-active-stroke: rgba(254,205,25,0.72);
      --ga-map-bg:
        radial-gradient(520px 260px at 20% 0%, rgba(121, 80, 229, 0.16), transparent 60%),
        radial-gradient(520px 260px at 90% 0%, rgba(0, 162, 254, 0.12), transparent 62%),
        rgba(22,22,38,0.60);
      min-height: 100vh;
      background: var(--ga-bg);
      color: var(--ga-text);
      font-family: var(--ga-font);
    }
    .ga-root[data-ga-theme="light"] {
      --ga-bg: #f4f7fc;
      --ga-surface: #ffffff;
      --ga-surface-2: #f9fbff;
      --ga-card: #ffffff;
      --ga-card-2: #f8fbff;
      --ga-text: #1f2a38;
      --ga-text-muted: #4b5d74;
      --ga-border: #c8d5e6;
      --ga-control-bg: #ffffff;
      --ga-control-text: #1f2a38;
      --ga-control-border: #b7c7dd;
      --ga-axis-color: #51647e;
      --ga-axis-grid: #c2cfdf;
      --ga-axis-text: #2b3d56;
      --ga-link: #563B9A;
      --ga-overlay-bg: rgba(10,12,18,0.35);
      --ga-focus-ring: color-mix(in srgb, var(--ga-accent) 55%, transparent);
      --ga-map-border: rgba(0,0,0,0.12);
      --ga-map-toolbar-bg: rgba(255,255,255,0.86);
      --ga-map-toolbar-border: rgba(0,0,0,0.12);
      --ga-map-hint: rgba(31,42,56,0.68);
      --ga-map-fill: rgba(31,42,56,0.05);
      --ga-map-stroke: rgba(31,42,56,0.18);
      --ga-map-selectable-fill: rgba(0, 162, 254, 0.16);
      --ga-map-selectable-hover: rgba(0, 162, 254, 0.24);
      --ga-map-disabled-fill: rgba(31,42,56,0.03);
      --ga-map-disabled-stroke: rgba(31,42,56,0.10);
      --ga-map-active-fill: rgba(121, 80, 229, 0.34);
      --ga-map-active-stroke: rgba(121, 80, 229, 0.74);
      --ga-map-bg:
        radial-gradient(520px 260px at 20% 0%, rgba(121, 80, 229, 0.10), transparent 60%),
        radial-gradient(520px 260px at 90% 0%, rgba(0, 162, 254, 0.10), transparent 62%),
        rgba(255,255,255,0.92);
    }
    .ga-root[data-ga-theme="geoguessr"] {
      --ga-font: "Poppins", ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
      --ga-bg:
        radial-gradient(1200px 720px at 18% -12%, rgba(58, 232, 189, 0.18), transparent 62%),
        radial-gradient(980px 560px at 86% -6%, rgba(0, 162, 254, 0.18), transparent 60%),
        radial-gradient(1200px 860px at 50% 112%, rgba(121, 80, 229, 0.24), transparent 56%),
        linear-gradient(180deg, #10101C 0%, #1A1A2E 100%);
      --ga-surface: rgba(22, 22, 38, 0.72);
      --ga-surface-2: rgba(26, 26, 46, 0.78);
      --ga-card: rgba(22, 22, 38, 0.62);
      --ga-card-2: rgba(18, 18, 32, 0.56);
      --ga-text: rgba(243, 244, 255, 0.92);
      --ga-text-muted: rgba(208, 214, 238, 0.68);
      --ga-border: rgba(255,255,255,0.12);
      --ga-control-bg: rgba(16, 16, 28, 0.45);
      --ga-control-text: rgba(243, 244, 255, 0.92);
      --ga-control-border: rgba(255,255,255,0.14);
      --ga-axis-color: rgba(220, 226, 250, 0.50);
      --ga-axis-grid: rgba(255,255,255,0.10);
      --ga-axis-text: rgba(233, 236, 255, 0.78);
      --ga-accent: #7950E5;
      --ga-accent2: #00A2FE;
      --ga-good: #3AE8BD;
      --ga-warn: #FECD19;
      --ga-danger: #ff6b6b;
      --ga-link: #3AE8BD;
      --ga-overlay-bg: rgba(6, 6, 14, 0.72);
      --ga-focus-ring: color-mix(in srgb, #00A2FE 55%, transparent);
      --ga-graph-color: var(--ga-good);
    }
    .ga-topbar {
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:10px 14px;
      border-bottom:1px solid var(--ga-border);
      background: var(--ga-surface);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .ga-title { font-weight: 700; display:flex; align-items:center; gap:10px; }
    .ga-title-logo svg { display:block; filter: drop-shadow(0 0 14px rgba(0,162,254,0.28)); }
    .ga-topbar-actions { display:flex; align-items:center; gap:8px; }
    .ga-close, .ga-gear {
      background: var(--ga-control-bg);
      border:1px solid var(--ga-control-border);
      color:var(--ga-control-text);
      border-radius:10px;
      padding:6px 10px;
      cursor:pointer;
    }
    .ga-root button:focus-visible,
    .ga-root select:focus-visible,
    .ga-root input:focus-visible,
    .ga-root textarea:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px var(--ga-focus-ring);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-topbar {
      backdrop-filter: blur(12px);
      box-shadow: 0 10px 34px rgba(0,0,0,0.20);
    }
    .ga-body { padding: 8px 12px 16px; }

    .ga-filters-host {
      position: sticky;
      top: var(--ga-topbar-h);
      z-index: 9;
      background: var(--ga-bg);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-filters-host {
      background: linear-gradient(180deg, rgba(16, 16, 28, 0.68) 0%, rgba(16, 16, 28, 0.28) 100%);
      backdrop-filter: blur(14px);
    }
    .ga-filters {
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px 6px;
      flex-wrap:wrap;
    }
    .ga-filters-left { display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end; flex: 1 1 auto; min-width: 0; }
    .ga-filters-right { display:flex; gap:8px; flex-wrap:wrap; align-items:flex-end; }
    .ga-filter {
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:8px 10px;
      background: var(--ga-surface);
      border:1px solid var(--ga-border);
      border-radius:12px;
      min-width: 200px;
    }
    .ga-filter-label { font-size:12px; color: var(--ga-text-muted); }
    .ga-filter-row { display:flex; gap:8px; align-items:center; }
    .ga-filter select, .ga-filter input[type="date"] {
      background: var(--ga-control-bg);
      color: var(--ga-control-text);
      border:1px solid var(--ga-control-border);
      border-radius:8px;
      padding:6px 8px;
      font: inherit;
      font-size: 12px;
    }

    .ga-filter.ga-filter-map { min-width: 340px; }
    .ga-filter.ga-filter-map.ga-filter-map-wide { flex: 1 1 100%; width: 100%; min-width: 520px; }
    .ga-filter-map-selected {
      font-size: 12px;
      color: var(--ga-text-muted);
      margin-bottom: 2px;
    }
    .ga-filter-map-host { width: 340px; max-width: 100%; }
    .ga-filter.ga-filter-map.ga-filter-map-wide .ga-filter-map-host { width: 100%; }
    .ga-country-map {
      height: var(--ga-country-map-h, 240px);
      width: 100%;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid var(--ga-map-border);
      background: var(--ga-map-bg);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
    }
    /* Wide map: keep correct world aspect by default; cap via dashboard.json map.height (max-height). */
    .ga-filter.ga-filter-map.ga-filter-map-wide .ga-country-map {
      height: auto;
      aspect-ratio: 2 / 1;
      max-height: var(--ga-country-map-h, 720px);
      min-height: 320px;
    }
    .ga-country-map-wrap { width: 100%; height: 100%; display:flex; flex-direction:column; gap:6px; padding:8px; box-sizing:border-box; }
    .ga-country-map-toolbar { display:flex; gap:8px; align-items:center; }
    .ga-country-map-btn {
      width: 30px;
      height: 30px;
      border-radius: 10px;
      border: 1px solid var(--ga-map-toolbar-border);
      background: var(--ga-map-toolbar-bg);
      color: var(--ga-control-text);
      cursor: pointer;
      font-weight: 800;
      line-height: 1;
    }
    .ga-country-map-btn:hover { background: color-mix(in srgb, var(--ga-map-toolbar-bg) 78%, #000); }
    .ga-country-map-hint { font-size: 11px; color: var(--ga-map-hint); }
    .ga-country-map-svg { width: 100%; flex: 1; border-radius: 10px; overflow: hidden; touch-action: none; display:block; }
    .ga-country-shape {
      fill: var(--ga-map-fill);
      stroke: var(--ga-map-stroke);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
      cursor: grab;
      transition: fill 120ms ease, stroke 120ms ease;
    }
    .ga-country-shape.selectable { fill: var(--ga-map-selectable-fill); stroke: var(--ga-map-stroke); cursor: pointer; }
    .ga-country-shape.disabled { fill: var(--ga-map-disabled-fill); stroke: var(--ga-map-disabled-stroke); opacity: 0.45; pointer-events: none; }
    .ga-country-shape.selectable.hover { fill: var(--ga-map-selectable-hover); }
    .ga-country-shape.active {
      fill: var(--ga-map-active-fill);
      stroke: var(--ga-map-active-stroke);
      stroke-width: 2;
    }
    .ga-filter-map-error { font-size: 12px; color: rgba(255,143,143,0.95); }
    .ga-filter-btn {
      background: var(--ga-control-bg);
      border:1px solid var(--ga-control-border);
      color: var(--ga-control-text);
      border-radius:10px;
      padding:7px 10px;
      cursor:pointer;
      font-size:12px;
      height: 34px;
    }
    .ga-tabs {
      display:flex;
      gap:8px;
      padding:10px;
      position: sticky;
      top: calc(var(--ga-topbar-h) + var(--ga-filters-h));
      z-index: 8;
      background: var(--ga-bg);
    }
    .ga-tab {
      background:var(--ga-control-bg);
      color:var(--ga-control-text);
      border:1px solid var(--ga-control-border);
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer;
    }
    .ga-tab.active { background: var(--ga-surface-2); }
    .ga-content { padding:10px; }
    .ga-card {
      background: var(--ga-card);
      border:1px solid var(--ga-border);
      border-radius:14px;
      overflow:hidden;
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-card {
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 54px rgba(0,0,0,0.18);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-close,
    .ga-root[data-ga-theme="geoguessr"] .ga-gear,
    .ga-root[data-ga-theme="geoguessr"] .ga-filter-btn,
    .ga-root[data-ga-theme="geoguessr"] .ga-chart-actions button,
    .ga-root[data-ga-theme="geoguessr"] .ga-breakdown-toggle {
      background: linear-gradient(180deg, rgba(121, 80, 229, 0.38) 0%, rgba(86, 59, 154, 0.26) 100%);
      border-color: rgba(255,255,255,0.16);
      box-shadow: 0 10px 26px rgba(0,0,0,0.22);
      border-radius: 999px;
      padding: 7px 12px;
      font-weight: 650;
      letter-spacing: 0.15px;
      transition: transform 160ms ease, filter 160ms ease, box-shadow 160ms ease;
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-close:hover,
    .ga-root[data-ga-theme="geoguessr"] .ga-gear:hover,
    .ga-root[data-ga-theme="geoguessr"] .ga-filter-btn:hover,
    .ga-root[data-ga-theme="geoguessr"] .ga-chart-actions button:hover,
    .ga-root[data-ga-theme="geoguessr"] .ga-breakdown-toggle:hover {
      filter: brightness(1.06);
      box-shadow: 0 16px 38px rgba(0,0,0,0.28);
      transform: translateY(-1px);
    }

    /* GeoGuessr-like section tabs (top navigation vibe) */
    .ga-root[data-ga-theme="geoguessr"] .ga-tabs {
      padding: 6px 10px;
      gap: 12px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(16, 16, 28, 0.42) 0%, rgba(16, 16, 28, 0.18) 100%);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.05), 0 14px 34px rgba(0,0,0,0.20);
      backdrop-filter: blur(14px);
      overflow-x: auto;
      scrollbar-width: none;
      width: fit-content;
      max-width: 100%;
      margin: 4px 10px 0;
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-tabs::-webkit-scrollbar { display: none; }
    .ga-root[data-ga-theme="geoguessr"] .ga-tabs .ga-tab {
      background: transparent;
      border: 0;
      box-shadow: none;
      border-radius: 10px;
      padding: 8px 4px;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.9px;
      text-transform: uppercase;
      color: rgba(243,244,255,0.70);
      transition: color 160ms ease, background 160ms ease;
    }

    .ga-team-local-filters, .ga-country-local-filters {
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:flex-end;
      margin: 6px 0 10px;
    }
    .ga-team-local-filters .ga-filter, .ga-country-local-filters .ga-filter { min-width: 240px; }
    .ga-root[data-ga-theme="geoguessr"] .ga-tabs .ga-tab:hover {
      background: rgba(255,255,255,0.04);
      color: rgba(255,255,255,0.88);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-tabs .ga-tab.active {
      background: transparent;
      color: rgba(255,255,255,0.96);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-tabs .ga-tab.active::after {
      content: "";
      position: absolute;
      left: 6px;
      right: 6px;
      bottom: 2px;
      height: 2px;
      border-radius: 999px;
      background: rgba(254, 205, 25, 0.95);
      filter: drop-shadow(0 6px 14px rgba(0,0,0,0.32));
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-tabs .ga-tab { position: relative; }

    /* GeoGuessr-like drilldown styling */
    .ga-root[data-ga-theme="geoguessr"] .ga-drilldown-panel {
      border-radius: 18px;
      background:
        radial-gradient(900px 520px at 18% 0%, rgba(121, 80, 229, 0.22), transparent 58%),
        radial-gradient(900px 520px at 86% 0%, rgba(0, 162, 254, 0.16), transparent 60%),
        color-mix(in srgb, var(--ga-surface) 88%, transparent);
      border-color: rgba(255,255,255,0.14);
      box-shadow: 0 28px 90px rgba(0,0,0,0.48);
      overflow: auto;
      overscroll-behavior: contain;
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-drilldown-header {
      background: linear-gradient(180deg, rgba(22,22,38,0.82) 0%, rgba(22,22,38,0.58) 100%);
      border-bottom-color: rgba(255,255,255,0.10);
      backdrop-filter: blur(14px);
      padding: 12px 14px;
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-drilldown-title {
      font-size: 13px;
      font-weight: 750;
      letter-spacing: 0.3px;
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-drilldown-close {
      border-radius: 999px;
      width: 34px;
      height: 34px;
      background: rgba(16, 16, 28, 0.45);
      border-color: rgba(255,255,255,0.16);
      box-shadow: 0 10px 24px rgba(0,0,0,0.32);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-drilldown-close:hover {
      filter: brightness(1.06);
      transform: translateY(-1px);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-drilldown-table thead th {
      background: rgba(16,16,28,0.42);
      border-bottom-color: rgba(255,255,255,0.10);
      color: rgba(243,244,255,0.72);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-drilldown-table th,
    .ga-root[data-ga-theme="geoguessr"] .ga-drilldown-table td {
      border-bottom-color: rgba(255,255,255,0.08);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-dd-tr:hover td {
      background: rgba(121, 80, 229, 0.10);
    }
    .ga-root[data-ga-theme="geoguessr"] .ga-dd-th.ga-dd-sortable:hover {
      background: rgba(58, 232, 189, 0.08);
    }
    .ga-card-header { padding:10px 12px; border-bottom:1px solid var(--ga-border); font-weight:650; }
    .ga-card-body { padding:12px; }
    .ga-card-inner, .ga-child, .ga-widget { min-width: 0; width: 100%; }
    .ga-widget-title { font-size:12px; color: var(--ga-text-muted); margin-bottom:6px; }
    .ga-statlist-box {
      background: var(--ga-card-2);
      border:1px solid var(--ga-border);
      border-radius:12px;
      padding:10px;
    }
    .ga-recordlist-box {
      background: var(--ga-card-2);
      border:1px solid var(--ga-border);
      border-radius:12px;
      padding:10px;
    }
    .ga-statrow {
      display:flex;
      justify-content:space-between;
      padding:6px 2px;
      border-bottom:1px dashed color-mix(in srgb, var(--ga-text) 12%, transparent);
    }
    .ga-statrow:last-child { border-bottom:none; }
    .ga-chart-box {
      background: var(--ga-card-2);
      border:1px solid var(--ga-border);
      border-radius:12px;
      padding:10px;
      color: var(--ga-text);
      width: 100%;
      overflow: hidden;
    }
    .ga-chart-controls { display:flex; gap:8px; align-items:center; margin-bottom:8px; justify-content:space-between; flex-wrap:wrap; }
    .ga-chart-controls-left { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .ga-chart-actions { display:flex; gap:8px; align-items:center; }
    .ga-chart-actions button {
      background: var(--ga-control-bg);
      border:1px solid var(--ga-control-border);
      color: var(--ga-control-text);
      border-radius:8px;
      padding:4px 8px;
      cursor:pointer;
      font-size:12px;
    }
    .ga-chart-host { width:100%; }
    .ga-chart-svg { width:100%; max-width:100%; display:block; overflow: visible; }
    .ga-chart-bar { transform-box: view-box; }
    .ga-chart-svg[data-anim-state="pending"] .ga-chart-bar {
      transform: scaleY(0);
      opacity: 0.25;
    }
    .ga-chart-svg[data-anim-state="pending"] .ga-chart-line-path {
      stroke-dashoffset: var(--ga-line-length);
      opacity: 0.65;
    }
    .ga-chart-svg[data-anim-state="pending"] .ga-chart-line-dot {
      transform: scale(0);
      opacity: 0;
      transform-box: fill-box;
      transform-origin: center;
    }
    .ga-root[data-ga-chart-animations="off"] .ga-chart-svg .ga-chart-bar {
      transform: none !important;
      opacity: 0.72 !important;
      animation: none !important;
    }
    .ga-root[data-ga-chart-animations="off"] .ga-chart-svg .ga-chart-line-path {
      stroke-dasharray: none !important;
      stroke-dashoffset: 0 !important;
      animation: none !important;
      opacity: 0.9 !important;
    }
    .ga-root[data-ga-chart-animations="off"] .ga-chart-svg .ga-chart-line-dot {
      transform: none !important;
      animation: none !important;
      opacity: 0.95 !important;
    }
    @keyframes ga-bar-rise {
      from { transform: scaleY(0); opacity: 0.25; }
      to { transform: scaleY(1); opacity: 0.72; }
    }
    @keyframes ga-line-draw {
      from { stroke-dashoffset: var(--ga-line-length); opacity: 0.65; }
      to { stroke-dashoffset: 0; opacity: 0.9; }
    }
    @keyframes ga-dot-in {
      from { transform: scale(0); opacity: 0; }
      to { transform: scale(1); opacity: 0.95; }
    }
    .ga-chart-svg[data-anim-state="run"] .ga-chart-bar {
      animation: ga-bar-rise 420ms ease-out both;
    }
    .ga-chart-svg[data-anim-state="run"] .ga-chart-line-path {
      animation: ga-line-draw 520ms ease-out both;
    }
    .ga-chart-svg[data-anim-state="run"] .ga-chart-line-dot {
      animation: ga-dot-in 220ms ease-out both;
      animation-delay: calc(min(var(--ga-dot-index, 0) * 60ms, 520ms));
    }
    .ga-breakdown-box {
      display:flex;
      flex-direction:column;
      gap:8px;
      background: var(--ga-card-2);
      border:1px solid var(--ga-border);
      border-radius:12px;
      padding:10px;
    }
    .ga-breakdown-header {
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-end;
      margin: 2px 0 8px 0;
      font-size: 11px;
      letter-spacing: 0.15px;
      color: color-mix(in srgb, var(--ga-text) 78%, transparent);
    }
    .ga-breakdown-header-left {
      flex: 0 0 var(--ga-breakdown-label-w);
      max-width: var(--ga-breakdown-label-w);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      font-weight: 650;
    }
    .ga-breakdown-header-right { flex:1; text-align:right; font-weight: 650; }
    .ga-breakdown-controls { display:flex; justify-content:flex-end; gap:8px; align-items:center; flex-wrap:wrap; }
    .ga-breakdown-ctl-label { opacity: 0.9; font-weight: 650; }
    .ga-breakdown-ctl-select {
      background: var(--ga-control-bg);
      color: var(--ga-control-text);
      border:1px solid var(--ga-control-border);
      border-radius:8px;
      padding:3px 8px;
      font-size:12px;
      max-width: min(360px, 62vw);
    }
    .ga-breakdown { --ga-breakdown-label-w: clamp(120px, 20%, 260px); }
    .ga-breakdown-row { display:flex; gap:8px; align-items:center; justify-content:flex-start; }
    .ga-breakdown-label {
      flex: 0 0 var(--ga-breakdown-label-w);
      max-width: var(--ga-breakdown-label-w);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .ga-breakdown-right { flex:1; min-width:0; display:flex; align-items:center; gap:10px; }
    .ga-breakdown-value { min-width:72px; text-align:right; font-variant-numeric: tabular-nums; }
    .ga-breakdown-barwrap { flex:1; height:8px; background: color-mix(in srgb, var(--ga-text) 14%, transparent); border-radius:999px; overflow:hidden; }
    .ga-breakdown-bar { height:100%; background: var(--ga-graph-color); border-radius:999px; }
    .ga-breakdown-footer { display:flex; justify-content:flex-end; margin-top: 10px; }
    .ga-breakdown-toggle {
      background: var(--ga-control-bg);
      border:1px solid var(--ga-control-border);
      color: var(--ga-control-text);
      border-radius:8px;
      padding:4px 8px;
      cursor:pointer;
      font-size:12px;
    }
    .ga-breakdown-toggle:hover { filter: brightness(1.02); }
    .ga-drilldown-modal, .ga-settings-modal { position:fixed; inset:0; z-index:9999999; }
    .ga-drilldown-bg, .ga-settings-bg { position:absolute; inset:0; background: var(--ga-overlay-bg); }
    .ga-drilldown-panel {
      position:absolute;
      top:6%;
      left:50%;
      transform:translateX(-50%);
      width:min(1100px, 92vw);
      max-height:88vh;
      overflow:auto;
      background:var(--ga-surface);
      border:1px solid var(--ga-border);
      border-radius:14px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      color: var(--ga-text);
    }
    .ga-drilldown-header {
      position: sticky;
      top: 0;
      z-index: 5;
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid var(--ga-border);
      background: var(--ga-surface);
      backdrop-filter: blur(8px);
    }
    .ga-drilldown-title {
      font-size: 13px;
      font-weight: 650;
      letter-spacing: 0.2px;
    }
    .ga-drilldown-close {
      background: var(--ga-control-bg);
      border:1px solid var(--ga-control-border);
      color: var(--ga-control-text);
      border-radius:10px;
      width: 30px;
      height: 30px;
      padding:0;
      cursor:pointer;
    }
    .ga-drilldown-table { width:100%; border-collapse:separate; border-spacing:0; font-size:12px; }
    .ga-drilldown-table th, .ga-drilldown-table td {
      padding:8px 10px;
      border-bottom:1px solid color-mix(in srgb, var(--ga-text) 10%, transparent);
      text-align:left;
    }
    .ga-drilldown-table td { color: var(--ga-text); }
    .ga-drilldown-table thead th {
      position: sticky;
      top: 52px;
      z-index: 4;
      background: color-mix(in srgb, var(--ga-surface) 92%, transparent);
      border-bottom: 1px solid color-mix(in srgb, var(--ga-text) 14%, transparent);
      font-weight: 600;
      color: color-mix(in srgb, var(--ga-text) 85%, transparent);
    }
    .ga-dd-th.ga-dd-sortable { cursor: pointer; user-select: none; }
    .ga-dd-th.ga-dd-sortable:hover { background: color-mix(in srgb, var(--ga-text) 6%, transparent); }
    .ga-dd-tr:hover td { background: color-mix(in srgb, var(--ga-text) 5%, transparent); }
    .ga-dd-tr.ga-dd-no-sep td { border-bottom-color: transparent; }
    .ga-dd-link {
      color: var(--ga-link);
      text-decoration: underline;
      text-underline-offset: 2px;
    }
    .ga-dd-pos { color: var(--ga-good); font-variant-numeric: tabular-nums; }
    .ga-dd-neg { color: var(--ga-danger); font-variant-numeric: tabular-nums; }
    .ga-settings-panel {
      position:absolute;
      top:6%;
      left:50%;
      transform:translateX(-50%);
      width:min(1260px, 96vw);
      max-height:90vh;
      overflow:auto;
      background: var(--ga-surface);
      border:1px solid var(--ga-border);
      border-radius:14px;
      box-shadow: 0 28px 90px rgba(0,0,0,0.55);
    }
    .ga-settings-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid var(--ga-border);
    }
    .ga-settings-body { padding: 14px; }
    .ga-settings-tabs { display:flex; gap:8px; margin-bottom:12px; }
    .ga-settings-tab {
      background: var(--ga-control-bg);
      color: var(--ga-control-text);
      border:1px solid var(--ga-control-border);
      border-radius:8px;
      padding:6px 10px;
      cursor:pointer;
    }
    .ga-settings-tab.active { background: var(--ga-surface-2); }
    .ga-settings-pane { display:none; }
    .ga-settings-pane.active { display:block; }
    .ga-settings-grid { display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    .ga-settings-field { display:flex; flex-direction:column; gap:6px; }
    .ga-settings-field label { font-size:12px; color: var(--ga-text-muted); }
    .ga-settings-field input, .ga-settings-field select, .ga-settings-field textarea {
      background: var(--ga-control-bg);
      color: var(--ga-control-text);
      border:1px solid var(--ga-control-border);
      border-radius:8px;
      padding:8px;
      font: inherit;
    }
    .ga-settings-field textarea {
      min-height: 340px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre;
    }
    .ga-settings-note { font-size:12px; color: var(--ga-text-muted); }
    .ga-settings-status { margin-top: 8px; font-size:12px; }
    .ga-settings-status.error { color: #ff8f8f; }
    .ga-settings-status.ok { color: #8fe3a1; }
    .ga-settings-actions { display:flex; gap:8px; margin-top: 8px; flex-wrap:wrap; }

    /* Layout editor (Settings -> Layout) */
    .ga-layout-editor-wrap { display:flex; flex-direction:column; gap:10px; }
    .ga-le-head { display:flex; justify-content:space-between; align-items:flex-start; gap:12px; flex-wrap:wrap; }
    .ga-le-head-actions { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .ga-le-toggle { display:flex; align-items:center; gap:8px; font-size:12px; color: var(--ga-text-muted); user-select:none; }
    .ga-le-toggle input { width: 16px; height: 16px; }
    .ga-le-head {
      position: sticky;
      top: 0;
      z-index: 5;
      padding: 10px 0;
      background: color-mix(in srgb, var(--ga-surface) 92%, transparent);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid color-mix(in srgb, var(--ga-border) 70%, transparent);
    }
    .ga-layout-editor { display:block; padding-top: 10px; }
    .ga-le-left, .ga-le-right { min-width: 0; }
    .ga-le-left-head { display:flex; gap:8px; margin-bottom:10px; }
    .ga-le-list { display:flex; flex-direction:column; gap:6px; }
    .ga-le-list-item {
      background: var(--ga-control-bg);
      border: 1px solid var(--ga-control-border);
      color: var(--ga-control-text);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      text-align: left;
      font-weight: 650;
      opacity: 0.9;
    }
    .ga-le-list-item.active { background: var(--ga-surface-2); opacity: 1; }
    .ga-le-toprow { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:10px; }
    .ga-le-btn {
      background: var(--ga-control-bg);
      border: 1px solid var(--ga-control-border);
      color: var(--ga-control-text);
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 12px;
      height: 32px;
    }
    .ga-le-btn-icon {
      width: 32px;
      min-width: 32px;
      padding: 0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size: 13px;
      line-height: 1;
    }
    .ga-le-btn-primary { border-color: color-mix(in srgb, var(--ga-accent2) 55%, var(--ga-control-border)); }
    .ga-le-btn-danger { border-color: color-mix(in srgb, var(--ga-danger) 60%, var(--ga-control-border)); }
    .ga-le-field { display:flex; flex-direction:column; gap:6px; margin-bottom:10px; }
    .ga-le-field label { font-size:12px; color: var(--ga-text-muted); }
    .ga-le-inputhost { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .ga-le-field input, .ga-le-field select, .ga-le-inline-select {
      background: var(--ga-control-bg);
      color: var(--ga-control-text);
      border:1px solid var(--ga-control-border);
      border-radius:8px;
      padding:7px 8px;
      font: inherit;
      font-size: 12px;
      min-width: 220px;
    }
    .ga-le-field textarea {
      background: var(--ga-control-bg);
      color: var(--ga-control-text);
      border:1px solid var(--ga-control-border);
      border-radius:8px;
      padding:8px;
      font: inherit;
      font-size: 12px;
      min-height: 200px;
      resize: vertical;
      width: 100%;
      box-sizing: border-box;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      white-space: pre;
      line-height: 1.35;
    }
    .ga-le-field select[multiple] { min-width: 260px; padding: 6px; }
    .ga-le-hr { border:0; height:1px; background: var(--ga-border); margin: 12px 0; opacity: 0.9; }
    .ga-le-box { background: var(--ga-card-2); border:1px solid var(--ga-border); border-radius:12px; padding:10px; margin-bottom:10px; }
    .ga-le-box-head { font-weight: 750; font-size: 12px; color: var(--ga-text); margin-bottom: 8px; }
    .ga-le-item { background: color-mix(in srgb, var(--ga-card) 65%, transparent); border:1px solid var(--ga-border); border-radius:12px; padding:10px; margin-top:10px; }
    .ga-le-compact-row {
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      background: color-mix(in srgb, var(--ga-card) 65%, transparent);
      border:1px solid var(--ga-border);
      border-radius:12px;
      padding:8px 10px;
      margin-top:8px;
    }
    .ga-le-compact-row.dragover { outline: 2px solid color-mix(in srgb, var(--ga-accent2) 55%, transparent); }
    .ga-le-drag {
      width: 18px;
      min-width: 18px;
      opacity: 0.8;
      cursor: grab;
      user-select:none;
      text-align:center;
      font-weight: 900;
      letter-spacing: -1px;
    }
    .ga-le-compact-title { font-weight: 750; font-size: 12px; color: var(--ga-text); flex: 1 1 auto; min-width: 0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .ga-le-compact-meta { font-size: 11px; color: var(--ga-text-muted); opacity: 0.9; flex: 0 0 auto; }
    .ga-le-compact-actions { display:flex; gap:8px; align-items:center; flex: 0 0 auto; }
    .ga-le-compact-row-col { justify-content:flex-start; }
    .ga-le-col-key { min-width: 160px; width: 160px; }
    .ga-le-col-label { min-width: 220px; width: min(420px, 42vw); }
    .ga-le-compact-chk { display:flex; align-items:center; gap:6px; font-size:11px; color: var(--ga-text-muted); user-select:none; }
    .ga-le-compact-chk input { width: 14px; height: 14px; }
    .ga-le-grid4 { display:grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap:10px; }
    @media (max-width: 820px) { .ga-le-grid4 { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    .ga-le-subbox { background: color-mix(in srgb, var(--ga-card) 55%, transparent); border:1px solid var(--ga-border); border-radius:12px; padding:10px; margin-top:10px; }
    .ga-le-subhead { font-weight: 700; font-size: 12px; color: var(--ga-text-muted); margin-bottom: 8px; }
    .ga-le-widget { background: color-mix(in srgb, var(--ga-card-2) 65%, transparent); border:1px dashed var(--ga-border); border-radius:12px; padding:10px; margin-top:10px; }
    .ga-le-details { border:1px solid var(--ga-border); border-radius:12px; padding:0; margin-top:10px; background: color-mix(in srgb, var(--ga-card-2) 60%, transparent); }
    .ga-le-details > summary {
      cursor:pointer;
      padding:10px 12px;
      font-weight: 750;
      font-size: 12px;
      color: var(--ga-text);
      user-select:none;
      list-style: none;
    }
    .ga-le-details[open] > summary { border-bottom: 1px solid var(--ga-border); }
    .ga-le-details > summary::-webkit-details-marker { display:none; }
    .ga-le-details > .ga-le-item { margin-top: 0; border: 0; border-top-left-radius: 0; border-top-right-radius: 0; background: transparent; }
    .ga-le-adv { margin-top: 10px; }
    .ga-le-adv > summary { cursor:pointer; user-select:none; font-weight: 700; font-size:12px; color: var(--ga-text-muted); list-style:none; }
    .ga-le-adv > summary::-webkit-details-marker { display:none; }
    .ga-le-panels { display:flex; flex-direction:column; gap:12px; }
    .ga-le-inline-input {
      background: var(--ga-control-bg);
      color: var(--ga-control-text);
      border:1px solid var(--ga-control-border);
      border-radius:8px;
      padding:7px 8px;
      font: inherit;
      font-size: 12px;
      min-width: 220px;
      height: 32px;
    }

    /* Section editor modal */
    .ga-le-modal { position: fixed; inset: 0; z-index: 99999999; }
    .ga-le-modal-bg { position:absolute; inset:0; background: var(--ga-overlay-bg); }
    .ga-le-modal-panel {
      position:absolute;
      top: 6%;
      left: 50%;
      transform: translateX(-50%);
      width: min(1200px, 96vw);
      max-height: 88vh;
      overflow: auto;
      background: var(--ga-surface);
      border: 1px solid var(--ga-border);
      border-radius: 14px;
      box-shadow: 0 28px 90px rgba(0,0,0,0.55);
      color: var(--ga-text);
    }
    .ga-le-modal-header {
      position: sticky;
      top: 0;
      z-index: 5;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--ga-border);
      background: color-mix(in srgb, var(--ga-surface) 92%, transparent);
      backdrop-filter: blur(10px);
    }
    .ga-le-modal-title { font-size: 13px; font-weight: 700; letter-spacing: 0.2px; }
    .ga-le-modal-body { padding: 12px; }
    .ga-le-cards-layout { display:grid; grid-template-columns: minmax(220px, 320px) 1fr; gap:12px; align-items:start; }
    @media (max-width: 980px) { .ga-le-cards-layout { grid-template-columns: 1fr; } }
    .ga-le-outline {
      position: sticky;
      top: 86px;
      background: color-mix(in srgb, var(--ga-card) 55%, transparent);
      border:1px solid var(--ga-border);
      border-radius:12px;
      padding:10px;
    }
    .ga-le-outline-head { font-weight: 800; font-size: 12px; color: var(--ga-text); margin-bottom: 6px; }
    .ga-le-outline-search {
      width: 100%;
      min-width: 0;
      box-sizing: border-box;
      background: var(--ga-control-bg);
      color: var(--ga-control-text);
      border:1px solid var(--ga-control-border);
      border-radius:8px;
      padding:7px 8px;
      font: inherit;
      font-size: 12px;
      margin-top: 6px;
    }
    .ga-le-outline-list { display:flex; flex-direction:column; gap:6px; margin-top:10px; max-height: 62vh; overflow:auto; padding-right: 4px; }
    .ga-le-outline-item {
      background: var(--ga-control-bg);
      border: 1px solid var(--ga-control-border);
      color: var(--ga-control-text);
      border-radius: 10px;
      padding: 7px 10px;
      cursor: pointer;
      text-align: left;
      font-weight: 650;
      opacity: 0.95;
      font-size: 12px;
    }
    .ga-le-outline-item:hover { filter: brightness(1.03); }
    .ga-le-outline-item.active { background: var(--ga-surface-2); border-color: color-mix(in srgb, var(--ga-accent2) 55%, var(--ga-control-border)); }
    .ga-le-outline-item-widget { padding-left: 18px; font-weight: 600; opacity: 0.9; }
    .ga-le-flash { outline: 2px solid color-mix(in srgb, var(--ga-accent2) 70%, transparent); outline-offset: 2px; }
  `;
    doc.head.appendChild(style);
  }

  // src/ui/settingsStore.ts
  var SETTINGS_KEY = "geoanalyzr:semantic:settings:v1";
  var THEME_KEY = "geoanalyzr.theme";
  var DASHBOARD_TEMPLATE_KEY = "geoanalyzr:semantic:dashboard-template:v1";
  var DEFAULT_SETTINGS = {
    appearance: {
      theme: "geoguessr",
      graphColor: "#7eb6ff",
      chartAnimations: true
    },
    standards: {
      dateFormat: "dd/mm/yyyy",
      sessionGapMinutes: 45,
      countryFormat: "iso2"
    }
  };
  function cloneTemplate(value) {
    if (typeof structuredClone === "function") return structuredClone(value);
    return JSON.parse(JSON.stringify(value));
  }
  function normalizeColor(value, fallback) {
    if (typeof value !== "string") return fallback;
    const trimmed = value.trim();
    if (/^#[0-9a-fA-F]{6}$/.test(trimmed)) return trimmed;
    return fallback;
  }
  function normalizeTheme(value) {
    if (value === "geoguessr") return value;
    if (value === "light" || value === "dark") return value;
    return "geoguessr";
  }
  function normalizeBool(value, fallback) {
    if (typeof value === "boolean") return value;
    return fallback;
  }
  function normalizeDateFormat(value) {
    return value === "mm/dd/yyyy" || value === "yyyy-mm-dd" || value === "locale" ? value : "dd/mm/yyyy";
  }
  function normalizeCountryFormat(value) {
    return value === "english" ? "english" : "iso2";
  }
  function normalizeSettings(raw) {
    const r = typeof raw === "object" && raw ? raw : {};
    const appearance = typeof r.appearance === "object" && r.appearance ? r.appearance : {};
    const standards = typeof r.standards === "object" && r.standards ? r.standards : {};
    const sessionGapRaw = Number(standards.sessionGapMinutes);
    return {
      appearance: {
        theme: normalizeTheme(appearance.theme),
        graphColor: normalizeColor(appearance.graphColor, DEFAULT_SETTINGS.appearance.graphColor),
        chartAnimations: normalizeBool(appearance.chartAnimations, DEFAULT_SETTINGS.appearance.chartAnimations)
      },
      standards: {
        dateFormat: normalizeDateFormat(standards.dateFormat),
        sessionGapMinutes: Number.isFinite(sessionGapRaw) ? Math.max(1, Math.min(360, Math.round(sessionGapRaw))) : DEFAULT_SETTINGS.standards.sessionGapMinutes,
        countryFormat: normalizeCountryFormat(standards.countryFormat)
      }
    };
  }
  function getStorage(doc) {
    try {
      return doc.defaultView?.localStorage ?? null;
    } catch {
      return null;
    }
  }
  function getSystemPreferredTheme(doc) {
    try {
      const w = doc.defaultView;
      if (!w || typeof w.matchMedia !== "function") return DEFAULT_SETTINGS.appearance.theme;
      if (w.matchMedia("(prefers-color-scheme: light)").matches) return "light";
      return "geoguessr";
    } catch {
      return DEFAULT_SETTINGS.appearance.theme;
    }
  }
  function loadSettings(doc) {
    const storage = getStorage(doc);
    if (!storage) {
      const s = cloneTemplate(DEFAULT_SETTINGS);
      s.appearance.theme = getSystemPreferredTheme(doc);
      return s;
    }
    try {
      const themeOverrideRaw = storage.getItem(THEME_KEY);
      const raw = storage.getItem(SETTINGS_KEY);
      if (!raw) {
        const s2 = cloneTemplate(DEFAULT_SETTINGS);
        s2.appearance.theme = themeOverrideRaw ? normalizeTheme(themeOverrideRaw) : getSystemPreferredTheme(doc);
        return s2;
      }
      const s = normalizeSettings(JSON.parse(raw));
      if (themeOverrideRaw) s.appearance.theme = normalizeTheme(themeOverrideRaw);
      return s;
    } catch {
      const s = cloneTemplate(DEFAULT_SETTINGS);
      s.appearance.theme = getSystemPreferredTheme(doc);
      return s;
    }
  }
  function saveSettings(doc, settings) {
    const storage = getStorage(doc);
    if (!storage) return;
    try {
      storage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      storage.setItem(THEME_KEY, settings.appearance.theme);
    } catch {
    }
  }
  function loadDashboardTemplate(doc, fallback) {
    const storage = getStorage(doc);
    if (!storage) return cloneTemplate(fallback);
    try {
      const raw = storage.getItem(DASHBOARD_TEMPLATE_KEY);
      if (!raw) return cloneTemplate(fallback);
      const parsed = JSON.parse(raw);
      const merged = {
        ...cloneTemplate(fallback),
        ...parsed,
        dashboard: {
          ...cloneTemplate(fallback).dashboard,
          ...parsed.dashboard,
          globalFilters: parsed.dashboard?.globalFilters ?? cloneTemplate(fallback).dashboard.globalFilters,
          sections: Array.isArray(parsed.dashboard?.sections) ? parsed.dashboard.sections : cloneTemplate(fallback).dashboard.sections
        }
      };
      return merged;
    } catch {
      return cloneTemplate(fallback);
    }
  }
  function saveDashboardTemplate(doc, dashboard) {
    const storage = getStorage(doc);
    if (!storage) return;
    try {
      storage.setItem(DASHBOARD_TEMPLATE_KEY, JSON.stringify(dashboard, null, 2));
    } catch {
    }
  }
  function applySettingsToRoot(root, settings) {
    root.dataset.gaTheme = settings.appearance.theme;
    root.dataset.gaChartAnimations = settings.appearance.chartAnimations ? "on" : "off";
    root.dataset.gaDateFormat = settings.standards.dateFormat;
    root.dataset.gaSessionGapMinutes = String(settings.standards.sessionGapMinutes);
    root.dataset.gaCountryFormat = settings.standards.countryFormat;
    root.style.setProperty("--ga-graph-color", settings.appearance.theme === "geoguessr" ? "#FECD19" : settings.appearance.graphColor);
  }

  // src/engine/semanticMerge.ts
  function cloneJson(value) {
    if (typeof structuredClone === "function") return structuredClone(value);
    return JSON.parse(JSON.stringify(value));
  }
  function getDrilldownPresetsOverrideFromDashboard(dashboard) {
    const raw = dashboard?.dashboard?.drilldownPresets;
    if (!raw || typeof raw !== "object") return {};
    return raw;
  }
  function mergeSemanticWithDashboard(base, dashboard) {
    const override = getDrilldownPresetsOverrideFromDashboard(dashboard);
    const hasOverride = override && Object.keys(override).length > 0;
    if (!hasOverride) return base;
    const next = { ...base, drilldownPresets: { ...base.drilldownPresets } };
    for (const [target, o] of Object.entries(override)) {
      const baseTarget = next.drilldownPresets?.[target] ?? {};
      const baseCols = { ...baseTarget.columnsPresets ?? {} };
      const oCols = o?.columnsPresets && typeof o.columnsPresets === "object" ? o.columnsPresets : {};
      const mergedCols = { ...baseCols, ...cloneJson(oCols) };
      next.drilldownPresets[target] = {
        ...baseTarget,
        ...o?.defaultPreset ? { defaultPreset: o.defaultPreset } : {},
        columnsPresets: mergedCols
      };
    }
    return next;
  }

  // src/ui/layoutEditor.ts
  function cloneJson2(value) {
    if (typeof structuredClone === "function") return structuredClone(value);
    return JSON.parse(JSON.stringify(value));
  }
  function safePrompt(doc, message, value) {
    try {
      const w = doc.defaultView;
      const out = typeof w?.prompt === "function" ? w.prompt(message, value ?? "") : null;
      return typeof out === "string" ? out : null;
    } catch {
      return null;
    }
  }
  function asInt(value, fallback) {
    const n = typeof value === "number" ? value : typeof value === "string" ? Number(value) : NaN;
    return Number.isFinite(n) ? Math.round(n) : fallback;
  }
  function mkBtn(doc, label, onClick, kind = "ghost") {
    const b = doc.createElement("button");
    b.type = "button";
    b.className = `ga-le-btn ga-le-btn-${kind}`;
    b.textContent = label;
    b.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      ev.stopImmediatePropagation?.();
      onClick();
    });
    return b;
  }
  function mkIconBtn(doc, label, onClick, kind = "ghost") {
    const b = mkBtn(doc, label, onClick, kind);
    b.classList.add("ga-le-btn-icon");
    b.setAttribute("aria-label", label);
    return b;
  }
  function mkField(doc, label) {
    const wrap = doc.createElement("div");
    wrap.className = "ga-le-field";
    const l = doc.createElement("label");
    l.textContent = label;
    wrap.appendChild(l);
    const inputHost = doc.createElement("div");
    inputHost.className = "ga-le-inputhost";
    wrap.appendChild(inputHost);
    return { wrap, inputHost };
  }
  function mkTextInput(doc, label, value, onChange) {
    const f = mkField(doc, label);
    const input = doc.createElement("input");
    input.type = "text";
    input.value = value ?? "";
    input.addEventListener("change", () => onChange(input.value));
    f.inputHost.appendChild(input);
    return f.wrap;
  }
  function mkNumberInput(doc, label, value, onChange, opts) {
    const f = mkField(doc, label);
    const input = doc.createElement("input");
    input.type = "number";
    if (opts?.min !== void 0) input.min = String(opts.min);
    if (opts?.max !== void 0) input.max = String(opts.max);
    input.step = String(opts?.step ?? 1);
    input.value = String(value);
    input.addEventListener("change", () => onChange(asInt(input.value, value)));
    f.inputHost.appendChild(input);
    return f.wrap;
  }
  function mkSelect(doc, label, value, options, onChange) {
    const f = mkField(doc, label);
    const sel = doc.createElement("select");
    for (const o of options) sel.appendChild(new Option(o.label, o.value));
    if (options.some((o) => o.value === value)) sel.value = value;
    sel.addEventListener("change", () => onChange(sel.value));
    f.inputHost.appendChild(sel);
    return f.wrap;
  }
  function mkMultiSelect(doc, label, values, options, onChange) {
    const f = mkField(doc, label);
    const sel = doc.createElement("select");
    sel.multiple = true;
    sel.size = Math.min(10, Math.max(3, options.length));
    for (const o of options) {
      const opt = new Option(o.label, o.value);
      opt.selected = values.includes(o.value);
      sel.appendChild(opt);
    }
    sel.addEventListener("change", () => onChange(Array.from(sel.selectedOptions).map((o) => o.value)));
    f.inputHost.appendChild(sel);
    return f.wrap;
  }
  function mkToggle(doc, label, checked, onChange) {
    const f = mkField(doc, label);
    const input = doc.createElement("input");
    input.type = "checkbox";
    input.checked = checked;
    input.addEventListener("change", () => onChange(input.checked));
    f.inputHost.appendChild(input);
    return f.wrap;
  }
  function mkHr(doc) {
    const hr = doc.createElement("hr");
    hr.className = "ga-le-hr";
    return hr;
  }
  function allowedGrains(semantic) {
    return Object.keys(semantic.datasets ?? {});
  }
  function allowedMeasureOptions(semantic, grain) {
    const keys2 = Object.keys(semantic.measures ?? {});
    const out = [];
    for (const id of keys2) {
      const m = semantic.measures[id];
      if (m?.grain === grain) out.push({ value: id, label: `${id}${m?.label ? ` \u2014 ${m.label}` : ""}` });
    }
    out.sort((a, b) => a.value.localeCompare(b.value));
    return out;
  }
  function allowedDimensionOptions(semantic, grain) {
    const keys2 = Object.keys(semantic.dimensions ?? {});
    const out = [];
    for (const id of keys2) {
      const d = semantic.dimensions[id];
      const grains = Array.isArray(d?.grain) ? d.grain : [d?.grain];
      if (grains.includes(grain)) out.push({ value: id, label: `${id}${d?.label ? ` \u2014 ${d.label}` : ""}` });
    }
    out.sort((a, b) => a.value.localeCompare(b.value));
    return out;
  }
  function renderLayoutEditor(args) {
    const { doc, semantic, onChange, statusEl } = args;
    const mode = args.mode ?? "section_layout";
    const win = doc.defaultView ?? window;
    const safeConfirm = (msg) => {
      try {
        return typeof win.confirm === "function" ? win.confirm(msg) : true;
      } catch {
        return true;
      }
    };
    const wrap = doc.createElement("div");
    wrap.className = "ga-layout-editor-wrap";
    const head = doc.createElement("div");
    head.className = "ga-le-head";
    const help = doc.createElement("div");
    help.className = "ga-settings-note";
    help.textContent = "Build your dashboard here (sections, cards, widgets, global filters). Tip: text fields apply on blur (click outside). Use Focus mode + the Outline to jump between cards/widgets without drowning in nested panels. Advanced JSON is optional - use it for drilldowns and other power features.";
    const headActions = doc.createElement("div");
    headActions.className = "ga-le-head-actions";
    const autoWrap = doc.createElement("label");
    autoWrap.className = "ga-le-toggle";
    const auto = doc.createElement("input");
    auto.type = "checkbox";
    const autoTxt = doc.createElement("span");
    autoTxt.textContent = "Auto-apply";
    autoWrap.appendChild(auto);
    autoWrap.appendChild(autoTxt);
    const applyBtn = mkBtn(doc, "Apply changes", () => applyNow(), "primary");
    const revertBtn = mkBtn(doc, "Revert", () => revertNow(), "ghost");
    headActions.appendChild(autoWrap);
    headActions.appendChild(applyBtn);
    headActions.appendChild(revertBtn);
    head.appendChild(help);
    head.appendChild(headActions);
    wrap.appendChild(head);
    const root = doc.createElement("div");
    root.className = "ga-layout-editor";
    wrap.appendChild(root);
    let applied = cloneJson2(args.dashboard);
    let draft = cloneJson2(args.dashboard);
    let dirty = false;
    let autoApply = false;
    let editSectionIdx = null;
    let newPresetIdByTarget = {};
    let active = { kind: "section", idx: 0 };
    let lastSectionIdx = 0;
    let focusMode = true;
    let focusCardIdx = 0;
    let focusWidgetIdx = 0;
    let scrollToId = null;
    let editGlobalFilters = false;
    let editGlobalFilterIdx = null;
    let editDrilldownTarget = null;
    let editDrilldownPreset = null;
    const grains = allowedGrains(semantic);
    const grainDefault = grains[0] ?? "round";
    const grainOpts = grains.map((g) => ({ value: g, label: g }));
    const setStatus = (kind, message) => {
      statusEl.textContent = message;
      statusEl.className = "ga-settings-status";
      if (kind === "ok") statusEl.classList.add("ok");
      if (kind === "error") statusEl.classList.add("error");
    };
    const validateDraft = () => {
      try {
        validateDashboardAgainstSemantic(mergeSemanticWithDashboard(semantic, draft), draft);
        return { ok: true };
      } catch (e) {
        return { ok: false, error: e instanceof Error ? e.message : String(e) };
      }
    };
    const syncActions = () => {
      applyBtn.disabled = !dirty;
      revertBtn.disabled = false;
    };
    const applyNow = () => {
      const res = validateDraft();
      if (!res.ok) return setStatus("error", res.error);
      onChange(cloneJson2(draft));
      applied = cloneJson2(draft);
      dirty = false;
      syncActions();
      setStatus("ok", "Layout applied.");
    };
    const revertNow = () => {
      if (!dirty) {
        setStatus("ok", "Nothing to revert.");
        return;
      }
      if (!safeConfirm("Discard unsaved layout changes?")) return;
      draft = cloneJson2(applied);
      dirty = false;
      syncActions();
      setStatus("ok", "Reverted.");
      render();
    };
    syncActions();
    let debounce = null;
    const markDirty = (rerender = true) => {
      dirty = true;
      syncActions();
      if (debounce !== null) doc.defaultView?.clearTimeout?.(debounce);
      debounce = doc.defaultView?.setTimeout?.(() => {
        debounce = null;
        const res = validateDraft();
        if (!res.ok) return setStatus("error", res.error);
        if (!autoApply) return setStatus("ok", "Valid. Click Apply changes to update the dashboard.");
        setStatus("info", "Applying...");
        applyNow();
      }, 200);
      if (rerender) render();
    };
    auto.addEventListener("change", () => {
      autoApply = auto.checked;
      if (autoApply && dirty) markDirty(false);
    });
    const renderGlobalFilters = (right) => {
      const current = draft.dashboard.globalFilters ?? {
        enabled: true,
        layout: { variant: "compact" },
        controls: [],
        buttons: { apply: false, reset: true }
      };
      const patch = (next) => {
        const n = cloneJson2(draft);
        n.dashboard.globalFilters = next;
        draft = n;
        markDirty();
      };
      const controls = Array.isArray(current.controls) ? current.controls : [];
      const dimsAll = Object.keys(semantic.dimensions ?? {}).map((id) => ({ value: id, label: id }));
      const addRow = doc.createElement("div");
      addRow.className = "ga-le-toprow";
      addRow.appendChild(
        mkBtn(
          doc,
          "Add select filter",
          () => {
            const id = `filter_${Math.random().toString(36).slice(2, 7)}`;
            patch({
              ...current,
              controls: [
                ...controls,
                { id, type: "select", label: "New filter", dimension: "", default: "all", options: "auto_distinct", appliesTo: [grainDefault] }
              ]
            });
          },
          "primary"
        )
      );
      addRow.appendChild(
        mkBtn(
          doc,
          "Add date range",
          () => {
            const id = `date_${Math.random().toString(36).slice(2, 7)}`;
            patch({ ...current, controls: [...controls, { id, type: "date_range", label: "Date range", default: { fromTs: null, toTs: null }, appliesTo: [grainDefault] }] });
          },
          "primary"
        )
      );
      const presets = [
        {
          id: "country_map",
          label: "Country (map)",
          make: () => ({
            id: `country_${Math.random().toString(36).slice(2, 7)}`,
            type: "select",
            label: "Country",
            dimension: "true_country",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round"],
            presentation: "map",
            map: { variant: "compact", height: 340, restrictToOptions: true, tintSelectable: true }
          })
        },
        {
          id: "movement",
          label: "Movement",
          make: () => ({
            id: `move_${Math.random().toString(36).slice(2, 7)}`,
            type: "select",
            label: "Movement",
            dimension: "movement_type",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round"]
          })
        },
        {
          id: "mode_family",
          label: "Mode family",
          make: () => ({
            id: `mode_${Math.random().toString(36).slice(2, 7)}`,
            type: "select",
            label: "Mode family",
            dimension: "mode_family",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round"]
          })
        },
        {
          id: "guess_time",
          label: "Guess time bucket",
          make: () => ({
            id: `time_${Math.random().toString(36).slice(2, 7)}`,
            type: "select",
            label: "Guess time",
            dimension: "duration_bucket",
            default: "all",
            options: "auto_distinct",
            appliesTo: ["round"]
          })
        },
        {
          id: "teammate",
          label: "Teammate",
          make: () => ({
            id: `mate_${Math.random().toString(36).slice(2, 7)}`,
            type: "select",
            label: "Teammate",
            dimension: "teammate_name",
            default: "all",
            options: "auto_teammates",
            appliesTo: ["round"]
          })
        }
      ];
      const presetSel = doc.createElement("select");
      presetSel.className = "ga-le-inline-select";
      for (const p of presets) presetSel.appendChild(new Option(p.label, p.id));
      addRow.appendChild(presetSel);
      addRow.appendChild(
        mkBtn(
          doc,
          "Add preset",
          () => {
            const picked = presets.find((p) => p.id === presetSel.value) ?? presets[0];
            if (!picked) return;
            const ctrl = picked.make();
            if (Array.isArray(ctrl.appliesTo) && ctrl.appliesTo.length) ctrl.appliesTo = [grainDefault];
            patch({ ...current, controls: [...controls, ctrl] });
          },
          "primary"
        )
      );
      right.appendChild(addRow);
      right.appendChild(mkToggle(doc, "enabled", !!current.enabled, (v) => patch({ ...current, enabled: v })));
      const gfNote = doc.createElement("div");
      gfNote.className = "ga-settings-note";
      gfNote.textContent = "`appliesTo` controls where each filter is active (round/game/session).";
      right.appendChild(gfNote);
      right.appendChild(
        mkSelect(
          doc,
          "layout.variant",
          String(current?.layout?.variant ?? "compact"),
          [{ value: "compact", label: "compact" }, { value: "full", label: "full" }],
          (v) => patch({ ...current, layout: { ...current.layout ?? {}, variant: v } })
        )
      );
      right.appendChild(mkToggle(doc, "buttons.reset", current?.buttons?.reset !== false, (v) => patch({ ...current, buttons: { ...current.buttons ?? {}, reset: v } })));
      right.appendChild(mkToggle(doc, "buttons.apply", !!current?.buttons?.apply, (v) => patch({ ...current, buttons: { ...current.buttons ?? {}, apply: v } })));
      right.appendChild(renderAdvancedJson(doc, "Advanced JSON (globalFilters)", current, (next) => patch(next)));
      right.appendChild(mkHr(doc));
      controls.forEach((ctrl, idx) => {
        const item = doc.createElement("div");
        item.className = "ga-le-item";
        const row = doc.createElement("div");
        row.className = "ga-le-toprow";
        const t = doc.createElement("div");
        t.className = "ga-le-box-head";
        t.textContent = `${ctrl.type} \u2014 ${ctrl.label || ctrl.id}`;
        row.appendChild(t);
        row.appendChild(
          mkBtn(
            doc,
            "Delete",
            () => {
              if (!safeConfirm(`Delete global filter '${ctrl.label || ctrl.id}'?`)) return;
              patch({ ...current, controls: controls.filter((_, i) => i !== idx) });
            },
            "danger"
          )
        );
        item.appendChild(row);
        const patchCtrl = (nextCtrl) => patch({ ...current, controls: controls.map((c, i) => i === idx ? nextCtrl : c) });
        item.appendChild(mkTextInput(doc, "id", String(ctrl.id ?? ""), (v) => patchCtrl({ ...ctrl, id: v })));
        item.appendChild(
          mkSelect(
            doc,
            "type",
            String(ctrl.type ?? "select"),
            [
              { value: "select", label: "select" },
              { value: "date_range", label: "date_range" }
            ],
            (v) => {
              if (v === ctrl.type) return;
              if (v === "date_range") {
                patchCtrl({ id: ctrl.id, type: "date_range", label: ctrl.label || "Date range", default: { fromTs: null, toTs: null }, appliesTo: ctrl.appliesTo ?? [grainDefault] });
              } else {
                patchCtrl({
                  id: ctrl.id,
                  type: "select",
                  label: ctrl.label || "New filter",
                  dimension: "",
                  default: "all",
                  options: "auto_distinct",
                  appliesTo: ctrl.appliesTo ?? [grainDefault]
                });
              }
            }
          )
        );
        item.appendChild(mkTextInput(doc, "label", String(ctrl.label ?? ""), (v) => patchCtrl({ ...ctrl, label: v })));
        item.appendChild(mkMultiSelect(doc, "appliesTo", Array.isArray(ctrl.appliesTo) ? ctrl.appliesTo : [grainDefault], grainOpts, (vals) => patchCtrl({ ...ctrl, appliesTo: vals })));
        if (ctrl.type === "select") {
          item.appendChild(mkSelect(doc, "dimension", String(ctrl.dimension ?? ""), dimsAll, (v) => patchCtrl({ ...ctrl, dimension: v })));
          item.appendChild(
            mkSelect(
              doc,
              "options",
              String(ctrl.options ?? "auto_distinct"),
              [{ value: "auto_distinct", label: "auto_distinct" }, { value: "auto_teammates", label: "auto_teammates" }],
              (v) => patchCtrl({ ...ctrl, options: v })
            )
          );
          item.appendChild(mkTextInput(doc, "default", String(ctrl.default ?? "all"), (v) => patchCtrl({ ...ctrl, default: v })));
          item.appendChild(
            mkSelect(
              doc,
              "presentation",
              String(ctrl.presentation ?? "dropdown"),
              [{ value: "dropdown", label: "dropdown" }, { value: "map", label: "map" }],
              (v) => patchCtrl({ ...ctrl, presentation: v })
            )
          );
          if (ctrl.presentation === "map") {
            const map = ctrl.map ?? {};
            item.appendChild(
              mkSelect(
                doc,
                "map.variant",
                String(map.variant ?? "compact"),
                [{ value: "compact", label: "compact" }, { value: "wide", label: "wide" }],
                (v) => patchCtrl({ ...ctrl, map: { ...map, variant: v } })
              )
            );
            item.appendChild(
              mkNumberInput(doc, "map.height", asInt(map.height, 340), (n) => patchCtrl({ ...ctrl, map: { ...map, height: Math.max(160, Math.min(1200, n)) } }), {
                min: 160,
                max: 1200,
                step: 10
              })
            );
            item.appendChild(mkToggle(doc, "map.restrictToOptions", !!map.restrictToOptions, (v) => patchCtrl({ ...ctrl, map: { ...map, restrictToOptions: v } })));
            item.appendChild(mkToggle(doc, "map.tintSelectable", map.tintSelectable !== false, (v) => patchCtrl({ ...ctrl, map: { ...map, tintSelectable: v } })));
          }
        } else if (ctrl.type === "date_range") {
          const btnRow = doc.createElement("div");
          btnRow.className = "ga-le-toprow";
          btnRow.appendChild(mkBtn(doc, "Reset default", () => patchCtrl({ ...ctrl, default: { fromTs: null, toTs: null } })));
          item.appendChild(btnRow);
        }
        item.appendChild(renderAdvancedJson(doc, "Advanced JSON (control)", ctrl, (next) => patchCtrl(next)));
        right.appendChild(item);
      });
    };
    const mkModal = (title, onClose) => {
      const overlay = doc.createElement("div");
      overlay.className = "ga-le-modal";
      const bg = doc.createElement("div");
      bg.className = "ga-le-modal-bg";
      bg.addEventListener("click", onClose);
      const panel = doc.createElement("div");
      panel.className = "ga-le-modal-panel";
      const header = doc.createElement("div");
      header.className = "ga-le-modal-header";
      const ht = doc.createElement("div");
      ht.className = "ga-le-modal-title";
      ht.textContent = title;
      header.appendChild(ht);
      header.appendChild(mkBtn(doc, "Close", onClose));
      const body = doc.createElement("div");
      body.className = "ga-le-modal-body";
      panel.appendChild(header);
      panel.appendChild(body);
      overlay.appendChild(bg);
      overlay.appendChild(panel);
      return { overlay, body };
    };
    function renderPanels() {
      try {
        wrap.querySelector(".ga-le-modal")?.remove();
      } catch {
      }
      const sem = mergeSemanticWithDashboard(semantic, draft);
      const panels = doc.createElement("div");
      panels.className = "ga-le-panels";
      panels.style.gridColumn = "1 / -1";
      root.appendChild(panels);
      const sections = Array.isArray(draft.dashboard?.sections) ? draft.dashboard.sections : [];
      const setSections = (nextSections) => {
        const next = cloneJson2(draft);
        next.dashboard.sections = nextSections;
        draft = next;
        markDirty();
      };
      const ensureOneCardContainer = (sectionIdx) => {
        const next = cloneJson2(draft);
        const sec = next.dashboard.sections?.[sectionIdx];
        if (!sec) return;
        const cols = Math.max(1, Math.min(24, asInt(sec.layout?.columns, 12)));
        sec.layout = sec.layout ?? { mode: "grid", columns: cols, cards: [] };
        sec.layout.columns = cols;
        const cards = Array.isArray(sec.layout.cards) ? sec.layout.cards : [];
        if (cards.length === 0) cards.push(defaultCard());
        const first = cards[0];
        first.x = 0;
        first.y = 0;
        first.w = cols;
        first.h = Math.max(10, asInt(first.h, 12));
        first.title = String(sec.title ?? first.title ?? "Section");
        first.card = first.card ?? { type: "composite", children: [] };
        first.card.children = Array.isArray(first.card.children) ? first.card.children : [];
        sec.layout.cards = [first];
        next.dashboard.sections[sectionIdx] = sec;
        draft = next;
        markDirty();
      };
      const flattenCardsIntoFirst = (sectionIdx) => {
        const next = cloneJson2(draft);
        const sec = next.dashboard.sections?.[sectionIdx];
        if (!sec) return;
        const cols = Math.max(1, Math.min(24, asInt(sec.layout?.columns, 12)));
        const cards = Array.isArray(sec.layout?.cards) ? sec.layout.cards : [];
        if (cards.length <= 1) return ensureOneCardContainer(sectionIdx);
        const base = cards[0];
        base.card = base.card ?? { type: "composite", children: [] };
        const baseChildren = Array.isArray(base.card.children) ? base.card.children : [];
        let cursorY = 0;
        for (const w of baseChildren) {
          const p = w?.placement ?? {};
          cursorY = Math.max(cursorY, asInt(p.y, 0) + asInt(p.h, 3));
        }
        cursorY += 1;
        for (const c of cards.slice(1)) {
          const kids = Array.isArray(c?.card?.children) ? c.card.children : [];
          for (const w of kids) {
            const p = w?.placement ?? { x: 0, y: 0, w: cols, h: 3 };
            baseChildren.push({ ...w, placement: { ...p, y: asInt(p.y, 0) + cursorY } });
          }
          let maxLocal = 0;
          for (const w of kids) {
            const p = w?.placement ?? {};
            maxLocal = Math.max(maxLocal, asInt(p.y, 0) + asInt(p.h, 3));
          }
          cursorY += maxLocal + 1;
        }
        base.card.children = baseChildren;
        base.x = 0;
        base.y = 0;
        base.w = cols;
        base.h = Math.max(10, asInt(base.h, 12));
        base.title = String(sec.title ?? base.title ?? "Section");
        sec.layout.cards = [base];
        next.dashboard.sections[sectionIdx] = sec;
        draft = next;
        markDirty();
      };
      const getSectionChildren = (sectionIdx) => {
        const sec = draft.dashboard.sections?.[sectionIdx] ?? null;
        const c0 = Array.isArray(sec?.layout?.cards) ? sec.layout.cards[0] : null;
        const kids = c0?.card ? c0.card.children : null;
        return Array.isArray(kids) ? kids : [];
      };
      const setSectionChildren = (sectionIdx, nextChildren) => {
        const next = cloneJson2(draft);
        const sec = next.dashboard.sections?.[sectionIdx];
        if (!sec) return;
        const cols = Math.max(1, Math.min(24, asInt(sec.layout?.columns, 12)));
        sec.layout = sec.layout ?? { mode: "grid", columns: cols, cards: [] };
        sec.layout.columns = cols;
        const cards = Array.isArray(sec.layout.cards) ? sec.layout.cards : [];
        if (cards.length === 0) cards.push(defaultCard());
        const first = cards[0];
        first.x = 0;
        first.y = 0;
        first.w = cols;
        first.h = Math.max(10, asInt(first.h, 12));
        first.title = String(sec.title ?? first.title ?? "Section");
        first.card = first.card ?? { type: "composite", children: [] };
        first.card.children = nextChildren;
        sec.layout.cards = [first];
        next.dashboard.sections[sectionIdx] = sec;
        draft = next;
        markDirty();
      };
      const sectionsBox = doc.createElement("div");
      sectionsBox.className = "ga-le-box";
      const sHead = doc.createElement("div");
      sHead.className = "ga-le-box-head";
      sHead.textContent = "Sections";
      sectionsBox.appendChild(sHead);
      const sNote = doc.createElement("div");
      sNote.className = "ga-settings-note";
      sNote.textContent = "Sections are your tabs. Rename, reorder, and click Edit to configure widgets.";
      sectionsBox.appendChild(sNote);
      const reorderSection = (fromIdx, toIdx) => {
        if (fromIdx === toIdx) return;
        if (fromIdx < 0 || fromIdx >= sections.length) return;
        if (toIdx < 0 || toIdx >= sections.length) return;
        const next = [...sections];
        const [picked] = next.splice(fromIdx, 1);
        next.splice(toIdx, 0, picked);
        setSections(next);
      };
      sections.forEach((sec, idx) => {
        const row = doc.createElement("div");
        row.className = "ga-le-compact-row";
        row.draggable = true;
        row.dataset.idx = String(idx);
        row.addEventListener("dragstart", (ev) => {
          try {
            ev.dataTransfer?.setData("text/plain", String(idx));
            ev.dataTransfer?.setDragImage?.(row, 12, 12);
          } catch {
          }
          row.classList.add("dragging");
        });
        row.addEventListener("dragend", () => row.classList.remove("dragging"));
        row.addEventListener("dragover", (ev) => {
          ev.preventDefault();
          row.classList.add("dragover");
        });
        row.addEventListener("dragleave", () => row.classList.remove("dragover"));
        row.addEventListener("drop", (ev) => {
          ev.preventDefault();
          row.classList.remove("dragover");
          const raw = ev.dataTransfer?.getData("text/plain") ?? "";
          const fromIdx = asInt(raw, -1);
          if (fromIdx < 0) return;
          reorderSection(fromIdx, idx);
        });
        const drag = doc.createElement("div");
        drag.className = "ga-le-drag";
        drag.title = "Drag to reorder";
        drag.textContent = "\u22EE\u22EE";
        row.appendChild(drag);
        const title = doc.createElement("div");
        title.className = "ga-le-compact-title";
        title.textContent = sec?.title || sec?.id || "Untitled";
        row.appendChild(title);
        const meta = doc.createElement("div");
        meta.className = "ga-le-compact-meta";
        meta.textContent = String(sec?.id || "");
        row.appendChild(meta);
        const actions = doc.createElement("div");
        actions.className = "ga-le-compact-actions";
        actions.appendChild(
          mkIconBtn(doc, "\u270E", () => {
            const nextTitle = safePrompt(doc, "Rename section title:", String(sec?.title ?? ""));
            if (nextTitle === null) return;
            const next = [...sections];
            next[idx] = { ...sec, title: nextTitle };
            setSections(next);
          })
        );
        actions.appendChild(
          mkIconBtn(
            doc,
            "\u{1F5D1}",
            () => {
              if (!safeConfirm(`Delete section '${sec?.title || sec?.id}'?`)) return;
              const next = sections.filter((_, i) => i !== idx);
              setSections(next);
              if (editSectionIdx === idx) editSectionIdx = null;
            },
            "danger"
          )
        );
        actions.appendChild(
          mkBtn(
            doc,
            "Edit",
            () => {
              editSectionIdx = idx;
              render();
            },
            "primary"
          )
        );
        row.appendChild(actions);
        sectionsBox.appendChild(row);
      });
      const addSectionRow = doc.createElement("div");
      addSectionRow.className = "ga-le-compact-row";
      addSectionRow.title = "Add section";
      const addSection = () => {
        const next = [...sections, defaultSection()];
        setSections(next);
        editSectionIdx = Math.max(0, next.length - 1);
        render();
      };
      addSectionRow.addEventListener("click", () => addSection());
      const addDrag = doc.createElement("div");
      addDrag.className = "ga-le-drag";
      addDrag.textContent = "+";
      addSectionRow.appendChild(addDrag);
      const addTitle = doc.createElement("div");
      addTitle.className = "ga-le-compact-title";
      addTitle.textContent = "Add section";
      addSectionRow.appendChild(addTitle);
      const addMeta = doc.createElement("div");
      addMeta.className = "ga-le-compact-meta";
      addMeta.textContent = "";
      addSectionRow.appendChild(addMeta);
      const addActions = doc.createElement("div");
      addActions.className = "ga-le-compact-actions";
      addActions.appendChild(mkBtn(doc, "+", () => addSection(), "primary"));
      addSectionRow.appendChild(addActions);
      sectionsBox.appendChild(addSectionRow);
      if (mode === "section_layout") {
        panels.appendChild(sectionsBox);
      }
      if (mode === "global_filters") {
        const gfFallback = {
          enabled: true,
          layout: { variant: "compact" },
          controls: [],
          buttons: { apply: false, reset: true }
        };
        const gfRaw = draft.dashboard.globalFilters;
        const gfCurrent = gfRaw && typeof gfRaw === "object" ? { ...gfFallback, ...gfRaw } : gfFallback;
        if (!gfCurrent.layout || typeof gfCurrent.layout !== "object") gfCurrent.layout = { variant: "compact" };
        if (!gfCurrent.buttons || typeof gfCurrent.buttons !== "object") gfCurrent.buttons = { apply: false, reset: true };
        const gfControls = Array.isArray(gfCurrent.controls) ? gfCurrent.controls : [];
        const setGlobalFilters = (nextGlobalFilters) => {
          const next = cloneJson2(draft);
          next.dashboard.globalFilters = nextGlobalFilters;
          draft = next;
          markDirty();
        };
        const setControls = (nextControls) => setGlobalFilters({ ...gfCurrent, controls: nextControls });
        const gfBox = doc.createElement("div");
        gfBox.className = "ga-le-box";
        const gfh = doc.createElement("div");
        gfh.className = "ga-le-box-head";
        gfh.textContent = "Global filters";
        gfBox.appendChild(gfh);
        const gfNote = doc.createElement("div");
        gfNote.className = "ga-settings-note";
        gfNote.textContent = "Drag to reorder. Click Edit to configure a filter. Use + to add a new filter.";
        gfBox.appendChild(gfNote);
        const gfEnabled = gfCurrent?.enabled !== false;
        const barRow = doc.createElement("div");
        barRow.className = "ga-le-compact-row";
        const barDrag = doc.createElement("div");
        barDrag.className = "ga-le-drag";
        barDrag.textContent = "";
        barRow.appendChild(barDrag);
        const barTitle = doc.createElement("div");
        barTitle.className = "ga-le-compact-title";
        barTitle.textContent = "Global filter bar";
        barRow.appendChild(barTitle);
        const barMeta = doc.createElement("div");
        barMeta.className = "ga-le-compact-meta";
        barMeta.textContent = `${gfEnabled ? "Enabled" : "Disabled"} \u2022 ${String(gfCurrent?.layout?.variant ?? "compact")}`;
        barRow.appendChild(barMeta);
        const barActions = doc.createElement("div");
        barActions.className = "ga-le-compact-actions";
        barActions.appendChild(
          mkBtn(
            doc,
            gfEnabled ? "Disable" : "Enable",
            () => setGlobalFilters({ ...gfCurrent, enabled: !gfEnabled }),
            gfEnabled ? "ghost" : "primary"
          )
        );
        barActions.appendChild(
          mkBtn(
            doc,
            "Advanced",
            () => {
              editGlobalFilters = true;
              render();
            },
            "ghost"
          )
        );
        barRow.appendChild(barActions);
        gfBox.appendChild(barRow);
        const reorderControl = (fromIdx, toIdx) => {
          if (fromIdx === toIdx) return;
          if (fromIdx < 0 || fromIdx >= gfControls.length) return;
          if (toIdx < 0 || toIdx >= gfControls.length) return;
          const next = [...gfControls];
          const [picked] = next.splice(fromIdx, 1);
          next.splice(toIdx, 0, picked);
          setControls(next);
        };
        gfControls.forEach((ctrl, idx) => {
          const row = doc.createElement("div");
          row.className = "ga-le-compact-row";
          row.draggable = true;
          row.dataset.idx = String(idx);
          row.addEventListener("click", () => {
            editGlobalFilterIdx = idx;
            render();
          });
          row.addEventListener("dragstart", (ev) => {
            try {
              ev.dataTransfer?.setData("text/plain", String(idx));
              ev.dataTransfer?.setDragImage?.(row, 12, 12);
            } catch {
            }
            row.classList.add("dragging");
          });
          row.addEventListener("dragend", () => row.classList.remove("dragging"));
          row.addEventListener("dragover", (ev) => {
            ev.preventDefault();
            row.classList.add("dragover");
          });
          row.addEventListener("dragleave", () => row.classList.remove("dragover"));
          row.addEventListener("drop", (ev) => {
            ev.preventDefault();
            row.classList.remove("dragover");
            const raw = ev.dataTransfer?.getData("text/plain") ?? "";
            const fromIdx = asInt(raw, -1);
            if (fromIdx < 0) return;
            reorderControl(fromIdx, idx);
          });
          const drag = doc.createElement("div");
          drag.className = "ga-le-drag";
          drag.title = "Drag to reorder";
          drag.textContent = "\u22EE\u22EE";
          row.appendChild(drag);
          const title = doc.createElement("div");
          title.className = "ga-le-compact-title";
          title.textContent = String(ctrl?.label || ctrl?.id || "Untitled filter");
          row.appendChild(title);
          const meta = doc.createElement("div");
          meta.className = "ga-le-compact-meta";
          const metaParts = [];
          if (ctrl?.id) metaParts.push(String(ctrl.id));
          metaParts.push(String(ctrl?.type ?? "select"));
          if (ctrl?.type === "select") metaParts.push(String(ctrl?.dimension ?? "(no dimension)"));
          if (Array.isArray(ctrl?.appliesTo) && ctrl.appliesTo.length) metaParts.push(String(ctrl.appliesTo.join(",")));
          meta.textContent = metaParts.filter(Boolean).join(" \u2022 ");
          row.appendChild(meta);
          const actions = doc.createElement("div");
          actions.className = "ga-le-compact-actions";
          actions.appendChild(
            mkIconBtn(doc, "\u270E", () => {
              editGlobalFilterIdx = idx;
              render();
            })
          );
          actions.appendChild(
            mkIconBtn(
              doc,
              "\u{1F5D1}",
              () => {
                if (!safeConfirm(`Delete global filter '${ctrl?.label || ctrl?.id}'?`)) return;
                setControls(gfControls.filter((_, i) => i !== idx));
                if (editGlobalFilterIdx === idx) editGlobalFilterIdx = null;
              },
              "danger"
            )
          );
          actions.appendChild(
            mkBtn(
              doc,
              "Edit",
              () => {
                editGlobalFilterIdx = idx;
                render();
              },
              "primary"
            )
          );
          row.appendChild(actions);
          gfBox.appendChild(row);
        });
        const addFilter = () => {
          const id = `filter_${Math.random().toString(36).slice(2, 7)}`;
          const next = [
            ...gfControls,
            { id, type: "select", label: "New filter", dimension: "", default: "all", options: "auto_distinct", appliesTo: [grainDefault] }
          ];
          setControls(next);
          editGlobalFilterIdx = Math.max(0, next.length - 1);
          render();
        };
        const addFilterRow = doc.createElement("div");
        addFilterRow.className = "ga-le-compact-row";
        addFilterRow.title = "Add filter";
        addFilterRow.addEventListener("click", () => addFilter());
        const addDrag2 = doc.createElement("div");
        addDrag2.className = "ga-le-drag";
        addDrag2.textContent = "+";
        addFilterRow.appendChild(addDrag2);
        const addTitle2 = doc.createElement("div");
        addTitle2.className = "ga-le-compact-title";
        addTitle2.textContent = "Add filter";
        addFilterRow.appendChild(addTitle2);
        const addMeta2 = doc.createElement("div");
        addMeta2.className = "ga-le-compact-meta";
        addMeta2.textContent = "";
        addFilterRow.appendChild(addMeta2);
        const addActions2 = doc.createElement("div");
        addActions2.className = "ga-le-compact-actions";
        addActions2.appendChild(mkBtn(doc, "+", () => addFilter(), "primary"));
        addFilterRow.appendChild(addActions2);
        gfBox.appendChild(addFilterRow);
        panels.appendChild(gfBox);
      }
      if (mode === "drilldowns") {
        panels.appendChild(mkHr(doc));
        const ddBox = doc.createElement("div");
        ddBox.className = "ga-le-box";
        const ddh = doc.createElement("div");
        ddh.className = "ga-le-box-head";
        ddh.textContent = "Drilldown presets";
        ddBox.appendChild(ddh);
        const ddn = doc.createElement("div");
        ddn.className = "ga-settings-note";
        ddn.textContent = "Define which columns show up in drilldown tables (and which are sortable). Saved into your template.";
        ddBox.appendChild(ddn);
        const ddOverride2 = draft.dashboard?.drilldownPresets ?? {};
        const setDdOverride2 = (target, nextTarget) => {
          const next = cloneJson2(draft);
          const cur = next.dashboard.drilldownPresets ?? {};
          next.dashboard.drilldownPresets = { ...cur, [target]: nextTarget };
          draft = next;
          markDirty();
        };
        const removeDdOverride2 = (target) => {
          const next = cloneJson2(draft);
          const cur = next.dashboard.drilldownPresets ?? {};
          const { [target]: _, ...rest } = cur;
          next.dashboard.drilldownPresets = rest;
          draft = next;
          markDirty();
        };
        const targets = Object.keys(sem?.drilldownPresets ?? {});
        if (targets.length === 0) {
          const none = doc.createElement("div");
          none.className = "ga-settings-note";
          none.textContent = "No drilldown targets found.";
          ddBox.appendChild(none);
        }
        targets.forEach((target) => {
          const preset = sem?.drilldownPresets?.[target] ?? {};
          const keys2 = Object.keys(preset?.columnsPresets ?? {});
          const left = doc.createElement("div");
          left.className = "ga-le-compact-title";
          left.textContent = `${target} \u2022 ${keys2.length} presets`;
          const row = doc.createElement("div");
          row.className = "ga-le-compact-row";
          row.appendChild(left);
          const actions = doc.createElement("div");
          actions.className = "ga-le-compact-actions";
          actions.appendChild(
            mkBtn(
              doc,
              "Edit",
              () => {
                editDrilldownTarget = target;
                render();
              },
              "primary"
            )
          );
          row.appendChild(actions);
          ddBox.appendChild(row);
        });
        panels.appendChild(ddBox);
      }
      if (editGlobalFilters) {
        const { overlay, body } = mkModal("Global filters", () => {
          editGlobalFilters = false;
          render();
        });
        renderGlobalFilters(body);
        wrap.appendChild(overlay);
      }
      if (editGlobalFilterIdx !== null) {
        const gfFallback = {
          enabled: true,
          layout: { variant: "compact" },
          controls: [],
          buttons: { apply: false, reset: true }
        };
        const gfRaw = draft.dashboard.globalFilters;
        const gfCurrent = gfRaw && typeof gfRaw === "object" ? { ...gfFallback, ...gfRaw } : gfFallback;
        if (!gfCurrent.layout || typeof gfCurrent.layout !== "object") gfCurrent.layout = { variant: "compact" };
        if (!gfCurrent.buttons || typeof gfCurrent.buttons !== "object") gfCurrent.buttons = { apply: false, reset: true };
        const controls = Array.isArray(gfCurrent.controls) ? gfCurrent.controls : [];
        const idx = editGlobalFilterIdx;
        const ctrl = controls[idx];
        if (!ctrl) {
          editGlobalFilterIdx = null;
        } else {
          const { overlay, body } = mkModal(`Global filter: ${String(ctrl?.label || ctrl?.id || "")}`, () => {
            editGlobalFilterIdx = null;
            render();
          });
          const setGlobalFilters = (nextGlobalFilters) => {
            const next = cloneJson2(draft);
            next.dashboard.globalFilters = nextGlobalFilters;
            draft = next;
            markDirty();
          };
          const patchCtrl = (nextCtrl) => setGlobalFilters({ ...gfCurrent, controls: controls.map((c, i) => i === idx ? nextCtrl : c) });
          const top = doc.createElement("div");
          top.className = "ga-le-toprow";
          top.appendChild(
            mkBtn(
              doc,
              "Delete",
              () => {
                if (!safeConfirm(`Delete global filter '${ctrl?.label || ctrl?.id}'?`)) return;
                setGlobalFilters({ ...gfCurrent, controls: controls.filter((_, i) => i !== idx) });
                editGlobalFilterIdx = null;
                render();
              },
              "danger"
            )
          );
          top.appendChild(
            mkBtn(doc, "Advanced (all)", () => {
              editGlobalFilterIdx = null;
              editGlobalFilters = true;
              render();
            })
          );
          body.appendChild(top);
          const dimsAll = Object.keys(semantic.dimensions ?? {}).map((id) => ({ value: id, label: id }));
          body.appendChild(mkTextInput(doc, "id", String(ctrl.id ?? ""), (v) => patchCtrl({ ...ctrl, id: v })));
          body.appendChild(
            mkSelect(
              doc,
              "type",
              String(ctrl.type ?? "select"),
              [
                { value: "select", label: "select" },
                { value: "date_range", label: "date_range" }
              ],
              (v) => {
                if (v === ctrl.type) return;
                if (v === "date_range") {
                  patchCtrl({
                    id: ctrl.id,
                    type: "date_range",
                    label: ctrl.label || "Date range",
                    default: { fromTs: null, toTs: null },
                    appliesTo: ctrl.appliesTo ?? [grainDefault]
                  });
                } else {
                  patchCtrl({
                    id: ctrl.id,
                    type: "select",
                    label: ctrl.label || "New filter",
                    dimension: "",
                    default: "all",
                    options: "auto_distinct",
                    appliesTo: ctrl.appliesTo ?? [grainDefault]
                  });
                }
              }
            )
          );
          body.appendChild(mkTextInput(doc, "label", String(ctrl.label ?? ""), (v) => patchCtrl({ ...ctrl, label: v })));
          body.appendChild(
            mkMultiSelect(doc, "appliesTo", Array.isArray(ctrl.appliesTo) ? ctrl.appliesTo : [grainDefault], grainOpts, (vals) => patchCtrl({ ...ctrl, appliesTo: vals }))
          );
          if (ctrl.type === "select") {
            body.appendChild(mkSelect(doc, "dimension", String(ctrl.dimension ?? ""), dimsAll, (v) => patchCtrl({ ...ctrl, dimension: v })));
            body.appendChild(
              mkSelect(
                doc,
                "options",
                String(ctrl.options ?? "auto_distinct"),
                [
                  { value: "auto_distinct", label: "auto_distinct" },
                  { value: "auto_teammates", label: "auto_teammates" }
                ],
                (v) => patchCtrl({ ...ctrl, options: v })
              )
            );
            body.appendChild(mkTextInput(doc, "default", String(ctrl.default ?? "all"), (v) => patchCtrl({ ...ctrl, default: v })));
            body.appendChild(
              mkSelect(
                doc,
                "presentation",
                String(ctrl.presentation ?? "dropdown"),
                [{ value: "dropdown", label: "dropdown" }, { value: "map", label: "map" }],
                (v) => patchCtrl({ ...ctrl, presentation: v })
              )
            );
            if (ctrl.presentation === "map") {
              const map = ctrl.map ?? {};
              body.appendChild(
                mkSelect(
                  doc,
                  "map.variant",
                  String(map.variant ?? "compact"),
                  [{ value: "compact", label: "compact" }, { value: "wide", label: "wide" }],
                  (v) => patchCtrl({ ...ctrl, map: { ...map, variant: v } })
                )
              );
              body.appendChild(
                mkNumberInput(doc, "map.height", asInt(map.height, 340), (n) => patchCtrl({ ...ctrl, map: { ...map, height: Math.max(160, Math.min(1200, n)) } }), {
                  min: 160,
                  max: 1200,
                  step: 10
                })
              );
              body.appendChild(mkToggle(doc, "map.restrictToOptions", !!map.restrictToOptions, (v) => patchCtrl({ ...ctrl, map: { ...map, restrictToOptions: v } })));
              body.appendChild(mkToggle(doc, "map.tintSelectable", map.tintSelectable !== false, (v) => patchCtrl({ ...ctrl, map: { ...map, tintSelectable: v } })));
            }
          } else if (ctrl.type === "date_range") {
            const btnRow = doc.createElement("div");
            btnRow.className = "ga-le-toprow";
            btnRow.appendChild(mkBtn(doc, "Reset default", () => patchCtrl({ ...ctrl, default: { fromTs: null, toTs: null } })));
            body.appendChild(btnRow);
          }
          body.appendChild(renderAdvancedJson(doc, "Advanced JSON (control)", ctrl, (next) => patchCtrl(next)));
          wrap.appendChild(overlay);
        }
      }
      if (editDrilldownTarget) {
        const target = editDrilldownTarget;
        const preset = sem?.drilldownPresets?.[target] ?? {};
        const keys2 = Object.keys(preset?.columnsPresets ?? {});
        const override = ddOverride?.[target] ?? {};
        const { overlay, body } = mkModal(`Drilldown presets: ${target}`, () => {
          editDrilldownTarget = null;
          editDrilldownPreset = null;
          render();
        });
        if (override && Object.keys(override).length) {
          const top = doc.createElement("div");
          top.className = "ga-le-toprow";
          top.appendChild(mkBtn(doc, "Reset overrides", () => removeDdOverride(target), "danger"));
          body.appendChild(top);
        }
        if (keys2.length > 0) {
          body.appendChild(
            mkSelect(
              doc,
              "defaultPreset",
              String(preset?.defaultPreset ?? keys2[0]),
              keys2.map((k) => ({ value: k, label: k })),
              (v) => setDdOverride(target, { ...override, defaultPreset: v, columnsPresets: override?.columnsPresets ?? {} })
            )
          );
        }
        const addRow = doc.createElement("div");
        addRow.className = "ga-le-toprow";
        const input = doc.createElement("input");
        input.type = "text";
        input.className = "ga-le-inline-input";
        input.placeholder = "new preset id (e.g. myPreset)";
        input.value = String(newPresetIdByTarget[target] ?? "");
        input.addEventListener("input", () => newPresetIdByTarget[target] = input.value);
        addRow.appendChild(input);
        addRow.appendChild(
          mkBtn(
            doc,
            "Add preset",
            () => {
              const id = String(newPresetIdByTarget[target] ?? "").trim();
              if (!id) return;
              const colsNext = { ...override?.columnsPresets ?? {} };
              if (colsNext[id]) return;
              colsNext[id] = [{ key: "ts", label: "Date", sortable: true }];
              setDdOverride(target, { ...override, columnsPresets: colsNext });
              newPresetIdByTarget[target] = "";
              render();
            },
            "primary"
          )
        );
        body.appendChild(addRow);
        const mergedPresets = preset?.columnsPresets ?? {};
        for (const [pid, cols] of Object.entries(mergedPresets)) {
          const isEditable = !!override?.columnsPresets?.[pid];
          const row = doc.createElement("div");
          row.className = "ga-le-compact-row";
          const left = doc.createElement("div");
          left.className = "ga-le-compact-title";
          left.textContent = `${pid} \u2022 ${Array.isArray(cols) ? cols.length : 0} cols`;
          row.appendChild(left);
          const actions = doc.createElement("div");
          actions.className = "ga-le-compact-actions";
          if (!isEditable) {
            actions.appendChild(
              mkBtn(doc, "Customize", () => {
                const colsNext = { ...override?.columnsPresets ?? {} };
                colsNext[pid] = cloneJson2(cols);
                setDdOverride(target, { ...override, columnsPresets: colsNext });
                editDrilldownPreset = { target, presetId: pid };
                render();
              })
            );
          } else {
            actions.appendChild(
              mkIconBtn(
                doc,
                "\u{1F5D1}",
                () => {
                  if (!safeConfirm(`Delete preset '${pid}'?`)) return;
                  const colsNext = { ...override?.columnsPresets ?? {} };
                  delete colsNext[pid];
                  setDdOverride(target, { ...override, columnsPresets: colsNext });
                  if (editDrilldownPreset?.target === target && editDrilldownPreset?.presetId === pid) editDrilldownPreset = null;
                  render();
                },
                "danger"
              )
            );
          }
          actions.appendChild(
            mkBtn(
              doc,
              "Edit",
              () => {
                if (!isEditable) {
                  const colsNext = { ...override?.columnsPresets ?? {} };
                  colsNext[pid] = cloneJson2(cols);
                  setDdOverride(target, { ...override, columnsPresets: colsNext });
                }
                editDrilldownPreset = { target, presetId: pid };
                render();
              },
              "primary"
            )
          );
          row.appendChild(actions);
          body.appendChild(row);
        }
        wrap.appendChild(overlay);
      }
      if (editDrilldownPreset) {
        const { target, presetId } = editDrilldownPreset;
        const semPreset = sem?.drilldownPresets?.[target] ?? {};
        const mergedCols = semPreset?.columnsPresets?.[presetId] ?? [];
        const override = ddOverride?.[target] ?? {};
        const isEditable = !!override?.columnsPresets?.[presetId];
        if (!isEditable) {
          editDrilldownPreset = null;
        } else {
          const colsArr = Array.isArray(mergedCols) ? mergedCols : [];
          const { overlay, body } = mkModal(`Edit columns: ${target}.${presetId}`, () => {
            editDrilldownPreset = null;
            render();
          });
          const colsNextBase = () => ({ ...override?.columnsPresets ?? {} });
          const setColsForPreset = (nextArr) => {
            const colsNext = colsNextBase();
            colsNext[presetId] = nextArr;
            setDdOverride(target, { ...override, columnsPresets: colsNext });
          };
          const addRow = doc.createElement("div");
          addRow.className = "ga-le-toprow";
          addRow.appendChild(
            mkBtn(
              doc,
              "Add column",
              () => setColsForPreset([...colsArr, { key: "", label: "", sortable: false }]),
              "primary"
            )
          );
          body.appendChild(addRow);
          const reorder = (fromIdx, toIdx) => {
            if (fromIdx === toIdx) return;
            if (fromIdx < 0 || toIdx < 0) return;
            if (fromIdx >= colsArr.length || toIdx >= colsArr.length) return;
            const next = [...colsArr];
            const [picked] = next.splice(fromIdx, 1);
            next.splice(toIdx, 0, picked);
            setColsForPreset(next);
          };
          colsArr.forEach((c, cIdx) => {
            const row = doc.createElement("div");
            row.className = "ga-le-compact-row ga-le-compact-row-col";
            row.draggable = true;
            row.addEventListener("dragstart", (ev) => {
              try {
                ev.dataTransfer?.setData("text/plain", String(cIdx));
                ev.dataTransfer?.setDragImage?.(row, 12, 12);
              } catch {
              }
              row.classList.add("dragging");
            });
            row.addEventListener("dragend", () => row.classList.remove("dragging"));
            row.addEventListener("dragover", (ev) => {
              ev.preventDefault();
              row.classList.add("dragover");
            });
            row.addEventListener("dragleave", () => row.classList.remove("dragover"));
            row.addEventListener("drop", (ev) => {
              ev.preventDefault();
              row.classList.remove("dragover");
              const raw = ev.dataTransfer?.getData("text/plain") ?? "";
              reorder(asInt(raw, -1), cIdx);
            });
            const drag = doc.createElement("div");
            drag.className = "ga-le-drag";
            drag.title = "Drag to reorder";
            drag.textContent = "\u22EE\u22EE";
            row.appendChild(drag);
            const key = doc.createElement("input");
            key.type = "text";
            key.className = "ga-le-inline-input ga-le-col-key";
            key.placeholder = "key";
            key.value = String(c?.key ?? "");
            key.addEventListener("change", () => {
              const next = [...colsArr];
              next[cIdx] = { ...c, key: key.value };
              setColsForPreset(next);
            });
            row.appendChild(key);
            const label = doc.createElement("input");
            label.type = "text";
            label.className = "ga-le-inline-input ga-le-col-label";
            label.placeholder = "label";
            label.value = String(c?.label ?? "");
            label.addEventListener("change", () => {
              const next = [...colsArr];
              next[cIdx] = { ...c, label: label.value };
              setColsForPreset(next);
            });
            row.appendChild(label);
            const mkChk = (txt, checked, onChange2) => {
              const w = doc.createElement("label");
              w.className = "ga-le-compact-chk";
              const cb = doc.createElement("input");
              cb.type = "checkbox";
              cb.checked = checked;
              cb.addEventListener("change", () => onChange2(cb.checked));
              const s = doc.createElement("span");
              s.textContent = txt;
              w.appendChild(cb);
              w.appendChild(s);
              return w;
            };
            row.appendChild(
              mkChk("sort", !!c?.sortable, (v) => {
                const next = [...colsArr];
                next[cIdx] = { ...c, sortable: v };
                setColsForPreset(next);
              })
            );
            row.appendChild(
              mkChk("color", !!c?.colored, (v) => {
                const next = [...colsArr];
                next[cIdx] = { ...c, colored: v };
                setColsForPreset(next);
              })
            );
            row.appendChild(
              mkIconBtn(
                doc,
                "\u{1F5D1}",
                () => setColsForPreset(colsArr.filter((_, i) => i !== cIdx)),
                "danger"
              )
            );
            body.appendChild(row);
            const adv = renderAdvancedJson(doc, "Advanced JSON (column)", c, (nextCol) => {
              const next = [...colsArr];
              next[cIdx] = nextCol;
              setColsForPreset(next);
            });
            body.appendChild(adv);
          });
          wrap.appendChild(overlay);
        }
      }
      if (editSectionIdx !== null && sections[editSectionIdx]) {
        const sec = sections[editSectionIdx];
        const overlay = doc.createElement("div");
        overlay.className = "ga-le-modal";
        const bg = doc.createElement("div");
        bg.className = "ga-le-modal-bg";
        bg.addEventListener("click", () => {
          editSectionIdx = null;
          render();
        });
        const panel = doc.createElement("div");
        panel.className = "ga-le-modal-panel";
        const header = doc.createElement("div");
        header.className = "ga-le-modal-header";
        const ht = doc.createElement("div");
        ht.className = "ga-le-modal-title";
        ht.textContent = `Edit section: ${sec?.title || sec?.id || editSectionIdx}`;
        header.appendChild(ht);
        header.appendChild(
          mkBtn(doc, "Close", () => {
            editSectionIdx = null;
            render();
          })
        );
        panel.appendChild(header);
        const body = doc.createElement("div");
        body.className = "ga-le-modal-body";
        const patchSection = (partial) => {
          const next = [...sections];
          next[editSectionIdx] = { ...sec, ...partial };
          setSections(next);
        };
        body.appendChild(mkTextInput(doc, "section.id", String(sec?.id ?? ""), (v) => patchSection({ id: v })));
        body.appendChild(mkTextInput(doc, "section.title", String(sec?.title ?? ""), (v) => patchSection({ title: v })));
        const colNote = doc.createElement("div");
        colNote.className = "ga-settings-note";
        colNote.textContent = "layout.columns = the grid width inside the section (recommended: 12).";
        body.appendChild(colNote);
        body.appendChild(
          mkNumberInput(
            doc,
            "layout.columns",
            asInt(sec?.layout?.columns, 12),
            (n) => patchSection({ layout: { ...sec.layout ?? {}, columns: Math.max(1, Math.min(24, n)) } }),
            { min: 1, max: 24 }
          )
        );
        const cardsCount = Array.isArray(sec?.layout?.cards) ? sec.layout.cards.length : 0;
        if (cardsCount !== 1) {
          const warn = doc.createElement("div");
          warn.className = "ga-settings-note";
          warn.textContent = cardsCount === 0 ? "This section has no container yet. Create one to add widgets." : `This section has ${cardsCount} cards. Layout UI assumes 1 container per section.`;
          body.appendChild(warn);
          const fix = doc.createElement("div");
          fix.className = "ga-le-toprow";
          fix.appendChild(
            mkBtn(
              doc,
              cardsCount === 0 ? "Create container" : "Flatten to 1 container",
              () => {
                if (cardsCount <= 1) ensureOneCardContainer(editSectionIdx);
                else {
                  if (!safeConfirm("Flatten all cards into one container?")) return;
                  flattenCardsIntoFirst(editSectionIdx);
                }
                render();
              },
              "primary"
            )
          );
          body.appendChild(fix);
        }
        body.appendChild(mkHr(doc));
        const cols = Math.max(1, Math.min(24, asInt(sec?.layout?.columns, 12)));
        const children = getSectionChildren(editSectionIdx);
        const addRow = doc.createElement("div");
        addRow.className = "ga-le-toprow";
        addRow.appendChild(mkBtn(doc, "Add graph", () => setSectionChildren(editSectionIdx, [...children, defaultWidget(grainDefault, "chart", cols)]), "primary"));
        addRow.appendChild(mkBtn(doc, "Add stat rows", () => setSectionChildren(editSectionIdx, [...children, defaultWidget(grainDefault, "stat_list", cols)]), "primary"));
        addRow.appendChild(mkBtn(doc, "Add box", () => setSectionChildren(editSectionIdx, [...children, defaultWidget(grainDefault, "stat_value", cols)]), "primary"));
        body.appendChild(addRow);
        const widgetTypes = ["stat_list", "stat_value", "chart", "breakdown", "record_list", "leader_list"];
        const typeOpts = widgetTypes.map((t) => ({ value: t, label: t }));
        const patchWidgetAt = (wIdx, nextWidget) => {
          const next = children.map((x, i) => i === wIdx ? nextWidget : x);
          setSectionChildren(editSectionIdx, next);
        };
        const moveWidget = (wIdx, delta) => {
          const nextIdx = wIdx + delta;
          if (nextIdx < 0 || nextIdx >= children.length) return;
          const next = [...children];
          const [picked] = next.splice(wIdx, 1);
          next.splice(nextIdx, 0, picked);
          setSectionChildren(editSectionIdx, next);
        };
        const renderWidgetEditor = (w, wIdx) => {
          const det = doc.createElement("details");
          det.className = "ga-le-details";
          det.open = false;
          const sum = doc.createElement("summary");
          sum.textContent = `${w.type} - ${w.title || w.widgetId}`;
          det.appendChild(sum);
          const wItem = doc.createElement("div");
          wItem.className = "ga-le-widget";
          const actions = doc.createElement("div");
          actions.className = "ga-le-toprow";
          actions.appendChild(mkBtn(doc, "Up", () => moveWidget(wIdx, -1)));
          actions.appendChild(mkBtn(doc, "Down", () => moveWidget(wIdx, 1)));
          actions.appendChild(
            mkBtn(
              doc,
              "Delete",
              () => {
                if (!safeConfirm(`Delete widget '${w.title || w.widgetId}'?`)) return;
                setSectionChildren(editSectionIdx, children.filter((_, i) => i !== wIdx));
              },
              "danger"
            )
          );
          wItem.appendChild(actions);
          wItem.appendChild(mkTextInput(doc, "widgetId", String(w.widgetId ?? ""), (v) => patchWidgetAt(wIdx, { ...w, widgetId: v })));
          wItem.appendChild(
            mkSelect(doc, "type", String(w.type ?? "stat_list"), typeOpts, (v) => {
              const nextWidget = defaultWidget(String(w.grain ?? grainDefault), v);
              nextWidget.widgetId = w.widgetId;
              nextWidget.title = w.title;
              nextWidget.grain = w.grain ?? grainDefault;
              nextWidget.placement = w.placement;
              patchWidgetAt(wIdx, nextWidget);
            })
          );
          wItem.appendChild(mkTextInput(doc, "title", String(w.title ?? ""), (v) => patchWidgetAt(wIdx, { ...w, title: v })));
          wItem.appendChild(mkSelect(doc, "grain", String(w.grain ?? grainDefault), grainOpts, (v) => patchWidgetAt(wIdx, { ...w, grain: v })));
          const p = w.placement ?? { x: 0, y: 0, w: cols, h: 3 };
          const pGrid = doc.createElement("div");
          pGrid.className = "ga-le-grid4";
          pGrid.appendChild(mkNumberInput(doc, "x", asInt(p.x, 0), (n) => patchWidgetAt(wIdx, { ...w, placement: { ...p, x: n } })));
          pGrid.appendChild(mkNumberInput(doc, "y", asInt(p.y, 0), (n) => patchWidgetAt(wIdx, { ...w, placement: { ...p, y: n } })));
          pGrid.appendChild(mkNumberInput(doc, "w", asInt(p.w, cols), (n) => patchWidgetAt(wIdx, { ...w, placement: { ...p, w: n } })));
          pGrid.appendChild(mkNumberInput(doc, "h", asInt(p.h, 3), (n) => patchWidgetAt(wIdx, { ...w, placement: { ...p, h: n } })));
          wItem.appendChild(pGrid);
          const widgetGrain = String(w.grain ?? grainDefault);
          const spec = w.spec ?? {};
          const dims = allowedDimensionOptions(semantic, widgetGrain);
          const meas = allowedMeasureOptions(semantic, widgetGrain);
          if (w.type === "chart") {
            wItem.appendChild(
              mkSelect(
                doc,
                "chart.type",
                String(spec.type ?? "bar"),
                [
                  { value: "bar", label: "bar" },
                  { value: "line", label: "line" }
                ],
                (v) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, type: v } })
              )
            );
            wItem.appendChild(
              mkSelect(
                doc,
                "x.dimension",
                String(spec?.x?.dimension ?? ""),
                dims,
                (v) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, x: { ...spec.x ?? {}, dimension: v } } })
              )
            );
            wItem.appendChild(
              mkSelect(
                doc,
                "y.measure",
                String(spec?.y?.measure ?? ""),
                meas,
                (v) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, y: { ...spec.y ?? {}, measure: v } } })
              )
            );
            wItem.appendChild(
              renderClickActionEditor(
                doc,
                sem,
                "actions.click (drilldown)",
                spec.actions,
                (nextActions) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, actions: nextActions } })
              )
            );
          } else if (w.type === "breakdown") {
            wItem.appendChild(mkSelect(doc, "dimension", String(spec.dimension ?? ""), dims, (v) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, dimension: v } })));
            wItem.appendChild(mkSelect(doc, "measure", String(spec.measure ?? ""), meas, (v) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, measure: v } })));
            wItem.appendChild(mkNumberInput(doc, "limit", asInt(spec.limit, 12), (n) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, limit: n } }), { min: 1, max: 500 }));
            wItem.appendChild(
              renderClickActionEditor(
                doc,
                sem,
                "actions.click (drilldown)",
                spec.actions,
                (nextActions) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, actions: nextActions } })
              )
            );
          } else if (w.type === "stat_value") {
            wItem.appendChild(mkTextInput(doc, "label", String(spec.label ?? ""), (v) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, label: v } })));
            wItem.appendChild(mkSelect(doc, "measure", String(spec.measure ?? ""), meas, (v) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, measure: v } })));
            wItem.appendChild(
              renderClickActionEditor(
                doc,
                sem,
                "actions.click (drilldown)",
                spec.actions,
                (nextActions) => patchWidgetAt(wIdx, { ...w, spec: { ...spec, actions: nextActions } })
              )
            );
          } else if (w.type === "stat_list") {
            const rows = Array.isArray(spec.rows) ? spec.rows : [];
            const rowsBox = doc.createElement("div");
            rowsBox.className = "ga-le-subbox";
            const rh = doc.createElement("div");
            rh.className = "ga-le-subhead";
            rh.textContent = `Rows (${rows.length})`;
            rowsBox.appendChild(rh);
            rowsBox.appendChild(mkBtn(doc, "Add row", () => patchWidgetAt(wIdx, { ...w, spec: { ...spec, rows: [...rows, { label: "Row", measure: "" }] } }), "primary"));
            rows.forEach((r, rIdx) => {
              const rowItem = doc.createElement("div");
              rowItem.className = "ga-le-item";
              rowItem.appendChild(
                mkTextInput(doc, "label", String(r.label ?? ""), (v) => {
                  const nextRows = rows.map((x, i) => i === rIdx ? { ...x, label: v } : x);
                  patchWidgetAt(wIdx, { ...w, spec: { ...spec, rows: nextRows } });
                })
              );
              rowItem.appendChild(
                mkSelect(doc, "measure", String(r.measure ?? ""), meas, (v) => {
                  const nextRows = rows.map((x, i) => i === rIdx ? { ...x, measure: v } : x);
                  patchWidgetAt(wIdx, { ...w, spec: { ...spec, rows: nextRows } });
                })
              );
              rowItem.appendChild(
                renderClickActionEditor(doc, sem, "row.actions.click (drilldown)", r.actions, (nextActions) => {
                  const nextRows = rows.map((x, i) => i === rIdx ? { ...x, actions: nextActions } : x);
                  patchWidgetAt(wIdx, { ...w, spec: { ...spec, rows: nextRows } });
                })
              );
              rowItem.appendChild(
                mkBtn(
                  doc,
                  "Delete row",
                  () => {
                    if (!safeConfirm("Delete this row?")) return;
                    patchWidgetAt(wIdx, { ...w, spec: { ...spec, rows: rows.filter((_, i) => i !== rIdx) } });
                  },
                  "danger"
                )
              );
              rowsBox.appendChild(rowItem);
            });
            wItem.appendChild(rowsBox);
          } else {
            wItem.appendChild(renderWidgetSpecEditorPlaceholder(doc));
          }
          wItem.appendChild(renderAdvancedJson(doc, "Advanced JSON (spec)", spec, (nextSpec) => patchWidgetAt(wIdx, { ...w, spec: nextSpec })));
          det.appendChild(wItem);
          return det;
        };
        const byCat = { graphs: [], statrows: [], boxes: [], other: [] };
        children.forEach((w, i) => {
          const t = String(w?.type ?? "");
          if (t === "chart" || t === "breakdown") byCat.graphs.push(i);
          else if (t === "stat_list") byCat.statrows.push(i);
          else if (t === "stat_value" || t === "record_list" || t === "leader_list") byCat.boxes.push(i);
          else byCat.other.push(i);
        });
        const renderCat = (title, idxs) => {
          const det = doc.createElement("details");
          det.className = "ga-le-details";
          det.open = true;
          const sum = doc.createElement("summary");
          sum.textContent = `${title} (${idxs.length})`;
          det.appendChild(sum);
          const host = doc.createElement("div");
          host.className = "ga-le-item";
          idxs.forEach((i) => host.appendChild(renderWidgetEditor(children[i], i)));
          det.appendChild(host);
          body.appendChild(det);
        };
        renderCat("Graphs", byCat.graphs);
        renderCat("Stat rows", byCat.statrows);
        renderCat("Boxes", byCat.boxes);
        if (byCat.other.length) renderCat("Other", byCat.other);
        panel.appendChild(body);
        overlay.appendChild(bg);
        overlay.appendChild(panel);
        wrap.appendChild(overlay);
      }
      void sem;
      return true;
    }
    const render = () => {
      root.innerHTML = "";
      if (renderPanels()) return;
      const left = doc.createElement("div");
      left.className = "ga-le-left";
      const right = doc.createElement("div");
      right.className = "ga-le-right";
      const sections = draft.dashboard.sections ?? [] ?? [];
      if (active.kind === "section") {
        if (active.idx < 0) active = { kind: "section", idx: 0 };
        if (active.idx >= sections.length) active = { kind: "section", idx: Math.max(0, sections.length - 1) };
      }
      const leftHead = doc.createElement("div");
      leftHead.className = "ga-le-left-head";
      leftHead.appendChild(
        mkBtn(
          doc,
          "Add section",
          () => {
            const next = cloneJson2(draft);
            next.dashboard.sections = [...next.dashboard.sections ?? [], defaultSection()];
            draft = next;
            active = { kind: "section", idx: next.dashboard.sections.length - 1 };
            markDirty();
          },
          "primary"
        )
      );
      left.appendChild(leftHead);
      const list = doc.createElement("div");
      list.className = "ga-le-list";
      const globalItem = doc.createElement("button");
      globalItem.type = "button";
      globalItem.className = "ga-le-list-item";
      globalItem.classList.toggle("active", active.kind === "global_filters");
      globalItem.textContent = "Global filters";
      globalItem.addEventListener("click", () => {
        active = { kind: "global_filters" };
        render();
      });
      list.appendChild(globalItem);
      sections.forEach((s, idx) => {
        const item = doc.createElement("button");
        item.type = "button";
        item.className = "ga-le-list-item";
        item.classList.toggle("active", active.kind === "section" && active.idx === idx);
        item.textContent = s.title || s.id || "(untitled)";
        item.addEventListener("click", () => {
          active = { kind: "section", idx };
          render();
        });
        list.appendChild(item);
      });
      left.appendChild(list);
      if (active.kind === "global_filters") {
        renderGlobalFilters(right);
        root.appendChild(left);
        root.appendChild(right);
        return;
      }
      const section = sections[active.idx];
      if (!section) {
        const note = doc.createElement("div");
        note.className = "ga-settings-note";
        note.textContent = "No sections yet. Click Add section to get started.";
        right.appendChild(note);
        root.appendChild(left);
        root.appendChild(right);
        return;
      }
      if (lastSectionIdx !== active.idx) {
        lastSectionIdx = active.idx;
        focusCardIdx = 0;
        focusWidgetIdx = 0;
        scrollToId = null;
      }
      const topRow = doc.createElement("div");
      topRow.className = "ga-le-toprow";
      topRow.appendChild(
        mkBtn(doc, "Move up", () => {
          if (active.idx <= 0) return;
          const next = cloneJson2(draft);
          const arr = [...next.dashboard.sections];
          const [picked] = arr.splice(active.idx, 1);
          arr.splice(active.idx - 1, 0, picked);
          next.dashboard.sections = arr;
          draft = next;
          active = { kind: "section", idx: active.idx - 1 };
          markDirty();
        })
      );
      topRow.appendChild(
        mkBtn(doc, "Move down", () => {
          if (active.idx >= sections.length - 1) return;
          const next = cloneJson2(draft);
          const arr = [...next.dashboard.sections];
          const [picked] = arr.splice(active.idx, 1);
          arr.splice(active.idx + 1, 0, picked);
          next.dashboard.sections = arr;
          draft = next;
          active = { kind: "section", idx: active.idx + 1 };
          markDirty();
        })
      );
      topRow.appendChild(
        mkBtn(
          doc,
          "Delete",
          () => {
            setStatus("info", "Deleting section\u2026");
            if (!safeConfirm(`Delete section '${section.title || section.id}'?`)) return;
            const next = cloneJson2(draft);
            next.dashboard.sections = next.dashboard.sections.filter((_, i) => i !== active.idx);
            draft = next;
            active = { kind: "section", idx: Math.max(0, active.idx - 1) };
            markDirty();
          },
          "danger"
        )
      );
      right.appendChild(topRow);
      const patchSection = (partial) => {
        const next = cloneJson2(draft);
        next.dashboard.sections[active.idx] = { ...next.dashboard.sections[active.idx], ...partial };
        draft = next;
        markDirty();
      };
      right.appendChild(mkTextInput(doc, "section.id", section.id, (v) => patchSection({ id: v })));
      right.appendChild(mkTextInput(doc, "section.title", section.title, (v) => patchSection({ title: v })));
      right.appendChild(
        mkNumberInput(
          doc,
          "layout.columns",
          asInt(section.layout?.columns, 12),
          (n) => patchSection({ layout: { ...section.layout, columns: Math.max(1, Math.min(24, n)) } }),
          { min: 1, max: 24 }
        )
      );
      const gf = draft.dashboard.globalFilters;
      const controlIds = gf?.enabled ? (gf.controls ?? []).map((c) => c.id) : [];
      const ctrlOpts = controlIds.map((id) => ({ value: id, label: id }));
      const include = Array.isArray(section?.filterScope?.include) ? section.filterScope.include : [];
      const exclude = Array.isArray(section?.filterScope?.exclude) ? section.filterScope.exclude : [];
      if (ctrlOpts.length > 0) {
        const fsBox = doc.createElement("div");
        fsBox.className = "ga-le-box";
        const fsHead = doc.createElement("div");
        fsHead.className = "ga-le-box-head";
        fsHead.textContent = "Global filter visibility (optional)";
        fsBox.appendChild(fsHead);
        const note = doc.createElement("div");
        note.className = "ga-settings-note";
        note.textContent = "Choose which global filter controls are shown for this section. Default: show all.";
        fsBox.appendChild(note);
        const mode2 = include.length ? "only" : exclude.length ? "except" : "all";
        fsBox.appendChild(
          mkSelect(
            doc,
            "Mode",
            mode2,
            [
              { value: "all", label: "Show all filters" },
              { value: "only", label: "Show only selected" },
              { value: "except", label: "Show all except selected" }
            ],
            (v) => {
              if (v === "all") return patchSection({ filterScope: void 0 });
              if (v === "only") return patchSection({ filterScope: normalizeFilterScope({ include, exclude: [] }) });
              return patchSection({ filterScope: normalizeFilterScope({ include: [], exclude }) });
            }
          )
        );
        const selected = mode2 === "only" ? include : mode2 === "except" ? exclude : [];
        if (mode2 !== "all") {
          fsBox.appendChild(
            mkMultiSelect(doc, "Filters", selected, ctrlOpts, (vals) => {
              if (mode2 === "only") return patchSection({ filterScope: normalizeFilterScope({ include: vals, exclude: [] }) });
              return patchSection({ filterScope: normalizeFilterScope({ include: [], exclude: vals }) });
            })
          );
        }
        right.appendChild(fsBox);
      }
      right.appendChild(mkHr(doc));
      const widgetTypes = ["stat_list", "stat_value", "chart", "breakdown", "record_list", "leader_list"];
      const typeOpts = widgetTypes.map((t) => ({ value: t, label: t }));
      const cardsBox = doc.createElement("div");
      cardsBox.className = "ga-le-box";
      const ch = doc.createElement("div");
      ch.className = "ga-le-box-head";
      ch.textContent = "Cards";
      cardsBox.appendChild(ch);
      const patchCard = (cardIdx, partial) => {
        const next = cloneJson2(draft);
        const sec = next.dashboard.sections[active.idx];
        const cards2 = [...sec.layout.cards];
        cards2[cardIdx] = { ...cards2[cardIdx], ...partial };
        sec.layout.cards = cards2;
        draft = next;
        markDirty();
      };
      const patchWidget = (cardIdx, widgetIdx, nextWidget) => {
        const next = cloneJson2(draft);
        const sec = next.dashboard.sections[active.idx];
        const card = sec.layout.cards[cardIdx];
        const children = card.card.children ?? [];
        children[widgetIdx] = nextWidget;
        card.card.children = children;
        draft = next;
        markDirty();
      };
      const moveCard = (cardIdx, delta) => {
        const cards2 = draft.dashboard.sections[active.idx].layout.cards ?? [];
        const nextIdx = cardIdx + delta;
        if (nextIdx < 0 || nextIdx >= cards2.length) return;
        const next = cloneJson2(draft);
        const arr = [...next.dashboard.sections[active.idx].layout.cards];
        const [picked] = arr.splice(cardIdx, 1);
        arr.splice(nextIdx, 0, picked);
        next.dashboard.sections[active.idx].layout.cards = arr;
        draft = next;
        markDirty();
      };
      const moveWidget = (cardIdx, widgetIdx, delta) => {
        const sec = draft.dashboard.sections[active.idx];
        const card = sec.layout.cards[cardIdx];
        const children = card.card.children ?? [];
        const nextIdx = widgetIdx + delta;
        if (nextIdx < 0 || nextIdx >= children.length) return;
        const next = cloneJson2(draft);
        const c = next.dashboard.sections[active.idx].layout.cards[cardIdx];
        const arr = [...c.card.children ?? []];
        const [picked] = arr.splice(widgetIdx, 1);
        arr.splice(nextIdx, 0, picked);
        c.card.children = arr;
        draft = next;
        markDirty();
      };
      const cards = section.layout.cards ?? [] ?? [];
      if (focusCardIdx < 0) focusCardIdx = 0;
      if (focusCardIdx >= cards.length) focusCardIdx = Math.max(0, cards.length - 1);
      const focusedCard = cards[focusCardIdx] ?? null;
      const focusedChildren = focusedCard ? focusedCard.card.children ?? [] : [];
      if (focusWidgetIdx < 0) focusWidgetIdx = 0;
      if (focusWidgetIdx >= focusedChildren.length) focusWidgetIdx = Math.max(0, focusedChildren.length - 1);
      const cardsTop = doc.createElement("div");
      cardsTop.className = "ga-le-toprow";
      cardsTop.appendChild(
        mkBtn(
          doc,
          "Add card",
          () => {
            const next = cloneJson2(draft);
            next.dashboard.sections[active.idx].layout.cards = [...next.dashboard.sections[active.idx].layout.cards ?? [], defaultCard()];
            draft = next;
            focusCardIdx = Math.max(0, (next.dashboard.sections[active.idx].layout.cards ?? []).length - 1);
            focusWidgetIdx = 0;
            scrollToId = `ga-le-card-${focusCardIdx}`;
            markDirty();
          },
          "primary"
        )
      );
      const focusWrap = doc.createElement("label");
      focusWrap.className = "ga-le-toggle";
      const focusInput = doc.createElement("input");
      focusInput.type = "checkbox";
      focusInput.checked = focusMode;
      const focusTxt = doc.createElement("span");
      focusTxt.textContent = "Focus mode";
      focusWrap.appendChild(focusInput);
      focusWrap.appendChild(focusTxt);
      focusInput.addEventListener("change", () => {
        focusMode = focusInput.checked;
        render();
      });
      cardsTop.appendChild(focusWrap);
      cardsTop.appendChild(
        mkBtn(
          doc,
          focusMode ? "Show all" : "Focus selected",
          () => {
            focusMode = !focusMode;
            render();
          },
          "ghost"
        )
      );
      cardsBox.appendChild(cardsTop);
      const cardsLayout = doc.createElement("div");
      cardsLayout.className = "ga-le-cards-layout";
      const outline = doc.createElement("div");
      outline.className = "ga-le-outline";
      const oh = doc.createElement("div");
      oh.className = "ga-le-outline-head";
      oh.textContent = "Outline";
      outline.appendChild(oh);
      const oNote = doc.createElement("div");
      oNote.className = "ga-settings-note";
      oNote.textContent = "Click to jump. In Focus mode only the selected card/widget stays open.";
      outline.appendChild(oNote);
      const oSearch = doc.createElement("input");
      oSearch.type = "text";
      oSearch.placeholder = "Search cards/widgets...";
      oSearch.className = "ga-le-outline-search";
      outline.appendChild(oSearch);
      const oList = doc.createElement("div");
      oList.className = "ga-le-outline-list";
      outline.appendChild(oList);
      const cardsHost = doc.createElement("div");
      cardsHost.className = "ga-le-cards-host";
      cards.forEach((card, cardIdx) => {
        const cardElId = `ga-le-card-${cardIdx}`;
        const cardTitle = `${card.title || "Card"} (${card.cardId})`;
        const cBtn = doc.createElement("button");
        cBtn.type = "button";
        cBtn.className = "ga-le-outline-item";
        cBtn.classList.toggle("active", focusCardIdx === cardIdx);
        cBtn.textContent = cardTitle;
        cBtn.dataset.searchText = cardTitle.toLowerCase();
        cBtn.addEventListener("click", () => {
          focusMode = true;
          focusCardIdx = cardIdx;
          focusWidgetIdx = 0;
          scrollToId = cardElId;
          render();
        });
        oList.appendChild(cBtn);
        const outlineChildren = card.card.children ?? [];
        outlineChildren.forEach((w, wIdx) => {
          const wElId = `ga-le-widget-${cardIdx}-${wIdx}`;
          const wTitle = `${w.type} - ${w.title || w.widgetId}`;
          const wBtn = doc.createElement("button");
          wBtn.type = "button";
          wBtn.className = "ga-le-outline-item ga-le-outline-item-widget";
          wBtn.classList.toggle("active", focusCardIdx === cardIdx && focusWidgetIdx === wIdx);
          wBtn.textContent = wTitle;
          wBtn.dataset.searchText = `${cardTitle} ${wTitle}`.toLowerCase();
          wBtn.addEventListener("click", () => {
            focusMode = true;
            focusCardIdx = cardIdx;
            focusWidgetIdx = wIdx;
            scrollToId = wElId;
            render();
          });
          oList.appendChild(wBtn);
        });
        const details = doc.createElement("details");
        details.id = cardElId;
        details.open = focusMode ? cardIdx === focusCardIdx : true;
        details.className = "ga-le-details";
        const summary = doc.createElement("summary");
        summary.textContent = cardTitle;
        summary.addEventListener("click", (ev) => {
          focusCardIdx = cardIdx;
          if (focusMode) {
            ev.preventDefault();
            focusWidgetIdx = 0;
            scrollToId = cardElId;
            render();
          }
        });
        details.appendChild(summary);
        const cardItem = doc.createElement("div");
        cardItem.className = "ga-le-item";
        const cardActions = doc.createElement("div");
        cardActions.className = "ga-le-toprow";
        cardActions.appendChild(mkBtn(doc, "Up", () => moveCard(cardIdx, -1)));
        cardActions.appendChild(mkBtn(doc, "Down", () => moveCard(cardIdx, 1)));
        cardActions.appendChild(
          mkBtn(
            doc,
            "Delete card",
            () => {
              setStatus("info", "Deleting card\u2026");
              if (!safeConfirm(`Delete card '${card.title || card.cardId}'?`)) return;
              const next = cloneJson2(draft);
              next.dashboard.sections[active.idx].layout.cards = next.dashboard.sections[active.idx].layout.cards.filter((_, i) => i !== cardIdx);
              draft = next;
              markDirty();
            },
            "danger"
          )
        );
        cardItem.appendChild(cardActions);
        cardItem.appendChild(mkTextInput(doc, "cardId", String(card.cardId ?? ""), (v) => patchCard(cardIdx, { cardId: v })));
        cardItem.appendChild(mkTextInput(doc, "title", String(card.title ?? ""), (v) => patchCard(cardIdx, { title: v })));
        const placeNote = doc.createElement("div");
        placeNote.className = "ga-settings-note";
        placeNote.textContent = `Card placement uses the section grid (layout.columns = ${asInt(section.layout?.columns, 12)}): x/y = position, w/h = size (grid units).`;
        cardItem.appendChild(placeNote);
        const grid = doc.createElement("div");
        grid.className = "ga-le-grid4";
        grid.appendChild(mkNumberInput(doc, "x", asInt(card.x, 0), (n) => patchCard(cardIdx, { x: n })));
        grid.appendChild(mkNumberInput(doc, "y", asInt(card.y, 0), (n) => patchCard(cardIdx, { y: n })));
        grid.appendChild(mkNumberInput(doc, "w", asInt(card.w, 12), (n) => patchCard(cardIdx, { w: n })));
        grid.appendChild(mkNumberInput(doc, "h", asInt(card.h, 10), (n) => patchCard(cardIdx, { h: n })));
        cardItem.appendChild(grid);
        const wBox = doc.createElement("div");
        wBox.className = "ga-le-subbox";
        const wh = doc.createElement("div");
        wh.className = "ga-le-subhead";
        const children = card.card.children ?? [];
        wh.textContent = `Widgets (${children.length})`;
        wBox.appendChild(wh);
        wBox.appendChild(
          mkBtn(
            doc,
            "Add widget",
            () => {
              const next = cloneJson2(draft);
              const c = next.dashboard.sections[active.idx].layout.cards[cardIdx];
              const w = defaultWidget(grainDefault, widgetTypes[0]);
              c.card.children = [...c.card.children ?? [], w];
              draft = next;
              focusCardIdx = cardIdx;
              focusWidgetIdx = Math.max(0, (c.card.children ?? []).length - 1);
              scrollToId = `ga-le-widget-${cardIdx}-${focusWidgetIdx}`;
              markDirty();
            },
            "primary"
          )
        );
        children.forEach((w, wIdx) => {
          const wDetails = doc.createElement("details");
          const wElId = `ga-le-widget-${cardIdx}-${wIdx}`;
          wDetails.id = wElId;
          wDetails.open = focusMode ? cardIdx === focusCardIdx && wIdx === focusWidgetIdx : false;
          wDetails.className = "ga-le-details";
          const wSummary = doc.createElement("summary");
          wSummary.addEventListener("click", (ev) => {
            focusCardIdx = cardIdx;
            focusWidgetIdx = wIdx;
            if (focusMode) {
              ev.preventDefault();
              scrollToId = wElId;
              render();
            }
          });
          wSummary.textContent = `${w.type} \u2014 ${w.title || w.widgetId}`;
          wDetails.appendChild(wSummary);
          const wItem = doc.createElement("div");
          wItem.className = "ga-le-widget";
          const wActions = doc.createElement("div");
          wActions.className = "ga-le-toprow";
          wActions.appendChild(mkBtn(doc, "Up", () => moveWidget(cardIdx, wIdx, -1)));
          wActions.appendChild(mkBtn(doc, "Down", () => moveWidget(cardIdx, wIdx, 1)));
          wActions.appendChild(
            mkBtn(
              doc,
              "Delete",
              () => {
                setStatus("info", "Deleting widget\u2026");
                if (!safeConfirm(`Delete widget '${w.title || w.widgetId}'?`)) return;
                const next = cloneJson2(draft);
                const c = next.dashboard.sections[active.idx].layout.cards[cardIdx];
                c.card.children = (c.card.children ?? []).filter((_, i) => i !== wIdx);
                draft = next;
                markDirty();
              },
              "danger"
            )
          );
          wItem.appendChild(wActions);
          wItem.appendChild(mkTextInput(doc, "widgetId", String(w.widgetId ?? ""), (v) => patchWidget(cardIdx, wIdx, { ...w, widgetId: v })));
          wItem.appendChild(
            mkSelect(doc, "type", String(w.type ?? "stat_list"), typeOpts, (v) => {
              const nextWidget = defaultWidget(String(w.grain ?? grainDefault), v);
              nextWidget.widgetId = w.widgetId;
              nextWidget.title = w.title;
              nextWidget.grain = w.grain ?? grainDefault;
              nextWidget.placement = w.placement;
              patchWidget(cardIdx, wIdx, nextWidget);
            })
          );
          wItem.appendChild(mkTextInput(doc, "title", String(w.title ?? ""), (v) => patchWidget(cardIdx, wIdx, { ...w, title: v })));
          const grainNote = doc.createElement("div");
          grainNote.className = "ga-settings-note";
          grainNote.textContent = "grain = the dataset level the widget is calculated on (e.g. round vs. game).";
          wItem.appendChild(grainNote);
          wItem.appendChild(mkSelect(doc, "grain", String(w.grain ?? grainDefault), grainOpts, (v) => patchWidget(cardIdx, wIdx, { ...w, grain: v })));
          const p = w.placement ?? { x: 0, y: 0, w: 12, h: 3 };
          const widgetPlaceNote = doc.createElement("div");
          widgetPlaceNote.className = "ga-settings-note";
          widgetPlaceNote.textContent = `Widget placement uses a grid inside the card: x/y = position, w/h = size (grid units). Tip: keep w within layout.columns (${asInt(section.layout?.columns, 12)}).`;
          wItem.appendChild(widgetPlaceNote);
          const pGrid = doc.createElement("div");
          pGrid.className = "ga-le-grid4";
          pGrid.appendChild(mkNumberInput(doc, "x", asInt(p.x, 0), (n) => patchWidget(cardIdx, wIdx, { ...w, placement: { ...p, x: n } })));
          pGrid.appendChild(mkNumberInput(doc, "y", asInt(p.y, 0), (n) => patchWidget(cardIdx, wIdx, { ...w, placement: { ...p, y: n } })));
          pGrid.appendChild(mkNumberInput(doc, "w", asInt(p.w, 12), (n) => patchWidget(cardIdx, wIdx, { ...w, placement: { ...p, w: n } })));
          pGrid.appendChild(mkNumberInput(doc, "h", asInt(p.h, 3), (n) => patchWidget(cardIdx, wIdx, { ...w, placement: { ...p, h: n } })));
          wItem.appendChild(pGrid);
          const widgetGrain = String(w.grain ?? grainDefault);
          const spec = w.spec ?? {};
          const dims = allowedDimensionOptions(semantic, widgetGrain);
          const meas = allowedMeasureOptions(semantic, widgetGrain);
          if (w.type === "chart") {
            wItem.appendChild(
              mkSelect(
                doc,
                "chart.type",
                String(spec.type ?? "bar"),
                [{ value: "bar", label: "bar" }, { value: "line", label: "line" }],
                (v) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, type: v } })
              )
            );
            wItem.appendChild(
              mkSelect(
                doc,
                "x.dimension",
                String(spec?.x?.dimension ?? ""),
                dims,
                (v) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, x: { ...spec.x ?? {}, dimension: v } } })
              )
            );
            wItem.appendChild(
              mkSelect(
                doc,
                "y.measure",
                String(spec?.y?.measure ?? ""),
                meas,
                (v) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, y: { ...spec.y ?? {}, measure: v } } })
              )
            );
            wItem.appendChild(
              mkToggle(
                doc,
                "actions.hover",
                !!spec?.actions?.hover,
                (v) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, actions: { ...spec.actions ?? {}, hover: v } } })
              )
            );
            wItem.appendChild(
              renderClickActionEditor(
                doc,
                semantic,
                "actions.click (drilldown)",
                spec.actions,
                (nextActions) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, actions: nextActions } })
              )
            );
          } else if (w.type === "breakdown") {
            wItem.appendChild(mkSelect(doc, "dimension", String(spec.dimension ?? ""), dims, (v) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, dimension: v } })));
            wItem.appendChild(mkSelect(doc, "measure", String(spec.measure ?? ""), meas, (v) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, measure: v } })));
            wItem.appendChild(mkNumberInput(doc, "limit", asInt(spec.limit, 12), (n) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, limit: n } }), { min: 1, max: 500 }));
            wItem.appendChild(
              renderClickActionEditor(
                doc,
                semantic,
                "actions.click (drilldown)",
                spec.actions,
                (nextActions) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, actions: nextActions } })
              )
            );
          } else if (w.type === "stat_value") {
            wItem.appendChild(mkTextInput(doc, "label", String(spec.label ?? ""), (v) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, label: v } })));
            wItem.appendChild(mkSelect(doc, "measure", String(spec.measure ?? ""), meas, (v) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, measure: v } })));
            wItem.appendChild(
              renderClickActionEditor(
                doc,
                semantic,
                "actions.click (drilldown)",
                spec.actions,
                (nextActions) => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, actions: nextActions } })
              )
            );
          } else if (w.type === "stat_list") {
            const rows = Array.isArray(spec.rows) ? spec.rows : [];
            const rowsBox = doc.createElement("div");
            rowsBox.className = "ga-le-subbox";
            const rh = doc.createElement("div");
            rh.className = "ga-le-subhead";
            rh.textContent = `Rows (${rows.length})`;
            rowsBox.appendChild(rh);
            rowsBox.appendChild(
              mkBtn(doc, "Add row", () => patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, rows: [...rows, { label: "Row", measure: "" }] } }), "primary")
            );
            rows.forEach((r, rIdx) => {
              const rowItem = doc.createElement("div");
              rowItem.className = "ga-le-item";
              rowItem.appendChild(
                mkTextInput(doc, "label", String(r.label ?? ""), (v) => {
                  const nextRows = rows.map((x, i) => i === rIdx ? { ...x, label: v } : x);
                  patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, rows: nextRows } });
                })
              );
              rowItem.appendChild(
                mkSelect(doc, "measure", String(r.measure ?? ""), meas, (v) => {
                  const nextRows = rows.map((x, i) => i === rIdx ? { ...x, measure: v } : x);
                  patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, rows: nextRows } });
                })
              );
              rowItem.appendChild(
                renderClickActionEditor(doc, semantic, "row.actions.click (drilldown)", r.actions, (nextActions) => {
                  const nextRows = rows.map((x, i) => i === rIdx ? { ...x, actions: nextActions } : x);
                  patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, rows: nextRows } });
                })
              );
              const delRow = doc.createElement("div");
              delRow.className = "ga-le-toprow";
              delRow.appendChild(
                mkBtn(
                  doc,
                  "Delete row",
                  () => {
                    if (!safeConfirm("Delete this row?")) return;
                    const nextRows = rows.filter((_, i) => i !== rIdx);
                    patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, rows: nextRows } });
                  },
                  "danger"
                )
              );
              rowItem.appendChild(delRow);
              rowsBox.appendChild(rowItem);
            });
            wItem.appendChild(rowsBox);
          } else if (w.type === "record_list") {
            const records = Array.isArray(spec.records) ? spec.records : [];
            const recBox = doc.createElement("div");
            recBox.className = "ga-le-subbox";
            const rh = doc.createElement("div");
            rh.className = "ga-le-subhead";
            rh.textContent = `Records (${records.length})`;
            recBox.appendChild(rh);
            const addRecord = mkBtn(
              doc,
              "Add record",
              () => {
                const id = `rec_${Math.random().toString(36).slice(2, 7)}`;
                const next = [...records, { id, label: "Record", kind: "group_extreme", extreme: "max" }];
                patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, records: next } });
              },
              "primary"
            );
            recBox.appendChild(addRecord);
            const recNote = doc.createElement("div");
            recNote.className = "ga-settings-note";
            recNote.textContent = "Records are configurable items (not stat rows). Use kind + fields below, or Advanced JSON for full control.";
            recBox.appendChild(recNote);
            const kindOpts = [
              { value: "group_extreme", label: "group_extreme" },
              { value: "streak", label: "streak" },
              { value: "same_value_streak", label: "same_value_streak" }
            ];
            const extremeOpts = [
              { value: "max", label: "max" },
              { value: "min", label: "min" }
            ];
            const displayKeyOpts = [
              { value: "group", label: "group" },
              { value: "first_ts", label: "first_ts" },
              { value: "first_ts_score", label: "first_ts_score" }
            ];
            records.forEach((r, rIdx) => {
              const rDetails = doc.createElement("details");
              rDetails.open = false;
              rDetails.className = "ga-le-details";
              const sum = doc.createElement("summary");
              sum.textContent = `${r.label || "Record"} (${r.id || rIdx})`;
              rDetails.appendChild(sum);
              const item = doc.createElement("div");
              item.className = "ga-le-item";
              const top = doc.createElement("div");
              top.className = "ga-le-toprow";
              top.appendChild(
                mkBtn(
                  doc,
                  "Delete record",
                  () => {
                    if (!safeConfirm("Delete this record?")) return;
                    const next = records.filter((_, i) => i !== rIdx);
                    patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, records: next } });
                  },
                  "danger"
                )
              );
              item.appendChild(top);
              const patchRecord = (nextRec) => {
                const next = records.map((x, i) => i === rIdx ? nextRec : x);
                patchWidget(cardIdx, wIdx, { ...w, spec: { ...spec, records: next } });
              };
              item.appendChild(mkTextInput(doc, "id", String(r.id ?? ""), (v) => patchRecord({ ...r, id: v })));
              item.appendChild(mkTextInput(doc, "label", String(r.label ?? ""), (v) => patchRecord({ ...r, label: v })));
              item.appendChild(mkSelect(doc, "kind", String(r.kind ?? "group_extreme"), kindOpts, (v) => patchRecord({ ...r, kind: v })));
              item.appendChild(mkSelect(doc, "displayKey", String(r.displayKey ?? "group"), displayKeyOpts, (v) => patchRecord({ ...r, displayKey: v })));
              if ((r.kind ?? "group_extreme") === "group_extreme") {
                item.appendChild(mkSelect(doc, "metric", String(r.metric ?? ""), meas, (v) => patchRecord({ ...r, metric: v })));
                item.appendChild(mkSelect(doc, "groupBy", String(r.groupBy ?? ""), dims, (v) => patchRecord({ ...r, groupBy: v })));
                item.appendChild(mkSelect(doc, "extreme", String(r.extreme ?? "max"), extremeOpts, (v) => patchRecord({ ...r, extreme: v })));
              }
              if ((r.kind ?? "") === "same_value_streak") {
                item.appendChild(mkSelect(doc, "dimension", String(r.dimension ?? ""), dims, (v) => patchRecord({ ...r, dimension: v })));
              }
              item.appendChild(
                renderClickActionEditor(doc, semantic, "actions.click (drilldown)", r.actions, (nextActions) => {
                  patchRecord({ ...r, actions: nextActions });
                })
              );
              item.appendChild(renderAdvancedJson(doc, "Advanced JSON (record)", r, (next) => patchRecord(next)));
              rDetails.appendChild(item);
              recBox.appendChild(rDetails);
            });
            wItem.appendChild(recBox);
          } else {
            wItem.appendChild(renderWidgetSpecEditorPlaceholder(doc));
          }
          wItem.appendChild(renderAdvancedJson(doc, "Advanced JSON (spec)", spec, (next) => patchWidget(cardIdx, wIdx, { ...w, spec: next })));
          wDetails.appendChild(wItem);
          wBox.appendChild(wDetails);
        });
        cardItem.appendChild(wBox);
        details.appendChild(cardItem);
        cardsHost.appendChild(details);
      });
      oSearch.addEventListener("input", () => {
        const q = oSearch.value.trim().toLowerCase();
        const items = Array.from(oList.querySelectorAll("button"));
        for (const it of items) {
          const hay = String(it.dataset.searchText ?? "").toLowerCase();
          it.style.display = !q || hay.includes(q) ? "" : "none";
        }
      });
      cardsLayout.appendChild(outline);
      cardsLayout.appendChild(cardsHost);
      cardsBox.appendChild(cardsLayout);
      right.appendChild(cardsBox);
      root.appendChild(left);
      root.appendChild(right);
      if (scrollToId) {
        const el2 = doc.getElementById(scrollToId);
        scrollToId = null;
        if (el2) {
          try {
            el2.classList.add("ga-le-flash");
            el2.scrollIntoView?.({ behavior: "smooth", block: "start" });
            win?.setTimeout?.(() => el2.classList.remove("ga-le-flash"), 900);
          } catch {
          }
        }
      }
    };
    render();
    const initRes = validateDraft();
    if (!initRes.ok) setStatus("error", initRes.error);
    return wrap;
  }
  function defaultCard() {
    return {
      cardId: `card_${Math.random().toString(36).slice(2, 7)}`,
      title: "Card",
      x: 0,
      y: 0,
      w: 12,
      h: 10,
      card: { type: "composite", children: [] }
    };
  }
  function defaultSection() {
    return {
      id: `section_${Math.random().toString(36).slice(2, 7)}`,
      title: "New Section",
      layout: { mode: "grid", columns: 12, cards: [defaultCard()] }
    };
  }
  function defaultWidget(grain, type, columns = 12) {
    const widgetId = `w_${type}_${Math.random().toString(36).slice(2, 7)}`;
    const w = Math.max(1, Math.min(24, asInt(columns, 12)));
    const placement = { x: 0, y: 0, w, h: 3 };
    const base = { widgetId, type, title: type, grain, placement };
    if (type === "stat_value") base.spec = { label: "Value", measure: "" };
    else if (type === "stat_list") base.spec = { rows: [{ label: "Row", measure: "" }] };
    else if (type === "chart") base.spec = { type: "bar", x: { dimension: "" }, y: { measure: "" }, actions: { hover: true } };
    else if (type === "breakdown") base.spec = { dimension: "", measure: "", limit: 12 };
    else if (type === "record_list") base.spec = { records: [] };
    else base.spec = {};
    return base;
  }
  function normalizeFilterScope(fs) {
    const include = Array.isArray(fs?.include) ? fs.include.filter((x) => typeof x === "string" && x.trim()) : [];
    const exclude = Array.isArray(fs?.exclude) ? fs.exclude.filter((x) => typeof x === "string" && x.trim()) : [];
    const out = {};
    if (include.length) out.include = include;
    if (exclude.length) out.exclude = exclude;
    return Object.keys(out).length ? out : void 0;
  }
  function renderWidgetSpecEditorPlaceholder(doc) {
    const note = doc.createElement("div");
    note.className = "ga-settings-note";
    note.textContent = "Advanced widget settings are available in the Advanced JSON editor below.";
    return note;
  }
  function renderAdvancedJson(doc, title, value, onApply) {
    const details = doc.createElement("details");
    details.className = "ga-le-adv";
    const summary = doc.createElement("summary");
    summary.textContent = title;
    details.appendChild(summary);
    const areaField = mkField(doc, "JSON");
    const area = doc.createElement("textarea");
    area.value = JSON.stringify(value ?? {}, null, 2);
    areaField.inputHost.appendChild(area);
    details.appendChild(areaField.wrap);
    const actions = doc.createElement("div");
    actions.className = "ga-le-toprow";
    actions.appendChild(
      mkBtn(doc, "Format", () => {
        try {
          const parsed = JSON.parse(area.value);
          area.value = JSON.stringify(parsed, null, 2);
        } catch {
        }
      })
    );
    actions.appendChild(
      mkBtn(
        doc,
        "Apply JSON",
        () => {
          const parsed = JSON.parse(area.value);
          onApply(parsed);
        },
        "primary"
      )
    );
    details.appendChild(actions);
    return details;
  }
  function renderClickActionEditor(doc, semantic, title, actions, onChange) {
    const box = doc.createElement("div");
    box.className = "ga-le-subbox";
    const head = doc.createElement("div");
    head.className = "ga-le-subhead";
    head.textContent = title;
    box.appendChild(head);
    const current = actions ?? {};
    const click = current?.click ?? null;
    const drilldownPresets = semantic?.drilldownPresets ?? {};
    const targetIds = Object.keys(drilldownPresets);
    const targetOptions = targetIds.length > 0 ? targetIds.map((t) => ({ value: t, label: t })) : ["rounds", "games", "sessions", "players"].map((t) => ({ value: t, label: t }));
    const normalizeTarget = (value) => {
      const s = String(value ?? "");
      return targetOptions.some((o) => o.value === s) ? s : String(targetOptions[0]?.value ?? "rounds");
    };
    const defaultClickForTarget = (target) => {
      const preset = drilldownPresets?.[target];
      const keys2 = Object.keys(preset?.columnsPresets ?? {});
      const columnsPreset = String(preset?.defaultPreset ?? keys2[0] ?? "default");
      return { type: "drilldown", target, columnsPreset };
    };
    box.appendChild(
      mkToggle(doc, "enabled", !!click, (enabled) => {
        const next = { ...current ?? {} };
        if (!enabled) delete next.click;
        else {
          const target = normalizeTarget(click?.target);
          next.click = defaultClickForTarget(target);
        }
        onChange(next);
      })
    );
    if (!click) return box;
    const storedTarget = String(click?.target ?? "");
    const uiTarget = normalizeTarget(storedTarget || (targetOptions[0]?.value ?? "rounds"));
    box.appendChild(
      mkSelect(
        doc,
        "target",
        uiTarget,
        targetOptions,
        (v) => {
          const preset = drilldownPresets?.[v];
          const keys2 = Object.keys(preset?.columnsPresets ?? {});
          const currentPreset = String(click.columnsPreset ?? "");
          const nextPreset = keys2.includes(currentPreset) ? currentPreset : String(preset?.defaultPreset ?? keys2[0] ?? currentPreset ?? "default");
          onChange({ ...current ?? {}, click: { ...click, target: v, columnsPreset: nextPreset } });
        }
      )
    );
    if (storedTarget && storedTarget !== uiTarget) {
      const warn = doc.createElement("div");
      warn.className = "ga-settings-note";
      warn.textContent = `Unknown target '${storedTarget}'. Select a valid target or click Fix to use '${uiTarget}'.`;
      box.appendChild(warn);
      box.appendChild(mkBtn(doc, "Fix target", () => onChange({ ...current ?? {}, click: defaultClickForTarget(uiTarget) }), "primary"));
    }
    const currentTarget = uiTarget;
    const targetPreset = drilldownPresets?.[currentTarget];
    const presetKeys = Object.keys(targetPreset?.columnsPresets ?? {});
    if (presetKeys.length > 0) {
      const presetOptions = presetKeys.map((k) => ({
        value: k,
        label: `${k} (${(targetPreset?.columnsPresets?.[k] ?? []).length})`
      }));
      const wanted = String(click.columnsPreset ?? "");
      const safeValue = presetKeys.includes(wanted) ? wanted : String(targetPreset?.defaultPreset ?? presetKeys[0]);
      box.appendChild(mkSelect(doc, "columnsPreset", safeValue, presetOptions, (v) => onChange({ ...current ?? {}, click: { ...click, columnsPreset: v } })));
      if (wanted && wanted !== safeValue) {
        const warn = doc.createElement("div");
        warn.className = "ga-settings-note";
        warn.textContent = `Unknown columnsPreset '${wanted}' for target '${currentTarget}'. Click Fix to use '${safeValue}'.`;
        box.appendChild(warn);
        box.appendChild(mkBtn(doc, "Fix columnsPreset", () => onChange({ ...current ?? {}, click: { ...click, columnsPreset: safeValue } }), "primary"));
      }
      const presetNote = doc.createElement("div");
      presetNote.className = "ga-settings-note";
      presetNote.textContent = "columnsPreset selects a predefined set of columns for the drilldown table (per target).";
      box.appendChild(presetNote);
    } else {
      box.appendChild(
        mkTextInput(doc, "columnsPreset", String(click.columnsPreset ?? ""), (v) => onChange({ ...current ?? {}, click: { ...click, columnsPreset: v } }))
      );
      const presetNote = doc.createElement("div");
      presetNote.className = "ga-settings-note";
      presetNote.textContent = "No presets found for this target. If drilldown fails validation, check semantic.json drilldownPresets.";
      box.appendChild(presetNote);
    }
    box.appendChild(mkToggle(doc, "filterFromPoint", !!click.filterFromPoint, (v) => onChange({ ...current ?? {}, click: { ...click, filterFromPoint: v } })));
    const sortBox = doc.createElement("div");
    sortBox.className = "ga-le-subbox";
    const sh = doc.createElement("div");
    sh.className = "ga-le-subhead";
    sh.textContent = "initialSort (optional)";
    sortBox.appendChild(sh);
    sortBox.appendChild(
      mkTextInput(doc, "key", String(click?.initialSort?.key ?? ""), (v) => {
        const key = v.trim();
        if (!key) {
          const nextClick = { ...click };
          delete nextClick.initialSort;
          return onChange({ ...current ?? {}, click: nextClick });
        }
        onChange({ ...current ?? {}, click: { ...click, initialSort: { key, dir: click?.initialSort?.dir ?? "desc" } } });
      })
    );
    sortBox.appendChild(
      mkSelect(doc, "dir", String(click?.initialSort?.dir ?? "desc"), [{ value: "asc", label: "asc" }, { value: "desc", label: "desc" }], (v) => {
        if (!click?.initialSort?.key) return;
        onChange({ ...current ?? {}, click: { ...click, initialSort: { ...click.initialSort, dir: v } } });
      })
    );
    box.appendChild(sortBox);
    const note = doc.createElement("div");
    note.className = "ga-settings-note";
    note.textContent = "For extraFilters and advanced settings, use Advanced JSON.";
    box.appendChild(note);
    return box;
  }

  // src/ui/settingsModal.ts
  function attachSettingsModal(opts) {
    const {
      doc,
      targetWindow,
      root,
      openButton,
      semantic,
      getDashboard,
      getDefaultDashboard,
      applyDashboard,
      getSettings,
      applySettings
    } = opts;
    const cloneDashboard = (value) => {
      if (typeof structuredClone === "function") return structuredClone(value);
      return JSON.parse(JSON.stringify(value));
    };
    const settingsModal = doc.createElement("div");
    settingsModal.className = "ga-settings-modal";
    settingsModal.style.display = "none";
    root.appendChild(settingsModal);
    const openSettings = async () => {
      settingsModal.innerHTML = "";
      settingsModal.style.display = "block";
      const bg = doc.createElement("div");
      bg.className = "ga-settings-bg";
      bg.addEventListener("click", () => {
        settingsModal.style.display = "none";
      });
      const panel = doc.createElement("div");
      panel.className = "ga-settings-panel";
      const header = doc.createElement("div");
      header.className = "ga-settings-header";
      const headerTitle = doc.createElement("div");
      headerTitle.textContent = "Dashboard Settings";
      const headerClose = doc.createElement("button");
      headerClose.className = "ga-close";
      headerClose.textContent = "Close";
      headerClose.addEventListener("click", () => {
        settingsModal.style.display = "none";
      });
      header.appendChild(headerTitle);
      header.appendChild(headerClose);
      const bodyEl = doc.createElement("div");
      bodyEl.className = "ga-settings-body";
      const tabs = doc.createElement("div");
      tabs.className = "ga-settings-tabs";
      const panes = doc.createElement("div");
      const appearanceTab = doc.createElement("button");
      appearanceTab.className = "ga-settings-tab active";
      appearanceTab.textContent = "Appearance";
      const standardsTab = doc.createElement("button");
      standardsTab.className = "ga-settings-tab";
      standardsTab.textContent = "Standards";
      const templateTab = doc.createElement("button");
      templateTab.className = "ga-settings-tab";
      templateTab.textContent = "Template";
      const sectionLayoutTab = doc.createElement("button");
      sectionLayoutTab.className = "ga-settings-tab";
      sectionLayoutTab.textContent = "Section Layout";
      const globalFiltersTab = doc.createElement("button");
      globalFiltersTab.className = "ga-settings-tab";
      globalFiltersTab.textContent = "Global Filters";
      const drilldownsTab = doc.createElement("button");
      drilldownsTab.className = "ga-settings-tab";
      drilldownsTab.textContent = "Drilldowns";
      tabs.appendChild(appearanceTab);
      tabs.appendChild(standardsTab);
      tabs.appendChild(sectionLayoutTab);
      tabs.appendChild(globalFiltersTab);
      tabs.appendChild(drilldownsTab);
      tabs.appendChild(templateTab);
      const settings = getSettings();
      let dashboard = getDashboard();
      const appearancePane = doc.createElement("div");
      appearancePane.className = "ga-settings-pane active";
      const appearanceGrid = doc.createElement("div");
      appearanceGrid.className = "ga-settings-grid";
      const themeField = doc.createElement("div");
      themeField.className = "ga-settings-field";
      const themeLabel = doc.createElement("label");
      themeLabel.textContent = "Theme";
      const themeSelect = doc.createElement("select");
      themeSelect.innerHTML = `
      <option value="geoguessr">GeoGuessr</option>
      <option value="dark">Dark</option>
      <option value="light">Light</option>
    `;
      themeSelect.value = settings.appearance.theme;
      themeField.appendChild(themeLabel);
      themeField.appendChild(themeSelect);
      const colorField = doc.createElement("div");
      colorField.className = "ga-settings-field";
      const colorLabel = doc.createElement("label");
      colorLabel.textContent = "Graph color";
      const colorInput = doc.createElement("input");
      colorInput.type = "color";
      colorInput.value = normalizeColor(settings.appearance.graphColor, DEFAULT_SETTINGS.appearance.graphColor);
      colorField.appendChild(colorLabel);
      colorField.appendChild(colorInput);
      const animField = doc.createElement("div");
      animField.className = "ga-settings-field";
      const animLabel = doc.createElement("label");
      animLabel.textContent = "Chart animations";
      const animSelect = doc.createElement("select");
      animSelect.innerHTML = `<option value="on">On</option><option value="off">Off</option>`;
      animSelect.value = settings.appearance.chartAnimations ? "on" : "off";
      animField.appendChild(animLabel);
      animField.appendChild(animSelect);
      appearanceGrid.appendChild(themeField);
      appearanceGrid.appendChild(colorField);
      appearanceGrid.appendChild(animField);
      appearancePane.appendChild(appearanceGrid);
      const syncAppearanceUi = () => {
        const isGeoGuessr = themeSelect.value === "geoguessr";
        colorInput.disabled = isGeoGuessr;
        colorInput.title = isGeoGuessr ? "GeoGuessr theme uses a tuned graph color." : "";
      };
      syncAppearanceUi();
      const standardsPane = doc.createElement("div");
      standardsPane.className = "ga-settings-pane";
      const standardsGrid = doc.createElement("div");
      standardsGrid.className = "ga-settings-grid";
      const dateField = doc.createElement("div");
      dateField.className = "ga-settings-field";
      const dateLabel = doc.createElement("label");
      dateLabel.textContent = "Date format";
      const dateSelect = doc.createElement("select");
      dateSelect.innerHTML = `
      <option value="dd/mm/yyyy">DD/MM/YYYY</option>
      <option value="mm/dd/yyyy">MM/DD/YYYY</option>
      <option value="yyyy-mm-dd">YYYY-MM-DD</option>
      <option value="locale">Locale</option>
    `;
      dateSelect.value = settings.standards.dateFormat;
      dateField.appendChild(dateLabel);
      dateField.appendChild(dateSelect);
      const sessionField = doc.createElement("div");
      sessionField.className = "ga-settings-field";
      const sessionLabel = doc.createElement("label");
      sessionLabel.textContent = "New session gap (minutes)";
      const sessionInput = doc.createElement("input");
      sessionInput.type = "number";
      sessionInput.min = "1";
      sessionInput.max = "360";
      sessionInput.step = "1";
      sessionInput.value = String(settings.standards.sessionGapMinutes);
      sessionField.appendChild(sessionLabel);
      sessionField.appendChild(sessionInput);
      const countryField = doc.createElement("div");
      countryField.className = "ga-settings-field";
      const countryLabel = doc.createElement("label");
      countryLabel.textContent = "Country format";
      const countrySelect = doc.createElement("select");
      countrySelect.innerHTML = `
      <option value="iso2">ISO2 (e.g. US)</option>
      <option value="english">English (e.g. United States)</option>
    `;
      countrySelect.value = settings.standards.countryFormat;
      countryField.appendChild(countryLabel);
      countryField.appendChild(countrySelect);
      standardsGrid.appendChild(dateField);
      standardsGrid.appendChild(sessionField);
      standardsGrid.appendChild(countryField);
      standardsPane.appendChild(standardsGrid);
      const standardsNote = doc.createElement("div");
      standardsNote.className = "ga-settings-note";
      standardsNote.textContent = "Date format is applied in drilldowns. Session gap is stored as a standard value for session-based views. Country format affects country labels (confusion matrix stays ISO2).";
      standardsPane.appendChild(standardsNote);
      const templatePane = doc.createElement("div");
      templatePane.className = "ga-settings-pane";
      const templateWarn = doc.createElement("div");
      templateWarn.className = "ga-settings-note";
      templateWarn.textContent = "Warning: Editing the template JSON can easily break the dashboard. Prefer Section Layout / Global Filters / Drilldowns unless you know what you're doing.";
      templatePane.appendChild(templateWarn);
      const templateField = doc.createElement("div");
      templateField.className = "ga-settings-field";
      const templateLabel = doc.createElement("label");
      templateLabel.textContent = "Live dashboard JSON template";
      const templateEditor = doc.createElement("textarea");
      templateEditor.value = JSON.stringify(dashboard, null, 2);
      const templateStatus = doc.createElement("div");
      templateStatus.className = "ga-settings-status";
      templateField.appendChild(templateLabel);
      templateField.appendChild(templateEditor);
      templatePane.appendChild(templateField);
      const templateActions = doc.createElement("div");
      templateActions.className = "ga-settings-actions";
      const templateDownload = doc.createElement("button");
      templateDownload.type = "button";
      templateDownload.className = "ga-filter-btn";
      templateDownload.textContent = "Download template";
      templateDownload.title = "Download the current dashboard template as JSON";
      const templateUpload = doc.createElement("button");
      templateUpload.type = "button";
      templateUpload.className = "ga-filter-btn";
      templateUpload.textContent = "Upload template";
      templateUpload.title = "Upload a dashboard template JSON file";
      const templateUploadInput = doc.createElement("input");
      templateUploadInput.type = "file";
      templateUploadInput.accept = "application/json,.json";
      templateUploadInput.style.display = "none";
      const templateReset = doc.createElement("button");
      templateReset.type = "button";
      templateReset.className = "ga-filter-btn";
      templateReset.textContent = "Reset to latest";
      templateReset.title = "Reset template to the latest bundled dashboard.json";
      templateActions.appendChild(templateDownload);
      templateActions.appendChild(templateUpload);
      templateActions.appendChild(templateUploadInput);
      templateActions.appendChild(templateReset);
      templatePane.appendChild(templateActions);
      templatePane.appendChild(templateStatus);
      const sectionLayoutPane = doc.createElement("div");
      sectionLayoutPane.className = "ga-settings-pane";
      const sectionLayoutStatus = doc.createElement("div");
      sectionLayoutStatus.className = "ga-settings-status";
      const sectionLayoutHost = doc.createElement("div");
      sectionLayoutPane.appendChild(sectionLayoutHost);
      sectionLayoutPane.appendChild(sectionLayoutStatus);
      const globalFiltersPane = doc.createElement("div");
      globalFiltersPane.className = "ga-settings-pane";
      const globalFiltersStatus = doc.createElement("div");
      globalFiltersStatus.className = "ga-settings-status";
      const globalFiltersHost = doc.createElement("div");
      globalFiltersPane.appendChild(globalFiltersHost);
      globalFiltersPane.appendChild(globalFiltersStatus);
      const drilldownsPane = doc.createElement("div");
      drilldownsPane.className = "ga-settings-pane";
      const drilldownsStatus = doc.createElement("div");
      drilldownsStatus.className = "ga-settings-status";
      const drilldownsHost = doc.createElement("div");
      drilldownsPane.appendChild(drilldownsHost);
      drilldownsPane.appendChild(drilldownsStatus);
      panes.appendChild(appearancePane);
      panes.appendChild(standardsPane);
      panes.appendChild(sectionLayoutPane);
      panes.appendChild(globalFiltersPane);
      panes.appendChild(drilldownsPane);
      panes.appendChild(templatePane);
      const renderLayout = (mode, host, status) => {
        host.innerHTML = "";
        const latest = getDashboard();
        dashboard = latest;
        templateEditor.value = JSON.stringify(latest, null, 2);
        host.appendChild(
          renderLayoutEditor({
            doc,
            semantic,
            dashboard: latest,
            mode,
            statusEl: status,
            onChange: (next) => {
              void (async () => {
                try {
                  await applyDashboard(next);
                  dashboard = next;
                  templateEditor.value = JSON.stringify(next, null, 2);
                } catch (e) {
                  status.textContent = e instanceof Error ? e.message : String(e);
                  status.className = "ga-settings-status error";
                }
              })();
            }
          })
        );
      };
      let renderedSectionLayout = false;
      let renderedGlobalFilters = false;
      let renderedDrilldowns = false;
      const setActiveTab = (idx) => {
        const tabButtons = [appearanceTab, standardsTab, sectionLayoutTab, globalFiltersTab, drilldownsTab, templateTab];
        const tabPanes = [appearancePane, standardsPane, sectionLayoutPane, globalFiltersPane, drilldownsPane, templatePane];
        tabButtons.forEach((t, i) => t.classList.toggle("active", i === idx));
        tabPanes.forEach((p, i) => p.classList.toggle("active", i === idx));
        if (idx === 2 && !renderedSectionLayout) {
          renderedSectionLayout = true;
          renderLayout("section_layout", sectionLayoutHost, sectionLayoutStatus);
        }
        if (idx === 3 && !renderedGlobalFilters) {
          renderedGlobalFilters = true;
          renderLayout("global_filters", globalFiltersHost, globalFiltersStatus);
        }
        if (idx === 4 && !renderedDrilldowns) {
          renderedDrilldowns = true;
          renderLayout("drilldowns", drilldownsHost, drilldownsStatus);
        }
      };
      appearanceTab.addEventListener("click", () => setActiveTab(0));
      standardsTab.addEventListener("click", () => setActiveTab(1));
      sectionLayoutTab.addEventListener("click", () => setActiveTab(2));
      globalFiltersTab.addEventListener("click", () => setActiveTab(3));
      drilldownsTab.addEventListener("click", () => setActiveTab(4));
      templateTab.addEventListener("click", () => setActiveTab(5));
      const persistSettings = async () => {
        const next = {
          appearance: {
            theme: normalizeTheme(themeSelect.value),
            graphColor: normalizeColor(colorInput.value, DEFAULT_SETTINGS.appearance.graphColor),
            chartAnimations: animSelect.value !== "off"
          },
          standards: {
            dateFormat: normalizeDateFormat(dateSelect.value),
            sessionGapMinutes: (() => {
              const raw = Number(sessionInput.value);
              return Number.isFinite(raw) ? Math.max(1, Math.min(360, Math.round(raw))) : DEFAULT_SETTINGS.standards.sessionGapMinutes;
            })(),
            countryFormat: normalizeCountryFormat(countrySelect.value)
          }
        };
        await applySettings(next);
      };
      themeSelect.addEventListener("change", () => {
        syncAppearanceUi();
        void persistSettings();
      });
      colorInput.addEventListener("input", () => {
        void persistSettings();
      });
      animSelect.addEventListener("change", () => {
        void persistSettings();
      });
      dateSelect.addEventListener("change", () => {
        void persistSettings();
      });
      sessionInput.addEventListener("change", () => {
        void persistSettings();
      });
      countrySelect.addEventListener("change", () => {
        void persistSettings();
      });
      let templateDebounce = null;
      const tryApplyTemplate = async () => {
        templateStatus.textContent = "";
        templateStatus.className = "ga-settings-status";
        try {
          const parsed = JSON.parse(templateEditor.value);
          validateDashboardAgainstSemantic(mergeSemanticWithDashboard(semantic, parsed), parsed);
          await applyDashboard(parsed);
          dashboard = parsed;
          templateStatus.textContent = "Template applied.";
          templateStatus.classList.add("ok");
        } catch (error) {
          templateStatus.textContent = error instanceof Error ? error.message : String(error);
          templateStatus.classList.add("error");
        }
      };
      const downloadTextFile = (filename, text) => {
        const blob = new Blob([text], { type: "application/json;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = doc.createElement("a");
        a.href = url;
        a.download = filename;
        (doc.body ?? doc.documentElement).appendChild(a);
        a.click();
        a.remove();
        targetWindow.setTimeout(() => URL.revokeObjectURL(url), 0);
      };
      templateDownload.addEventListener("click", () => {
        try {
          const parsed = JSON.parse(templateEditor.value);
          validateDashboardAgainstSemantic(mergeSemanticWithDashboard(semantic, parsed), parsed);
          const stamp = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
          downloadTextFile(`geoanalyzr-dashboard-template-${stamp}.json`, JSON.stringify(parsed, null, 2));
          templateStatus.textContent = "Template downloaded.";
          templateStatus.className = "ga-settings-status ok";
        } catch (error) {
          templateStatus.textContent = error instanceof Error ? error.message : String(error);
          templateStatus.className = "ga-settings-status error";
        }
      });
      templateUpload.addEventListener("click", () => {
        templateUploadInput.value = "";
        templateUploadInput.click();
      });
      templateUploadInput.addEventListener("change", () => {
        const f = templateUploadInput.files?.[0] ?? null;
        if (!f) return;
        const reader = new FileReader();
        reader.onload = () => {
          const text = typeof reader.result === "string" ? reader.result : "";
          templateEditor.value = text;
          void tryApplyTemplate();
        };
        reader.onerror = () => {
          templateStatus.textContent = "Failed to read file.";
          templateStatus.className = "ga-settings-status error";
        };
        reader.readAsText(f);
      });
      templateReset.addEventListener("click", () => {
        void (async () => {
          templateStatus.textContent = "";
          templateStatus.className = "ga-settings-status";
          try {
            const next = cloneDashboard(getDefaultDashboard());
            validateDashboardAgainstSemantic(mergeSemanticWithDashboard(semantic, next), next);
            await applyDashboard(next);
            dashboard = next;
            templateEditor.value = JSON.stringify(next, null, 2);
            templateStatus.textContent = "Template reset to latest version.";
            templateStatus.classList.add("ok");
          } catch (error) {
            templateStatus.textContent = error instanceof Error ? error.message : String(error);
            templateStatus.classList.add("error");
          }
        })();
      });
      templateEditor.addEventListener("input", () => {
        if (templateDebounce !== null) {
          targetWindow.clearTimeout(templateDebounce);
        }
        templateDebounce = targetWindow.setTimeout(() => {
          void tryApplyTemplate();
        }, 280);
      });
      bodyEl.appendChild(tabs);
      bodyEl.appendChild(panes);
      panel.appendChild(header);
      panel.appendChild(bodyEl);
      settingsModal.appendChild(bg);
      settingsModal.appendChild(panel);
    };
    openButton.addEventListener("click", () => {
      void openSettings();
    });
  }

  // src/ui/drilldownOverlay.ts
  var DrilldownOverlay = class {
    root;
    doc;
    modal;
    sessionMapByGap = /* @__PURE__ */ new Map();
    // gameId -> sessionId
    sessionRowByIdByGap = /* @__PURE__ */ new Map();
    // sessionId -> sessionRow
    constructor(root) {
      this.root = root;
      this.doc = root.ownerDocument;
      this.modal = this.doc.createElement("div");
      this.modal.className = "ga-drilldown-modal";
      this.modal.style.display = "none";
      this.root.appendChild(this.modal);
    }
    getDocument() {
      return this.doc;
    }
    readSessionGapMinutes() {
      const root = this.root;
      const raw = Number(root.dataset?.gaSessionGapMinutes);
      return Number.isFinite(raw) ? Math.max(1, Math.min(360, Math.round(raw))) : 45;
    }
    async ensureSessionMaps(semantic) {
      const gap = this.readSessionGapMinutes();
      const cachedGame = this.sessionMapByGap.get(gap);
      const cachedSess = this.sessionRowByIdByGap.get(gap);
      if (cachedGame && cachedSess) return { gap, gameToSession: cachedGame, sessionById: cachedSess };
      const sessions = await getSessions({ global: { spec: void 0, state: {}, sessionGapMinutes: gap } });
      const gameToSession = /* @__PURE__ */ new Map();
      const sessionById = /* @__PURE__ */ new Map();
      for (const s of sessions) {
        const sid = typeof s?.sessionId === "string" ? s.sessionId : "";
        if (!sid) continue;
        sessionById.set(sid, s);
        const ids = Array.isArray(s?.gameIds) ? s.gameIds : [];
        for (const gid of ids) {
          if (typeof gid === "string" && gid) gameToSession.set(gid, sid);
        }
      }
      this.sessionMapByGap.set(gap, gameToSession);
      this.sessionRowByIdByGap.set(gap, sessionById);
      return { gap, gameToSession, sessionById };
    }
    open(semantic, req) {
      this.modal.innerHTML = "";
      this.modal.style.display = "block";
      const bg = this.doc.createElement("div");
      bg.className = "ga-drilldown-bg";
      bg.addEventListener("click", () => this.close());
      const panel = this.doc.createElement("div");
      panel.className = "ga-drilldown-panel";
      const header = this.doc.createElement("div");
      header.className = "ga-drilldown-header";
      const hTitle = this.doc.createElement("div");
      hTitle.className = "ga-drilldown-title";
      hTitle.textContent = `${req.title} (${req.rows.length})`;
      const btn = this.doc.createElement("button");
      btn.className = "ga-drilldown-close";
      btn.type = "button";
      btn.setAttribute("aria-label", "Close");
      btn.textContent = "X";
      btn.addEventListener("click", () => this.close());
      header.appendChild(hTitle);
      header.appendChild(btn);
      const preset = semantic.drilldownPresets[req.target];
      const dateFormat = this.readDateFormatMode();
      const rawCols = preset?.columnsPresets?.[req.columnsPreset] ?? [];
      const cols = rawCols.map((c) => typeof c === "string" ? { key: c } : c);
      let sortKey = cols.find((c) => c.sortable)?.key ?? cols[0]?.key ?? "";
      let sortDir = "desc";
      const initKey = req.initialSort?.key;
      const initDir = req.initialSort?.dir;
      if (typeof initKey === "string" && initKey.trim().length > 0 && cols.some((c) => c.key === initKey)) {
        sortKey = initKey;
        if (initDir === "asc" || initDir === "desc") sortDir = initDir;
      }
      const sortRankForResult = (v) => {
        const s = typeof v === "string" ? v.trim().toLowerCase() : "";
        if (s === "win" || s === "w" || s === "true") return 2;
        if (s === "tie" || s === "t") return 1;
        if (s === "loss" || s === "l" || s === "false") return 0;
        return -1;
      };
      const getSortValue = (row, col) => {
        const key = col.key;
        const v = this.getCellRawValue(row, key, semantic);
        if (key === "result") return sortRankForResult(v);
        if (typeof v === "number" && Number.isFinite(v)) return v;
        const s = typeof v === "string" ? v : String(v ?? "");
        const k = key.toLowerCase();
        if ((k.includes("date") || k.includes("time") || k.includes("playedat") || k.includes("ts")) && s) {
          const parsed = Date.parse(s);
          if (Number.isFinite(parsed)) return parsed;
        }
        return s.toLowerCase();
      };
      const isSameGame = (a, b) => {
        const ga = pickWithAliases(a, "gameId", semantic.columnAliases);
        const gb = pickWithAliases(b, "gameId", semantic.columnAliases);
        return typeof ga === "string" && typeof gb === "string" && ga.length > 0 && ga === gb;
      };
      const sortRows2 = (rows) => {
        const col = cols.find((c) => c.key === sortKey);
        if (!col) return rows;
        const sorted = [...rows].sort((a, b) => {
          const av = getSortValue(a, col);
          const bv = getSortValue(b, col);
          if (typeof av === "number" && typeof bv === "number") return sortDir === "asc" ? av - bv : bv - av;
          return sortDir === "asc" ? String(av).localeCompare(String(bv)) : String(bv).localeCompare(String(av));
        });
        return sorted;
      };
      const table = this.doc.createElement("table");
      table.className = "ga-drilldown-table";
      const thead = this.doc.createElement("thead");
      const trh = this.doc.createElement("tr");
      thead.appendChild(trh);
      const tbody = this.doc.createElement("tbody");
      const openRoundsForGameId = async (gameId, titleSuffix) => {
        const all = await getRounds({});
        const rows = all.filter((r) => typeof r?.gameId === "string" && r.gameId === gameId);
        this.open(semantic, {
          title: `${req.title}${titleSuffix}`,
          target: "rounds",
          columnsPreset: semantic.drilldownPresets.rounds?.defaultPreset ?? "roundMode",
          rows
        });
      };
      const openGameById = async (gameId, titleSuffix) => {
        const all = await getGames({});
        const rows = all.filter((g) => typeof g?.gameId === "string" && g.gameId === gameId);
        this.open(semantic, {
          title: `${req.title}${titleSuffix}`,
          target: "games",
          columnsPreset: semantic.drilldownPresets.games?.defaultPreset ?? "gameMode",
          rows
        });
      };
      const openGamesForSessionId = async (sessionId, titleSuffix) => {
        const { sessionById } = await this.ensureSessionMaps(semantic);
        const sess = sessionById.get(sessionId);
        const ids = Array.isArray(sess?.gameIds) ? sess.gameIds : [];
        const idSet = new Set(ids.filter((x) => typeof x === "string" && x));
        const all = await getGames({});
        const rows = all.filter((g) => typeof g?.gameId === "string" && idSet.has(g.gameId));
        this.open(semantic, {
          title: `${req.title}${titleSuffix}`,
          target: "games",
          columnsPreset: semantic.drilldownPresets.games?.defaultPreset ?? "gameMode",
          rows
        });
      };
      const openSessionById = async (sessionId, titleSuffix) => {
        const { sessionById } = await this.ensureSessionMaps(semantic);
        const row = sessionById.get(sessionId);
        this.open(semantic, {
          title: `${req.title}${titleSuffix}`,
          target: "sessions",
          columnsPreset: semantic.drilldownPresets.sessions?.defaultPreset ?? "sessionMode",
          rows: row ? [row] : []
        });
      };
      const renderHeader = () => {
        trh.innerHTML = "";
        for (const c of cols) {
          const th = this.doc.createElement("th");
          th.className = "ga-dd-th";
          const label = c.label ?? c.key;
          if (c.sortable) {
            th.classList.add("ga-dd-sortable");
            const arrow = c.key === sortKey ? sortDir === "asc" ? " ^" : " v" : "";
            th.textContent = `${label}${arrow}`;
            th.addEventListener("click", () => {
              if (sortKey === c.key) sortDir = sortDir === "asc" ? "desc" : "asc";
              else {
                sortKey = c.key;
                sortDir = "desc";
              }
              renderBody(true);
              renderHeader();
            });
          } else {
            th.textContent = label;
          }
          trh.appendChild(th);
        }
      };
      const renderBody = (reset = false) => {
        const rows = sortRows2(req.rows);
        if (reset) tbody.innerHTML = "";
        tbody.innerHTML = "";
        for (let i = 0; i < rows.length; i++) {
          const r = rows[i];
          const tr = this.doc.createElement("tr");
          tr.className = "ga-dd-tr";
          const next = rows[i + 1];
          if (next && isSameGame(r, next)) tr.classList.add("ga-dd-no-sep");
          for (const c of cols) {
            const td = this.doc.createElement("td");
            td.className = "ga-dd-td";
            this.renderCell(td, r, c, semantic, dateFormat);
            const key = String(c?.key ?? "");
            const raw = this.getCellRawValue(r, key, semantic);
            if (req.target === "rounds" && key === "gameId" && typeof raw === "string" && raw) {
              td.style.cursor = "pointer";
              td.addEventListener("click", () => void openGameById(raw, ` (game ${raw})`));
            }
            if (req.target === "rounds" && key === "sessionId") {
              const gid = this.getCellRawValue(r, "gameId", semantic);
              if (typeof raw === "string" && raw) {
                td.style.cursor = "pointer";
                td.addEventListener("click", () => void openSessionById(raw, ` (session ${raw})`));
              } else if (typeof gid === "string" && gid) {
                td.style.cursor = "pointer";
                td.textContent = "...";
                void (async () => {
                  const { gameToSession } = await this.ensureSessionMaps(semantic);
                  const sid = gameToSession.get(gid) ?? "";
                  td.textContent = sid || "-";
                  if (sid) td.addEventListener("click", () => void openSessionById(sid, ` (session ${sid})`));
                })();
              }
            }
            if ((req.target === "games" || req.target === "players") && key === "roundsCount") {
              const gid = this.getCellRawValue(r, "gameId", semantic);
              if (typeof gid === "string" && gid) {
                td.style.cursor = "pointer";
                td.addEventListener("click", () => void openRoundsForGameId(gid, ` (game ${gid})`));
              }
            }
            if ((req.target === "games" || req.target === "players") && key === "gameId" && typeof raw === "string" && raw) {
              td.style.cursor = "pointer";
              td.addEventListener("click", () => void openRoundsForGameId(raw, ` (game ${raw})`));
            }
            if ((req.target === "games" || req.target === "players") && key === "sessionId") {
              const gid = this.getCellRawValue(r, "gameId", semantic);
              if (typeof raw === "string" && raw) {
                td.style.cursor = "pointer";
                td.addEventListener("click", () => void openSessionById(raw, ` (session ${raw})`));
              } else if (typeof gid === "string" && gid) {
                td.style.cursor = "pointer";
                td.textContent = "...";
                void (async () => {
                  const { gameToSession } = await this.ensureSessionMaps(semantic);
                  const sid = gameToSession.get(gid) ?? "";
                  td.textContent = sid || "-";
                  if (sid) td.addEventListener("click", () => void openSessionById(sid, ` (session ${sid})`));
                })();
              }
            }
            if (req.target === "sessions" && key === "gamesCount") {
              const sid = this.getCellRawValue(r, "sessionId", semantic);
              if (typeof sid === "string" && sid) {
                td.style.cursor = "pointer";
                td.addEventListener("click", () => void openGamesForSessionId(sid, ` (session ${sid})`));
              }
            }
            if (req.target === "sessions" && key === "sessionId" && typeof raw === "string" && raw) {
              td.style.cursor = "pointer";
              td.addEventListener("click", () => void openGamesForSessionId(raw, ` (session ${raw})`));
            }
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
      };
      renderHeader();
      renderBody(true);
      table.appendChild(thead);
      table.appendChild(tbody);
      panel.appendChild(header);
      panel.appendChild(table);
      this.modal.appendChild(bg);
      this.modal.appendChild(panel);
    }
    close() {
      this.modal.style.display = "none";
    }
    readDateFormatMode() {
      const root = this.root;
      const mode = root.dataset?.gaDateFormat;
      return mode === "mm/dd/yyyy" || mode === "yyyy-mm-dd" || mode === "locale" ? mode : "dd/mm/yyyy";
    }
    readCountryFormatMode() {
      const root = this.root;
      return root.dataset?.gaCountryFormat === "english" ? "english" : "iso2";
    }
    formatCountry(isoOrName) {
      const mode = this.readCountryFormatMode();
      if (mode === "iso2") return isoOrName;
      const iso2 = isoOrName.trim().toUpperCase();
      if (!/^[A-Z]{2}$/.test(iso2)) return isoOrName;
      if (typeof Intl === "undefined" || !Intl.DisplayNames) return isoOrName;
      try {
        const dn = new Intl.DisplayNames(["en"], { type: "region" });
        return dn.of(iso2) ?? isoOrName;
      } catch {
        return isoOrName;
      }
    }
    formatDate(ts, mode) {
      const d = new Date(ts);
      if (!Number.isFinite(d.getTime())) return String(ts);
      if (mode === "locale") return d.toLocaleString();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      const hh = String(d.getHours()).padStart(2, "0");
      const mm = String(d.getMinutes()).padStart(2, "0");
      const ss = String(d.getSeconds()).padStart(2, "0");
      if (mode === "yyyy-mm-dd") return `${y}-${m}-${day} ${hh}:${mm}:${ss}`;
      if (mode === "mm/dd/yyyy") return `${m}/${day}/${y} ${hh}:${mm}:${ss}`;
      return `${day}/${m}/${y} ${hh}:${mm}:${ss}`;
    }
    formatCellValue(value, columnName, dateMode) {
      if (value === void 0 || value === null) return "";
      const col = columnName.toLowerCase();
      const looksLikeDateColumn = col === "ts" || col === "playedat" || col === "starttime" || col === "endtime" || col.endsWith("ts") || col.includes("date") || col.includes("time") || col.includes("playedat") || col.includes("timestamp");
      if (typeof value === "number" && Number.isFinite(value)) {
        if (looksLikeDateColumn && value > 9466848e5 && value < 41024448e5) {
          return this.formatDate(value, dateMode);
        }
        return String(value);
      }
      if (typeof value === "string") {
        const trimmed = value.trim();
        if (looksLikeDateColumn) {
          if (/^[0-9]{10,13}$/.test(trimmed)) {
            const n = Number(trimmed);
            if (Number.isFinite(n)) {
              const ts = trimmed.length === 10 ? n * 1e3 : n;
              if (ts > 9466848e5 && ts < 41024448e5) return this.formatDate(ts, dateMode);
            }
          }
          const parsed = Date.parse(trimmed);
          if (Number.isFinite(parsed)) return this.formatDate(parsed, dateMode);
        }
        return value;
      }
      return String(value);
    }
    movementLabel(v) {
      const s = typeof v === "string" ? v.trim().toLowerCase() : "";
      if (!s) return "";
      if (s === "moving") return "Moving";
      if (s === "no_move" || s === "nomove" || s.includes("no move")) return "No Move";
      if (s === "nmpz" || s.includes("nmpz")) return "NMPZ";
      return v;
    }
    gameModeLabel(v) {
      const s = typeof v === "string" ? v.trim() : "";
      const k = s.toLowerCase();
      if (!k) return "";
      if (k === "duels" || k === "duel") return "Duel";
      if (k === "teamduels" || k === "teamduel" || k.includes("team") && k.includes("duel")) return "Team Duel";
      return s;
    }
    getCellRawValue(row, key, semantic) {
      const pickNum = (k) => {
        const v = pickWithAliases(row, k, semantic.columnAliases);
        return typeof v === "number" && Number.isFinite(v) ? v : void 0;
      };
      const pickBool = (k) => {
        const v = pickWithAliases(row, k, semantic.columnAliases);
        return typeof v === "boolean" ? v : void 0;
      };
      const bestOwnGuess = () => {
        const mf = String(row?.modeFamily ?? "").toLowerCase();
        if (mf !== "teamduels") {
          return {
            lat: pickNum("player_self_guessLat"),
            lng: pickNum("player_self_guessLng"),
            score: pickNum("player_self_score")
          };
        }
        const self2 = {
          lat: pickNum("player_self_guessLat"),
          lng: pickNum("player_self_guessLng"),
          score: pickNum("player_self_score"),
          best: pickBool("player_self_isBestGuess")
        };
        const mate = {
          lat: pickNum("player_mate_guessLat"),
          lng: pickNum("player_mate_guessLng"),
          score: pickNum("player_mate_score"),
          best: pickBool("player_mate_isBestGuess")
        };
        if (mate.best === true && self2.best !== true) return mate;
        if (self2.best === true && mate.best !== true) return self2;
        if (typeof mate.score === "number" && typeof self2.score === "number") return mate.score > self2.score ? mate : self2;
        if (typeof mate.score === "number") return mate;
        return self2;
      };
      if (key === "guess_maps") {
        const g = bestOwnGuess();
        if (typeof g.lat === "number" && typeof g.lng === "number") return `https://www.google.com/maps?q=${g.lat},${g.lng}`;
        return void 0;
      }
      if (key === "street_view") {
        const lat = pickWithAliases(row, "trueLat", semantic.columnAliases);
        const lng = pickWithAliases(row, "trueLng", semantic.columnAliases);
        if (typeof lat === "number" && typeof lng === "number") return `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${lat},${lng}`;
        return void 0;
      }
      if (key === "opponentName") return typeof row?.opponentName === "string" ? row.opponentName : void 0;
      if (key === "opponentCountry") return typeof row?.opponentCountry === "string" ? row.opponentCountry : void 0;
      if (key === "matchups") return typeof row?.matchups === "number" ? row.matchups : void 0;
      if (key === "player_self_score") {
        const mf = String(row?.modeFamily ?? "").toLowerCase();
        if (mf === "teamduels") {
          const g = bestOwnGuess();
          if (typeof g.score === "number") return g.score;
        }
      }
      if (key === "endRating") {
        const mf = String(row?.modeFamily ?? "").toLowerCase();
        if (mf === "teamduels" || mf.includes("team") && mf.includes("duel") || row?.isTeamDuels === true) {
          return pickWithAliases(row, "teamOneEndRating", semantic.columnAliases) ?? pickWithAliases(row, "player_self_endRating", semantic.columnAliases) ?? pickWithAliases(row, "playerOneEndRating", semantic.columnAliases);
        }
        return pickWithAliases(row, "player_self_endRating", semantic.columnAliases) ?? pickWithAliases(row, "playerOneEndRating", semantic.columnAliases);
      }
      if (key === "ratingDelta") {
        const direct = row?.ratingDelta;
        if (typeof direct === "number" && Number.isFinite(direct)) return direct;
        const mf = String(row?.modeFamily ?? "").toLowerCase();
        const isTeam = mf === "teamduels" || mf.includes("team") && mf.includes("duel") || row?.isTeamDuels === true;
        const start = isTeam ? pickWithAliases(row, "teamOneStartRating", semantic.columnAliases) ?? pickWithAliases(row, "player_self_startRating", semantic.columnAliases) : pickWithAliases(row, "player_self_startRating", semantic.columnAliases) ?? pickWithAliases(row, "playerOneStartRating", semantic.columnAliases);
        const end = this.getCellRawValue(row, "endRating", semantic);
        if (typeof start === "number" && Number.isFinite(start) && typeof end === "number" && Number.isFinite(end)) return end - start;
        return void 0;
      }
      return pickWithAliases(row, key, semantic.columnAliases);
    }
    renderCell(td, row, col, semantic, dateMode) {
      const key = col.key;
      const raw = this.getCellRawValue(row, key, semantic);
      const mkProfileUrl = (id) => {
        const s = typeof id === "string" ? id.trim() : "";
        return s ? `https://www.geoguessr.com/user/${s}` : "";
      };
      const maybeRenderProfileLink = (nameKey, idKey) => {
        if (key !== nameKey) return false;
        if (typeof raw !== "string" || !raw.trim()) return true;
        const id = pickWithAliases(row, idKey, semantic.columnAliases);
        const href = mkProfileUrl(id);
        if (!href) return false;
        const a = this.doc.createElement("a");
        a.className = "ga-dd-link";
        a.href = href;
        a.target = "_blank";
        a.rel = "noopener";
        a.textContent = raw;
        td.appendChild(a);
        return true;
      };
      if (maybeRenderProfileLink("player_opponent_name", "player_opponent_id") || maybeRenderProfileLink("player_opponent_mate_name", "player_opponent_mate_id") || maybeRenderProfileLink("player_mate_name", "player_mate_id")) {
        return;
      }
      if (col.type === "link" || key === "guess_maps" || key === "street_view") {
        const href = typeof raw === "string" ? raw : "";
        if (!href) return;
        const a = this.doc.createElement("a");
        a.className = "ga-dd-link";
        a.href = href;
        a.target = "_blank";
        a.rel = "noopener";
        a.textContent = col.link?.label ?? "Open";
        td.appendChild(a);
        return;
      }
      let text = this.formatCellValue(raw, key, dateMode);
      if (key === "movementType" || key === "movement_type" || key === "movement") {
        const lbl = this.movementLabel(raw);
        if (lbl) text = String(lbl);
      }
      if (key === "gameMode" || key === "game_mode" || key === "modeFamily") {
        const lbl = this.gameModeLabel(raw);
        if (lbl) text = String(lbl);
      }
      if (key === "result") {
        if (typeof raw === "boolean") text = raw ? "Win" : "Loss";
        else if (typeof raw === "string") text = raw;
        else text = "-";
      }
      if (key === "durationSeconds" && typeof raw === "number" && Number.isFinite(raw)) {
        text = `${raw.toFixed(1)}s`;
      }
      if (key === "damage" && typeof raw === "number" && Number.isFinite(raw)) {
        const signed = raw > 0 ? `+${Math.round(raw)}` : `${Math.round(raw)}`;
        text = signed;
      }
      if (key === "ratingDelta" && typeof raw === "number" && Number.isFinite(raw)) {
        const signed = raw > 0 ? `+${Math.round(raw)}` : `${Math.round(raw)}`;
        text = signed;
      }
      if ((key === "true_country" || key === "trueCountry" || key === "player_self_country" || key === "player_self_guessCountry" || key === "opponentCountry") && typeof raw === "string") {
        text = this.formatCountry(raw);
      }
      if (key === "gameId" && col.display?.truncate) {
        const head = typeof col.display.truncateHead === "number" ? col.display.truncateHead : 8;
        const s = typeof raw === "string" ? raw : text;
        if (s.length > head + 3) text = `${s.slice(0, head)}...`;
      }
      if (key === "sessionId" && col.display?.truncate) {
        const head = typeof col.display.truncateHead === "number" ? col.display.truncateHead : 2;
        const s = typeof raw === "string" ? raw : text;
        if (s.length > head + 3) text = `${s.slice(0, head)}...`;
      }
      const span = this.doc.createElement("span");
      span.textContent = text;
      if (col.colored) {
        if (key === "result") {
          const s = (typeof raw === "string" ? raw : String(raw ?? "")).trim().toLowerCase();
          if (s === "win" || s === "w" || s === "true") span.classList.add("ga-dd-pos");
          else if (s === "loss" || s === "l" || s === "false") span.classList.add("ga-dd-neg");
        }
        if (key === "damage" && typeof raw === "number" && Number.isFinite(raw)) {
          if (raw > 0) span.classList.add("ga-dd-pos");
          else if (raw < 0) span.classList.add("ga-dd-neg");
        }
        if (key === "ratingDelta" && typeof raw === "number" && Number.isFinite(raw)) {
          if (raw > 0) span.classList.add("ga-dd-pos");
          else if (raw < 0) span.classList.add("ga-dd-neg");
        }
      }
      td.appendChild(span);
    }
  };

  // src/engine/measures.ts
  function medianOf(values) {
    const finite = values.filter((v) => typeof v === "number" && Number.isFinite(v));
    if (finite.length === 0) return 0;
    finite.sort((a, b) => a - b);
    const mid = Math.floor(finite.length / 2);
    return finite.length % 2 ? finite[mid] : (finite[mid - 1] + finite[mid]) / 2;
  }
  function stddevOf(values) {
    const finite = values.filter((v) => typeof v === "number" && Number.isFinite(v));
    const n = finite.length;
    if (n <= 1) return 0;
    const mean = finite.reduce((a, b) => a + b, 0) / n;
    let sumSq = 0;
    for (const v of finite) sumSq += (v - mean) * (v - mean);
    return Math.sqrt(sumSq / n);
  }
  function is5k(r) {
    const s = getSelfScore(r);
    return typeof s === "number" && s >= 5e3;
  }
  function isHit(r) {
    const truth = getTrueCountry(r);
    if (!truth) return false;
    const guess = getGuessCountrySelf(r);
    return typeof guess === "string" && guess === truth;
  }
  function isThrowLt50(r) {
    const s = getSelfScore(r);
    return typeof s === "number" && s < 50;
  }
  function isNearPerfect(r) {
    const s = getSelfScore(r);
    return typeof s === "number" && s >= 4500;
  }
  function isLowScoreLt500(r) {
    const s = getSelfScore(r);
    return typeof s === "number" && s < 500;
  }
  function getGameSelfVictory(g) {
    const v = pick(g, "player_self_victory") ?? pick(g, "playerOneVictory") ?? pick(g, "teamOneVictory");
    return typeof v === "boolean" ? v : void 0;
  }
  function getGameSelfStartRating(g) {
    const v = pick(g, "player_self_startRating") ?? pick(g, "playerOneStartRating") ?? pick(g, "teamOneStartRating");
    return typeof v === "number" ? v : void 0;
  }
  function getGameSelfEndRating(g) {
    const v = pick(g, "player_self_endRating") ?? pick(g, "playerOneEndRating") ?? pick(g, "teamOneEndRating");
    return typeof v === "number" ? v : void 0;
  }
  function getGameModeFamily(g) {
    const v = pick(g, "modeFamily") ?? pick(g, "mode_family");
    return typeof v === "string" ? v.trim().toLowerCase() : "";
  }
  function getGameDuelStartRating(g) {
    const v = pick(g, "player_self_startRating") ?? pick(g, "playerOneStartRating");
    return typeof v === "number" ? v : void 0;
  }
  function getGameDuelEndRating(g) {
    const v = pick(g, "player_self_endRating") ?? pick(g, "playerOneEndRating");
    return typeof v === "number" ? v : void 0;
  }
  function getGameTeamStartRating(g) {
    const v = pick(g, "teamOneStartRating") ?? pick(g, "player_self_startRating");
    return typeof v === "number" ? v : void 0;
  }
  function getGameTeamEndRating(g) {
    const v = pick(g, "teamOneEndRating") ?? pick(g, "player_self_endRating");
    return typeof v === "number" ? v : void 0;
  }
  function getGameEffectiveStartRating(g) {
    return getGameModeFamily(g) === "teamduels" ? getGameTeamStartRating(g) : getGameDuelStartRating(g);
  }
  function getGameEffectiveEndRating(g) {
    return getGameModeFamily(g) === "teamduels" ? getGameTeamEndRating(g) : getGameDuelEndRating(g);
  }
  function ratingModeForRows(rows) {
    for (const g of rows) {
      if (getGameModeFamily(g) === "duels") return "duel";
    }
    return "team";
  }
  function getGameOutcome2(g) {
    const v = getGameSelfVictory(g);
    if (typeof v === "boolean") return v ? "win" : "loss";
    const r = pick(g, "result");
    const s = typeof r === "string" ? r.trim().toLowerCase() : "";
    if (!s) return null;
    if (s === "win" || s === "w" || s === "true") return "win";
    if (s === "loss" || s === "l" || s === "false") return "loss";
    if (s === "tie" || s === "t" || s === "draw") return "tie";
    return null;
  }
  var ROUND_MEASURES_BY_FORMULA_ID = {
    count_rounds: (rows) => rows.length,
    count_distinct_game_id: (rows) => {
      const seen = /* @__PURE__ */ new Set();
      for (const r of rows) {
        const gid = typeof r?.gameId === "string" ? r.gameId : "";
        if (gid) seen.add(gid);
      }
      return seen.size;
    },
    min_played_at_ts: (rows) => {
      let min = Infinity;
      for (const r of rows) {
        const ts = getPlayedAt(r) ?? r?.ts;
        if (typeof ts === "number" && Number.isFinite(ts)) min = Math.min(min, ts);
      }
      return Number.isFinite(min) ? min : 0;
    },
    max_played_at_ts: (rows) => {
      let max = -Infinity;
      for (const r of rows) {
        const ts = getPlayedAt(r) ?? r?.ts;
        if (typeof ts === "number" && Number.isFinite(ts)) max = Math.max(max, ts);
      }
      return Number.isFinite(max) ? max : 0;
    },
    spread_player_self_score: (rows) => {
      let min = Infinity;
      let max = -Infinity;
      for (const r of rows) {
        const s = getSelfScore(r);
        if (typeof s !== "number" || !Number.isFinite(s)) continue;
        if (s < min) min = s;
        if (s > max) max = s;
      }
      if (!Number.isFinite(min) || !Number.isFinite(max)) return 0;
      return Math.max(0, max - min);
    },
    // Share-of-total measures are normalized in chart/breakdown widgets (they need access to total rows).
    // In non-grouped contexts (e.g. stat row over all rows), returning 1.0 is a sensible default (100% of itself).
    share_damage_dealt: (_rows) => 1,
    share_damage_taken: (_rows) => 1,
    mean_player_self_score: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        const s = getSelfScore(r);
        if (typeof s === "number") {
          sum += s;
          n++;
        }
      }
      return n ? sum / n : 0;
    },
    // Record-style per-round measures: return NaN if value is missing so Record widgets can skip invalid groups.
    round_score_value: (rows) => {
      for (const r of rows) {
        const s = getSelfScore(r);
        if (typeof s === "number" && Number.isFinite(s) && s >= 0) return s;
      }
      return NaN;
    },
    round_damage_dealt_value: (rows) => {
      for (const r of rows) {
        const dmg = r?.damage;
        if (typeof dmg !== "number" || !Number.isFinite(dmg)) continue;
        if (dmg > 0) return dmg;
      }
      return NaN;
    },
    round_damage_taken_value: (rows) => {
      for (const r of rows) {
        const dmg = r?.damage;
        if (typeof dmg !== "number" || !Number.isFinite(dmg)) continue;
        if (dmg < 0) return -dmg;
      }
      return NaN;
    },
    round_guess_duration_value: (rows) => {
      for (const r of rows) {
        const s = getDurationSeconds(r);
        if (typeof s === "number" && Number.isFinite(s) && s > 0) return s;
      }
      return NaN;
    },
    round_score_per_second: (rows) => {
      let best = -Infinity;
      let found = false;
      for (const r of rows) {
        const score = getSelfScore(r);
        const dur = getDurationSeconds(r);
        if (typeof score !== "number" || !Number.isFinite(score) || score < 0) continue;
        if (typeof dur !== "number" || !Number.isFinite(dur) || dur <= 0) continue;
        const v = score / dur;
        if (Number.isFinite(v)) {
          found = true;
          best = Math.max(best, v);
        }
      }
      return found ? best : NaN;
    },
    median_player_self_score: (rows) => medianOf(rows.map((r) => getSelfScore(r)).filter((v) => typeof v === "number")),
    stddev_player_self_score: (rows) => stddevOf(rows.map((r) => getSelfScore(r)).filter((v) => typeof v === "number")),
    rate_player_self_score_eq_5000: (rows) => {
      const n = rows.length;
      if (!n) return 0;
      let k = 0;
      for (const r of rows) if (is5k(r)) k++;
      return k / n;
    },
    rate_true_country_hit: (rows) => {
      const n = rows.length;
      if (!n) return 0;
      let k = 0;
      for (const r of rows) if (isHit(r)) k++;
      return k / n;
    },
    rate_throw_round: (rows) => {
      const n = rows.length;
      if (!n) return 0;
      let k = 0;
      for (const r of rows) if (isThrowLt50(r)) k++;
      return k / n;
    },
    count_5k_round: (rows) => {
      let k = 0;
      for (const r of rows) if (is5k(r)) k++;
      return k;
    },
    rate_near_perfect_round: (rows) => {
      const n = rows.length;
      if (!n) return 0;
      let k = 0;
      for (const r of rows) if (isNearPerfect(r)) k++;
      return k / n;
    },
    count_near_perfect_round: (rows) => {
      let k = 0;
      for (const r of rows) if (isNearPerfect(r)) k++;
      return k;
    },
    count_hit_round: (rows) => {
      let k = 0;
      for (const r of rows) if (isHit(r)) k++;
      return k;
    },
    count_throw_round: (rows) => {
      let k = 0;
      for (const r of rows) if (isThrowLt50(r)) k++;
      return k;
    },
    rate_low_score_round: (rows) => {
      const n = rows.length;
      if (!n) return 0;
      let k = 0;
      for (const r of rows) if (isLowScoreLt500(r)) k++;
      return k / n;
    },
    count_low_score_round: (rows) => {
      let k = 0;
      for (const r of rows) if (isLowScoreLt500(r)) k++;
      return k;
    },
    mean_player_self_score_hit_only: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        if (!isHit(r)) continue;
        const s = getSelfScore(r);
        if (typeof s === "number") {
          sum += s;
          n++;
        }
      }
      return n ? sum / n : 0;
    },
    mean_duration_seconds: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        const v = getDurationSeconds(r);
        if (typeof v === "number" && Number.isFinite(v)) {
          sum += v;
          n++;
        }
      }
      return n ? sum / n : 0;
    },
    median_duration_seconds: (rows) => medianOf(rows.map((r) => getDurationSeconds(r)).filter((v) => typeof v === "number")),
    sum_duration_seconds: (rows) => {
      let sum = 0;
      for (const r of rows) {
        const v = getDurationSeconds(r);
        if (typeof v === "number" && Number.isFinite(v)) sum += v;
      }
      return sum;
    },
    count_rounds_with_duration: (rows) => {
      let k = 0;
      for (const r of rows) {
        const v = getDurationSeconds(r);
        if (typeof v === "number" && Number.isFinite(v)) k++;
      }
      return k;
    },
    mean_player_self_distance_km: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        const v = getDistanceKm(r);
        if (typeof v === "number" && Number.isFinite(v)) {
          sum += v;
          n++;
        }
      }
      return n ? sum / n : 0;
    },
    median_player_self_distance_km: (rows) => medianOf(rows.map((r) => getDistanceKm(r)).filter((v) => typeof v === "number")),
    mean_damage_dealt: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        const dmg = r.damage;
        if (typeof dmg === "number" && Number.isFinite(dmg)) {
          sum += Math.max(0, dmg);
          n++;
        }
      }
      return n ? sum / n : 0;
    },
    mean_damage_taken: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        const dmg = r.damage;
        if (typeof dmg === "number" && Number.isFinite(dmg)) {
          sum += Math.max(0, -dmg);
          n++;
        }
      }
      return n ? sum / n : 0;
    }
  };
  var GAME_MEASURES_BY_FORMULA_ID = {
    count_games: (rows) => rows.length,
    count_distinct_opponent_name: (rows) => {
      const set = /* @__PURE__ */ new Set();
      for (const g of rows) {
        const s = typeof g?.opponentName === "string" ? g.opponentName.trim() : "";
        if (s) set.add(s);
      }
      return set.size;
    },
    count_distinct_opponent_country: (rows) => {
      const set = /* @__PURE__ */ new Set();
      for (const g of rows) {
        const s = typeof g?.opponentCountry === "string" ? g.opponentCountry.trim() : "";
        if (s) set.add(s);
      }
      return set.size;
    },
    mean_game_length_rounds: (rows) => {
      let sum = 0;
      let n = 0;
      for (const g of rows) {
        const v = g?.roundsCount;
        if (typeof v === "number" && Number.isFinite(v) && v > 0) {
          sum += v;
          n++;
        }
      }
      return n ? sum / n : 0;
    },
    rate_player_self_win: (rows) => {
      let n = 0;
      let k = 0;
      for (const g of rows) {
        const o = getGameOutcome2(g);
        if (!o) continue;
        n++;
        if (o === "win") k++;
      }
      return n ? k / n : 0;
    },
    mean_player_self_end_rating: (rows) => {
      let sum = 0;
      let n = 0;
      for (const g of rows) {
        const v = getGameSelfEndRating(g);
        if (typeof v === "number") {
          sum += v;
          n++;
        }
      }
      return n ? sum / n : 0;
    },
    last_player_self_end_rating: (rows) => {
      const sorted = [...rows].sort((a, b) => (Number(a?.ts) || Number(a?.playedAt) || 0) - (Number(b?.ts) || Number(b?.playedAt) || 0));
      const mode = ratingModeForRows(sorted);
      for (let i = sorted.length - 1; i >= 0; i--) {
        const v = mode === "duel" ? getGameDuelEndRating(sorted[i]) : getGameTeamEndRating(sorted[i]);
        if (typeof v === "number" && Number.isFinite(v)) return v;
      }
      return 0;
    },
    trend_player_self_rating: (rows) => {
      const sorted = [...rows].sort((a, b) => (Number(a?.ts) || Number(a?.playedAt) || 0) - (Number(b?.ts) || Number(b?.playedAt) || 0));
      if (sorted.length === 0) return 0;
      const pickFiniteNonZero = (v) => typeof v === "number" && Number.isFinite(v) && v !== 0 ? v : null;
      let firstRating = null;
      for (const g of sorted) {
        const start = pickFiniteNonZero(getGameEffectiveStartRating(g) ?? getGameEffectiveEndRating(g));
        const end = pickFiniteNonZero(getGameEffectiveEndRating(g) ?? getGameEffectiveStartRating(g));
        const r = start ?? end;
        if (r !== null) {
          firstRating = r;
          break;
        }
      }
      let lastRating = null;
      for (let i = sorted.length - 1; i >= 0; i--) {
        const g = sorted[i];
        const end = pickFiniteNonZero(getGameEffectiveEndRating(g) ?? getGameEffectiveStartRating(g));
        const start = pickFiniteNonZero(getGameEffectiveStartRating(g) ?? getGameEffectiveEndRating(g));
        const r = end ?? start;
        if (r !== null) {
          lastRating = r;
          break;
        }
      }
      if (firstRating !== null && lastRating !== null) return lastRating - firstRating;
      return 0;
    },
    mean_player_self_rating_delta: (rows) => {
      let sum = 0;
      let n = 0;
      for (const g of rows) {
        const start = getGameSelfStartRating(g);
        const end = getGameSelfEndRating(g);
        if (typeof start === "number" && typeof end === "number") {
          sum += end - start;
          n++;
        }
      }
      return n ? sum / n : 0;
    },
    max_player_self_rating_delta: (rows) => {
      let best = -Infinity;
      for (const g of rows) {
        const start = getGameEffectiveStartRating(g) ?? getGameEffectiveEndRating(g);
        const end = getGameEffectiveEndRating(g);
        if (typeof start !== "number" || typeof end !== "number") continue;
        if (!Number.isFinite(start) || !Number.isFinite(end)) continue;
        if (start === 0 || end === 0) continue;
        best = Math.max(best, end - start);
      }
      return Number.isFinite(best) ? best : 0;
    },
    min_player_self_rating_delta: (rows) => {
      let best = Infinity;
      for (const g of rows) {
        const start = getGameEffectiveStartRating(g) ?? getGameEffectiveEndRating(g);
        const end = getGameEffectiveEndRating(g);
        if (typeof start !== "number" || typeof end !== "number") continue;
        if (!Number.isFinite(start) || !Number.isFinite(end)) continue;
        if (start === 0 || end === 0) continue;
        best = Math.min(best, end - start);
      }
      return Number.isFinite(best) ? best : 0;
    },
    game_avg_score_over_rounds: (rows) => {
      for (const g of rows) {
        const roundsCount = typeof g?.roundsCount === "number" ? g.roundsCount : 0;
        const scoreSum = typeof g?.scoreSum === "number" ? g.scoreSum : null;
        const scoreCount = typeof g?.scoreCount === "number" ? g.scoreCount : 0;
        if (roundsCount <= 0) return NaN;
        if (scoreSum === null || scoreCount !== roundsCount) return NaN;
        return scoreCount > 0 ? scoreSum / scoreCount : NaN;
      }
      return NaN;
    },
    game_5k_count: (rows) => {
      for (const g of rows) {
        const v = g?.fivekCount;
        if (typeof v === "number" && Number.isFinite(v)) return v;
      }
      return NaN;
    },
    game_throw_count: (rows) => {
      for (const g of rows) {
        const v = g?.throwCount;
        if (typeof v === "number" && Number.isFinite(v)) return v;
      }
      return NaN;
    },
    game_hit_rate: (rows) => {
      for (const g of rows) {
        const hit = typeof g?.hitCount === "number" ? g.hitCount : null;
        const denom = typeof g?.hitDenom === "number" ? g.hitDenom : null;
        const roundsCount = typeof g?.roundsCount === "number" ? g.roundsCount : 0;
        if (hit === null || denom === null || denom <= 0) return NaN;
        if (roundsCount > 0 && denom / roundsCount < 0.5) return NaN;
        return hit / denom;
      }
      return NaN;
    },
    game_rating_delta_value: (rows) => {
      for (const g of rows) {
        const d = g?.ratingDelta;
        if (typeof d === "number" && Number.isFinite(d)) return d;
        const start = g?.player_self_startRating ?? g?.playerOneStartRating ?? g?.teamOneStartRating ?? null;
        const end = g?.player_self_endRating ?? g?.playerOneEndRating ?? g?.teamOneEndRating ?? null;
        if (typeof start === "number" && typeof end === "number" && Number.isFinite(start) && Number.isFinite(end) && start !== 0 && end !== 0) return end - start;
      }
      return NaN;
    },
    game_duration_seconds: (rows) => {
      for (const g of rows) {
        const v = g?.gameDurationSeconds;
        if (typeof v === "number" && Number.isFinite(v) && v > 0) return v;
      }
      return NaN;
    },
    game_final_health: (rows) => {
      for (const g of rows) {
        const v = g?.player_self_finalHealth ?? g?.playerOneFinalHealth ?? g?.teamOneFinalHealth ?? g?.team1FinalHealth ?? null;
        if (typeof v === "number" && Number.isFinite(v) && v >= 0) return v;
      }
      return NaN;
    },
    count_flawless_wins: (rows) => {
      let k = 0;
      for (const g of rows) if (g?.isFlawlessWin === true) k++;
      return k;
    },
    // Record-style: return 1 for flawless win else NaN, to pick an example game via record_list if needed.
    is_flawless_win_value: (rows) => {
      for (const g of rows) return g?.isFlawlessWin === true ? 1 : NaN;
      return NaN;
    },
    count_win_game: (rows) => {
      let k = 0;
      for (const g of rows) if (getGameOutcome2(g) === "win") k++;
      return k;
    },
    count_loss_game: (rows) => {
      let k = 0;
      for (const g of rows) if (getGameOutcome2(g) === "loss") k++;
      return k;
    },
    count_tie_game: (rows) => {
      let k = 0;
      for (const g of rows) if (getGameOutcome2(g) === "tie") k++;
      return k;
    },
    count_games_with_result: (rows) => {
      let k = 0;
      for (const g of rows) if (getGameOutcome2(g)) k++;
      return k;
    },
    max_player_self_end_rating: (rows) => {
      let best = -Infinity;
      const mode = ratingModeForRows(rows);
      for (const g of rows) {
        const v = mode === "duel" ? getGameDuelEndRating(g) : getGameTeamEndRating(g);
        if (typeof v === "number" && Number.isFinite(v)) best = Math.max(best, v);
      }
      return Number.isFinite(best) ? best : 0;
    },
    max_win_streak: (rows) => {
      const sorted = [...rows].sort((a, b) => (Number(a?.ts) || 0) - (Number(b?.ts) || 0));
      let best = 0;
      let cur = 0;
      for (const g of sorted) {
        const o = getGameOutcome2(g);
        if (!o) continue;
        if (o === "win") {
          cur++;
          best = Math.max(best, cur);
        } else {
          cur = 0;
        }
      }
      return best;
    },
    max_loss_streak: (rows) => {
      const sorted = [...rows].sort((a, b) => (Number(a?.ts) || 0) - (Number(b?.ts) || 0));
      let best = 0;
      let cur = 0;
      for (const g of sorted) {
        const o = getGameOutcome2(g);
        if (!o) continue;
        if (o === "loss") {
          cur++;
          best = Math.max(best, cur);
        } else {
          cur = 0;
        }
      }
      return best;
    },
    max_opponent_start_rating: (rows) => {
      let best = -Infinity;
      for (const g of rows) {
        const mode = String(g?.modeFamily ?? "").trim().toLowerCase();
        const vals = mode === "teamduels" ? [g.player_opponent_startRating, g.player_opponent_mate_startRating] : [g.player_opponent_startRating, g.playerTwoStartRating];
        for (const v of vals) {
          if (typeof v === "number" && Number.isFinite(v)) best = Math.max(best, v);
        }
      }
      return Number.isFinite(best) ? best : 0;
    },
    max_defeated_opponent_start_rating: (rows) => {
      let best = -Infinity;
      for (const g of rows) {
        if (getGameOutcome2(g) !== "win") continue;
        const mode = String(g?.modeFamily ?? "").trim().toLowerCase();
        const vals = mode === "teamduels" ? [g.player_opponent_startRating, g.player_opponent_mate_startRating] : [g.player_opponent_startRating, g.playerTwoStartRating];
        for (const v of vals) {
          if (typeof v === "number" && Number.isFinite(v)) best = Math.max(best, v);
        }
      }
      return Number.isFinite(best) ? best : 0;
    }
  };
  var SESSION_MEASURES_BY_FORMULA_ID = {
    count_sessions: (rows) => rows.length,
    mean_games_per_session: (rows) => {
      if (!rows.length) return 0;
      const sum = rows.reduce((a, r) => a + (typeof r.gamesCount === "number" ? r.gamesCount : 0), 0);
      return sum / rows.length;
    },
    session_avg_score_hit: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        const ss = r.hitScoreSum;
        const sc = r.hitScoreCount;
        if (typeof ss === "number" && typeof sc === "number" && sc > 0) {
          sum += ss;
          n += sc;
        }
      }
      return n ? sum / n : 0;
    },
    session_5k_count: (rows) => rows.reduce((a, r) => a + (typeof r.fivekCount === "number" ? r.fivekCount : 0), 0),
    session_hit_count: (rows) => rows.reduce((a, r) => a + (typeof r.hitCount === "number" ? r.hitCount : 0), 0),
    session_throw_count: (rows) => rows.reduce((a, r) => a + (typeof r.throwCount === "number" ? r.throwCount : 0), 0),
    session_win_count: (rows) => rows.reduce((a, r) => a + (typeof r.winCount === "number" ? r.winCount : 0), 0),
    session_win_rate: (rows) => {
      let wins = 0;
      let n = 0;
      for (const r of rows) {
        const w = r.winCount;
        const g = r.gamesWithOutcome;
        if (typeof w === "number" && Number.isFinite(w) && typeof g === "number" && Number.isFinite(g) && g > 0) {
          wins += w;
          n += g;
        }
      }
      return n ? wins / n : 0;
    },
    session_start_rating: (rows) => {
      const sorted = [...rows].sort((a, b) => Number(a?.sessionStartTs ?? 0) - Number(b?.sessionStartTs ?? 0));
      for (const r of sorted) {
        const start = r?.ratingStart;
        if (typeof start === "number" && Number.isFinite(start)) return start;
        const end = r?.ratingEnd;
        if (typeof end === "number" && Number.isFinite(end)) return end;
      }
      return 0;
    },
    session_end_rating: (rows) => {
      const sorted = [...rows].sort((a, b) => Number(a?.sessionEndTs ?? 0) - Number(b?.sessionEndTs ?? 0));
      for (let i = sorted.length - 1; i >= 0; i--) {
        const r = sorted[i];
        const end = r?.ratingEnd;
        if (typeof end === "number" && Number.isFinite(end)) return end;
        const start = r?.ratingStart;
        if (typeof start === "number" && Number.isFinite(start)) return start;
      }
      return 0;
    },
    session_duration_seconds: (rows) => {
      let sum = 0;
      for (const r of rows) {
        const start = r?.sessionStartTs;
        const end = r?.sessionEndTs;
        if (typeof start !== "number" || typeof end !== "number") continue;
        if (!Number.isFinite(start) || !Number.isFinite(end)) continue;
        const delta = end - start;
        if (Number.isFinite(delta) && delta > 0) sum += delta / 1e3;
      }
      return sum;
    },
    session_duration_minutes: (rows) => {
      let sum = 0;
      for (const r of rows) {
        const start = r?.sessionStartTs;
        const end = r?.sessionEndTs;
        if (typeof start !== "number" || typeof end !== "number") continue;
        if (!Number.isFinite(start) || !Number.isFinite(end)) continue;
        const delta = end - start;
        if (Number.isFinite(delta) && delta > 0) sum += delta / 6e4;
      }
      return sum;
    },
    max_break_between_sessions_seconds: (rows) => {
      const sorted = [...rows].sort((a, b) => Number(a?.sessionStartTs ?? 0) - Number(b?.sessionStartTs ?? 0));
      let best = 0;
      for (let i = 1; i < sorted.length; i++) {
        const prev = sorted[i - 1];
        const cur = sorted[i];
        const gapMs = Number(cur.sessionStartTs ?? 0) - Number(prev.sessionEndTs ?? 0);
        if (Number.isFinite(gapMs) && gapMs > best) best = gapMs;
      }
      return best / 1e3;
    },
    session_games_count: (rows) => rows.reduce((a, r) => a + (typeof r.gamesCount === "number" ? r.gamesCount : 0), 0),
    session_rounds_count: (rows) => rows.reduce((a, r) => a + (typeof r.roundsCount === "number" ? r.roundsCount : 0), 0),
    session_avg_score: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        const ss = r.scoreSum;
        const sc = r.scoreCount;
        if (typeof ss === "number" && typeof sc === "number" && sc > 0) {
          sum += ss;
          n += sc;
        }
      }
      return n ? sum / n : 0;
    },
    session_avg_guess_duration: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        const ss = r.durationSum;
        const sc = r.durationCount;
        if (typeof ss === "number" && typeof sc === "number" && sc > 0) {
          sum += ss;
          n += sc;
        }
      }
      return n ? sum / n : 0;
    },
    session_avg_distance_km: (rows) => {
      let sum = 0;
      let n = 0;
      for (const r of rows) {
        const ss = r.distanceSum;
        const sc = r.distanceCount;
        if (typeof ss === "number" && typeof sc === "number" && sc > 0) {
          sum += ss;
          n += sc;
        }
      }
      return n ? sum / n : 0;
    },
    session_fivek_rate: (rows) => {
      let fivek = 0;
      let n = 0;
      for (const r of rows) {
        const fk = r.fivekCount;
        const rc = r.roundsCount;
        if (typeof fk === "number" && typeof rc === "number" && rc > 0) {
          fivek += fk;
          n += rc;
        }
      }
      return n ? fivek / n : 0;
    },
    session_hit_rate: (rows) => {
      let k = 0;
      let n = 0;
      for (const r of rows) {
        const hk = r.hitCount;
        const rc = r.roundsCount;
        if (typeof hk === "number" && typeof rc === "number" && rc > 0) {
          k += hk;
          n += rc;
        }
      }
      return n ? k / n : 0;
    },
    session_throw_rate: (rows) => {
      let k = 0;
      let n = 0;
      for (const r of rows) {
        const tk = r.throwCount;
        const rc = r.roundsCount;
        if (typeof tk === "number" && typeof rc === "number" && rc > 0) {
          k += tk;
          n += rc;
        }
      }
      return n ? k / n : 0;
    },
    session_delta_rating: (rows) => {
      let sum = 0;
      for (const r of rows) {
        const d = r?.ratingDelta;
        if (typeof d === "number" && Number.isFinite(d)) sum += d;
      }
      return sum;
    },
    // Day-grain helpers (group sessions by time_day).
    day_win_rate_min5: (rows) => {
      let win = 0;
      let denom = 0;
      for (const r of rows) {
        const w = r?.winCount;
        const g = r?.gamesWithOutcome;
        if (typeof w === "number" && Number.isFinite(w) && typeof g === "number" && Number.isFinite(g) && g > 0) {
          win += w;
          denom += g;
        }
      }
      if (denom < 5) return NaN;
      return win / denom;
    },
    max_consecutive_days_without_games: (rows) => {
      const dayIndexSet = /* @__PURE__ */ new Set();
      for (const r of rows) {
        const ts = typeof r?.sessionStartTs === "number" ? r.sessionStartTs : typeof r?.ts === "number" ? r.ts : null;
        if (typeof ts !== "number" || !Number.isFinite(ts)) continue;
        const d = new Date(ts);
        const midnight = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
        dayIndexSet.add(Math.floor(midnight / 864e5));
      }
      const days2 = Array.from(dayIndexSet.values()).sort((a, b) => a - b);
      let bestGap = 0;
      for (let i = 1; i < days2.length; i++) {
        const gap = days2[i] - days2[i - 1] - 1;
        if (gap > bestGap) bestGap = gap;
      }
      return bestGap;
    },
    longest_active_streak_days: (rows) => {
      const dayIndexSet = /* @__PURE__ */ new Set();
      for (const r of rows) {
        const ts = typeof r?.sessionStartTs === "number" ? r.sessionStartTs : typeof r?.ts === "number" ? r.ts : null;
        if (typeof ts !== "number" || !Number.isFinite(ts)) continue;
        const d = new Date(ts);
        const midnight = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
        dayIndexSet.add(Math.floor(midnight / 864e5));
      }
      const days2 = Array.from(dayIndexSet.values()).sort((a, b) => a - b);
      let best = 0;
      let cur = 0;
      for (let i = 0; i < days2.length; i++) {
        if (i === 0 || days2[i] === days2[i - 1] + 1) cur++;
        else cur = 1;
        if (cur > best) best = cur;
      }
      return best;
    },
    longest_5k_day_streak_days: (rows) => {
      const dayIndexSet = /* @__PURE__ */ new Set();
      for (const r of rows) {
        const fivek = r?.fivekCount;
        if (typeof fivek !== "number" || !Number.isFinite(fivek) || fivek <= 0) continue;
        const ts = typeof r?.sessionStartTs === "number" ? r.sessionStartTs : typeof r?.ts === "number" ? r.ts : null;
        if (typeof ts !== "number" || !Number.isFinite(ts)) continue;
        const d = new Date(ts);
        const midnight = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
        dayIndexSet.add(Math.floor(midnight / 864e5));
      }
      const days2 = Array.from(dayIndexSet.values()).sort((a, b) => a - b);
      let best = 0;
      let cur = 0;
      for (let i = 0; i < days2.length; i++) {
        if (i === 0 || days2[i] === days2[i - 1] + 1) cur++;
        else cur = 1;
        if (cur > best) best = cur;
      }
      return best;
    }
  };
  var MEASURES_BY_GRAIN = {
    round: ROUND_MEASURES_BY_FORMULA_ID,
    game: GAME_MEASURES_BY_FORMULA_ID,
    session: SESSION_MEASURES_BY_FORMULA_ID
  };

  // src/ui/widgets/statListWidget.ts
  function readDateFormatMode(doc) {
    const root = doc.querySelector(".ga-root");
    const mode = root?.dataset?.gaDateFormat;
    return mode === "mm/dd/yyyy" || mode === "yyyy-mm-dd" || mode === "locale" ? mode : "dd/mm/yyyy";
  }
  function formatDateTime(doc, ts) {
    const d = new Date(ts);
    if (!Number.isFinite(d.getTime())) return String(ts);
    const mode = readDateFormatMode(doc);
    if (mode === "locale") return d.toLocaleString();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    const hh = String(d.getHours()).padStart(2, "0");
    const mm = String(d.getMinutes()).padStart(2, "0");
    const ss = String(d.getSeconds()).padStart(2, "0");
    if (mode === "yyyy-mm-dd") return `${y}-${m}-${day} ${hh}:${mm}:${ss}`;
    if (mode === "mm/dd/yyyy") return `${m}/${day}/${y} ${hh}:${mm}:${ss}`;
    return `${day}/${m}/${y} ${hh}:${mm}:${ss}`;
  }
  function formatValue(doc, semantic, measureId, value) {
    const m = semantic.measures[measureId];
    const unit = semantic.units[m.unit];
    if (!unit) return String(value);
    if (unit.format === "datetime") return formatDateTime(doc, value);
    if (unit.format === "percent") {
      const decimals2 = unit.decimals ?? 1;
      const clamped = Math.max(0, Math.min(1, value));
      return `${(clamped * 100).toFixed(decimals2)}%`;
    }
    if (unit.format === "duration") {
      const s = Math.max(0, Math.round(value));
      const days2 = Math.floor(s / 86400);
      const hours = Math.floor(s % 86400 / 3600);
      const mins = Math.floor(s % 3600 / 60);
      if (days2 > 0) return `${days2}d ${hours}h`;
      if (hours > 0) return `${hours}h ${mins}m`;
      if (mins > 0) return `${mins}m ${s % 60}s`;
      return `${Math.max(0, value).toFixed(1)}s`;
    }
    if (unit.format === "int") {
      const v = Math.round(value);
      return unit.showSign && v > 0 ? `+${v}` : String(v);
    }
    const decimals = unit.decimals ?? 1;
    const txt = value.toFixed(decimals);
    const base = unit.showSign && value > 0 ? `+${txt}` : txt;
    const suffix = (() => {
      const u = String(m.unit ?? "").trim().toLowerCase();
      if (u === "km") return " km";
      if (u === "seconds") return " s";
      return "";
    })();
    return `${base}${suffix}`;
  }
  async function computeMeasure(semantic, measureId, baseRows, grain, filters) {
    const m = semantic.measures[measureId];
    if (!m) return 0;
    const rowsAll = baseRows ?? (grain === "game" ? await getGames({}) : grain === "session" ? await getSessions({}) : await getRounds({}));
    const rows = applyFilters(rowsAll, filters, grain);
    const fn = MEASURES_BY_GRAIN[grain]?.[m.formulaId];
    if (!fn) throw new Error(`Missing measure implementation for formulaId=${m.formulaId}`);
    return fn(rows);
  }
  function attachClickIfAny(el2, actions, overlay, semantic, title, baseRows, grain, filters, measureId) {
    const clickBase = actions?.click;
    const click = clickBase && clickBase.type === "drilldown" ? {
      ...clickBase,
      filterFromPoint: clickBase.filterFromPoint ?? semantic.measures[measureId ?? ""]?.drilldown?.filterFromPoint,
      extraFilters: [
        ...semantic.measures[measureId ?? ""]?.drilldown?.extraFilters ?? [],
        ...clickBase.extraFilters ?? []
      ]
    } : clickBase;
    if (!click) return;
    el2.style.cursor = "pointer";
    el2.addEventListener("click", async () => {
      if (click.type === "drilldown") {
        const rowsAll = baseRows ?? (grain === "game" ? await getGames({}) : grain === "session" ? await getSessions({}) : await getRounds({}));
        const mergedFilters = [...filters ?? [], ...click.extraFilters ?? []];
        let rows = applyFilters(rowsAll, mergedFilters, grain);
        const meas = measureId ? semantic.measures[measureId] : void 0;
        const formulaId = meas?.formulaId ?? "";
        if (grain === "game" && formulaId === "max_player_self_end_rating") {
          const mode = (() => {
            for (const g of rows) {
              if (String(g?.modeFamily ?? "").trim().toLowerCase() === "duels") return "duel";
            }
            return "team";
          })();
          const getNum = (v) => typeof v === "number" && Number.isFinite(v) ? v : null;
          const endRatingOf = (g) => {
            if (mode === "duel") {
              return getNum(g.player_self_endRating) ?? getNum(g.playerOneEndRating) ?? getNum(g.player_self_end_rating) ?? null;
            }
            return getNum(g.teamOneEndRating) ?? getNum(g.player_self_endRating) ?? getNum(g.player_self_end_rating) ?? null;
          };
          let best = -Infinity;
          for (const g of rows) {
            const v = endRatingOf(g);
            if (typeof v === "number") best = Math.max(best, v);
          }
          if (Number.isFinite(best)) {
            const candidates = rows.filter((g) => endRatingOf(g) === best);
            const tsOf = (g) => typeof g.ts === "number" ? g.ts : typeof g.playedAt === "number" ? g.playedAt : 0;
            const bestOne = candidates.sort((a, b) => tsOf(b) - tsOf(a))[0];
            rows = bestOne ? [bestOne] : candidates;
          }
        }
        if (grain === "game" && (formulaId === "max_win_streak" || formulaId === "max_loss_streak")) {
          const want = formulaId === "max_win_streak" ? "Win" : "Loss";
          const outcomeKey = DIMENSION_EXTRACTORS.game?.result;
          const tsOf = (g) => typeof g.ts === "number" ? g.ts : typeof g.playedAt === "number" ? g.playedAt : 0;
          const mergedFiltersForStreak = mergedFilters.filter((c) => c?.dimension !== "result");
          const rowsForStreak = applyFilters(rowsAll, mergedFiltersForStreak, grain);
          const sorted = [...rowsForStreak].sort((a, b) => tsOf(a) - tsOf(b));
          let bestLen = 0;
          let bestEnd = -1;
          let cur = 0;
          for (let i = 0; i < sorted.length; i++) {
            const o = outcomeKey ? outcomeKey(sorted[i]) : sorted[i]?.result;
            if (!o) continue;
            if (o === want) {
              cur++;
              if (cur > bestLen) {
                bestLen = cur;
                bestEnd = i;
              }
            } else {
              cur = 0;
            }
          }
          if (bestLen > 0 && bestEnd >= 0) {
            rows = sorted.slice(bestEnd - bestLen + 1, bestEnd + 1);
          }
        }
        if (grain === "game" && (formulaId === "max_opponent_start_rating" || formulaId === "max_defeated_opponent_start_rating")) {
          const filtered = formulaId === "max_defeated_opponent_start_rating" ? rows.filter((g) => (DIMENSION_EXTRACTORS.game?.result?.(g) ?? g.result) === "Win") : rows;
          const opponentStartOf = (g) => {
            const mode = String(g?.modeFamily ?? "").trim().toLowerCase();
            const nums = [];
            const pushNum = (v) => {
              if (typeof v === "number" && Number.isFinite(v)) nums.push(v);
            };
            if (mode === "teamduels") {
              pushNum(g.player_opponent_startRating);
              pushNum(g.player_opponent_mate_startRating);
            } else {
              pushNum(g.player_opponent_startRating);
              pushNum(g.playerTwoStartRating);
            }
            if (!nums.length) return null;
            return Math.max(...nums);
          };
          let best = -Infinity;
          for (const g of filtered) {
            const v = opponentStartOf(g);
            if (typeof v === "number") best = Math.max(best, v);
          }
          if (Number.isFinite(best)) {
            const candidates = filtered.filter((g) => opponentStartOf(g) === best);
            const tsOf = (g) => typeof g.ts === "number" ? g.ts : typeof g.playedAt === "number" ? g.playedAt : 0;
            const bestOne = candidates.sort((a, b) => tsOf(b) - tsOf(a))[0];
            rows = bestOne ? [bestOne] : candidates;
          } else {
            rows = [];
          }
        }
        if (grain === "game" && (formulaId === "max_player_self_rating_delta" || formulaId === "min_player_self_rating_delta")) {
          const getNum = (v) => typeof v === "number" && Number.isFinite(v) ? v : null;
          const isTeam = (g) => {
            const mf = String(g?.modeFamily ?? g?.mode_family ?? "").trim().toLowerCase();
            return g?.isTeamDuels === true || mf === "teamduels" || mf.includes("team") && mf.includes("duel");
          };
          const startRatingOf = (g) => {
            if (isTeam(g)) return getNum(g.teamOneStartRating) ?? getNum(g.player_self_startRating) ?? getNum(g.playerOneStartRating) ?? null;
            return getNum(g.player_self_startRating) ?? getNum(g.playerOneStartRating) ?? null;
          };
          const endRatingOf = (g) => {
            if (isTeam(g)) return getNum(g.teamOneEndRating) ?? getNum(g.player_self_endRating) ?? getNum(g.playerOneEndRating) ?? null;
            return getNum(g.player_self_endRating) ?? getNum(g.playerOneEndRating) ?? null;
          };
          const deltaOf = (g) => {
            const end = endRatingOf(g);
            const start = startRatingOf(g) ?? end;
            if (end === null || start === null) return null;
            if (end === 0 || start === 0) return null;
            return end - start;
          };
          let best = formulaId === "min_player_self_rating_delta" ? Infinity : -Infinity;
          for (const g of rows) {
            const d = deltaOf(g);
            if (typeof d !== "number" || !Number.isFinite(d)) continue;
            best = formulaId === "min_player_self_rating_delta" ? Math.min(best, d) : Math.max(best, d);
          }
          if (Number.isFinite(best)) {
            const candidates = rows.filter((g) => deltaOf(g) === best);
            const tsOf = (g) => typeof g.ts === "number" ? g.ts : typeof g.playedAt === "number" ? g.playedAt : 0;
            const bestOne = candidates.sort((a, b) => tsOf(b) - tsOf(a))[0];
            rows = bestOne ? [bestOne] : candidates;
          } else {
            rows = [];
          }
        }
        overlay.open(semantic, {
          title,
          target: click.target,
          columnsPreset: click.columnsPreset,
          rows,
          extraFilters: click.extraFilters,
          initialSort: click.initialSort
        });
      }
    });
  }
  async function renderStatListWidget(semantic, widget, overlay, baseRows) {
    const spec = widget.spec;
    const doc = overlay.getDocument();
    const widgetGrain = widget.grain;
    const wrap = doc.createElement("div");
    wrap.className = "ga-widget ga-statlist";
    const title = doc.createElement("div");
    title.className = "ga-widget-title";
    title.textContent = widget.title;
    const box = doc.createElement("div");
    box.className = "ga-statlist-box";
    for (const row of spec.rows) {
      const rowGrain = row.grain ? row.grain : widgetGrain;
      const rowBaseRows = rowGrain === widgetGrain ? baseRows : void 0;
      const line = doc.createElement("div");
      line.className = "ga-statrow";
      const left = doc.createElement("div");
      left.className = "ga-statrow-label";
      left.textContent = row.label;
      const right = doc.createElement("div");
      right.className = "ga-statrow-value";
      right.textContent = "...";
      const val = await computeMeasure(semantic, row.measure, rowBaseRows, rowGrain, row.filters);
      const primaryText = formatValue(doc, semantic, row.measure, val);
      const secondaryId = typeof row.secondaryMeasure === "string" ? row.secondaryMeasure.trim() : "";
      if (secondaryId) {
        const secVal = await computeMeasure(semantic, secondaryId, rowBaseRows, rowGrain, row.filters);
        const secondaryText = formatValue(doc, semantic, secondaryId, secVal);
        right.textContent = `${primaryText} (${secondaryText})`;
      } else {
        right.textContent = primaryText;
      }
      attachClickIfAny(line, row.actions, overlay, semantic, `${row.label} - Drilldown`, rowBaseRows, rowGrain, row.filters, row.measure);
      line.appendChild(left);
      line.appendChild(right);
      box.appendChild(line);
    }
    wrap.appendChild(title);
    wrap.appendChild(box);
    return wrap;
  }

  // src/engine/aggregate.ts
  function groupByKey(rows, keyFn) {
    const m = /* @__PURE__ */ new Map();
    for (const r of rows) {
      const k = keyFn(r);
      if (!k) continue;
      const arr = m.get(k);
      if (arr) arr.push(r);
      else m.set(k, [r]);
    }
    return m;
  }

  // src/ui/widgets/chartWidget.ts
  function getShareKindFromFormulaId(formulaId) {
    if (formulaId === "share_damage_dealt") return "dealt";
    if (formulaId === "share_damage_taken") return "taken";
    return null;
  }
  function sumDamage(rows, kind) {
    let sum = 0;
    for (const r of rows) {
      const dmg = r?.damage;
      if (typeof dmg !== "number" || !Number.isFinite(dmg)) continue;
      if (kind === "dealt") sum += Math.max(0, dmg);
      else sum += Math.max(0, -dmg);
    }
    return sum;
  }
  function sortKeysChronological(keys2) {
    const weekdayRank = (k) => {
      const v = k.trim().toLowerCase();
      if (v === "mon") return 0;
      if (v === "tue") return 1;
      if (v === "wed") return 2;
      if (v === "thu") return 3;
      if (v === "fri") return 4;
      if (v === "sat") return 5;
      if (v === "sun") return 6;
      return void 0;
    };
    const weekdayKeys = keys2.map((k) => weekdayRank(k));
    if (weekdayKeys.every((r) => r !== void 0)) {
      return [...keys2].sort((a, b) => (weekdayRank(a) ?? 0) - (weekdayRank(b) ?? 0));
    }
    const parseKey = (k) => {
      const first = k.split("-")[0] ?? k;
      const t = first.trim();
      if (t.startsWith("<")) return -1;
      if (t.startsWith(">")) return 1e9;
      const parsed = Number(t.replace(/[^0-9.]/g, ""));
      return Number.isFinite(parsed) ? parsed : void 0;
    };
    return [...keys2].sort((a, b) => {
      const na = parseKey(a);
      const nb = parseKey(b);
      if (na !== void 0 && nb !== void 0) return na - nb;
      if (na !== void 0) return -1;
      if (nb !== void 0) return 1;
      return a.localeCompare(b);
    });
  }
  function sortData(data, mode) {
    if (mode === "chronological") {
      const keys2 = sortKeysChronological(data.map((d) => d.x));
      const rank = new Map(keys2.map((k, i) => [k, i]));
      return [...data].sort((a, b) => (rank.get(a.x) ?? 0) - (rank.get(b.x) ?? 0));
    }
    if (mode === "asc") return [...data].sort((a, b) => a.y - b.y);
    if (mode === "desc") return [...data].sort((a, b) => b.y - a.y);
    return data;
  }
  function getSortModes(spec) {
    const out = [];
    const single = spec.sort?.mode;
    if (single) out.push(single);
    if (Array.isArray(spec.sorts)) {
      for (const s of spec.sorts) {
        const mode = s?.mode;
        if (!mode) continue;
        if (!out.includes(mode)) out.push(mode);
      }
    }
    return out;
  }
  function sortLabel(mode) {
    if (mode === "chronological") return "Chronological";
    if (mode === "asc") return "Ascending";
    return "Descending";
  }
  function accumulationLabel(mode) {
    return mode === "to_date" ? "To date" : "Per period";
  }
  function toDayKey(ts) {
    const d = new Date(ts);
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`;
  }
  function dayKeysBetween(fromTs, toTs2) {
    const out = [];
    const start = new Date(fromTs);
    start.setHours(0, 0, 0, 0);
    const end = new Date(toTs2);
    end.setHours(0, 0, 0, 0);
    for (let t = start.getTime(); t <= end.getTime(); t += 24 * 60 * 60 * 1e3) {
      out.push(toDayKey(t));
    }
    return out;
  }
  function chunkKeys(keys2, maxPoints, labelMode = "range") {
    if (!Number.isFinite(maxPoints) || maxPoints <= 1) return keys2.map((k) => ({ label: k, keys: [k] }));
    if (keys2.length <= maxPoints) return keys2.map((k) => ({ label: k, keys: [k] }));
    const bucket = Math.ceil(keys2.length / maxPoints);
    const out = [];
    for (let i = 0; i < keys2.length; i += bucket) {
      const slice = keys2.slice(i, i + bucket);
      const label = slice.length <= 1 ? slice[0] : labelMode === "start" ? slice[0] : `${slice[0]}..${slice[slice.length - 1]}`;
      out.push({ label, keys: slice });
    }
    return out;
  }
  function getMeasureIds(spec) {
    const out = [];
    const single = typeof spec.y.measure === "string" ? spec.y.measure.trim() : "";
    if (single) out.push(single);
    if (Array.isArray(spec.y.measures)) {
      for (const m of spec.y.measures) {
        if (typeof m !== "string") continue;
        const clean = m.trim();
        if (!clean || out.includes(clean)) continue;
        out.push(clean);
      }
    }
    return out;
  }
  function readDateFormatMode2(doc) {
    const root = doc.querySelector(".ga-root");
    const mode = root?.dataset?.gaDateFormat;
    return mode === "mm/dd/yyyy" || mode === "yyyy-mm-dd" || mode === "locale" ? mode : "dd/mm/yyyy";
  }
  function formatDateTime2(doc, ts) {
    const d = new Date(ts);
    if (!Number.isFinite(d.getTime())) return String(ts);
    const mode = readDateFormatMode2(doc);
    if (mode === "locale") return d.toLocaleString();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    const hh = String(d.getHours()).padStart(2, "0");
    const mm = String(d.getMinutes()).padStart(2, "0");
    const ss = String(d.getSeconds()).padStart(2, "0");
    if (mode === "yyyy-mm-dd") return `${y}-${m}-${day} ${hh}:${mm}:${ss}`;
    if (mode === "mm/dd/yyyy") return `${m}/${day}/${y} ${hh}:${mm}:${ss}`;
    return `${day}/${m}/${y} ${hh}:${mm}:${ss}`;
  }
  function readCountryFormatMode(doc) {
    const root = doc.querySelector(".ga-root");
    return root?.dataset?.gaCountryFormat === "english" ? "english" : "iso2";
  }
  function formatCountry(doc, isoOrName) {
    const mode = readCountryFormatMode(doc);
    if (mode === "iso2") return isoOrName;
    const iso2 = isoOrName.trim().toUpperCase();
    if (!/^[A-Z]{2}$/.test(iso2)) return isoOrName;
    if (typeof Intl === "undefined" || !Intl.DisplayNames) return isoOrName;
    try {
      const dn = new Intl.DisplayNames(["en"], { type: "region" });
      return dn.of(iso2) ?? isoOrName;
    } catch {
      return isoOrName;
    }
  }
  function formatDimensionKey(doc, dimId, key) {
    if (dimId === "confused_countries") return key;
    if (dimId === "true_country" || dimId === "guess_country" || dimId === "opponent_country") return formatCountry(doc, key);
    return key;
  }
  function formatMeasureValue(doc, semantic, measureId, value) {
    const measure = semantic.measures[measureId];
    const unit = measure ? semantic.units[measure.unit] : void 0;
    if (!unit) return `${value}`;
    if (unit.format === "datetime") return formatDateTime2(doc, value);
    if (unit.format === "percent") {
      const clamped = Math.max(0, Math.min(1, value));
      return `${(clamped * 100).toFixed(unit.decimals ?? 1)}%`;
    }
    if (unit.format === "duration") {
      const s = Math.max(0, Math.round(value));
      const days2 = Math.floor(s / 86400);
      const hours = Math.floor(s % 86400 / 3600);
      const mins = Math.floor(s % 3600 / 60);
      if (days2 > 0) return `${days2}d ${hours}h`;
      if (hours > 0) return `${hours}h ${mins}m`;
      if (mins > 0) return `${mins}m ${s % 60}s`;
      return `${Math.max(0, value).toFixed(1)}s`;
    }
    if (unit.format === "int") {
      const v = Math.round(value);
      return unit.showSign && v > 0 ? `+${v}` : `${v}`;
    }
    const txt = value.toFixed(unit.decimals ?? 1);
    return unit.showSign && value > 0 ? `+${txt}` : txt;
  }
  function clampForMeasure(semantic, measureId, value) {
    const measure = semantic.measures[measureId];
    const unit = measure ? semantic.units[measure.unit] : void 0;
    if (unit?.format === "percent") return Math.max(0, Math.min(1, value));
    return value;
  }
  function mergeDrilldownDefaults(base, defs) {
    if (!base) return base;
    if (!defs) return base;
    return {
      ...base,
      filterFromPoint: base.filterFromPoint ?? defs.filterFromPoint,
      extraFilters: [...defs.extraFilters ?? [], ...base.extraFilters ?? []]
    };
  }
  function normalizeClickForActiveMeasure(semantic, activeMeasureId, click) {
    if (!click || click.type !== "drilldown") return click;
    const meas = semantic.measures[activeMeasureId];
    const grain = meas?.grain ?? "";
    if (grain === "game") {
      return {
        ...click,
        target: "players",
        columnsPreset: "opponentMode"
      };
    }
    return click;
  }
  function computeYBounds(opts) {
    const { unitFormat, values, preferZero, hardMin, hardMax } = opts;
    const finite = values.filter((v) => Number.isFinite(v));
    if (finite.length === 0) return { minY: 0, maxY: 1 };
    if (unitFormat === "percent") {
      const clamped = finite.map((v) => Math.max(0, Math.min(1, v)));
      let min2 = Math.min(...clamped);
      let max2 = Math.max(...clamped);
      if (preferZero) min2 = 0;
      let range2 = max2 - min2;
      if (!Number.isFinite(range2) || range2 <= 0) range2 = Math.max(0.01, Math.abs(max2) || 0.01);
      const pad2 = range2 * 0.06;
      min2 = Math.max(0, min2 - pad2);
      max2 = Math.min(1, max2 + pad2);
      range2 = max2 - min2;
      const niceStep2 = (raw) => {
        if (!Number.isFinite(raw) || raw <= 0) return 0.01;
        const exp = Math.floor(Math.log10(raw));
        const base = 10 ** exp;
        const n = raw / base;
        const nice = n <= 1 ? 1 : n <= 2 ? 2 : n <= 2.5 ? 2.5 : n <= 5 ? 5 : 10;
        return nice * base;
      };
      const tickCount2 = 5;
      const step2 = niceStep2(range2 / tickCount2);
      const niceMin2 = preferZero ? 0 : Math.max(0, Math.floor(min2 / step2) * step2);
      const niceMax2 = Math.min(1, Math.ceil(max2 / step2) * step2);
      if (niceMax2 <= niceMin2) return { minY: niceMin2, maxY: Math.min(1, niceMin2 + Math.max(step2, 0.01)) };
      return { minY: niceMin2, maxY: niceMax2 };
    }
    let min = Math.min(...finite);
    let max = Math.max(...finite);
    if (preferZero) min = Math.min(0, min);
    if (typeof hardMin === "number" && Number.isFinite(hardMin)) min = Math.max(min, hardMin);
    if (typeof hardMax === "number" && Number.isFinite(hardMax)) max = Math.min(max, hardMax);
    let range = max - min;
    if (!Number.isFinite(range) || range <= 0) range = Math.max(1, Math.abs(max) || 1);
    const pad = range * 0.06;
    min -= pad;
    max += pad;
    if (typeof hardMin === "number" && Number.isFinite(hardMin)) min = Math.max(min, hardMin);
    if (typeof hardMax === "number" && Number.isFinite(hardMax)) max = Math.min(max, hardMax);
    range = max - min;
    const niceStep = (raw) => {
      if (!Number.isFinite(raw) || raw <= 0) return 1;
      const exp = Math.floor(Math.log10(raw));
      const base = 10 ** exp;
      const n = raw / base;
      const nice = n <= 1 ? 1 : n <= 2 ? 2 : n <= 2.5 ? 2.5 : n <= 5 ? 5 : 10;
      return nice * base;
    };
    const tickCount = 5;
    const step = niceStep(range / tickCount);
    const niceMin = preferZero ? 0 : Math.floor(min / step) * step;
    const niceMax = Math.ceil(max / step) * step;
    let outMin = Number.isFinite(niceMin) ? niceMin : 0;
    let outMax = Number.isFinite(niceMax) ? niceMax : 1;
    if (typeof hardMin === "number" && Number.isFinite(hardMin)) outMin = Math.max(outMin, hardMin);
    if (typeof hardMax === "number" && Number.isFinite(hardMax)) outMax = Math.min(outMax, hardMax);
    if (outMax <= outMin) return { minY: outMin, maxY: outMin + 1 };
    return { minY: outMin, maxY: outMax };
  }
  function normalizeHexColor(value) {
    if (typeof value !== "string") return void 0;
    const v = value.trim();
    return /^#[0-9a-fA-F]{6}$/.test(v) ? v : void 0;
  }
  function isAnimationsEnabled(doc) {
    const root = doc.getElementById("geoanalyzr-semantic-root");
    return root?.getAttribute("data-ga-chart-animations") !== "off";
  }
  function maybeAnimateChartSvg(svg, doc) {
    if (!isAnimationsEnabled(doc)) {
      svg.setAttribute("data-anim-state", "off");
      return;
    }
    svg.setAttribute("data-anim-state", "pending");
    const obs = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (!entry.isIntersecting) continue;
          svg.setAttribute("data-anim-state", "run");
          obs.disconnect();
          return;
        }
      },
      { threshold: 0.15 }
    );
    obs.observe(svg);
  }
  function sanitizeFileName(name) {
    const out = name.replace(/[<>:"/\\|?*\x00-\x1F]/g, "_").trim();
    return out.length > 0 ? out : "chart";
  }
  function triggerDownload(doc, blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = doc.createElement("a");
    a.href = url;
    a.download = filename;
    doc.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1e3);
  }
  function readCssVar(doc, name) {
    const root = doc.querySelector(".ga-root");
    const cs = root ? doc.defaultView?.getComputedStyle(root) : null;
    const v = cs?.getPropertyValue(name)?.trim() ?? "";
    return v.length > 0 ? v : null;
  }
  function resolveVarsInString(value, vars) {
    return value.replace(/var\(\s*(--[a-zA-Z0-9_-]+)\s*\)/g, (m, varName) => vars.get(String(varName)) ?? m);
  }
  function serializeSvg(svg) {
    const clone = svg.cloneNode(true);
    if (!clone.getAttribute("xmlns")) clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    clone.removeAttribute("data-anim-state");
    const vb = clone.getAttribute("viewBox")?.trim().split(/\s+/).map(Number) ?? [];
    const width = Number.isFinite(vb[2]) && vb[2] > 0 ? vb[2] : 1200;
    const height = Number.isFinite(vb[3]) && vb[3] > 0 ? vb[3] : 360;
    clone.setAttribute("width", String(width));
    clone.setAttribute("height", String(height));
    const doc = svg.ownerDocument;
    const vars = /* @__PURE__ */ new Map();
    const varNames = ["--ga-axis-color", "--ga-axis-grid", "--ga-axis-text", "--ga-graph-color", "--ga-surface", "--ga-card-2"];
    for (const n of varNames) {
      const v = readCssVar(doc, n);
      if (v) vars.set(n, v);
    }
    for (const [k, v] of vars.entries()) clone.style.setProperty(k, v);
    const bgSource = svg.closest(".ga-chart-box") ?? svg.closest(".ga-widget") ?? doc.querySelector(".ga-root");
    const bg = bgSource ? doc.defaultView?.getComputedStyle(bgSource)?.backgroundColor?.trim() : "";
    const bgFill = bg && bg !== "rgba(0, 0, 0, 0)" && bg !== "transparent" ? bg : vars.get("--ga-surface") ?? vars.get("--ga-card-2") ?? "#0f111a";
    const rect = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("x", "0");
    rect.setAttribute("y", "0");
    rect.setAttribute("width", String(width));
    rect.setAttribute("height", String(height));
    rect.setAttribute("fill", bgFill);
    clone.insertBefore(rect, clone.firstChild);
    const nodes = clone.querySelectorAll("*");
    for (const el2 of Array.from(nodes)) {
      for (const attr of ["fill", "stroke", "stop-color", "color"]) {
        const val = el2.getAttribute(attr);
        if (!val || !val.includes("var(")) continue;
        el2.setAttribute(attr, resolveVarsInString(val, vars));
      }
      const style = el2.getAttribute("style");
      if (style && style.includes("var(")) el2.setAttribute("style", resolveVarsInString(style, vars));
    }
    return { text: new XMLSerializer().serializeToString(clone), width, height };
  }
  async function downloadSvg(doc, svg, title) {
    const { text } = serializeSvg(svg);
    const blob = new Blob([text], { type: "image/svg+xml;charset=utf-8" });
    triggerDownload(doc, blob, `${sanitizeFileName(title)}.svg`);
  }
  async function downloadPng(doc, svg, title) {
    const prepared = serializeSvg(svg);
    const svgBlob = new Blob([prepared.text], { type: "image/svg+xml;charset=utf-8" });
    const url = URL.createObjectURL(svgBlob);
    try {
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = () => resolve();
        img.onerror = () => reject(new Error("Could not render chart image."));
        img.src = url;
      });
      const canvas = doc.createElement("canvas");
      canvas.width = prepared.width;
      canvas.height = prepared.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) throw new Error("Canvas context unavailable.");
      ctx.drawImage(img, 0, 0, prepared.width, prepared.height);
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
      if (blob) {
        triggerDownload(doc, blob, `${sanitizeFileName(title)}.png`);
        return;
      }
      const dataUrl = canvas.toDataURL("image/png");
      const fallbackBlob = await (await fetch(dataUrl)).blob();
      triggerDownload(doc, fallbackBlob, `${sanitizeFileName(title)}.png`);
    } finally {
      URL.revokeObjectURL(url);
    }
  }
  function prepareLineAnimation(path) {
    const len = Math.max(1, Math.ceil(path.getTotalLength()));
    path.style.setProperty("--ga-line-length", String(len));
    path.style.strokeDasharray = `${len}`;
    path.style.strokeDashoffset = `${len}`;
  }
  async function renderChartWidget(semantic, widget, overlay, datasets, context) {
    const spec = widget.spec;
    const doc = overlay.getDocument();
    const wrap = doc.createElement("div");
    wrap.className = "ga-widget ga-chart";
    const title = doc.createElement("div");
    title.className = "ga-widget-title";
    title.textContent = widget.title;
    const controls = doc.createElement("div");
    controls.className = "ga-chart-controls";
    const controlsLeft = doc.createElement("div");
    controlsLeft.className = "ga-chart-controls-left";
    controls.appendChild(controlsLeft);
    const actionsRight = doc.createElement("div");
    actionsRight.className = "ga-chart-actions";
    controls.appendChild(actionsRight);
    const box = doc.createElement("div");
    box.className = "ga-chart-box";
    const chartHost = doc.createElement("div");
    chartHost.className = "ga-chart-host";
    box.appendChild(chartHost);
    const dimId = spec.x.dimension;
    const dimDef = semantic.dimensions[dimId];
    if (!dimDef) throw new Error(`Unknown dimension '${dimId}' in widget ${widget.widgetId}`);
    const measureIds = getMeasureIds(spec);
    if (measureIds.length === 0) throw new Error(`Widget ${widget.widgetId} has no y.measure or y.measures`);
    const colorOverride = normalizeHexColor(spec.color);
    const sortModes = getSortModes(spec);
    let activeSortMode = spec.activeSort?.mode ?? spec.sort?.mode ?? sortModes[0];
    if (activeSortMode && !sortModes.includes(activeSortMode)) sortModes.unshift(activeSortMode);
    let activeMeasure = measureIds.includes(spec.y.activeMeasure || "") ? spec.y.activeMeasure : measureIds[0];
    const accModes = [];
    const singleAcc = spec.y.accumulation;
    if (singleAcc) accModes.push(singleAcc);
    if (Array.isArray(spec.y.accumulations)) {
      for (const a of spec.y.accumulations) {
        if (!a) continue;
        if (!accModes.includes(a)) accModes.push(a);
      }
    }
    let activeAcc = spec.y.activeAccumulation ?? spec.y.accumulation ?? accModes[0] ?? "period";
    if (!accModes.includes(activeAcc)) accModes.unshift(activeAcc);
    let currentSvg = null;
    const mkActionBtn = (label, onClick) => {
      const btn = doc.createElement("button");
      btn.type = "button";
      btn.textContent = label;
      btn.addEventListener("click", onClick);
      return btn;
    };
    actionsRight.appendChild(
      mkActionBtn("Save PNG", () => {
        if (currentSvg) void downloadPng(doc, currentSvg, `${widget.title}_${activeMeasure}`);
      })
    );
    actionsRight.appendChild(
      mkActionBtn("Save SVG", () => {
        if (currentSvg) void downloadSvg(doc, currentSvg, `${widget.title}_${activeMeasure}`);
      })
    );
    if (sortModes.length > 1) {
      const label = doc.createElement("label");
      label.style.fontSize = "12px";
      label.style.opacity = "0.9";
      label.textContent = "Sort:";
      const select = doc.createElement("select");
      select.style.background = "var(--ga-control-bg)";
      select.style.color = "var(--ga-control-text)";
      select.style.border = "1px solid var(--ga-control-border)";
      select.style.borderRadius = "8px";
      select.style.padding = "4px 8px";
      for (const mode of sortModes) {
        const option = doc.createElement("option");
        option.value = mode;
        option.textContent = sortLabel(mode);
        if (mode === activeSortMode) option.selected = true;
        select.appendChild(option);
      }
      select.addEventListener("change", () => {
        const next = select.value;
        if (!sortModes.includes(next)) return;
        activeSortMode = next;
        render();
      });
      controlsLeft.appendChild(label);
      controlsLeft.appendChild(select);
    }
    if (accModes.length > 1 && dimId === "time_day") {
      const label = doc.createElement("label");
      label.style.fontSize = "12px";
      label.style.opacity = "0.9";
      label.textContent = "Mode:";
      const select = doc.createElement("select");
      select.style.background = "var(--ga-control-bg)";
      select.style.color = "var(--ga-control-text)";
      select.style.border = "1px solid var(--ga-control-border)";
      select.style.borderRadius = "8px";
      select.style.padding = "4px 8px";
      for (const mode of accModes) {
        const option = doc.createElement("option");
        option.value = mode;
        option.textContent = accumulationLabel(mode);
        if (mode === activeAcc) option.selected = true;
        select.appendChild(option);
      }
      select.addEventListener("change", () => {
        const next = select.value;
        if (!accModes.includes(next)) return;
        activeAcc = next;
        render();
      });
      controlsLeft.appendChild(label);
      controlsLeft.appendChild(select);
    }
    function getActiveGrain() {
      const measDef = semantic.measures[activeMeasure];
      return measDef?.grain ?? widget.grain;
    }
    function getDatasetForGrain(g) {
      const provided = datasets?.[g];
      if (Array.isArray(provided)) return provided;
      if (g === "game") return [];
      if (g === "session") return [];
      return [];
    }
    const drilldownGrainForTarget = (target) => {
      if (target === "rounds") return "round";
      if (target === "players") return "game";
      if (target === "games") return "game";
      if (target === "sessions") return "session";
      return getActiveGrain();
    };
    const materializeRowsForDrilldown = (target, sourceGrain, rows) => {
      const g = drilldownGrainForTarget(target);
      if (g === sourceGrain) return { grain: g, rows };
      if (sourceGrain === "session" && g === "round") {
        const out = [];
        for (const s of rows) {
          const r = s?.rounds;
          if (Array.isArray(r)) out.push(...r);
        }
        return { grain: "round", rows: out };
      }
      return { grain: g, rows };
    };
    const buildDataForMeasure = (measureId, limitOverride) => {
      const measDef = semantic.measures[measureId];
      if (!measDef) return [];
      const g = measDef.grain;
      const rows = getDatasetForGrain(g);
      const keyFn = DIMENSION_EXTRACTORS[g]?.[dimId];
      if (!keyFn) return [];
      const measureFn = MEASURES_BY_GRAIN[g]?.[measDef.formulaId];
      if (!measureFn) return [];
      const shareKind = getShareKindFromFormulaId(measDef.formulaId);
      const denom = shareKind ? sumDamage(rows, shareKind) : 0;
      const yForRows = (bucketRows) => {
        if (!shareKind) return measureFn(bucketRows);
        return denom > 0 ? sumDamage(bucketRows, shareKind) / denom : 0;
      };
      if (dimId === "time_day") {
        const tsValues = rows.map(
          (r) => typeof r.playedAt === "number" ? r.playedAt : typeof r.ts === "number" ? r.ts : null
        ).filter((x) => typeof x === "number");
        const dataMinTs = tsValues.length ? Math.min(...tsValues) : null;
        const dataMaxTs = tsValues.length ? Math.max(...tsValues) : null;
        let fromTs = context?.dateRange?.fromTs ?? null;
        let toTs2 = context?.dateRange?.toTs ?? null;
        if (fromTs === null) fromTs = dataMinTs;
        if (toTs2 === null) toTs2 = dataMaxTs;
        if (dataMinTs !== null && fromTs !== null) fromTs = Math.max(fromTs, dataMinTs);
        if (dataMaxTs !== null && toTs2 !== null) toTs2 = Math.min(toTs2, dataMaxTs);
        if (fromTs !== null && toTs2 !== null && fromTs > toTs2) fromTs = toTs2;
        const grouped2 = groupByKey(rows, keyFn);
        const keys3 = fromTs !== null && toTs2 !== null ? dayKeysBetween(fromTs, toTs2) : sortKeysChronological(Array.from(grouped2.keys()));
        const maxPoints = typeof spec.maxPoints === "number" && Number.isFinite(spec.maxPoints) ? Math.floor(spec.maxPoints) : typeof limitOverride === "number" && Number.isFinite(limitOverride) ? Math.floor(limitOverride) : 0;
        const buckets = maxPoints > 1 ? chunkKeys(keys3, maxPoints, "start") : keys3.map((k) => ({ label: k, keys: [k] }));
        if (activeAcc === "to_date") {
          const cum = [];
          const out2 = [];
          for (const b of buckets) {
            const bucketRows = [];
            for (const k of b.keys) {
              const dayRows = grouped2.get(k) ?? [];
              if (dayRows.length) bucketRows.push(...dayRows);
            }
            if (bucketRows.length) cum.push(...bucketRows);
            out2.push({ x: b.label, y: clampForMeasure(semantic, measureId, yForRows(cum)), rows: cum.slice() });
          }
          return out2;
        }
        const fillMode = measDef.timeDayFill ?? "none";
        const isRating = measDef.unit === "rating";
        let lastY = null;
        const out = [];
        for (const b of buckets) {
          const bucketRows = [];
          for (const k of b.keys) {
            const dayRows = grouped2.get(k) ?? [];
            if (dayRows.length) bucketRows.push(...dayRows);
          }
          const yRaw = yForRows(bucketRows);
          const y = clampForMeasure(semantic, measureId, yRaw);
          if (fillMode === "carry_forward" && lastY !== null) {
            const isEmptyBucket = bucketRows.length === 0;
            const isMissingRatingValue = isRating && bucketRows.length > 0 && y === 0;
            const isNonFinite = !Number.isFinite(y);
            if (isEmptyBucket || isMissingRatingValue || isNonFinite) {
              out.push({ x: b.label, y: lastY, rows: bucketRows });
              continue;
            }
          }
          lastY = y;
          out.push({ x: b.label, y, rows: bucketRows });
        }
        return out;
      }
      const grouped = groupByKey(rows, keyFn);
      const keys2 = Array.from(grouped.keys());
      const baseData = keys2.map((k) => {
        const rowsForKey = grouped.get(k) ?? [];
        return { x: k, y: clampForMeasure(semantic, measureId, yForRows(rowsForKey)), rows: rowsForKey };
      });
      if (dimDef.ordered && typeof spec.maxPoints === "number" && Number.isFinite(spec.maxPoints) && spec.maxPoints > 1) {
        const maxPoints = Math.floor(spec.maxPoints);
        const ordered = sortData(baseData, "chronological");
        if (ordered.length > maxPoints && activeSortMode === "chronological") {
          const buckets = chunkKeys(ordered.map((d) => d.x), maxPoints);
          const byKey = new Map(ordered.map((d) => [d.x, d]));
          const out = buckets.map((b) => {
            const bucketRows = [];
            for (const k of b.keys) {
              const item = byKey.get(k);
              if (item?.rows?.length) bucketRows.push(...item.rows);
            }
            return { x: b.label, y: clampForMeasure(semantic, measureId, yForRows(bucketRows)), rows: bucketRows };
          });
          return out;
        }
      }
      const sortedData = sortData(baseData, activeSortMode);
      const limit = typeof limitOverride === "number" && Number.isFinite(limitOverride) && limitOverride > 0 ? limitOverride : spec.limit;
      return typeof limit === "number" && Number.isFinite(limit) && limit > 0 ? sortedData.slice(0, Math.floor(limit)) : sortedData;
    };
    const render = () => {
      chartHost.innerHTML = "";
      currentSvg = null;
      const measureDef = semantic.measures[activeMeasure];
      if (!measureDef) {
        const empty = doc.createElement("div");
        empty.style.fontSize = "12px";
        empty.style.opacity = "0.75";
        empty.textContent = "No chart data available for current selection.";
        chartHost.appendChild(empty);
        return;
      }
      const W = 1200;
      const H = 360;
      const PAD_L = 72;
      const PAD_B = 58;
      const PAD_T = 16;
      const PAD_R = 72;
      const innerW = W - PAD_L - PAD_R;
      const innerH = H - PAD_T - PAD_B;
      const effectiveLimit = spec.type === "bar" && !(typeof spec.limit === "number" && Number.isFinite(spec.limit) && spec.limit > 0) ? (() => {
        const hostW = chartHost.getBoundingClientRect().width;
        const safeHostW = hostW > 50 ? hostW : 1e3;
        const minBarPx = 18;
        const pxInnerW = safeHostW * (innerW / W);
        const maxBars = Math.floor(pxInnerW / minBarPx);
        return Math.max(6, Math.min(200, maxBars));
      })() : void 0;
      const data = buildDataForMeasure(activeMeasure, effectiveLimit);
      if (data.length === 0) {
        const empty = doc.createElement("div");
        empty.style.fontSize = "12px";
        empty.style.opacity = "0.75";
        empty.textContent = "No chart data available for current selection.";
        chartHost.appendChild(empty);
        return;
      }
      const unitFormatRaw = semantic.units[measureDef.unit]?.format ?? "float";
      const unitFormat = unitFormatRaw === "datetime" ? "int" : unitFormatRaw;
      const preferZero = spec.type === "bar" || unitFormat === "int";
      const yValsRaw = data.map((d) => clampForMeasure(semantic, activeMeasure, d.y));
      const ignoreZeroForRating = measureDef.unit === "rating" && yValsRaw.some((v) => typeof v === "number" && Number.isFinite(v) && v !== 0);
      const yVals = ignoreZeroForRating ? yValsRaw.filter((v) => v !== 0) : yValsRaw;
      const hardMin = measureDef.range?.min;
      const hardMax = measureDef.range?.max;
      const { minY, maxY } = computeYBounds({
        unitFormat,
        values: yVals,
        preferZero,
        hardMin: typeof hardMin === "number" && Number.isFinite(hardMin) ? hardMin : void 0,
        hardMax: typeof hardMax === "number" && Number.isFinite(hardMax) ? hardMax : void 0
      });
      const yRange = Math.max(1e-9, maxY - minY);
      const svg = doc.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.classList.add("ga-chart-svg");
      svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
      const axisX = doc.createElementNS(svg.namespaceURI, "line");
      axisX.setAttribute("x1", String(PAD_L));
      axisX.setAttribute("y1", String(PAD_T + innerH));
      axisX.setAttribute("x2", String(PAD_L + innerW));
      axisX.setAttribute("y2", String(PAD_T + innerH));
      axisX.setAttribute("stroke", "var(--ga-axis-color)");
      axisX.setAttribute("opacity", "0.7");
      svg.appendChild(axisX);
      const axisY = doc.createElementNS(svg.namespaceURI, "line");
      axisY.setAttribute("x1", String(PAD_L));
      axisY.setAttribute("y1", String(PAD_T));
      axisY.setAttribute("x2", String(PAD_L));
      axisY.setAttribute("y2", String(PAD_T + innerH));
      axisY.setAttribute("stroke", "var(--ga-axis-color)");
      axisY.setAttribute("opacity", "0.7");
      svg.appendChild(axisY);
      const tickCount = 5;
      for (let i = 0; i <= tickCount; i++) {
        const yVal = minY + yRange * i / tickCount;
        const yPos = PAD_T + innerH - (yVal - minY) / yRange * innerH;
        const grid = doc.createElementNS(svg.namespaceURI, "line");
        grid.setAttribute("x1", String(PAD_L));
        grid.setAttribute("y1", String(yPos));
        grid.setAttribute("x2", String(PAD_L + innerW));
        grid.setAttribute("y2", String(yPos));
        grid.setAttribute("stroke", "var(--ga-axis-grid)");
        grid.setAttribute("opacity", i === 0 ? "0.8" : "0.45");
        svg.appendChild(grid);
        const yTick = doc.createElementNS(svg.namespaceURI, "text");
        yTick.setAttribute("x", String(PAD_L - 8));
        yTick.setAttribute("y", String(yPos + 3));
        yTick.setAttribute("text-anchor", "end");
        yTick.setAttribute("font-size", "10");
        yTick.setAttribute("fill", "var(--ga-axis-text)");
        yTick.setAttribute("opacity", "0.95");
        yTick.textContent = formatMeasureValue(doc, semantic, activeMeasure, yVal);
        svg.appendChild(yTick);
      }
      const xAxisLabel = doc.createElementNS(svg.namespaceURI, "text");
      xAxisLabel.setAttribute("x", String(PAD_L + innerW / 2));
      xAxisLabel.setAttribute("y", String(H - 8));
      xAxisLabel.setAttribute("text-anchor", "middle");
      xAxisLabel.setAttribute("font-size", "12");
      xAxisLabel.setAttribute("fill", "var(--ga-axis-text)");
      xAxisLabel.setAttribute("opacity", "0.95");
      xAxisLabel.textContent = dimDef.label;
      svg.appendChild(xAxisLabel);
      if (dimId === "time_day" && data.length > 0) {
        const first = data[0].x;
        const last = data[data.length - 1].x;
        const lx = doc.createElementNS(svg.namespaceURI, "text");
        lx.setAttribute("x", String(PAD_L + 2));
        lx.setAttribute("y", String(PAD_T + innerH + 18));
        lx.setAttribute("text-anchor", "start");
        lx.setAttribute("font-size", "10");
        lx.setAttribute("fill", "var(--ga-axis-text)");
        lx.setAttribute("opacity", "0.95");
        lx.textContent = first;
        svg.appendChild(lx);
        const rx = doc.createElementNS(svg.namespaceURI, "text");
        rx.setAttribute("x", String(PAD_L + innerW - 2));
        rx.setAttribute("y", String(PAD_T + innerH + 18));
        rx.setAttribute("text-anchor", "end");
        rx.setAttribute("font-size", "10");
        rx.setAttribute("fill", "var(--ga-axis-text)");
        rx.setAttribute("opacity", "0.95");
        rx.textContent = last;
        svg.appendChild(rx);
      }
      const yAxisLabel = doc.createElementNS(svg.namespaceURI, "text");
      yAxisLabel.setAttribute("x", "16");
      yAxisLabel.setAttribute("y", String(PAD_T + innerH / 2));
      yAxisLabel.setAttribute("text-anchor", "middle");
      yAxisLabel.setAttribute("font-size", "12");
      yAxisLabel.setAttribute("fill", "var(--ga-axis-text)");
      yAxisLabel.setAttribute("opacity", "0.95");
      yAxisLabel.setAttribute("transform", `rotate(-90 16 ${PAD_T + innerH / 2})`);
      yAxisLabel.textContent = measureDef.label;
      svg.appendChild(yAxisLabel);
      if (spec.type === "line") {
        const outerPad = Math.min(28, innerW * 0.06);
        const xSpan = Math.max(1, innerW - outerPad * 2);
        const points = data.map((d, i) => {
          const x = PAD_L + outerPad + i / Math.max(1, data.length - 1) * xSpan;
          const yVal = clampForMeasure(semantic, activeMeasure, d.y);
          const missing = ignoreZeroForRating && yVal === 0;
          const y = missing ? NaN : PAD_T + innerH - (yVal - minY) / yRange * innerH;
          return { x, y, yVal, missing, d, idx: i };
        });
        const path = doc.createElementNS(svg.namespaceURI, "path");
        path.classList.add("ga-chart-line-path");
        const dParts = [];
        let started = false;
        for (const p of points) {
          if (p.missing) {
            started = false;
            continue;
          }
          if (!Number.isFinite(p.y)) continue;
          dParts.push(`${started ? "L" : "M"} ${p.x} ${p.y}`);
          started = true;
        }
        path.setAttribute("d", dParts.join(" "));
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", colorOverride ?? "var(--ga-graph-color)");
        path.setAttribute("stroke-width", "2.5");
        path.setAttribute("opacity", "0.9");
        svg.appendChild(path);
        if (isAnimationsEnabled(doc)) {
          prepareLineAnimation(path);
        }
        let lastValidIdx = -1;
        for (let i = points.length - 1; i >= 0; i--) {
          if (!points[i].missing && Number.isFinite(points[i].y)) {
            lastValidIdx = i;
            break;
          }
        }
        let prevValidY = null;
        let dotIdx = 0;
        points.forEach((p, i) => {
          if (p.missing || !Number.isFinite(p.y)) return;
          const isFirstValid = prevValidY === null;
          const isLastValid = i === lastValidIdx;
          const changed = !isFirstValid && prevValidY !== p.yVal;
          const showDot = isFirstValid || isLastValid || changed;
          if (!showDot) {
            prevValidY = p.yVal;
            return;
          }
          const dot = doc.createElementNS(svg.namespaceURI, "circle");
          dot.classList.add("ga-chart-line-dot");
          dot.style.setProperty("--ga-dot-index", String(dotIdx++));
          dot.setAttribute("cx", String(p.x));
          dot.setAttribute("cy", String(p.y));
          dot.setAttribute("r", "3");
          dot.setAttribute("fill", colorOverride ?? "var(--ga-graph-color)");
          dot.setAttribute("opacity", "0.95");
          const tooltip = doc.createElementNS(svg.namespaceURI, "title");
          tooltip.textContent = `${formatDimensionKey(doc, dimId, p.d.x)}: ${formatMeasureValue(doc, semantic, activeMeasure, clampForMeasure(semantic, activeMeasure, p.d.y))}`;
          dot.appendChild(tooltip);
          const clickBase = mergeDrilldownDefaults(spec.actions?.click, semantic.measures[activeMeasure]?.drilldown);
          const click = normalizeClickForActiveMeasure(semantic, activeMeasure, clickBase);
          if (click?.type === "drilldown") {
            dot.setAttribute("style", "cursor: pointer;");
            dot.addEventListener("click", () => {
              const sourceGrain = getActiveGrain();
              const ddGrain = drilldownGrainForTarget(click.target);
              const base = getDatasetForGrain(ddGrain);
              const sourceRows = click.filterFromPoint ? p.d.rows : base;
              const sourceRowsGrain = click.filterFromPoint ? sourceGrain : ddGrain;
              const { grain, rows } = materializeRowsForDrilldown(click.target, sourceRowsGrain, sourceRows);
              const filteredRows = applyFilters(rows, click.extraFilters, grain);
              overlay.open(semantic, {
                title: `${widget.title} - ${p.d.x}`,
                target: click.target,
                columnsPreset: click.columnsPreset,
                rows: filteredRows,
                extraFilters: click.extraFilters,
                initialSort: click.initialSort
              });
            });
          }
          svg.appendChild(dot);
          prevValidY = p.yVal;
        });
        maybeAnimateChartSvg(svg, doc);
      } else {
        const n = Math.max(1, data.length);
        const slotW = innerW / n;
        const outerPad = Math.min(28, slotW * 0.6);
        const xSpan = Math.max(1, innerW - outerPad * 2);
        const barW = xSpan / n;
        data.forEach((d, i) => {
          const x = PAD_L + outerPad + i * barW;
          const h = (clampForMeasure(semantic, activeMeasure, d.y) - minY) / yRange * innerH;
          const y = PAD_T + innerH - h;
          const rect = doc.createElementNS(svg.namespaceURI, "rect");
          rect.classList.add("ga-chart-bar");
          rect.style.setProperty("--ga-bar-index", String(i));
          rect.setAttribute("x", String(x + 1));
          rect.setAttribute("y", String(y));
          rect.setAttribute("width", String(Math.max(1, barW - 2)));
          rect.setAttribute("height", String(Math.max(0, h)));
          rect.setAttribute("rx", "2");
          rect.setAttribute("fill", colorOverride ?? "var(--ga-graph-color)");
          rect.setAttribute("opacity", "0.72");
          rect.style.animationDelay = `${Math.min(i * 18, 320)}ms`;
          rect.style.transformOrigin = `${x + barW / 2}px ${PAD_T + innerH}px`;
          rect.style.transformBox = "view-box";
          const tooltip = doc.createElementNS(svg.namespaceURI, "title");
          tooltip.textContent = `${formatDimensionKey(doc, dimId, d.x)}: ${formatMeasureValue(doc, semantic, activeMeasure, clampForMeasure(semantic, activeMeasure, d.y))}`;
          rect.appendChild(tooltip);
          const clickBase = mergeDrilldownDefaults(spec.actions?.click, semantic.measures[activeMeasure]?.drilldown);
          const click = normalizeClickForActiveMeasure(semantic, activeMeasure, clickBase);
          if (click?.type === "drilldown") {
            rect.setAttribute("style", `${rect.getAttribute("style") ?? ""};cursor:pointer;`);
            rect.addEventListener("click", () => {
              const sourceGrain = getActiveGrain();
              const ddGrain = drilldownGrainForTarget(click.target);
              const base = getDatasetForGrain(ddGrain);
              const sourceRows = click.filterFromPoint ? d.rows : base;
              const sourceRowsGrain = click.filterFromPoint ? sourceGrain : ddGrain;
              const { grain, rows } = materializeRowsForDrilldown(click.target, sourceRowsGrain, sourceRows);
              const filteredRows = applyFilters(rows, click.extraFilters, grain);
              overlay.open(semantic, {
                title: `${widget.title} - ${d.x}`,
                target: click.target,
                columnsPreset: click.columnsPreset,
                rows: filteredRows,
                extraFilters: click.extraFilters,
                initialSort: click.initialSort
              });
            });
          }
          svg.appendChild(rect);
          if (data.length <= 20 || i % Math.ceil(data.length / 10) === 0) {
            const tx = doc.createElementNS(svg.namespaceURI, "text");
            tx.setAttribute("x", String(x + barW / 2));
            tx.setAttribute("y", String(PAD_T + innerH + 16));
            tx.setAttribute("text-anchor", "middle");
            tx.setAttribute("font-size", "10");
            tx.setAttribute("fill", "var(--ga-axis-text)");
            tx.setAttribute("opacity", "0.95");
            tx.textContent = formatDimensionKey(doc, dimId, d.x);
            svg.appendChild(tx);
          }
        });
        maybeAnimateChartSvg(svg, doc);
      }
      chartHost.appendChild(svg);
      currentSvg = svg;
    };
    if (measureIds.length > 1) {
      const label = doc.createElement("label");
      label.style.fontSize = "12px";
      label.style.opacity = "0.9";
      label.textContent = "Measure:";
      const select = doc.createElement("select");
      select.style.background = "var(--ga-control-bg)";
      select.style.color = "var(--ga-control-text)";
      select.style.border = "1px solid var(--ga-control-border)";
      select.style.borderRadius = "8px";
      select.style.padding = "4px 8px";
      for (const measureId of measureIds) {
        const option = doc.createElement("option");
        option.value = measureId;
        option.textContent = semantic.measures[measureId]?.label || measureId;
        if (measureId === activeMeasure) option.selected = true;
        select.appendChild(option);
      }
      select.addEventListener("change", () => {
        activeMeasure = select.value;
        render();
      });
      controlsLeft.appendChild(label);
      controlsLeft.appendChild(select);
    }
    render();
    wrap.appendChild(title);
    wrap.appendChild(controls);
    wrap.appendChild(box);
    return wrap;
  }

  // src/ui/widgets/breakdownWidget.ts
  function getShareKindFromFormulaId2(formulaId) {
    if (formulaId === "share_damage_dealt") return "dealt";
    if (formulaId === "share_damage_taken") return "taken";
    return null;
  }
  function sumDamage2(rows, kind) {
    let sum = 0;
    for (const r of rows) {
      const dmg = r?.damage;
      if (typeof dmg !== "number" || !Number.isFinite(dmg)) continue;
      if (kind === "dealt") sum += Math.max(0, dmg);
      else sum += Math.max(0, -dmg);
    }
    return sum;
  }
  function normalizeHexColor2(value) {
    if (typeof value !== "string") return void 0;
    const v = value.trim();
    return /^#[0-9a-fA-F]{6}$/.test(v) ? v : void 0;
  }
  function sortRows(rows, mode) {
    if (mode === "asc") return [...rows].sort((a, b) => a.value - b.value);
    if (mode === "desc") return [...rows].sort((a, b) => b.value - a.value);
    const scoreBucketStart = (k) => k === "5000" ? 5e3 : parseInt(k.split("-")[0] ?? "0", 10);
    const isDate = (k) => /^\d{4}-\d{2}-\d{2}$/.test(k);
    const weekdayRank = (k) => {
      const v = k.trim().toLowerCase();
      if (v === "mon") return 0;
      if (v === "tue") return 1;
      if (v === "wed") return 2;
      if (v === "thu") return 3;
      if (v === "fri") return 4;
      if (v === "sat") return 5;
      if (v === "sun") return 6;
      return void 0;
    };
    return [...rows].sort((a, b) => {
      if (isDate(a.key) && isDate(b.key)) return a.key.localeCompare(b.key);
      const wa = weekdayRank(a.key);
      const wb = weekdayRank(b.key);
      if (wa !== void 0 && wb !== void 0) return wa - wb;
      const na = Number.isFinite(scoreBucketStart(a.key)) ? scoreBucketStart(a.key) : NaN;
      const nb = Number.isFinite(scoreBucketStart(b.key)) ? scoreBucketStart(b.key) : NaN;
      if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
      return a.key.localeCompare(b.key);
    });
  }
  function readDateFormatMode3(doc) {
    const root = doc.querySelector(".ga-root");
    const mode = root?.dataset?.gaDateFormat;
    return mode === "mm/dd/yyyy" || mode === "yyyy-mm-dd" || mode === "locale" ? mode : "dd/mm/yyyy";
  }
  function readCountryFormatMode2(doc) {
    const root = doc.querySelector(".ga-root");
    return root?.dataset?.gaCountryFormat === "english" ? "english" : "iso2";
  }
  function formatCountry2(doc, isoOrName) {
    const mode = readCountryFormatMode2(doc);
    if (mode === "iso2") return isoOrName;
    const iso2 = isoOrName.trim().toUpperCase();
    if (!/^[A-Z]{2}$/.test(iso2)) return isoOrName;
    if (typeof Intl === "undefined" || !Intl.DisplayNames) return isoOrName;
    try {
      const dn = new Intl.DisplayNames(["en"], { type: "region" });
      return dn.of(iso2) ?? isoOrName;
    } catch {
      return isoOrName;
    }
  }
  function formatDimensionKey2(doc, dimId, key) {
    if (dimId === "confused_countries") return key;
    if (dimId === "true_country" || dimId === "guess_country" || dimId === "opponent_country") return formatCountry2(doc, key);
    return key;
  }
  function formatDateTime3(doc, ts) {
    const d = new Date(ts);
    if (!Number.isFinite(d.getTime())) return String(ts);
    const mode = readDateFormatMode3(doc);
    if (mode === "locale") return d.toLocaleString();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    const hh = String(d.getHours()).padStart(2, "0");
    const mm = String(d.getMinutes()).padStart(2, "0");
    const ss = String(d.getSeconds()).padStart(2, "0");
    if (mode === "yyyy-mm-dd") return `${y}-${m}-${day} ${hh}:${mm}:${ss}`;
    if (mode === "mm/dd/yyyy") return `${m}/${day}/${y} ${hh}:${mm}:${ss}`;
    return `${day}/${m}/${y} ${hh}:${mm}:${ss}`;
  }
  function formatValue2(doc, semantic, measureId, value) {
    const m = semantic.measures[measureId];
    const unit = semantic.units[m.unit];
    if (!unit) return String(value);
    if (unit.format === "datetime") return formatDateTime3(doc, value);
    if (unit.format === "percent") {
      const clamped = Math.max(0, Math.min(1, value));
      const decimals2 = unit.decimals ?? 1;
      return `${(clamped * 100).toFixed(decimals2)}%`;
    }
    if (unit.format === "duration") {
      const s = Math.max(0, Math.round(value));
      const days2 = Math.floor(s / 86400);
      const hours = Math.floor(s % 86400 / 3600);
      const mins = Math.floor(s % 3600 / 60);
      if (days2 > 0) return `${days2}d ${hours}h`;
      if (hours > 0) return `${hours}h ${mins}m`;
      if (mins > 0) return `${mins}m ${s % 60}s`;
      return `${Math.max(0, value).toFixed(1)}s`;
    }
    if (unit.format === "int") {
      const v = Math.round(value);
      return unit.showSign && v > 0 ? `+${v}` : String(v);
    }
    const decimals = unit.decimals ?? 1;
    const txt = value.toFixed(decimals);
    return unit.showSign && value > 0 ? `+${txt}` : txt;
  }
  function clampForMeasure2(semantic, measureId, value) {
    const m = semantic.measures[measureId];
    const unit = m ? semantic.units[m.unit] : void 0;
    if (unit?.format === "percent") return Math.max(0, Math.min(1, value));
    return value;
  }
  function getMeasureIds2(spec) {
    const out = [];
    const single = typeof spec.measure === "string" ? spec.measure.trim() : "";
    if (single) out.push(single);
    if (Array.isArray(spec.measures)) {
      for (const m of spec.measures) {
        if (typeof m !== "string") continue;
        const clean = m.trim();
        if (!clean || out.includes(clean)) continue;
        out.push(clean);
      }
    }
    return out;
  }
  function getSortModes2(spec) {
    const out = [];
    const single = spec.sort?.mode;
    if (single) out.push(single);
    if (Array.isArray(spec.sorts)) {
      for (const s of spec.sorts) {
        const mode = s?.mode;
        if (!mode) continue;
        if (!out.includes(mode)) out.push(mode);
      }
    }
    return out;
  }
  function sortLabel2(mode) {
    if (mode === "chronological") return "Chronological";
    if (mode === "asc") return "Ascending";
    return "Descending";
  }
  function mergeDrilldownDefaults2(base, defs) {
    if (!base) return base;
    if (!defs) return base;
    return {
      ...base,
      filterFromPoint: base.filterFromPoint ?? defs.filterFromPoint,
      extraFilters: [...defs.extraFilters ?? [], ...base.extraFilters ?? []]
    };
  }
  async function renderBreakdownWidget(semantic, widget, overlay, baseRows) {
    const spec = widget.spec;
    const doc = overlay.getDocument();
    const exclude = new Set(
      Array.isArray(spec.excludeKeys) ? spec.excludeKeys.map((k) => typeof k === "string" ? k.trim().toLowerCase() : "").filter(Boolean) : []
    );
    const wrap = doc.createElement("div");
    wrap.className = "ga-widget ga-breakdown";
    const title = doc.createElement("div");
    title.className = "ga-widget-title";
    title.textContent = widget.title;
    const header = doc.createElement("div");
    header.className = "ga-breakdown-header";
    const box = doc.createElement("div");
    box.className = "ga-breakdown-box";
    const grain = widget.grain;
    const rowsAllBase = baseRows ?? (grain === "game" ? await getGames({}) : grain === "session" ? await getSessions({}) : await getRounds({}));
    const rowsAll = applyFilters(rowsAllBase, spec.filters, grain);
    const dimId = spec.dimension;
    const dimDef = semantic.dimensions[dimId];
    if (!dimDef) throw new Error(`Unknown dimension '${dimId}' in breakdown ${widget.widgetId}`);
    const keyFn = DIMENSION_EXTRACTORS[grain]?.[dimId];
    if (!keyFn) throw new Error(`No extractor implemented for dimension '${dimId}' (breakdown)`);
    const measureIds = getMeasureIds2(spec);
    if (measureIds.length === 0) throw new Error(`Breakdown ${widget.widgetId} has no measure or measures[]`);
    const measureFnById = /* @__PURE__ */ new Map();
    for (const measureId of measureIds) {
      const measDef = semantic.measures[measureId];
      if (!measDef) throw new Error(`Unknown measure '${measureId}' in breakdown ${widget.widgetId}`);
      const measureFn = MEASURES_BY_GRAIN[grain]?.[measDef.formulaId];
      if (!measureFn) throw new Error(`Missing measure implementation for formulaId=${measDef.formulaId}`);
      measureFnById.set(measureId, measureFn);
    }
    let activeMeasure = measureIds.includes(spec.activeMeasure || "") ? spec.activeMeasure : measureIds[0];
    const sortModes = getSortModes2(spec);
    let activeSortMode = spec.activeSort?.mode ?? spec.sort?.mode ?? sortModes[0] ?? "desc";
    if (!sortModes.includes(activeSortMode)) sortModes.unshift(activeSortMode);
    const grouped = groupByKey(rowsAll, keyFn);
    const colorOverride = normalizeHexColor2(spec.color);
    const limit = typeof spec.limit === "number" ? spec.limit : 12;
    let expanded = false;
    const headerLeft = doc.createElement("div");
    headerLeft.className = "ga-breakdown-header-left";
    headerLeft.textContent = dimDef.label;
    const headerRight = doc.createElement("div");
    headerRight.className = "ga-breakdown-header-right";
    header.appendChild(headerLeft);
    header.appendChild(headerRight);
    let rowsAllSorted = [];
    let maxValAll = 1e-9;
    const rebuildForActiveMeasure = () => {
      const measDef = semantic.measures[activeMeasure];
      if (!measDef) return;
      const shareKind = getShareKindFromFormulaId2(measDef.formulaId);
      const measureFn = shareKind ? null : measureFnById.get(activeMeasure);
      if (!shareKind && !measureFn) return;
      const denom = shareKind ? sumDamage2(rowsAll, shareKind) : 0;
      rowsAllSorted = Array.from(grouped.entries()).filter(([k]) => !exclude.has(String(k).trim().toLowerCase())).map(([k, g]) => ({
        key: k,
        value: clampForMeasure2(
          semantic,
          activeMeasure,
          shareKind ? denom > 0 ? sumDamage2(g, shareKind) / denom : 0 : measureFn(g)
        ),
        rows: g
      }));
      rowsAllSorted = sortRows(rowsAllSorted, activeSortMode);
      maxValAll = Math.max(1e-9, ...rowsAllSorted.map((r) => clampForMeasure2(semantic, activeMeasure, r.value)));
    };
    const renderHeaderRight = () => {
      headerRight.innerHTML = "";
      const measDef = semantic.measures[activeMeasure];
      const labelText = measDef ? measDef.label : activeMeasure;
      const wrapRight = doc.createElement("div");
      wrapRight.className = "ga-breakdown-controls";
      if (measureIds.length > 1) {
        const mLabel = doc.createElement("span");
        mLabel.className = "ga-breakdown-ctl-label";
        mLabel.textContent = "Measure:";
        const mSelect = doc.createElement("select");
        mSelect.className = "ga-breakdown-ctl-select";
        for (const measureId of measureIds) {
          const opt = doc.createElement("option");
          opt.value = measureId;
          opt.textContent = semantic.measures[measureId]?.label ?? measureId;
          if (measureId === activeMeasure) opt.selected = true;
          mSelect.appendChild(opt);
        }
        mSelect.addEventListener("change", () => {
          const next = mSelect.value;
          if (!measureIds.includes(next)) return;
          activeMeasure = next;
          rebuildForActiveMeasure();
          renderHeaderRight();
          renderRows();
          renderFooter();
        });
        wrapRight.appendChild(mLabel);
        wrapRight.appendChild(mSelect);
      } else {
        const mText = doc.createElement("span");
        mText.textContent = labelText;
        wrapRight.appendChild(mText);
      }
      if (sortModes.length > 1) {
        const sLabel = doc.createElement("span");
        sLabel.className = "ga-breakdown-ctl-label";
        sLabel.textContent = "Sort:";
        const sSelect = doc.createElement("select");
        sSelect.className = "ga-breakdown-ctl-select";
        for (const mode of sortModes) {
          const opt = doc.createElement("option");
          opt.value = mode;
          opt.textContent = sortLabel2(mode);
          if (mode === activeSortMode) opt.selected = true;
          sSelect.appendChild(opt);
        }
        sSelect.addEventListener("change", () => {
          const next = sSelect.value;
          if (!sortModes.includes(next)) return;
          activeSortMode = next;
          rebuildForActiveMeasure();
          renderRows();
          renderFooter();
        });
        wrapRight.appendChild(sLabel);
        wrapRight.appendChild(sSelect);
      }
      headerRight.appendChild(wrapRight);
    };
    const renderRows = () => {
      box.innerHTML = "";
      const visible = expanded ? rowsAllSorted : rowsAllSorted.slice(0, limit);
      for (const r of visible) {
        const line = doc.createElement("div");
        line.className = "ga-breakdown-row";
        const left = doc.createElement("div");
        left.className = "ga-breakdown-label";
        left.textContent = formatDimensionKey2(doc, dimId, r.key);
        const right = doc.createElement("div");
        right.className = "ga-breakdown-right";
        const val = doc.createElement("div");
        val.className = "ga-breakdown-value";
        val.textContent = formatValue2(doc, semantic, activeMeasure, r.value);
        const barWrap = doc.createElement("div");
        barWrap.className = "ga-breakdown-barwrap";
        const bar = doc.createElement("div");
        bar.className = "ga-breakdown-bar";
        bar.style.width = `${Math.max(2, r.value / maxValAll * 100)}%`;
        if (colorOverride) bar.style.background = colorOverride;
        barWrap.appendChild(bar);
        right.appendChild(val);
        right.appendChild(barWrap);
        line.appendChild(left);
        line.appendChild(right);
        const click = mergeDrilldownDefaults2(spec.actions?.click, semantic.measures[activeMeasure]?.drilldown);
        if (click?.type === "drilldown") {
          line.style.cursor = "pointer";
          line.addEventListener("click", () => {
            const rowsFromPoint = click.filterFromPoint ? r.rows : rowsAll;
            let sourceRows = rowsFromPoint;
            let targetGrain = grain;
            if (grain === "session" && click.target === "rounds") {
              targetGrain = "round";
              const out = [];
              for (const s of sourceRows) {
                const rr = s?.rounds;
                if (Array.isArray(rr)) out.push(...rr);
              }
              sourceRows = out;
            }
            const filteredRows = applyFilters(sourceRows, click.extraFilters, targetGrain);
            overlay.open(semantic, {
              title: `${widget.title} - ${r.key}`,
              target: click.target,
              columnsPreset: click.columnsPreset,
              rows: filteredRows,
              extraFilters: click.extraFilters
            });
          });
        }
        box.appendChild(line);
      }
    };
    const footer = doc.createElement("div");
    footer.className = "ga-breakdown-footer";
    const renderFooter = () => {
      footer.innerHTML = "";
      const canExpand = !!spec.extendable && rowsAllSorted.length > limit;
      if (!canExpand) return;
      const btn = doc.createElement("button");
      btn.type = "button";
      btn.className = "ga-breakdown-toggle";
      const updateLabel = () => {
        btn.textContent = expanded ? `Show top ${limit}` : `Show all (${rowsAllSorted.length})`;
      };
      updateLabel();
      btn.addEventListener("click", () => {
        expanded = !expanded;
        updateLabel();
        renderRows();
      });
      footer.appendChild(btn);
    };
    rebuildForActiveMeasure();
    renderHeaderRight();
    renderRows();
    renderFooter();
    wrap.appendChild(title);
    wrap.appendChild(header);
    wrap.appendChild(box);
    if (footer.childElementCount > 0) wrap.appendChild(footer);
    return wrap;
  }

  // src/ui/widgets/recordListWidget.ts
  function formatMetricValue(semantic, measureId, value) {
    const m = semantic.measures[measureId];
    const unit = m ? semantic.units[m.unit] : void 0;
    if (!unit) return String(value);
    if (unit.format === "percent") {
      const clamped = Math.max(0, Math.min(1, value));
      return `${(clamped * 100).toFixed(unit.decimals ?? 1)}%`;
    }
    if (unit.format === "duration") {
      const s = Math.max(0, Math.round(value));
      const days2 = Math.floor(s / 86400);
      const hours = Math.floor(s % 86400 / 3600);
      const mins = Math.floor(s % 3600 / 60);
      if (days2 > 0) return `${days2}d ${hours}h`;
      if (hours > 0) return `${hours}h ${mins}m`;
      if (mins > 0) return `${mins}m ${s % 60}s`;
      return `${Math.max(0, value).toFixed(1)}s`;
    }
    if (unit.format === "int") {
      const v = Math.round(value);
      return unit.showSign && v > 0 ? `+${v}` : String(v);
    }
    const txt = value.toFixed(unit.decimals ?? 1);
    const base = unit.showSign && value > 0 ? `+${txt}` : txt;
    const suffix = (() => {
      const u = String(m?.unit ?? "").trim().toLowerCase();
      if (u === "km") return " km";
      if (u === "seconds") return " s";
      return "";
    })();
    return `${base}${suffix}`;
  }
  function formatTs(ts) {
    const d = new Date(ts);
    if (!Number.isFinite(d.getTime())) return String(ts);
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    const hh = String(d.getHours()).padStart(2, "0");
    const mm = String(d.getMinutes()).padStart(2, "0");
    return `${day}/${m}/${y} ${hh}:${mm}`;
  }
  function getRowTs2(row) {
    const a = row?.playedAt;
    if (typeof a === "number" && Number.isFinite(a)) return a;
    const b = row?.ts;
    if (typeof b === "number" && Number.isFinite(b)) return b;
    return null;
  }
  function getScore(row, semantic) {
    const v = pickWithAliases(row, "player_self_score", semantic.columnAliases);
    return typeof v === "number" && Number.isFinite(v) && v >= 0 ? v : null;
  }
  function getTrustedGuessDurationSeconds(row, semantic) {
    const raw = pickWithAliases(row, "durationSeconds", semantic.columnAliases);
    const dur = typeof raw === "number" && Number.isFinite(raw) && raw > 0 ? raw : null;
    const start = row?.startTime ?? row?.roundStartTime ?? null;
    const end = row?.endTime ?? row?.roundEndTime ?? null;
    const startNum = typeof start === "number" && Number.isFinite(start) ? start : null;
    const endNum = typeof end === "number" && Number.isFinite(end) ? end : null;
    const derived = startNum !== null && endNum !== null && endNum > startNum ? (endNum - startNum) / 1e3 : null;
    const derivedOk = derived !== null && Number.isFinite(derived) && derived > 0 && derived < 60 * 30 ? derived : null;
    if (derivedOk !== null) {
      if (dur !== null && Math.abs(dur - derivedOk) > 6) return derivedOk;
      return dur ?? derivedOk;
    }
    return dur;
  }
  function buildOverall(semantic, grain, rowsAll, rec) {
    const metricId = typeof rec.metric === "string" ? rec.metric.trim() : "";
    if (!metricId) return null;
    const metric = semantic.measures[metricId];
    if (!metric) return null;
    const fn = MEASURES_BY_GRAIN[grain]?.[metric.formulaId];
    if (!fn) return null;
    const inputRows = Array.isArray(rec.filters) && rec.filters.length ? applyFilters(rowsAll, rec.filters, grain) : rowsAll;
    const v = fn(inputRows);
    if (!Number.isFinite(v)) return null;
    return {
      keyText: "",
      valueText: formatMetricValue(semantic, metricId, v),
      rows: inputRows,
      click: rec.actions?.click
    };
  }
  function buildGroupExtreme(semantic, grain, rowsAll, rec) {
    const metricId = typeof rec.metric === "string" ? rec.metric.trim() : "";
    const groupById = typeof rec.groupBy === "string" ? rec.groupBy.trim() : "";
    const extreme = rec.extreme === "min" ? "min" : "max";
    if (!metricId || !groupById) return null;
    const metric = semantic.measures[metricId];
    if (!metric) return null;
    const fn = MEASURES_BY_GRAIN[grain]?.[metric.formulaId];
    if (!fn) return null;
    const keyFn = DIMENSION_EXTRACTORS[grain]?.[groupById];
    if (!keyFn) return null;
    const inputRows = Array.isArray(rec.filters) && rec.filters.length ? applyFilters(rowsAll, rec.filters, grain) : rowsAll;
    const grouped = groupByKey(inputRows, keyFn);
    let bestKey = null;
    let bestVal = null;
    let bestRows = [];
    for (const [k, g] of grouped.entries()) {
      if (!g || g.length === 0) continue;
      if (grain === "round" && metricId === "avg_score") {
        const total = g.length;
        let valid = 0;
        for (const r of g) if (getScore(r, semantic) !== null) valid++;
        if (valid === 0) continue;
        if (groupById === "game_id" && valid !== total) continue;
        if (groupById === "time_day" && valid / Math.max(1, total) < 0.5) continue;
      }
      if (grain === "round" && metricId === "avg_guess_duration") {
        const total = g.length;
        let valid = 0;
        for (const r of g) if (getTrustedGuessDurationSeconds(r, semantic) !== null) valid++;
        if (valid === 0) continue;
        if (valid / Math.max(1, total) < 0.5) continue;
      }
      const v = (() => {
        if (grain === "round" && metricId === "avg_score") {
          let sum = 0;
          let n = 0;
          for (const r of g) {
            const s = getScore(r, semantic);
            if (s === null) continue;
            sum += s;
            n++;
          }
          return n ? sum / n : NaN;
        }
        if (grain === "round" && metricId === "avg_guess_duration") {
          let sum = 0;
          let n = 0;
          for (const r of g) {
            const s = getTrustedGuessDurationSeconds(r, semantic);
            if (s === null) continue;
            sum += s;
            n++;
          }
          return n ? sum / n : NaN;
        }
        return fn(g);
      })();
      if (!Number.isFinite(v)) continue;
      if (bestVal === null) {
        bestKey = k;
        bestVal = v;
        bestRows = g;
        continue;
      }
      const better = extreme === "max" ? v > bestVal : v < bestVal;
      if (better) {
        bestKey = k;
        bestVal = v;
        bestRows = g;
      }
    }
    if (!bestKey || bestVal === null) return null;
    const metricText = formatMetricValue(semantic, metricId, bestVal);
    const displayKey = rec.displayKey === "first_ts_score" ? "first_ts_score" : rec.displayKey === "first_ts" ? "first_ts" : "group";
    const firstTs = (() => {
      const ts = bestRows.map(getRowTs2).filter((x) => typeof x === "number");
      return ts.length ? Math.min(...ts) : null;
    })();
    const keyText = displayKey === "first_ts" || displayKey === "first_ts_score" ? firstTs !== null ? formatTs(firstTs) : bestKey : bestKey;
    let tieCount = 0;
    for (const [, g] of grouped.entries()) {
      if (!g || g.length === 0) continue;
      const v = (() => {
        if (grain === "round" && metricId === "avg_score") {
          let sum = 0;
          let n = 0;
          for (const r of g) {
            const s = getScore(r, semantic);
            if (s === null) continue;
            sum += s;
            n++;
          }
          return n ? sum / n : NaN;
        }
        if (grain === "round" && metricId === "avg_guess_duration") {
          let sum = 0;
          let n = 0;
          for (const r of g) {
            const s = getTrustedGuessDurationSeconds(r, semantic);
            if (s === null) continue;
            sum += s;
            n++;
          }
          return n ? sum / n : NaN;
        }
        return fn(g);
      })();
      if (!Number.isFinite(v)) continue;
      if (v === bestVal) tieCount++;
    }
    const tieSuffix = tieCount > 1 ? ` (${tieCount}x)` : "";
    if (grain === "session" && metricId === "session_delta_rating") {
      return { keyText: "", valueText: metricText, rows: bestRows, click: rec.actions?.click };
    }
    if (groupById === "game_id" && metricId === "rounds_count") {
      if (extreme === "max") {
        return { keyText, valueText: `${metricText} rounds (${keyText})${tieSuffix}`, rows: bestRows, click: rec.actions?.click };
      }
      const tied = [];
      let tieCount2 = 0;
      for (const [, g] of grouped.entries()) {
        if (!g || g.length === 0) continue;
        const v = fn(g);
        if (!Number.isFinite(v) || v !== bestVal) continue;
        tieCount2++;
        tied.push(...g);
      }
      const rows = tied.length ? tied : bestRows;
      return {
        keyText,
        valueText: `${metricText} rounds${tieCount2 > 1 ? ` (${tieCount2}x)` : ""}`,
        rows,
        click: rec.actions?.click
      };
    }
    if (groupById === "game_id" && metricId === "score_spread") {
      return { keyText, valueText: `${metricText} points (${keyText})${tieSuffix}`, rows: bestRows, click: rec.actions?.click };
    }
    if (displayKey === "first_ts_score") {
      let scoreText = "";
      const scoreMeasure = semantic.measures["avg_score"];
      const scoreFn = scoreMeasure ? MEASURES_BY_GRAIN[grain]?.[scoreMeasure.formulaId] : void 0;
      if (scoreFn) {
        const s = scoreFn(bestRows);
        if (Number.isFinite(s)) scoreText = ` (score ${Math.round(s)})`;
      }
      return { keyText, valueText: `${metricText} on ${keyText}${scoreText}${tieSuffix}`, rows: bestRows, click: rec.actions?.click };
    }
    const valueText = `${metricText}${tieSuffix}`;
    return { keyText, valueText, rows: bestRows, click: rec.actions?.click };
  }
  function buildStreak(semantic, grain, rowsAll, rec) {
    const clauses = Array.isArray(rec.streakFilters) ? rec.streakFilters : [];
    if (clauses.length === 0) return null;
    const sorted = [...rowsAll].sort((a, b) => (getRowTs2(a) ?? 0) - (getRowTs2(b) ?? 0));
    let cur = 0;
    let best = 0;
    let bestStart = -1;
    let bestEnd = -1;
    for (let i = 0; i < sorted.length; i++) {
      const r = sorted[i];
      const ok = applyFilters([r], clauses, grain).length === 1;
      if (ok) {
        cur++;
        if (cur > best) {
          best = cur;
          bestStart = i - cur + 1;
          bestEnd = i;
        }
      } else {
        cur = 0;
      }
    }
    const bestRows = best > 0 && bestStart >= 0 && bestEnd >= bestStart ? sorted.slice(bestStart, bestEnd + 1) : [];
    const keyText = bestRows.length ? (() => {
      const ts = getRowTs2(bestRows[0]);
      return ts !== null ? formatTs(ts) : "";
    })() : "";
    const valueText = best > 0 ? `${best} rounds in a row${keyText ? ` (${keyText})` : ""}` : "0";
    return { keyText, valueText, rows: bestRows, click: rec.actions?.click };
  }
  function buildSameValueStreak(semantic, grain, rowsAll, rec) {
    const dimId = typeof rec.dimension === "string" ? rec.dimension.trim() : "";
    if (!dimId) return null;
    const keyFn = DIMENSION_EXTRACTORS[grain]?.[dimId];
    if (!keyFn) return null;
    const sorted = [...rowsAll].sort((a, b) => (getRowTs2(a) ?? 0) - (getRowTs2(b) ?? 0));
    let best = 0;
    let bestStart = -1;
    let bestEnd = -1;
    let bestKey = null;
    let cur = 0;
    let curStart = 0;
    let prevKey = null;
    for (let i = 0; i < sorted.length; i++) {
      const r = sorted[i];
      const k = keyFn(r);
      if (!k) {
        cur = 0;
        prevKey = null;
        continue;
      }
      if (prevKey !== null && k === prevKey) {
        cur++;
      } else {
        cur = 1;
        curStart = i;
        prevKey = k;
      }
      if (cur > best) {
        best = cur;
        bestStart = curStart;
        bestEnd = i;
        bestKey = k;
      }
    }
    const bestRows = best > 0 && bestStart >= 0 && bestEnd >= bestStart ? sorted.slice(bestStart, bestEnd + 1) : [];
    const ts = bestRows.length ? getRowTs2(bestRows[0]) : null;
    const keyText = ts !== null ? formatTs(ts) : "";
    const valueText = best > 0 ? `${best} rounds in ${bestKey ?? ""}${keyText ? ` (${keyText})` : ""}`.trim() : "0";
    return { keyText, valueText, rows: bestRows, click: rec.actions?.click };
  }
  async function renderRecordListWidget(semantic, widget, overlay, baseRows) {
    const spec = widget.spec;
    const doc = overlay.getDocument();
    const grain = widget.grain;
    const wrap = doc.createElement("div");
    wrap.className = "ga-widget ga-recordlist";
    const title = doc.createElement("div");
    title.className = "ga-widget-title";
    title.textContent = widget.title;
    const box = doc.createElement("div");
    box.className = "ga-recordlist-box";
    const rowsAll = baseRows ?? (grain === "game" ? await getGames({}) : grain === "session" ? await getSessions({}) : await getRounds({}));
    for (const rec of spec.records) {
      const kind = rec.kind === "overall" ? "overall" : rec.kind === "same_value_streak" ? "same_value_streak" : rec.kind === "streak" ? "streak" : "group_extreme";
      const result = kind === "overall" ? buildOverall(semantic, grain, rowsAll, rec) : kind === "streak" ? buildStreak(semantic, grain, rowsAll, rec) : kind === "same_value_streak" ? buildSameValueStreak(semantic, grain, rowsAll, rec) : buildGroupExtreme(semantic, grain, rowsAll, rec);
      const line = doc.createElement("div");
      line.className = "ga-statrow";
      const left = doc.createElement("div");
      left.className = "ga-statrow-label";
      left.textContent = rec.label;
      const right = doc.createElement("div");
      right.className = "ga-statrow-value";
      right.textContent = result ? result.valueText : "-";
      line.appendChild(left);
      line.appendChild(right);
      box.appendChild(line);
      const click = result?.click;
      if (click?.type === "drilldown" && result) {
        line.style.cursor = "pointer";
        line.addEventListener("click", async () => {
          const rowsFromPoint = click.filterFromPoint ? result.rows : rowsAll;
          let sourceRows = rowsFromPoint;
          let targetGrain = grain;
          if (grain === "session" && click.target === "rounds") {
            targetGrain = "round";
            const out = [];
            for (const s of sourceRows) {
              const rr = s?.rounds;
              if (Array.isArray(rr)) out.push(...rr);
            }
            sourceRows = out;
          }
          if (grain === "session" && click.target === "games") {
            targetGrain = "game";
            const ids = /* @__PURE__ */ new Set();
            for (const s of sourceRows) {
              const gIds = s?.gameIds;
              if (!Array.isArray(gIds)) continue;
              for (const id of gIds) if (typeof id === "string" && id) ids.add(id);
            }
            const allGames = await getGames({});
            sourceRows = allGames.filter((g) => typeof g?.gameId === "string" && ids.has(g.gameId));
          }
          const filteredRows = applyFilters(sourceRows, click.extraFilters, targetGrain);
          overlay.open(semantic, {
            title: `${widget.title} - ${rec.label}${result.keyText ? ` (${result.keyText})` : ""}`,
            target: click.target,
            columnsPreset: click.columnsPreset,
            rows: filteredRows,
            extraFilters: click.extraFilters
          });
        });
      }
    }
    wrap.appendChild(title);
    wrap.appendChild(box);
    return wrap;
  }

  // src/ui/widgets/leaderListWidget.ts
  function formatPct01(v) {
    const clamped = Math.max(0, Math.min(1, v));
    return `${(clamped * 100).toFixed(1)}%`;
  }
  function getRowsAll(baseRows, grain) {
    if (Array.isArray(baseRows)) return Promise.resolve(baseRows);
    if (grain === "game") return getGames({});
    if (grain === "session") return getSessions({});
    return getRounds({});
  }
  function attachClickIfAny2(args) {
    const { el: el2, actions, overlay, semantic, title, grain, rows } = args;
    const click = actions?.click;
    if (!click) return;
    el2.style.cursor = "pointer";
    el2.addEventListener("click", () => {
      if (click.type !== "drilldown") return;
      const filteredRows = applyFilters(rows, click.extraFilters, grain);
      overlay.open(semantic, {
        title,
        target: click.target,
        columnsPreset: click.columnsPreset,
        rows: filteredRows,
        extraFilters: click.extraFilters
      });
    });
  }
  function computeLeaderText(counts, exclude) {
    const available = Array.from(counts.entries()).filter(([k]) => !exclude.has(k)).sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));
    const youKey = counts.has("You") ? "You" : available[0]?.[0] ?? "You";
    const mateKey = available.find(([k]) => k !== youKey)?.[0] ?? "Mate";
    const youCount = counts.get(youKey) ?? 0;
    const mateCount = counts.get(mateKey) ?? 0;
    const decisive = youCount + mateCount;
    if (decisive === 0) return "Tie (-)";
    if (youCount === mateCount) return `Tie (${formatPct01(0.5)})`;
    const leader = youCount > mateCount ? youKey : mateKey;
    const share = Math.max(youCount, mateCount) / decisive;
    return `${leader} (${formatPct01(share)})`;
  }
  async function renderLeaderListWidget(semantic, widget, overlay, baseRows) {
    const doc = overlay.getDocument();
    const spec = widget.spec;
    const grain = widget.grain;
    const wrap = doc.createElement("div");
    wrap.className = "ga-widget ga-leaderlist";
    const title = doc.createElement("div");
    title.className = "ga-widget-title";
    title.textContent = widget.title;
    const box = doc.createElement("div");
    box.className = "ga-statlist-box";
    const rowsAll = await getRowsAll(baseRows, grain);
    for (const row of spec.rows) {
      const dimId = row.dimension;
      const keyFn = DIMENSION_EXTRACTORS[grain]?.[dimId];
      if (!keyFn) continue;
      const exclude = new Set((row.excludeKeys ?? []).map((k) => typeof k === "string" ? k.trim() : "").filter(Boolean));
      const scoped = applyFilters(rowsAll, row.filters, grain);
      const counts = /* @__PURE__ */ new Map();
      for (const r of scoped) {
        const k = keyFn(r);
        if (typeof k !== "string" || !k.trim()) continue;
        counts.set(k, (counts.get(k) ?? 0) + 1);
      }
      const line = doc.createElement("div");
      line.className = "ga-statrow";
      const left = doc.createElement("div");
      left.textContent = row.label;
      const right = doc.createElement("div");
      right.style.fontVariantNumeric = "tabular-nums";
      right.textContent = computeLeaderText(counts, exclude);
      line.appendChild(left);
      line.appendChild(right);
      attachClickIfAny2({
        el: line,
        actions: row.actions,
        overlay,
        semantic,
        title: `${widget.title} - ${row.label}`,
        grain,
        rows: scoped
      });
      box.appendChild(line);
    }
    wrap.appendChild(title);
    wrap.appendChild(box);
    return wrap;
  }

  // src/ui/countryMapPicker.ts
  var WORLD_GEOJSON_URL = "https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json";
  var ISO_MAP_URL = "https://cdn.jsdelivr.net/npm/world-countries@5.1.0/countries.json";
  var dataPromise = null;
  function hasGmXhr2() {
    return typeof globalThis.GM_xmlhttpRequest === "function";
  }
  function gmGetText(url, accept) {
    return new Promise((resolve, reject) => {
      const gm = globalThis.GM_xmlhttpRequest;
      gm({
        method: "GET",
        url,
        headers: { Accept: accept ?? "application/json" },
        onload: (res) => resolve(typeof res?.responseText === "string" ? res.responseText : ""),
        onerror: (err) => reject(err),
        ontimeout: () => reject(new Error("GM_xmlhttpRequest timeout"))
      });
    });
  }
  async function fetchJson(url) {
    if (hasGmXhr2()) {
      const txt = await gmGetText(url, "application/json");
      return JSON.parse(txt);
    }
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    return res.json();
  }
  function normalizeIso23(v) {
    if (typeof v !== "string") return null;
    const x = v.trim().toLowerCase();
    return /^[a-z]{2}$/.test(x) ? x : null;
  }
  async function loadData() {
    if (!dataPromise) {
      dataPromise = (async () => {
        const [geojson, countries] = await Promise.all([fetchJson(WORLD_GEOJSON_URL), fetchJson(ISO_MAP_URL)]);
        const iso3ToIso2 = /* @__PURE__ */ new Map();
        if (Array.isArray(countries)) {
          for (const c of countries) {
            const iso2 = typeof c?.cca2 === "string" ? c.cca2.trim().toLowerCase() : "";
            const iso3 = typeof c?.cca3 === "string" ? c.cca3.trim().toUpperCase() : "";
            if (iso2 && iso3) iso3ToIso2.set(iso3, iso2);
          }
        }
        return { geojson, iso3ToIso2 };
      })();
    }
    return dataPromise;
  }
  function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }
  function project(lon, lat, w, h) {
    const x = (lon + 180) / 360 * w;
    const y = (90 - lat) / 180 * h;
    return [x, y];
  }
  function pathFromGeo(geometry, w, h) {
    const d = [];
    const addRing = (ring) => {
      if (!Array.isArray(ring) || ring.length < 2) return;
      const pts = ring.map((p) => Array.isArray(p) && p.length >= 2 ? [Number(p[0]), Number(p[1])] : null).filter((p) => !!p && Number.isFinite(p[0]) && Number.isFinite(p[1]));
      if (pts.length < 2) return;
      const [x0, y0] = project(pts[0][0], pts[0][1], w, h);
      d.push(`M${x0.toFixed(2)},${y0.toFixed(2)}`);
      for (let i = 1; i < pts.length; i++) {
        const [x, y] = project(pts[i][0], pts[i][1], w, h);
        d.push(`L${x.toFixed(2)},${y.toFixed(2)}`);
      }
      d.push("Z");
    };
    const type = geometry?.type;
    const coords = geometry?.coordinates;
    if (!type || !coords) return "";
    if (type === "Polygon") {
      for (const ring of coords) addRing(ring);
      return d.join(" ");
    }
    if (type === "MultiPolygon") {
      for (const poly of coords) {
        for (const ring of poly) addRing(ring);
      }
      return d.join(" ");
    }
    return "";
  }
  function applyViewport(g, vp) {
    g.setAttribute("transform", `translate(${vp.tx.toFixed(2)} ${vp.ty.toFixed(2)}) scale(${vp.scale.toFixed(4)})`);
  }
  async function renderCountryMapPicker(args) {
    const { container, value, onChange } = args;
    const doc = container.ownerDocument;
    container.innerHTML = "";
    container.classList.add("ga-country-map");
    const selectableMap = /* @__PURE__ */ new Map();
    if (Array.isArray(args.selectableValues)) {
      for (const v of args.selectableValues) {
        const norm = normalizeIso23(v);
        if (!norm) continue;
        if (!selectableMap.has(norm)) selectableMap.set(norm, String(v));
      }
    }
    const hasSelectableFilter = selectableMap.size > 0;
    const tintSelectable = args.tintSelectable !== false;
    let geojson;
    let iso3ToIso2;
    try {
      ({ geojson, iso3ToIso2 } = await loadData());
    } catch (e) {
      const msg = doc.createElement("div");
      msg.className = "ga-filter-map-error";
      msg.textContent = "Map unavailable (network/CSP).";
      container.appendChild(msg);
      throw e;
    }
    const wrap = doc.createElement("div");
    wrap.className = "ga-country-map-wrap";
    container.appendChild(wrap);
    const toolbar = doc.createElement("div");
    toolbar.className = "ga-country-map-toolbar";
    wrap.appendChild(toolbar);
    const btnMinus = doc.createElement("button");
    btnMinus.type = "button";
    btnMinus.className = "ga-country-map-btn";
    btnMinus.textContent = "\u2212";
    btnMinus.title = "Zoom out";
    const btnPlus = doc.createElement("button");
    btnPlus.type = "button";
    btnPlus.className = "ga-country-map-btn";
    btnPlus.textContent = "+";
    btnPlus.title = "Zoom in";
    const hint = doc.createElement("div");
    hint.className = "ga-country-map-hint";
    hint.textContent = "Scroll to zoom, drag to pan, click to select.";
    toolbar.appendChild(btnMinus);
    toolbar.appendChild(btnPlus);
    toolbar.appendChild(hint);
    const svg = doc.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.classList.add("ga-country-map-svg");
    wrap.appendChild(svg);
    const W = 1e3;
    const H = 500;
    svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
    const g = doc.createElementNS("http://www.w3.org/2000/svg", "g");
    svg.appendChild(g);
    const features = Array.isArray(geojson?.features) ? geojson.features : [];
    const pathsByIso2 = /* @__PURE__ */ new Map();
    for (const f of features) {
      const iso3 = typeof f?.id === "string" ? String(f.id).trim().toUpperCase() : "";
      const iso2 = iso3 ? iso3ToIso2.get(iso3) : void 0;
      if (!iso2) continue;
      const d = pathFromGeo(f.geometry, W, H);
      if (!d) continue;
      const p = doc.createElementNS("http://www.w3.org/2000/svg", "path");
      p.setAttribute("d", d);
      p.setAttribute("fill-rule", "evenodd");
      p.dataset.iso2 = iso2;
      p.classList.add("ga-country-shape");
      const isSelectable = !hasSelectableFilter || selectableMap.has(iso2);
      if (isSelectable) {
        if (tintSelectable) p.classList.add("selectable");
      } else {
        p.classList.add("disabled");
      }
      g.appendChild(p);
      const list = pathsByIso2.get(iso2) ?? [];
      list.push(p);
      pathsByIso2.set(iso2, list);
    }
    let selected = normalizeIso23(value);
    const refreshActive = () => {
      for (const [iso2, list] of pathsByIso2.entries()) {
        const active = !!selected && iso2 === selected;
        for (const el2 of list) el2.classList.toggle("active", active);
      }
    };
    refreshActive();
    for (const [iso2, list] of pathsByIso2.entries()) {
      const isSelectable = !hasSelectableFilter || selectableMap.has(iso2);
      if (!isSelectable) continue;
      for (const el2 of list) {
        el2.addEventListener("pointerenter", () => el2.classList.add("hover"));
        el2.addEventListener("pointerleave", () => el2.classList.remove("hover"));
      }
    }
    let vp = { scale: 1, tx: 0, ty: 0 };
    applyViewport(g, vp);
    const zoomAt = (px, py, nextScale) => {
      const s0 = vp.scale;
      const sx = (px - vp.tx) / s0;
      const sy = (py - vp.ty) / s0;
      vp = {
        scale: nextScale,
        tx: px - nextScale * sx,
        ty: py - nextScale * sy
      };
      applyViewport(g, vp);
    };
    const rectPoint = (clientX, clientY) => {
      const r = svg.getBoundingClientRect();
      const x = (clientX - r.left) / Math.max(1, r.width) * W;
      const y = (clientY - r.top) / Math.max(1, r.height) * H;
      return { x, y };
    };
    svg.addEventListener(
      "wheel",
      (ev) => {
        ev.preventDefault();
        const { x, y } = rectPoint(ev.clientX, ev.clientY);
        const dir = ev.deltaY > 0 ? 0.9 : 1.1;
        const nextScale = clamp(vp.scale * dir, 1, 8);
        zoomAt(x, y, nextScale);
      },
      { passive: false }
    );
    let dragging = false;
    let moved = false;
    let dragStart = null;
    svg.addEventListener("pointerdown", (ev) => {
      dragging = true;
      moved = false;
      svg.setPointerCapture?.(ev.pointerId);
      const { x, y } = rectPoint(ev.clientX, ev.clientY);
      const target = ev.target;
      const hit = target?.closest?.("path.ga-country-shape");
      const hitIso2 = normalizeIso23(hit?.dataset?.iso2) ?? null;
      const isSelectable = !hasSelectableFilter || (hitIso2 ? selectableMap.has(hitIso2) : false);
      dragStart = { x, y, tx: vp.tx, ty: vp.ty, hitIso2: isSelectable ? hitIso2 : null };
    });
    svg.addEventListener("pointermove", (ev) => {
      if (!dragging || !dragStart) return;
      const { x, y } = rectPoint(ev.clientX, ev.clientY);
      const dx = x - dragStart.x;
      const dy = y - dragStart.y;
      if (!moved && dx * dx + dy * dy > 6 * 6) moved = true;
      vp = { ...vp, tx: dragStart.tx + (x - dragStart.x), ty: dragStart.ty + (y - dragStart.y) };
      applyViewport(g, vp);
    });
    const stopDrag = () => {
      dragging = false;
      dragStart = null;
    };
    svg.addEventListener("pointerup", () => {
      if (dragging && dragStart && !moved && dragStart.hitIso2) {
        selected = dragStart.hitIso2;
        refreshActive();
        onChange(selectableMap.get(dragStart.hitIso2) ?? dragStart.hitIso2);
      }
      stopDrag();
    });
    svg.addEventListener("pointercancel", stopDrag);
    btnPlus.addEventListener("click", () => {
      zoomAt(W / 2, H / 2, clamp(vp.scale * 1.25, 1, 8));
    });
    btnMinus.addEventListener("click", () => {
      zoomAt(W / 2, H / 2, clamp(vp.scale / 1.25, 1, 8));
    });
  }

  // src/ui/dashboardRenderer.ts
  async function renderDashboard(root, semantic, dashboard, opts) {
    root.innerHTML = "";
    const doc = root.ownerDocument;
    const overlay = new DrilldownOverlay(root);
    const datasetsDefault = opts?.datasets ?? {};
    const datasetsBySection = opts?.datasetsBySection ?? {};
    const contextDefault = opts?.context;
    const contextBySection = opts?.contextBySection ?? {};
    let activeDatasets = datasetsDefault;
    let activeContext = contextDefault;
    const tabBar = doc.createElement("div");
    tabBar.className = "ga-tabs";
    const content = doc.createElement("div");
    content.className = "ga-content";
    root.appendChild(tabBar);
    root.appendChild(content);
    const sections = dashboard.dashboard.sections;
    let active = sections[0]?.id ?? "";
    const localStateBySection = /* @__PURE__ */ new Map();
    function makeTab(secId, label) {
      const btn = doc.createElement("button");
      btn.className = "ga-tab";
      btn.textContent = label;
      btn.addEventListener("click", async () => {
        active = secId;
        await renderActive();
        highlight();
      });
      tabBar.appendChild(btn);
    }
    function highlight() {
      const btns = Array.from(tabBar.querySelectorAll("button.ga-tab"));
      btns.forEach((b, i) => {
        b.classList.toggle("active", sections[i]?.id === active);
      });
    }
    async function renderWidget(widget) {
      const baseRows = activeDatasets[widget.grain];
      if (widget.type === "stat_list") return await renderStatListWidget(semantic, widget, overlay, baseRows);
      if (widget.type === "chart") return await renderChartWidget(semantic, widget, overlay, activeDatasets, activeContext);
      if (widget.type === "breakdown") return await renderBreakdownWidget(semantic, widget, overlay, baseRows);
      if (widget.type === "record_list") return await renderRecordListWidget(semantic, widget, overlay, baseRows);
      if (widget.type === "leader_list") return await renderLeaderListWidget(semantic, widget, overlay, baseRows);
      const ph = doc.createElement("div");
      ph.className = "ga-widget ga-placeholder";
      ph.textContent = `Widget type '${widget.type}' not implemented yet`;
      return ph;
    }
    const readCountryFormatMode4 = () => {
      const rootEl = root.closest?.(".ga-root") ?? null;
      return rootEl?.dataset?.gaCountryFormat === "english" ? "english" : "iso2";
    };
    const formatCountry4 = (isoOrName) => {
      if (readCountryFormatMode4() === "iso2") return isoOrName;
      const iso2 = isoOrName.trim().toUpperCase();
      if (!/^[A-Z]{2}$/.test(iso2)) return isoOrName;
      if (typeof Intl === "undefined" || !Intl.DisplayNames) return isoOrName;
      try {
        const dn = new Intl.DisplayNames(["en"], { type: "region" });
        return dn.of(iso2) ?? isoOrName;
      } catch {
        return isoOrName;
      }
    };
    const interpolate = (text, localState, dimById) => {
      return String(text).replace(/\{\{\s*local\.([A-Za-z0-9_\-]{3,64})\s*\}\}/g, (_, id) => {
        const v = localState[id];
        const raw = typeof v === "string" && v !== "all" ? v : "";
        const dim = dimById?.[id];
        if (!raw) return "";
        if (dim === "true_country" || dim === "guess_country" || dim === "opponent_country") return formatCountry4(raw);
        return raw;
      });
    };
    const renderLocalFiltersBar = async (args) => {
      const { host, spec, sectionId, datasets, onChange } = args;
      host.innerHTML = "";
      if (spec.enabled === false) return {};
      const base = localStateBySection.get(sectionId) ?? {};
      const nextState = { ...base };
      const bar = doc.createElement("div");
      bar.className = "ga-filters";
      host.appendChild(bar);
      const left = doc.createElement("div");
      left.className = "ga-filters-left";
      bar.appendChild(left);
      const right = doc.createElement("div");
      right.className = "ga-filters-right";
      bar.appendChild(right);
      const renderControlLabel2 = (label) => {
        const el2 = doc.createElement("div");
        el2.className = "ga-filter-label";
        el2.textContent = label;
        return el2;
      };
      const durationOrder2 = ["<20 sec", "20-30 sec", "30-45 sec", "45-60 sec", "60-90 sec", "90-180 sec", ">180 sec"];
      const durationRank2 = new Map(durationOrder2.map((k, i) => [k, i]));
      const movementLabel2 = (v) => {
        const k = v.trim().toLowerCase();
        if (k === "moving") return "Moving";
        if (k === "no_move") return "No move";
        if (k === "nmpz") return "NMPZ";
        if (k === "unknown") return "Unknown";
        return v;
      };
      const computeOptions = (control, stateWithoutSelf) => {
        const grains = control.appliesTo;
        const g = grains.includes("round") ? "round" : grains[0];
        const rowsBase = datasets[g];
        const rowsAll = Array.isArray(rowsBase) ? rowsBase : [];
        const clauses = spec.controls.filter((c) => c.id !== control.id).map((c) => ({ control: c, value: stateWithoutSelf[c.id] })).filter((x) => typeof x.value === "string" && x.value && x.value !== "all").map((x) => ({ dimension: x.control.dimension, op: "eq", value: x.value }));
        const filtered = clauses.length ? applyFilters(rowsAll, clauses, g) : rowsAll;
        if (control.options === "auto_teammates") {
          const gamesByMate = /* @__PURE__ */ new Map();
          const roundsByMate = /* @__PURE__ */ new Map();
          for (const r of filtered) {
            const mate = r.teammateName;
            const name = typeof mate === "string" ? mate.trim() : "";
            if (!name) continue;
            const gameId = String(r.gameId ?? "");
            if (!gameId) continue;
            const set = gamesByMate.get(name) ?? /* @__PURE__ */ new Set();
            set.add(gameId);
            gamesByMate.set(name, set);
            roundsByMate.set(name, (roundsByMate.get(name) ?? 0) + 1);
          }
          return Array.from(gamesByMate.entries()).map(([name, games]) => ({
            value: name,
            label: `${name} (${games.size} games, ${roundsByMate.get(name) ?? 0} rounds)`,
            n: games.size
          })).sort((a, b) => b.n - a.n || a.value.localeCompare(b.value));
        }
        const dimId = control.dimension;
        const extractor = ROUND_DIMENSION_EXTRACTORS[dimId];
        if (!extractor) return [];
        const counts = /* @__PURE__ */ new Map();
        for (const r of filtered) {
          const v = extractor(r);
          if (typeof v === "string" && v.length) counts.set(v, (counts.get(v) ?? 0) + 1);
        }
        let values = Array.from(counts.entries()).map(([value, n]) => ({ value, n })).sort((a, b) => b.n - a.n || a.value.localeCompare(b.value));
        if (dimId === "duration_bucket") values = values.sort((a, b) => (durationRank2.get(a.value) ?? 999) - (durationRank2.get(b.value) ?? 999));
        return values.map((v) => {
          const baseLabel = dimId === "movement_type" ? movementLabel2(v.value) : dimId === "true_country" || dimId === "guess_country" || dimId === "opponent_country" ? formatCountry4(v.value) : v.value;
          return {
            value: v.value,
            label: `${baseLabel} (${v.n} rounds)`,
            n: v.n
          };
        });
      };
      for (const control of spec.controls) {
        const wrap = doc.createElement("div");
        wrap.className = "ga-filter";
        wrap.appendChild(renderControlLabel2(control.label));
        const stateWithoutSelf = { ...nextState };
        delete stateWithoutSelf[control.id];
        const options = computeOptions(control, stateWithoutSelf);
        const isRequired = control.required === true;
        const current = typeof nextState[control.id] === "string" ? nextState[control.id] : "";
        const hasCurrent = options.some((o) => o.value === current);
        const desiredDefault = control.default === "auto_top" ? "" : control.default;
        const next = hasCurrent ? current : desiredDefault && options.some((o) => o.value === desiredDefault) ? desiredDefault : isRequired ? options[0]?.value ?? "" : "all";
        if (next && next !== current) nextState[control.id] = next;
        const isCountryDim = control.dimension === "true_country" || control.dimension === "guess_country" || control.dimension === "opponent_country";
        const presentation = control.presentation;
        const useMap = presentation === "map" && isCountryDim;
        if (useMap) {
          wrap.classList.add("ga-filter-map");
          const mapSpec = control.map;
          if (mapSpec?.variant === "wide") wrap.classList.add("ga-filter-map-wide");
          const selected = doc.createElement("div");
          selected.className = "ga-filter-map-selected";
          const txt = next && next !== "all" ? formatCountry4(next) : "";
          selected.textContent = txt ? `Selected: ${txt}` : "Click a country on the map";
          wrap.appendChild(selected);
          const mapHost = doc.createElement("div");
          mapHost.className = "ga-filter-map-host";
          const mapHeight = typeof mapSpec?.height === "number" && Number.isFinite(mapSpec.height) ? Math.round(mapSpec.height) : null;
          if (mapHeight && mapHeight >= 160 && mapHeight <= 520) {
            mapHost.style.setProperty("--ga-country-map-h", `${mapHeight}px`);
          }
          wrap.appendChild(mapHost);
          try {
            const restrictToOptions = mapSpec?.restrictToOptions === true;
            const selectableValues = restrictToOptions ? options.map((o) => o.value) : void 0;
            await renderCountryMapPicker({
              container: mapHost,
              value: next,
              selectableValues,
              tintSelectable: mapSpec?.tintSelectable !== false,
              onChange: (iso2) => {
                nextState[control.id] = iso2;
                localStateBySection.set(sectionId, { ...nextState });
                onChange();
              }
            });
          } catch {
            wrap.innerHTML = "";
            wrap.appendChild(renderControlLabel2(control.label));
            const sel = doc.createElement("select");
            sel.className = "ga-filter-select";
            if (!isRequired) sel.appendChild(new Option("All", "all"));
            for (const opt of options) sel.appendChild(new Option(opt.label, opt.value));
            if (next) sel.value = next;
            sel.addEventListener("change", () => {
              nextState[control.id] = sel.value;
              localStateBySection.set(sectionId, { ...nextState });
              onChange();
            });
            wrap.appendChild(sel);
          }
        } else {
          const sel = doc.createElement("select");
          sel.className = "ga-filter-select";
          if (!isRequired) sel.appendChild(new Option("All", "all"));
          for (const opt of options) sel.appendChild(new Option(opt.label, opt.value));
          if (next) sel.value = next;
          sel.addEventListener("change", () => {
            nextState[control.id] = sel.value;
            localStateBySection.set(sectionId, { ...nextState });
            onChange();
          });
          wrap.appendChild(sel);
        }
        left.appendChild(wrap);
      }
      const showReset = spec.buttons?.reset !== false;
      if (showReset) {
        const resetBtn = doc.createElement("button");
        resetBtn.className = "ga-filter-btn";
        resetBtn.textContent = "Reset";
        resetBtn.addEventListener("click", () => {
          localStateBySection.delete(sectionId);
          onChange();
        });
        right.appendChild(resetBtn);
      }
      localStateBySection.set(sectionId, { ...nextState });
      return nextState;
    };
    async function renderActive() {
      content.innerHTML = "";
      const section = sections.find((s) => s.id === active);
      if (!section) return;
      const baseDatasets = datasetsBySection[section.id] ?? datasetsDefault;
      activeContext = contextBySection[section.id] ?? contextDefault;
      opts?.onActiveSectionChange?.(section.id);
      const localHost = doc.createElement("div");
      content.appendChild(localHost);
      const localSpec = section.localFilters;
      const dimByLocalId = {};
      if (localSpec && Array.isArray(localSpec.controls)) {
        for (const c of localSpec.controls) {
          if (c && typeof c.id === "string" && typeof c.dimension === "string") dimByLocalId[c.id] = c.dimension;
        }
      }
      const localState = localSpec && Array.isArray(localSpec.controls) && localSpec.controls.length ? await renderLocalFiltersBar({
        host: localHost,
        spec: localSpec,
        sectionId: section.id,
        datasets: baseDatasets,
        onChange: () => void renderActive()
      }) : localStateBySection.get(section.id) ?? {};
      const localClauses = localSpec ? localSpec.controls.map((c) => ({ c, v: localState[c.id] })).filter((x) => typeof x.v === "string" && x.v && x.v !== "all").map((x) => ({ dimension: x.c.dimension, op: "eq", value: x.v, appliesTo: x.c.appliesTo })) : [];
      const localDatasets = { ...baseDatasets };
      for (const [grainKey, rows] of Object.entries(baseDatasets)) {
        if (!Array.isArray(rows)) continue;
        const clauses = localClauses.filter((c) => Array.isArray(c.appliesTo) && c.appliesTo.includes(grainKey));
        if (clauses.length) {
          localDatasets[grainKey] = applyFilters(rows, clauses.map((c) => ({ dimension: c.dimension, op: c.op, value: c.value })), grainKey);
        }
      }
      const usesSession = section.layout.cards.some((c) => c.card.children.some((w) => w.grain === "session"));
      const localRounds = localDatasets.round;
      if (usesSession && Array.isArray(localRounds)) {
        const rootEl = content.closest(".ga-root");
        const raw = Number(rootEl?.dataset?.gaSessionGapMinutes);
        const gap = Number.isFinite(raw) ? Math.max(1, Math.min(360, Math.round(raw))) : 45;
        localDatasets.session = await getSessions({ global: { spec: void 0, state: {}, sessionGapMinutes: gap } }, { rounds: localRounds });
      }
      activeDatasets = localDatasets;
      const grid = doc.createElement("div");
      grid.className = "ga-grid";
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = `repeat(${section.layout.columns}, minmax(0, 1fr))`;
      grid.style.gap = "12px";
      for (const placed of section.layout.cards) {
        const card = doc.createElement("div");
        card.className = "ga-card";
        card.style.gridColumn = `${placed.x + 1} / span ${placed.w}`;
        card.style.gridRow = `${placed.y + 1} / span ${placed.h}`;
        const header = doc.createElement("div");
        header.className = "ga-card-header";
        header.textContent = interpolate(placed.title, localState, dimByLocalId);
        const body = doc.createElement("div");
        body.className = "ga-card-body";
        const inner = doc.createElement("div");
        inner.className = "ga-card-inner";
        inner.style.display = "grid";
        inner.style.gridTemplateColumns = `repeat(${section.layout.columns}, minmax(0, 1fr))`;
        inner.style.gap = "10px";
        for (const w of placed.card.children) {
          const container = doc.createElement("div");
          container.className = "ga-child";
          const p = w.placement ?? { x: 0, y: 0, w: 12, h: 3 };
          container.style.gridColumn = `${p.x + 1} / span ${p.w}`;
          container.style.gridRow = `${p.y + 1} / span ${p.h}`;
          const wInterp = { ...w, title: interpolate(w.title, localState, dimByLocalId) };
          container.appendChild(await renderWidget(wInterp));
          inner.appendChild(container);
        }
        body.appendChild(inner);
        card.appendChild(header);
        card.appendChild(body);
        grid.appendChild(card);
      }
      content.appendChild(grid);
    }
    for (const s of sections) makeTab(s.id, s.title);
    await renderActive();
    highlight();
  }

  // src/ui/filterState.ts
  function cloneJson3(value) {
    if (typeof structuredClone === "function") return structuredClone(value);
    return JSON.parse(JSON.stringify(value));
  }
  function buildDefaults(spec) {
    const state = {};
    if (!spec?.enabled) return state;
    for (const c of spec.controls) {
      state[c.id] = cloneJson3(c.default);
    }
    return state;
  }
  function normalizeDateRangeValue(value, fallback) {
    if (!value || typeof value !== "object") return fallback;
    const v = value;
    const fromTs = v.fromTs === null ? null : Number(v.fromTs);
    const toTs2 = v.toTs === null ? null : Number(v.toTs);
    return {
      fromTs: Number.isFinite(fromTs) ? fromTs : null,
      toTs: Number.isFinite(toTs2) ? toTs2 : null
    };
  }
  function createGlobalFilterStore(spec) {
    let defaults = buildDefaults(spec);
    let state = cloneJson3(defaults);
    const listeners = /* @__PURE__ */ new Set();
    const notify = () => {
      for (const l of listeners) l();
    };
    return {
      getSpec: () => spec,
      getState: () => state,
      patchDefaults: (partial) => {
        defaults = { ...defaults, ...cloneJson3(partial) };
      },
      setValue: (id, value) => {
        if (!id) return;
        const control = spec?.enabled ? spec.controls.find((c) => c.id === id) : void 0;
        if (control?.type === "date_range") {
          const fb = defaults[id] ?? { fromTs: null, toTs: null };
          state = { ...state, [id]: normalizeDateRangeValue(value, fb) };
        } else {
          state = { ...state, [id]: value };
        }
        notify();
      },
      setAll: (next) => {
        state = { ...cloneJson3(defaults), ...cloneJson3(next) };
        notify();
      },
      reset: () => {
        state = cloneJson3(defaults);
        notify();
      },
      subscribe: (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      }
    };
  }

  // src/ui/globalFiltersBar.ts
  function toYmd(ts) {
    const d = new Date(ts);
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${dd}`;
  }
  function fromYmdStartOfDay(ymd) {
    const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(ymd);
    if (!m) return null;
    const y = Number(m[1]);
    const mo = Number(m[2]) - 1;
    const d = Number(m[3]);
    const dt = new Date(y, mo, d, 0, 0, 0, 0);
    const ts = dt.getTime();
    return Number.isFinite(ts) ? ts : null;
  }
  function fromYmdEndOfDay(ymd) {
    const start = fromYmdStartOfDay(ymd);
    if (start === null) return null;
    return start + 24 * 60 * 60 * 1e3 - 1;
  }
  function getDateRangeValue(state, id, fallback) {
    const v = state[id];
    if (!v || typeof v !== "object") return fallback;
    const r = v;
    return {
      fromTs: r.fromTs === null ? null : Number(r.fromTs),
      toTs: r.toTs === null ? null : Number(r.toTs)
    };
  }
  function renderControlLabel(doc, label) {
    const el2 = doc.createElement("div");
    el2.className = "ga-filter-label";
    el2.textContent = label;
    return el2;
  }
  function readCountryFormatMode3(doc) {
    const root = doc.querySelector(".ga-root");
    return root?.dataset?.gaCountryFormat === "english" ? "english" : "iso2";
  }
  function formatCountry3(doc, isoOrName) {
    const mode = readCountryFormatMode3(doc);
    if (mode === "iso2") return isoOrName;
    const iso2 = isoOrName.trim().toUpperCase();
    if (!/^[A-Z]{2}$/.test(iso2)) return isoOrName;
    if (typeof Intl === "undefined" || !Intl.DisplayNames) return isoOrName;
    try {
      const dn = new Intl.DisplayNames(["en"], { type: "region" });
      return dn.of(iso2) ?? isoOrName;
    } catch {
      return isoOrName;
    }
  }
  async function renderGlobalFiltersBar(args) {
    const { container, semantic, spec, state, setValue, setAll, reset, getDistinctOptions, controlIds, constraints } = args;
    const doc = container.ownerDocument;
    container.innerHTML = "";
    if (!spec?.enabled) return;
    const allowed = Array.isArray(controlIds) && controlIds.length > 0 ? new Set(controlIds) : null;
    const bar = doc.createElement("div");
    bar.className = "ga-filters";
    container.appendChild(bar);
    const left = doc.createElement("div");
    left.className = "ga-filters-left";
    bar.appendChild(left);
    const right = doc.createElement("div");
    right.className = "ga-filters-right";
    bar.appendChild(right);
    const applyMode = spec.buttons?.apply === true;
    const showReset = spec.buttons?.reset !== false;
    let pending = { ...state };
    const commit = () => setAll(pending);
    const updatePending = (id, value) => {
      pending = { ...pending, [id]: value };
      if (id === "teammate") {
        const v = typeof value === "string" ? value.trim() : "";
        if (v && v !== "all") {
          pending = { ...pending, modeFamily: "Team Duel" };
          if (!applyMode) setValue("modeFamily", "Team Duel");
        }
      }
      if (id === "modeFamily") {
        const v = typeof value === "string" ? value.trim() : "";
        const mate = typeof pending.teammate === "string" ? pending.teammate.trim() : "";
        if (v === "Duel" && mate && mate !== "all") {
          pending = { ...pending, teammate: "all" };
          if (!applyMode) setValue("teammate", "all");
        }
      }
      if (!applyMode) setValue(id, value);
    };
    const renderDateRange = (control) => {
      const c = control;
      const id = String(c.id);
      const def = c.default;
      const current = getDateRangeValue(applyMode ? pending : state, id, def);
      const wrap = doc.createElement("div");
      wrap.className = "ga-filter";
      wrap.appendChild(renderControlLabel(doc, c.label));
      const row = doc.createElement("div");
      row.className = "ga-filter-row";
      const from = doc.createElement("input");
      from.type = "date";
      from.value = current.fromTs ? toYmd(current.fromTs) : "";
      from.addEventListener("change", () => {
        const ts = from.value ? fromYmdStartOfDay(from.value) : null;
        const next = { ...current, fromTs: ts };
        updatePending(id, next);
      });
      const to = doc.createElement("input");
      to.type = "date";
      to.value = current.toTs ? toYmd(current.toTs) : "";
      to.addEventListener("change", () => {
        const ts = to.value ? fromYmdEndOfDay(to.value) : null;
        const next = { ...current, toTs: ts };
        updatePending(id, next);
      });
      row.appendChild(from);
      row.appendChild(to);
      wrap.appendChild(row);
      left.appendChild(wrap);
    };
    const renderSelect = async (control) => {
      const id = control.id;
      const isRequired = constraints?.[id]?.required === true;
      const current = String((applyMode ? pending : state)[id] ?? control.default ?? "all");
      const wrap = doc.createElement("div");
      wrap.className = "ga-filter";
      wrap.appendChild(renderControlLabel(doc, control.label));
      const sel = doc.createElement("select");
      sel.className = "ga-filter-select";
      const options = await getDistinctOptions({ control, spec, state: applyMode ? pending : state });
      if (!isRequired) sel.appendChild(new Option("All", "all"));
      for (const opt of options) {
        const label = control.dimension === "true_country" ? formatCountry3(doc, opt.label) : opt.label;
        sel.appendChild(new Option(label, opt.value));
      }
      const hasCurrent = options.some((o) => o.value === current);
      const nextValue = hasCurrent ? current : isRequired ? options[0]?.value ?? "" : "all";
      if (nextValue) sel.value = nextValue;
      if (isRequired && nextValue && nextValue !== current) {
        updatePending(id, nextValue);
      }
      sel.addEventListener("change", () => {
        updatePending(id, sel.value);
      });
      wrap.appendChild(sel);
      left.appendChild(wrap);
    };
    const controls = spec.controls;
    for (const c of controls) {
      if (allowed && !allowed.has(c.id)) continue;
      if (c.type === "date_range") {
        renderDateRange(c);
        continue;
      }
      if (c.type === "select") {
        const dim = semantic.dimensions[c.dimension];
        if (dim) {
          const grains = Array.isArray(dim.grain) ? dim.grain : [dim.grain];
          if (!grains.includes("round")) continue;
        }
        await renderSelect(c);
        continue;
      }
    }
    if (applyMode) {
      const applyBtn = doc.createElement("button");
      applyBtn.className = "ga-filter-btn";
      applyBtn.textContent = "Apply";
      applyBtn.addEventListener("click", () => {
        commit();
      });
      right.appendChild(applyBtn);
    }
    if (showReset) {
      const resetBtn = doc.createElement("button");
      resetBtn.className = "ga-filter-btn";
      resetBtn.textContent = "Reset";
      resetBtn.addEventListener("click", () => {
        reset();
      });
      right.appendChild(resetBtn);
    }
  }

  // src/engine/selectOptions.ts
  var cache = /* @__PURE__ */ new Map();
  function stableKey(spec, state, excludeId) {
    const parts = spec.controls.map((c) => c.id === excludeId ? `${c.id}=<excluded>` : `${c.id}=${JSON.stringify(state[c.id])}`);
    return `selectopts:${excludeId}:${parts.join("|")}`;
  }
  function movementLabel(v) {
    const k = v.trim().toLowerCase();
    if (k === "moving") return "Moving";
    if (k === "no_move") return "No move";
    if (k === "nmpz") return "NMPZ";
    if (k === "unknown") return "Unknown";
    return v;
  }
  var durationOrder = ["<20 sec", "20-30 sec", "30-45 sec", "45-60 sec", "60-90 sec", "90-180 sec", ">180 sec"];
  var durationRank = new Map(durationOrder.map((k, i) => [k, i]));
  async function getSelectOptionsForControl(opts) {
    const { spec, state, control } = opts;
    const key = stableKey(spec, state, control.id);
    const cached = cache.get(key);
    if (cached) return cached;
    const stateWithoutSelf = { ...state };
    delete stateWithoutSelf[control.id];
    const rows = await getRounds({ global: { spec, state: stateWithoutSelf } });
    if (control.options === "auto_teammates") {
      const gamesByMate = /* @__PURE__ */ new Map();
      const roundsByMate = /* @__PURE__ */ new Map();
      for (const r of rows) {
        const mate = r.teammateName;
        const name = typeof mate === "string" ? mate.trim() : "";
        const gameId = String(r.gameId ?? "");
        if (!gameId) continue;
        if (!name) continue;
        const set = gamesByMate.get(name) ?? /* @__PURE__ */ new Set();
        set.add(gameId);
        gamesByMate.set(name, set);
        roundsByMate.set(name, (roundsByMate.get(name) ?? 0) + 1);
      }
      const out2 = Array.from(gamesByMate.entries()).map(([name, games]) => ({
        value: name,
        label: `${name} (${games.size} games, ${roundsByMate.get(name) ?? 0} rounds)`,
        n: games.size
      })).sort((a, b) => b.n - a.n || a.value.localeCompare(b.value)).map(({ value, label }) => ({ value, label }));
      cache.set(key, out2);
      return out2;
    }
    const dimId = control.dimension;
    const extractor = ROUND_DIMENSION_EXTRACTORS[dimId];
    if (!extractor) return [];
    if (dimId === "map_slug") {
      const nameExtractor = ROUND_DIMENSION_EXTRACTORS["map_name"];
      const gameIdExtractor = ROUND_DIMENSION_EXTRACTORS["game_id"];
      const bySlug = /* @__PURE__ */ new Map();
      for (const r of rows) {
        const slug = extractor(r);
        if (typeof slug !== "string" || !slug.trim()) continue;
        const s = slug.trim();
        const cur = bySlug.get(s) ?? { games: /* @__PURE__ */ new Set() };
        const name = nameExtractor ? nameExtractor(r) : null;
        if (typeof name === "string" && name.trim() && !cur.name) cur.name = name.trim();
        const gid = gameIdExtractor ? gameIdExtractor(r) : null;
        if (typeof gid === "string" && gid.trim()) cur.games.add(gid.trim());
        bySlug.set(s, cur);
      }
      const out2 = Array.from(bySlug.entries()).map(([value, meta]) => {
        const nGames = meta.games.size;
        const labelBase = meta.name ? meta.name : value;
        const label = nGames > 0 ? `${labelBase} (${nGames} games)` : labelBase;
        return { value, label, n: nGames, labelBase };
      }).sort((a, b) => b.n - a.n || a.labelBase.localeCompare(b.labelBase)).map(({ value, label }) => ({ value, label }));
      cache.set(key, out2);
      return out2;
    }
    const seen = /* @__PURE__ */ new Set();
    for (const r of rows) {
      const v = extractor(r);
      if (typeof v === "string" && v.length) seen.add(v);
    }
    let values = Array.from(seen);
    if (dimId === "duration_bucket") {
      values.sort((a, b) => (durationRank.get(a) ?? 999) - (durationRank.get(b) ?? 999));
    } else {
      values.sort((a, b) => a.localeCompare(b));
    }
    const out = values.map((v) => ({
      value: v,
      label: dimId === "movement_type" ? movementLabel(v) : v
    }));
    cache.set(key, out);
    return out;
  }

  // src/ui/analysisRenderer.ts
  function explodeOpponentsFromGames(games) {
    const out = [];
    for (const g of games) {
      const base = { ...g };
      const mf = String(base?.modeFamily ?? "").toLowerCase();
      const matchups = mf === "teamduels" ? 2 : 1;
      const pushOpp = (name, country) => {
        const n = typeof name === "string" ? name.trim() : "";
        if (!n) return;
        const c = typeof country === "string" ? country.trim() : "";
        out.push({ ...base, opponentName: n, opponentCountry: c || "Unknown", matchups });
      };
      pushOpp(base.player_opponent_name ?? base.playerOpponentName, base.player_opponent_country ?? base.playerOpponentCountry);
      pushOpp(base.player_opponent_mate_name ?? base.playerOpponentMateName, base.player_opponent_mate_country ?? base.playerOpponentMateCountry);
    }
    return out;
  }
  async function renderAnalysisApp(opts) {
    const { body, semantic, dashboard } = opts;
    const doc = body.ownerDocument;
    body.innerHTML = "";
    const root = body.closest(".ga-root");
    const getSessionGapMinutes = () => {
      const raw = Number(root?.dataset.gaSessionGapMinutes);
      if (Number.isFinite(raw)) return Math.max(1, Math.min(360, Math.round(raw)));
      return semantic.settings?.sessionGapMinutesDefault ?? 45;
    };
    const filtersHost = doc.createElement("div");
    filtersHost.className = "ga-filters-host";
    body.appendChild(filtersHost);
    const dashboardHost = doc.createElement("div");
    dashboardHost.className = "ga-dashboard-host";
    body.appendChild(dashboardHost);
    const updateStickyVars = () => {
      if (!root) return;
      const topbar = root.querySelector(".ga-topbar");
      root.style.setProperty("--ga-topbar-h", `${topbar?.offsetHeight ?? 0}px`);
      root.style.setProperty("--ga-filters-h", `${filtersHost.offsetHeight}px`);
    };
    if (root && !root.__gaStickyVarsSetup) {
      root.__gaStickyVarsSetup = true;
      updateStickyVars();
      const win = doc.defaultView;
      if (win && typeof win.ResizeObserver !== "undefined") {
        const ro = new win.ResizeObserver(() => updateStickyVars());
        ro.observe(filtersHost);
        const topbar = root.querySelector(".ga-topbar");
        if (topbar) ro.observe(topbar);
      }
      win?.addEventListener("resize", () => updateStickyVars());
    }
    const spec = dashboard.dashboard.globalFilters;
    const store = createGlobalFilterStore(spec);
    if (spec?.enabled) {
      const bounds = await getGamePlayedAtBounds();
      if (bounds.minTs !== null && bounds.maxTs !== null) {
        for (const c of spec.controls) {
          if (c.type !== "date_range") continue;
          const current = store.getState()[c.id];
          const isUnset = !current || typeof current !== "object" || (current.fromTs === null || current.fromTs === void 0) && (current.toTs === null || current.toTs === void 0);
          if (!isUnset) continue;
          const next = { fromTs: bounds.minTs, toTs: bounds.maxTs };
          store.patchDefaults({ [c.id]: next });
          store.setValue(c.id, next);
        }
      }
    }
    const renderNow = async () => {
      const specFilters = spec;
      let state = store.getState();
      await renderGlobalFiltersBar({
        container: filtersHost,
        semantic,
        spec,
        state,
        setValue: store.setValue,
        setAll: store.setAll,
        reset: store.reset,
        getDistinctOptions: async ({ control, spec: s, state: st }) => getSelectOptionsForControl({ control, spec: s, state: st })
      });
      updateStickyVars();
      const resolveControlIdsForSection = (section) => {
        if (!specFilters?.enabled) return void 0;
        const all = specFilters.controls.map((c) => c.id);
        const include = Array.isArray(section?.filterScope?.include) ? section.filterScope.include : null;
        const exclude = Array.isArray(section?.filterScope?.exclude) ? section.filterScope.exclude : null;
        let ids = include && include.length ? all.filter((id) => include.includes(id)) : [...all];
        if (exclude && exclude.length) ids = ids.filter((id) => !exclude.includes(id));
        return ids;
      };
      const hasTeamDuels = await hasAnyTeamDuels();
      const sections = hasTeamDuels ? dashboard.dashboard.sections : dashboard.dashboard.sections.filter((s) => s.id !== "team");
      const datasetsBySection = {};
      const contextBySection = {};
      for (const section of sections) {
        const controlIds = resolveControlIdsForSection(section);
        const used = /* @__PURE__ */ new Set();
        for (const placed of section.layout.cards) {
          for (const w of placed.card.children) {
            used.add(w.grain);
            const anySpec = w.spec;
            if (w.type === "chart") {
              const xDimId = anySpec?.x?.dimension;
              const xDim = xDimId ? semantic.dimensions[xDimId] : void 0;
              const xGrains = xDim ? Array.isArray(xDim.grain) ? xDim.grain : [xDim.grain] : [];
              for (const g of xGrains) used.add(g);
              const ids = [];
              if (typeof anySpec?.y?.measure === "string") ids.push(anySpec.y.measure);
              if (Array.isArray(anySpec?.y?.measures)) ids.push(...anySpec.y.measures);
              for (const mId of ids) {
                const m = semantic.measures[mId];
                if (m) used.add(m.grain);
              }
            }
            if (w.type === "breakdown") {
              const ids = [];
              if (typeof anySpec?.measure === "string") ids.push(anySpec.measure);
              if (Array.isArray(anySpec?.measures)) ids.push(...anySpec.measures);
              for (const mId of ids) {
                const m = semantic.measures[mId];
                if (m) used.add(m.grain);
              }
            }
            if (w.type === "stat_list") {
              const rows = Array.isArray(anySpec?.rows) ? anySpec.rows : [];
              for (const r of rows) {
                const m = semantic.measures[r?.measure];
                if (m) used.add(m.grain);
              }
            }
            if (w.type === "stat_value") {
              const m = semantic.measures[anySpec?.measure];
              if (m) used.add(m.grain);
            }
            if (w.type === "record_list") {
              const recs = Array.isArray(anySpec?.records) ? anySpec.records : [];
              for (const r of recs) {
                if (Array.isArray(r?.streakFilters) && r.streakFilters.length > 0) used.add("round");
                if (typeof r?.metric === "string") {
                  const m = semantic.measures[r.metric];
                  if (m) used.add(m.grain);
                }
                if (typeof r?.groupBy === "string") {
                  const d = semantic.dimensions[r.groupBy];
                  const grains = d ? Array.isArray(d.grain) ? d.grain : [d.grain] : [];
                  for (const g of grains) used.add(g);
                }
              }
            }
          }
        }
        const filters = { global: { spec: specFilters, state, controlIds } };
        const datasets = {};
        const isOpponentsSection = section.id === "opponents";
        const isRatingSection = section.id === "rating";
        const teammateSelected = (() => {
          const v = state?.["teammate"];
          if (v === "all") return false;
          if (typeof v !== "string") return false;
          return v.trim().length > 0;
        })();
        if (used.has("round") || used.has("session") || isOpponentsSection) datasets.round = await getRounds(filters);
        if (used.has("game") || isOpponentsSection) datasets.game = await getGames(filters);
        if (isRatingSection && Array.isArray(datasets.round)) {
          const want = teammateSelected ? "teamduels" : "duels";
          datasets.round = datasets.round.filter((r) => String(r?.modeFamily ?? "").toLowerCase() === want);
        }
        if (isRatingSection && Array.isArray(datasets.game)) {
          const want = teammateSelected ? "teamduels" : "duels";
          datasets.game = datasets.game.filter((g) => String(g?.modeFamily ?? "").toLowerCase() === want);
        }
        if (Array.isArray(datasets.round) && Array.isArray(datasets.game) && specFilters?.enabled) {
          const allowedSet = Array.isArray(controlIds) && controlIds.length > 0 ? new Set(controlIds) : null;
          const hasActiveRoundOnly = specFilters.controls.some((c) => {
            if (allowedSet && !allowedSet.has(c.id)) return false;
            const appliesRound = Array.isArray(c.appliesTo) && c.appliesTo.includes("round");
            const appliesGame = Array.isArray(c.appliesTo) && c.appliesTo.includes("game");
            if (!appliesRound || appliesGame) return false;
            const v = state[c.id];
            return typeof v === "string" ? v !== "all" && v.trim().length > 0 : false;
          });
          if (hasActiveRoundOnly) {
            const rr = datasets.round;
            if (rr.length) {
              const allowedGames = new Set(rr.map((r) => r?.gameId).filter((x) => typeof x === "string" && x));
              datasets.game = datasets.game.filter((g) => allowedGames.has(g?.gameId));
            }
          }
        }
        if (used.has("session")) {
          const gap = getSessionGapMinutes();
          datasets.session = await getSessions({ global: { spec: specFilters, state, controlIds, sessionGapMinutes: gap } }, { rounds: datasets.round });
        }
        if (isOpponentsSection && Array.isArray(datasets.game)) {
          datasets.game = explodeOpponentsFromGames(datasets.game);
        }
        datasetsBySection[section.id] = datasets;
        const hasDate = !controlIds || controlIds.includes("dateRange");
        const dateVal = state["dateRange"];
        const fromTs = hasDate && dateVal && typeof dateVal === "object" ? dateVal.fromTs ?? null : null;
        const toTs2 = hasDate && dateVal && typeof dateVal === "object" ? dateVal.toTs ?? null : null;
        contextBySection[section.id] = { dateRange: { fromTs, toTs: toTs2 } };
      }
      const allControlIds = specFilters?.enabled ? specFilters.controls.map((c) => c.id) : void 0;
      const filtersAll = { global: { spec: specFilters, state, controlIds: allControlIds } };
      const datasetsAll = {};
      const usedAll = /* @__PURE__ */ new Set();
      for (const section of sections) {
        const d = datasetsBySection[section.id];
        if (d?.round) usedAll.add("round");
        if (d?.game) usedAll.add("game");
        if (d?.session) usedAll.add("session");
      }
      if (usedAll.has("round") || usedAll.has("session")) datasetsAll.round = await getRounds(filtersAll);
      if (usedAll.has("game")) datasetsAll.game = await getGames(filtersAll);
      if (usedAll.has("session")) {
        const gap = getSessionGapMinutes();
        datasetsAll.session = await getSessions({ global: { spec: specFilters, state, controlIds: allControlIds, sessionGapMinutes: gap } }, { rounds: datasetsAll.round });
      }
      const dateValAll = state["dateRange"];
      const fromTsAll = dateValAll && typeof dateValAll === "object" ? dateValAll.fromTs ?? null : null;
      const toTsAll = dateValAll && typeof dateValAll === "object" ? dateValAll.toTs ?? null : null;
      const effectiveDashboard = {
        ...dashboard,
        dashboard: {
          ...dashboard.dashboard,
          sections
        }
      };
      await renderDashboard(dashboardHost, semantic, effectiveDashboard, {
        datasets: datasetsAll,
        datasetsBySection,
        context: { dateRange: { fromTs: fromTsAll, toTs: toTsAll } },
        contextBySection
      });
    };
    store.subscribe(() => {
      void renderNow();
    });
    await renderNow();
  }

  // src/app/playerIdentity.ts
  var cachedPlayerName;
  function asTrimmedString3(v) {
    const s = typeof v === "string" ? v.trim() : "";
    return s ? s : void 0;
  }
  function pickFirst5(obj, paths) {
    for (const path of paths) {
      if (!obj || typeof obj !== "object") continue;
      const parts = path.split(".");
      let cur = obj;
      let ok = true;
      for (const p of parts) {
        if (!cur || typeof cur !== "object" || !(p in cur)) {
          ok = false;
          break;
        }
        cur = cur[p];
      }
      if (!ok) continue;
      if (cur !== void 0 && cur !== null) return cur;
    }
    return void 0;
  }
  async function fetchPlayerNameFromApi() {
    const idCandidates = [
      "https://www.geoguessr.com/api/v3/profiles",
      "https://www.geoguessr.com/api/v4/profiles",
      "https://www.geoguessr.com/api/v3/users/me"
    ];
    let playerId;
    for (const url of idCandidates) {
      try {
        const res = await httpGetJson(url);
        if (res.status < 200 || res.status >= 300) continue;
        const id = pickFirst5(res.data, ["user.id", "id", "player.id", "playerId", "user.userId"]);
        playerId = asTrimmedString3(id);
        if (playerId) break;
      } catch {
      }
    }
    if (!playerId) return void 0;
    try {
      const res = await httpGetJson(`https://www.geoguessr.com/api/v3/users/${encodeURIComponent(playerId)}`);
      if (res.status < 200 || res.status >= 300) return void 0;
      return asTrimmedString3(res.data?.nick);
    } catch {
      return void 0;
    }
  }
  async function guessPlayerNameFromDb() {
    try {
      const latest = await db.details.orderBy("fetchedAt").reverse().limit(10).toArray();
      for (const d of latest) {
        const candidate = asTrimmedString3(d?.player_self_name) ?? asTrimmedString3(d?.playerOneName) ?? asTrimmedString3(d?.playerOneNick) ?? asTrimmedString3(d?.playerOneNickname);
        if (candidate) return candidate;
      }
    } catch (e) {
      try {
        const all = await db.details.toArray();
        const sorted = all.slice().sort((a, b) => Number(b?.fetchedAt ?? 0) - Number(a?.fetchedAt ?? 0));
        for (const d of sorted.slice(0, 25)) {
          const candidate = asTrimmedString3(d?.player_self_name) ?? asTrimmedString3(d?.playerOneName) ?? asTrimmedString3(d?.playerOneNick) ?? asTrimmedString3(d?.playerOneNickname);
          if (candidate) return candidate;
        }
      } catch {
      }
      console.warn("Failed to guess player name from DB", e);
    }
    return void 0;
  }
  async function getCurrentPlayerName() {
    if (cachedPlayerName !== void 0) return cachedPlayerName || void 0;
    const fromApi = await fetchPlayerNameFromApi();
    if (fromApi) {
      cachedPlayerName = fromApi;
      return fromApi;
    }
    const fromDb = await guessPlayerNameFromDb();
    cachedPlayerName = fromDb ?? null;
    return fromDb;
  }

  // src/ui.ts
  function cloneTemplate2(value) {
    if (typeof structuredClone === "function") return structuredClone(value);
    return JSON.parse(JSON.stringify(value));
  }
  function createBootLog(doc) {
    let pre = null;
    const lines = [];
    const ensurePre = () => {
      if (pre) return pre;
      if (!doc.body) return null;
      pre = doc.createElement("pre");
      pre.id = "ga-boot-log";
      pre.style.cssText = [
        "position:fixed",
        "left:0",
        "top:0",
        "right:0",
        "max-height:40vh",
        "overflow:auto",
        "margin:0",
        "padding:10px 12px",
        "background:rgba(0,0,0,0.85)",
        "color:#c7f5d9",
        'font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
        "z-index:2147483647",
        "white-space:pre-wrap"
      ].join(";");
      doc.body.appendChild(pre);
      pre.textContent = lines.join("\n");
      return pre;
    };
    const fmt = (s) => {
      const t = /* @__PURE__ */ new Date();
      const hh = String(t.getHours()).padStart(2, "0");
      const mm = String(t.getMinutes()).padStart(2, "0");
      const ss = String(t.getSeconds()).padStart(2, "0");
      const ms = String(t.getMilliseconds()).padStart(3, "0");
      return `[${hh}:${mm}:${ss}.${ms}] ${s}`;
    };
    const append = (line) => {
      lines.push(fmt(line));
      const el2 = ensurePre();
      if (el2) el2.textContent = lines.join("\n");
    };
    const describeError = (err) => {
      if (!err) return "";
      if (err instanceof Error) {
        const stack = typeof err.stack === "string" && err.stack.trim().length ? `
${err.stack}` : "";
        return `${err.name}: ${err.message}${stack}`;
      }
      try {
        return String(err);
      } catch {
        return "<unprintable error>";
      }
    };
    return {
      log: (message) => append(message),
      error: (message, err) => append(`${message}${err ? `
${describeError(err)}` : ""}`),
      remove: () => {
        if (pre && pre.parentElement) pre.remove();
        pre = null;
      }
    };
  }
  async function ensureDocumentShell(targetWindow, doc) {
    if (doc.head && doc.body) return;
    try {
      doc.open();
      doc.write('<!doctype html><html><head><meta charset="utf-8"></head><body></body></html>');
      doc.close();
    } catch {
    }
    if (!doc.documentElement) {
      try {
        const html = doc.createElement("html");
        doc.appendChild(html);
      } catch {
        return;
      }
    }
    if (!doc.head) {
      try {
        const head = doc.createElement("head");
        doc.documentElement.insertBefore(head, doc.documentElement.firstChild);
      } catch {
      }
    }
    if (!doc.body) {
      try {
        const body = doc.createElement("body");
        doc.documentElement.appendChild(body);
      } catch {
      }
    }
    if (doc.head && doc.body) return;
    const timeoutMs = 1500;
    const start = Date.now();
    while (!(doc.head && doc.body)) {
      if (targetWindow.closed) break;
      if (Date.now() - start > timeoutMs) break;
      await new Promise((r) => setTimeout(r, 25));
    }
  }
  async function initAnalysisWindow(opts) {
    const targetWindow = opts?.targetWindow ?? window;
    if (!targetWindow || targetWindow.closed) {
      throw new Error("Semantic dashboard target window is unavailable.");
    }
    let doc;
    try {
      doc = targetWindow.document;
    } catch (e) {
      throw new Error(`Cannot access semantic dashboard document: ${e instanceof Error ? e.message : String(e)}`);
    }
    await ensureDocumentShell(targetWindow, doc);
    if (!doc.body || !doc.head) {
      throw new Error("Semantic dashboard target document is not ready.");
    }
    const boot = createBootLog(doc);
    const ua = doc.defaultView?.navigator?.userAgent ?? "";
    boot.log("GeoAnalyzr: analysis window boot");
    boot.log(`readyState=${doc.readyState} ua=${ua}`);
    if (!targetWindow.__gaBootHandlersInstalled) {
      targetWindow.__gaBootHandlersInstalled = true;
      targetWindow.addEventListener("error", (ev) => {
        const msg = typeof ev?.message === "string" ? ev.message : "Unhandled window error";
        boot.error(`window.onerror: ${msg}`, ev?.error);
      });
      targetWindow.addEventListener("unhandledrejection", (ev) => {
        boot.error("unhandledrejection", ev?.reason);
      });
    }
    doc.title = "GeoAnalyzr";
    doc.documentElement.classList.add("ga-semantic-page");
    doc.body.classList.add("ga-semantic-page");
    boot.log("Injecting dashboard CSS...");
    injectSemanticDashboardCssOnce(doc);
    boot.log("Loading templates/settings...");
    const semanticBase = cloneTemplate2(semantic_default);
    let dashboard = loadDashboardTemplate(doc, cloneTemplate2(dashboard_default));
    let settings = loadSettings(doc);
    let root = doc.getElementById("geoanalyzr-semantic-root");
    let body;
    boot.log("Resolving player name...");
    const playerName = await getCurrentPlayerName();
    const applyTitleTemplate = (tpl, vars) => {
      const raw = String(tpl ?? "");
      const rendered = raw.replace(/\{\{\s*([A-Za-z0-9_\-]{3,64})\s*\}\}/g, (_, key) => {
        const v = vars[key];
        return typeof v === "string" ? v : "";
      });
      return rendered.trim();
    };
    const updateTitles = () => {
      const dashTitle = dashboard?.dashboard?.title ?? "GeoAnalyzr";
      const ui = dashboard?.dashboard?.ui;
      const topTpl = typeof ui?.topbarTitle === "string" ? ui.topbarTitle : "{{dashboardTitle}}";
      const winTpl = typeof ui?.windowTitle === "string" ? ui.windowTitle : "{{dashboardTitle}}";
      const vars = { playerName, dashboardTitle: dashTitle };
      const topTitle = applyTitleTemplate(topTpl, vars) || dashTitle;
      const winTitle = applyTitleTemplate(winTpl, vars) || dashTitle;
      doc.title = winTitle;
      const titleTextEl = doc.querySelector(".ga-topbar .ga-title .ga-title-text");
      if (titleTextEl) titleTextEl.textContent = topTitle;
      else {
        const titleEl = doc.querySelector(".ga-topbar .ga-title");
        if (titleEl) titleEl.textContent = topTitle;
      }
    };
    const renderNow = async () => {
      body.innerHTML = "";
      boot.log("Merging semantic + validating...");
      const semantic = mergeSemanticWithDashboard(semanticBase, dashboard);
      validateDashboardAgainstSemantic(semantic, dashboard);
      updateTitles();
      boot.log("Rendering analysis app...");
      await renderAnalysisApp({ body, semantic, dashboard });
      boot.log("Render complete.");
      boot.remove();
    };
    if (!root) {
      root = doc.createElement("div");
      root.id = "geoanalyzr-semantic-root";
      root.className = "ga-root";
      const top = doc.createElement("div");
      top.className = "ga-topbar";
      const title = doc.createElement("div");
      title.className = "ga-title";
      const titleLogo = doc.createElement("span");
      titleLogo.className = "ga-title-logo";
      titleLogo.innerHTML = logoSvgMarkup({ size: 18, idPrefix: "ga-analysis-topbar", variant: "light", decorative: true });
      const titleText = doc.createElement("span");
      titleText.className = "ga-title-text";
      titleText.textContent = "GeoAnalyzr";
      title.appendChild(titleLogo);
      title.appendChild(titleText);
      const actions = doc.createElement("div");
      actions.className = "ga-topbar-actions";
      const settingsBtn = doc.createElement("button");
      settingsBtn.className = "ga-gear";
      settingsBtn.textContent = "Settings";
      settingsBtn.title = "Settings";
      const close = doc.createElement("button");
      close.className = "ga-close";
      close.textContent = "Close";
      close.addEventListener("click", () => {
        targetWindow.close();
      });
      actions.appendChild(settingsBtn);
      actions.appendChild(close);
      top.appendChild(title);
      top.appendChild(actions);
      body = doc.createElement("div");
      body.className = "ga-body";
      root.appendChild(top);
      root.appendChild(body);
      doc.body.appendChild(root);
      attachSettingsModal({
        doc,
        targetWindow,
        root,
        openButton: settingsBtn,
        semantic: semanticBase,
        getDashboard: () => dashboard,
        getDefaultDashboard: () => cloneTemplate2(dashboard_default),
        applyDashboard: async (next) => {
          dashboard = next;
          saveDashboardTemplate(doc, dashboard);
          updateTitles();
          await renderNow();
        },
        getSettings: () => settings,
        applySettings: async (next) => {
          settings = next;
          applySettingsToRoot(root, settings);
          saveSettings(doc, settings);
        }
      });
    } else {
      const foundBody = root.querySelector(".ga-body");
      if (!(foundBody instanceof HTMLDivElement)) {
        throw new Error("Semantic root has no .ga-body container");
      }
      body = foundBody;
    }
    if (!root) {
      throw new Error("Semantic root is missing after initialization.");
    }
    applySettingsToRoot(root, settings);
    updateTitles();
    try {
      await renderNow();
    } catch (error) {
      body.innerHTML = "";
      const pre = doc.createElement("pre");
      pre.style.margin = "12px";
      pre.style.whiteSpace = "pre-wrap";
      pre.style.color = "#ff9aa2";
      pre.textContent = `Failed to render semantic dashboard:
${error instanceof Error ? error.message : String(error)}`;
      body.appendChild(pre);
      boot.error("Failed to render semantic dashboard", error);
      throw error;
    }
  }

  // src/auth.ts
  var AUTH_META_KEY = "auth";
  function readNcfaFromDocumentCookie2() {
    if (typeof document === "undefined") return void 0;
    const raw = typeof document.cookie === "string" ? document.cookie : "";
    if (!raw) return void 0;
    const parts = raw.split(";");
    for (const part of parts) {
      const [k, ...rest] = part.trim().split("=");
      if (k !== "_ncfa") continue;
      const value = rest.join("=").trim();
      if (value) return value;
    }
    return void 0;
  }
  async function getNcfaToken() {
    const row = await db.meta.get(AUTH_META_KEY);
    const token = row?.value?.ncfa;
    return typeof token === "string" && token.trim() ? token.trim() : void 0;
  }
  async function getResolvedNcfaToken() {
    const stored = await getNcfaToken();
    if (stored) return { token: stored, source: "stored" };
    const cookie = readNcfaFromDocumentCookie2();
    if (cookie) return { token: cookie, source: "cookie" };
    return { source: "none" };
  }
  async function setNcfaToken(token) {
    const clean = typeof token === "string" ? token.trim() : "";
    if (!clean) {
      await db.meta.delete(AUTH_META_KEY);
      return;
    }
    await db.meta.put({
      key: AUTH_META_KEY,
      value: { ncfa: clean },
      updatedAt: Date.now()
    });
  }
  function basicNcfaFormatCheck(token) {
    const clean = token.trim();
    if (!clean) return { ok: false, reason: "Token is empty.", source: "format" };
    if (clean.length < 20) return { ok: false, reason: "Token looks too short.", source: "format" };
    if (/\s/.test(clean)) return { ok: false, reason: "Token must not contain whitespace.", source: "format" };
    return void 0;
  }
  async function validateNcfaToken(token) {
    const clean = typeof token === "string" ? token.trim() : "";
    const basic = basicNcfaFormatCheck(clean);
    if (basic) return basic;
    try {
      const res = await httpGetJson("https://www.geoguessr.com/api/v4/feed/private", {
        ncfa: clean,
        forceGm: true
      });
      if (res.status >= 200 && res.status < 300) {
        const hasEntries = Array.isArray(res.data?.entries);
        return hasEntries ? { ok: true, status: res.status, reason: "Token accepted by private feed endpoint.", source: "api" } : { ok: true, status: res.status, reason: "Token accepted (response shape unexpected).", source: "api" };
      }
      if (res.status === 401 || res.status === 403) {
        return { ok: false, status: res.status, reason: "Token rejected (unauthorized).", source: "api" };
      }
      if (res.status === 429) {
        return { ok: false, status: res.status, reason: "Rate-limited while validating token. Try again shortly.", source: "api" };
      }
      return { ok: false, status: res.status, reason: `Validation failed with HTTP ${res.status}.`, source: "api" };
    } catch (e) {
      return {
        ok: false,
        reason: `Validation request failed: ${e instanceof Error ? e.message : String(e)}`,
        source: "network"
      };
    }
  }

  // src/app/session.ts
  async function hasAuthenticatedSession() {
    try {
      const res = await fetch("https://www.geoguessr.com/api/v4/feed/private", { credentials: "include" });
      return res.status >= 200 && res.status < 300;
    } catch {
      return false;
    }
  }

  // src/app/uiActions.ts
  function errorText(e) {
    return e instanceof Error ? e.message : String(e);
  }
  async function refreshUI(ui) {
    const [games, rounds, detailsOk, detailsError, detailsMissing] = await Promise.all([
      db.games.count(),
      db.rounds.count(),
      db.details.where("status").equals("ok").count(),
      db.details.where("status").equals("error").count(),
      db.details.where("status").equals("missing").count()
    ]);
    ui.setCounts({ games, rounds, detailsOk, detailsError, detailsMissing });
  }
  function registerUiActions(ui) {
    ui.onUpdateClick(async () => {
      try {
        ui.setStatus("Update started...");
        let resolved = await getResolvedNcfaToken();
        let ncfa = resolved.token;
        if (!ncfa) {
          const wantsSet = confirm("No NCFA token found. Set it now for more complete fetching?");
          if (wantsSet) {
            const entered = prompt("Paste _ncfa token here.", "");
            if (entered !== null) {
              const clean = entered.trim();
              if (clean) {
                const check = await validateNcfaToken(clean);
                if (check.ok) {
                  await setNcfaToken(clean);
                  resolved = await getResolvedNcfaToken();
                  ncfa = resolved.token;
                  ui.setStatus(`NCFA token saved and validated (HTTP ${check.status ?? "ok"}). Continuing update...`);
                } else {
                  ui.setStatus(`NCFA token not saved: ${check.reason} Continuing without NCFA...`);
                }
              } else {
                await setNcfaToken("");
                ui.setStatus("No token saved. Continuing without NCFA...");
              }
            }
          }
        } else if (resolved.source === "cookie") {
          ui.setStatus("Using NCFA token from browser cookie. Continuing update...");
        }
        const res = await updateData({
          onStatus: (m) => ui.setStatus(m),
          maxPages: 5e3,
          delayMs: 200,
          detailConcurrency: 4,
          retryErrors: true,
          verifyCompleteness: true,
          enrichLimit: 2e3,
          ncfa
        });
        const norm = await normalizeLegacyRounds({ onStatus: (m) => ui.setStatus(m) });
        invalidateRoundsCache();
        ui.setStatus(`Update complete. Feed upserted: ${res.feedUpserted}. Details ok: ${res.detailsOk}, fail: ${res.detailsFail}.`);
        if (norm.updated > 0) ui.setStatus(`Update complete. Feed upserted: ${res.feedUpserted}. Normalized legacy rounds: ${norm.updated}.`);
        await refreshUI(ui);
      } catch (e) {
        ui.setStatus("Error: " + errorText(e));
        console.error(e);
      }
    });
    ui.onResetClick(async () => {
      if (!confirm("Reset database? This will permanently delete all local analyzer data.")) return;
      try {
        ui.setStatus("Resetting DB...");
        await db.transaction("rw", db.games, db.rounds, db.details, db.meta, async () => {
          await Promise.all([db.games.clear(), db.rounds.clear(), db.details.clear(), db.meta.clear()]);
        });
        invalidateRoundsCache();
        ui.setStatus("DB reset complete.");
        await refreshUI(ui);
      } catch (e) {
        ui.setStatus("Error: " + errorText(e));
        console.error(e);
      }
    });
    ui.onExportClick(async () => {
      try {
        await exportExcel((m) => ui.setStatus(m));
      } catch (e) {
        ui.setStatus("Error: " + errorText(e));
        console.error(e);
      }
    });
    ui.onTokenClick(async () => {
      const existing = await getNcfaToken();
      ui.openNcfaManager({
        initialToken: existing || "",
        helpText: "",
        repoUrl: "https://github.com/JonasLmbt/GeoAnalyzr#getting-your-_ncfa-cookie",
        onSave: async (token) => {
          const clean = token.trim();
          if (!clean) {
            await setNcfaToken("");
            const message2 = "NCFA token removed.";
            ui.setStatus(message2);
            return { saved: false, token: "", message: message2 };
          }
          const check = await validateNcfaToken(clean);
          if (!check.ok) {
            const message2 = `Token validation failed: ${check.reason}`;
            ui.setStatus(message2);
            return { saved: false, token: clean, message: message2 };
          }
          await setNcfaToken(clean);
          const now = await getNcfaToken();
          const message = `NCFA token saved and validated (HTTP ${check.status ?? "ok"}).`;
          ui.setStatus(message);
          return { saved: !!now, token: now, message };
        },
        onAutoDetect: async () => {
          const resolved = await getResolvedNcfaToken();
          if (resolved.token) {
            const check = await validateNcfaToken(resolved.token);
            if (check.ok) {
              await setNcfaToken(resolved.token);
              const message3 = `Auto-detect successful (${resolved.source}). Token validated and saved.`;
              ui.setStatus(message3);
              return { detected: true, token: resolved.token, source: resolved.source, message: message3 };
            }
            const message2 = `Auto-detected token failed validation (${resolved.source}): ${check.reason}`;
            ui.setStatus(message2);
            return { detected: false, token: resolved.token, source: resolved.source, message: message2 };
          }
          const sessionOk = await hasAuthenticatedSession();
          if (sessionOk) {
            const message2 = "No readable _ncfa token found. Session auth works, likely because _ncfa is HttpOnly. You can keep manual token if needed for cross-domain endpoints.";
            ui.setStatus(message2);
            return { detected: true, source: "session", message: message2 };
          }
          const message = "Auto-detect failed: no stored token, no readable cookie, and no authenticated session detected.";
          ui.setStatus(message);
          return { detected: false, source: "none", message };
        }
      });
    });
    ui.onOpenAnalysisClick(async () => {
      let semanticStatus = "";
      try {
        ui.setStatus("Opening dashboard...");
        const semanticTab = window.open("about:blank", "_blank");
        if (!semanticTab) {
          semanticStatus = " Semantic dashboard popup was blocked.";
        } else {
          try {
            await initAnalysisWindow({ targetWindow: semanticTab });
          } catch (semanticError) {
            const msg = errorText(semanticError);
            semanticStatus = ` Semantic dashboard failed to render: ${msg}`;
            ui.setStatus(`Dashboard error: ${msg}`);
            console.error("Failed to initialize semantic dashboard tab", semanticError);
          }
        }
        ui.setStatus(`Dashboard opened.${semanticStatus}`);
      } catch (e) {
        ui.setStatus("Error: " + errorText(e));
        console.error(e);
      }
    });
    ui.onDiscordClick(() => {
      const url = "https://discord.gg/8RA3VtSC";
      const w = window.open(url, "_blank", "noopener,noreferrer");
      if (w) w.opener = null;
    });
  }

  // src/app/routing.ts
  function watchRoutes(onRoute) {
    const origPush = history.pushState;
    const origReplace = history.replaceState;
    history.pushState = function() {
      origPush.apply(this, arguments);
      onRoute();
    };
    history.replaceState = function() {
      origReplace.apply(this, arguments);
      onRoute();
    };
    window.addEventListener("popstate", onRoute);
    setInterval(onRoute, 500);
    onRoute();
  }

  // src/app/boot.ts
  async function bootApp() {
    const ui = createUIOverlay();
    registerUiActions(ui);
    await refreshUI(ui);
    watchRoutes(() => {
      ui.setVisible(true);
    });
  }

  // src/main.ts
  void bootApp();
})();
/*! Bundled license information:

xlsx/xlsx.mjs:
  (*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com *)

xlsx/xlsx.mjs:
  (*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com *)
*/
